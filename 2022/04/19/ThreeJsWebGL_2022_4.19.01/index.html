<!DOCTYPE html><html lang="zh-TW" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Three.Js开发WebGL创建三维空间 | Arvin</title><meta name="keywords" content="教学文档,博客网站"><meta name="author" content="Arvin"><meta name="copyright" content="Arvin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Three.Js开发WebGL创建三维空间首先我们需要创建一个 HTML 文件 如：index.html 导入Three.Js 与 设置网页初始化 (边距为0 溢出隐藏) &lt;!doctype html&gt;&lt;html lang&#x3D;&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;">
<meta property="og:type" content="article">
<meta property="og:title" content="Three.Js开发WebGL创建三维空间">
<meta property="og:url" content="https://arvinroad.github.io/2022/04/19/ThreeJsWebGL_2022_4.19.01/index.html">
<meta property="og:site_name" content="Arvin">
<meta property="og:description" content="Three.Js开发WebGL创建三维空间首先我们需要创建一个 HTML 文件 如：index.html 导入Three.Js 与 设置网页初始化 (边距为0 溢出隐藏) &lt;!doctype html&gt;&lt;html lang&#x3D;&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://pic3.zhimg.com/v2-7af105b5915de8a7fdcf6332b681aba5_r.jpg">
<meta property="article:published_time" content="2022-04-19T06:46:00.000Z">
<meta property="article:modified_time" content="2022-04-19T06:50:56.812Z">
<meta property="article:author" content="Arvin">
<meta property="article:tag" content="教学文档">
<meta property="article:tag" content="博客网站">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic3.zhimg.com/v2-7af105b5915de8a7fdcf6332b681aba5_r.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://arvinroad.github.io/2022/04/19/ThreeJsWebGL_2022_4.19.01/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查詢的內容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"该文章创建于","messageNext":"天前，请以最新文章为准."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '複製成功',
    error: '複製錯誤',
    noSupport: '瀏覽器不支援'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '剛剛',
    min: '分鐘前',
    hour: '小時前',
    day: '天前',
    month: '個月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Arvin","link":"連結: ","source":"來源: Arvin","info":"著作權歸作者所有。商業轉載請聯絡作者獲得授權，非商業轉載請註明出處。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切換為繁體","cht_to_chs":"你已切換為簡體","day_to_night":"你已切換為深色模式","night_to_day":"你已切換為淺色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Three.Js开发WebGL创建三维空间',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-19 14:50:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">載入中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='./img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">標籤</div><div class="length-num">21</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分類</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 归档书屋</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book-open"></i><span> 阅读</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 休闲室</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 電影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 團隊成員</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pic3.zhimg.com/v2-7af105b5915de8a7fdcf6332b681aba5_r.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Arvin</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜尋</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 归档书屋</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book-open"></i><span> 阅读</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 休闲室</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 電影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 團隊成員</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Three.Js开发WebGL创建三维空间</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">發表於</span><time class="post-meta-date-created" datetime="2022-04-19T06:46:00.000Z" title="發表於 2022-04-19 14:46:00">2022-04-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新於</span><time class="post-meta-date-updated" datetime="2022-04-19T06:50:56.812Z" title="更新於 2022-04-19 14:50:56">2022-04-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%A8%8B%E5%BA%8F/">程序</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Three.Js开发WebGL创建三维空间"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">閱讀量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Three-Js开发WebGL创建三维空间"><a href="#Three-Js开发WebGL创建三维空间" class="headerlink" title="Three.Js开发WebGL创建三维空间"></a>Three.Js开发WebGL创建三维空间</h1><p>首先我们需要创建一个 HTML 文件 如：index.html</p>
<p>导入Three.Js 与 设置网页初始化 (边距为0 溢出隐藏)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=Edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Demo-01<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;libs/Three.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">body</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Three.Js GitHub地址：<a target="_blank" rel="noopener" href="https://github.com/mrdoob/three.js">点击跳转</a></p>
</blockquote>
<blockquote>
<p>Three.Js API说明文档：<a target="_blank" rel="noopener" href="https://threejs.org/docs/index.html#manual/zh/introduction/Creating-a-scene">点击跳转</a></p>
</blockquote>
<p>或者你可以采用本页提供的 Three.Js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@license</span></span></span><br><span class="line"><span class="comment"> * Copyright 2010-2022 Three.js Authors</span></span><br><span class="line"><span class="comment"> * SPDX-License-Identifier: MIT</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">global</span>, factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">&#x27;undefined&#x27;</span> ? factory(<span class="built_in">exports</span>) :</span><br><span class="line">        <span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.amd ? define([<span class="string">&#x27;exports&#x27;</span>], factory) :</span><br><span class="line">            (<span class="built_in">global</span> = <span class="keyword">typeof</span> globalThis !== <span class="string">&#x27;undefined&#x27;</span> ? globalThis : <span class="built_in">global</span> || self, factory(<span class="built_in">global</span>.THREE = &#123;&#125;));</span><br><span class="line">&#125;)(<span class="built_in">this</span>, (<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span></span>) </span>&#123; <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> REVISION = <span class="string">&#x27;139&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> MOUSE = &#123;</span><br><span class="line">        <span class="attr">LEFT</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">MIDDLE</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">RIGHT</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">ROTATE</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">DOLLY</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">PAN</span>: <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> TOUCH = &#123;</span><br><span class="line">        <span class="attr">ROTATE</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">PAN</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">DOLLY_PAN</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">DOLLY_ROTATE</span>: <span class="number">3</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> CullFaceNone = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> CullFaceBack = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> CullFaceFront = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> CullFaceFrontBack = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">const</span> BasicShadowMap = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> PCFShadowMap = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> PCFSoftShadowMap = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> VSMShadowMap = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">const</span> FrontSide = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> BackSide = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> DoubleSide = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> FlatShading = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> SmoothShading = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> NoBlending = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> NormalBlending = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> AdditiveBlending = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> SubtractiveBlending = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">const</span> MultiplyBlending = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">const</span> CustomBlending = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">const</span> AddEquation = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">const</span> SubtractEquation = <span class="number">101</span>;</span><br><span class="line">    <span class="keyword">const</span> ReverseSubtractEquation = <span class="number">102</span>;</span><br><span class="line">    <span class="keyword">const</span> MinEquation = <span class="number">103</span>;</span><br><span class="line">    <span class="keyword">const</span> MaxEquation = <span class="number">104</span>;</span><br><span class="line">    <span class="keyword">const</span> ZeroFactor = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">const</span> OneFactor = <span class="number">201</span>;</span><br><span class="line">    <span class="keyword">const</span> SrcColorFactor = <span class="number">202</span>;</span><br><span class="line">    <span class="keyword">const</span> OneMinusSrcColorFactor = <span class="number">203</span>;</span><br><span class="line">    <span class="keyword">const</span> SrcAlphaFactor = <span class="number">204</span>;</span><br><span class="line">    <span class="keyword">const</span> OneMinusSrcAlphaFactor = <span class="number">205</span>;</span><br><span class="line">    <span class="keyword">const</span> DstAlphaFactor = <span class="number">206</span>;</span><br><span class="line">    <span class="keyword">const</span> OneMinusDstAlphaFactor = <span class="number">207</span>;</span><br><span class="line">    <span class="keyword">const</span> DstColorFactor = <span class="number">208</span>;</span><br><span class="line">    <span class="keyword">const</span> OneMinusDstColorFactor = <span class="number">209</span>;</span><br><span class="line">    <span class="keyword">const</span> SrcAlphaSaturateFactor = <span class="number">210</span>;</span><br><span class="line">    <span class="keyword">const</span> NeverDepth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> AlwaysDepth = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> LessDepth = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> LessEqualDepth = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">const</span> EqualDepth = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">const</span> GreaterEqualDepth = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">const</span> GreaterDepth = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">const</span> NotEqualDepth = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">const</span> MultiplyOperation = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> MixOperation = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> AddOperation = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> NoToneMapping = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> LinearToneMapping = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> ReinhardToneMapping = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> CineonToneMapping = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">const</span> ACESFilmicToneMapping = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">const</span> CustomToneMapping = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">const</span> UVMapping = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">const</span> CubeReflectionMapping = <span class="number">301</span>;</span><br><span class="line">    <span class="keyword">const</span> CubeRefractionMapping = <span class="number">302</span>;</span><br><span class="line">    <span class="keyword">const</span> EquirectangularReflectionMapping = <span class="number">303</span>;</span><br><span class="line">    <span class="keyword">const</span> EquirectangularRefractionMapping = <span class="number">304</span>;</span><br><span class="line">    <span class="keyword">const</span> CubeUVReflectionMapping = <span class="number">306</span>;</span><br><span class="line">    <span class="keyword">const</span> RepeatWrapping = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">const</span> ClampToEdgeWrapping = <span class="number">1001</span>;</span><br><span class="line">    <span class="keyword">const</span> MirroredRepeatWrapping = <span class="number">1002</span>;</span><br><span class="line">    <span class="keyword">const</span> NearestFilter = <span class="number">1003</span>;</span><br><span class="line">    <span class="keyword">const</span> NearestMipmapNearestFilter = <span class="number">1004</span>;</span><br><span class="line">    <span class="keyword">const</span> NearestMipMapNearestFilter = <span class="number">1004</span>;</span><br><span class="line">    <span class="keyword">const</span> NearestMipmapLinearFilter = <span class="number">1005</span>;</span><br><span class="line">    <span class="keyword">const</span> NearestMipMapLinearFilter = <span class="number">1005</span>;</span><br><span class="line">    <span class="keyword">const</span> LinearFilter = <span class="number">1006</span>;</span><br><span class="line">    <span class="keyword">const</span> LinearMipmapNearestFilter = <span class="number">1007</span>;</span><br><span class="line">    <span class="keyword">const</span> LinearMipMapNearestFilter = <span class="number">1007</span>;</span><br><span class="line">    <span class="keyword">const</span> LinearMipmapLinearFilter = <span class="number">1008</span>;</span><br><span class="line">    <span class="keyword">const</span> LinearMipMapLinearFilter = <span class="number">1008</span>;</span><br><span class="line">    <span class="keyword">const</span> UnsignedByteType = <span class="number">1009</span>;</span><br><span class="line">    <span class="keyword">const</span> ByteType = <span class="number">1010</span>;</span><br><span class="line">    <span class="keyword">const</span> ShortType = <span class="number">1011</span>;</span><br><span class="line">    <span class="keyword">const</span> UnsignedShortType = <span class="number">1012</span>;</span><br><span class="line">    <span class="keyword">const</span> IntType = <span class="number">1013</span>;</span><br><span class="line">    <span class="keyword">const</span> UnsignedIntType = <span class="number">1014</span>;</span><br><span class="line">    <span class="keyword">const</span> FloatType = <span class="number">1015</span>;</span><br><span class="line">    <span class="keyword">const</span> HalfFloatType = <span class="number">1016</span>;</span><br><span class="line">    <span class="keyword">const</span> UnsignedShort4444Type = <span class="number">1017</span>;</span><br><span class="line">    <span class="keyword">const</span> UnsignedShort5551Type = <span class="number">1018</span>;</span><br><span class="line">    <span class="keyword">const</span> UnsignedInt248Type = <span class="number">1020</span>;</span><br><span class="line">    <span class="keyword">const</span> AlphaFormat = <span class="number">1021</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBFormat = <span class="number">1022</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBAFormat = <span class="number">1023</span>;</span><br><span class="line">    <span class="keyword">const</span> LuminanceFormat = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">const</span> LuminanceAlphaFormat = <span class="number">1025</span>;</span><br><span class="line">    <span class="keyword">const</span> DepthFormat = <span class="number">1026</span>;</span><br><span class="line">    <span class="keyword">const</span> DepthStencilFormat = <span class="number">1027</span>;</span><br><span class="line">    <span class="keyword">const</span> RedFormat = <span class="number">1028</span>;</span><br><span class="line">    <span class="keyword">const</span> RedIntegerFormat = <span class="number">1029</span>;</span><br><span class="line">    <span class="keyword">const</span> RGFormat = <span class="number">1030</span>;</span><br><span class="line">    <span class="keyword">const</span> RGIntegerFormat = <span class="number">1031</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBAIntegerFormat = <span class="number">1033</span>;</span><br><span class="line">    <span class="keyword">const</span> RGB_S3TC_DXT1_Format = <span class="number">33776</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBA_S3TC_DXT1_Format = <span class="number">33777</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBA_S3TC_DXT3_Format = <span class="number">33778</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBA_S3TC_DXT5_Format = <span class="number">33779</span>;</span><br><span class="line">    <span class="keyword">const</span> RGB_PVRTC_4BPPV1_Format = <span class="number">35840</span>;</span><br><span class="line">    <span class="keyword">const</span> RGB_PVRTC_2BPPV1_Format = <span class="number">35841</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBA_PVRTC_4BPPV1_Format = <span class="number">35842</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBA_PVRTC_2BPPV1_Format = <span class="number">35843</span>;</span><br><span class="line">    <span class="keyword">const</span> RGB_ETC1_Format = <span class="number">36196</span>;</span><br><span class="line">    <span class="keyword">const</span> RGB_ETC2_Format = <span class="number">37492</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBA_ETC2_EAC_Format = <span class="number">37496</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBA_ASTC_4x4_Format = <span class="number">37808</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBA_ASTC_5x4_Format = <span class="number">37809</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBA_ASTC_5x5_Format = <span class="number">37810</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBA_ASTC_6x5_Format = <span class="number">37811</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBA_ASTC_6x6_Format = <span class="number">37812</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBA_ASTC_8x5_Format = <span class="number">37813</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBA_ASTC_8x6_Format = <span class="number">37814</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBA_ASTC_8x8_Format = <span class="number">37815</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBA_ASTC_10x5_Format = <span class="number">37816</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBA_ASTC_10x6_Format = <span class="number">37817</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBA_ASTC_10x8_Format = <span class="number">37818</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBA_ASTC_10x10_Format = <span class="number">37819</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBA_ASTC_12x10_Format = <span class="number">37820</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBA_ASTC_12x12_Format = <span class="number">37821</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBA_BPTC_Format = <span class="number">36492</span>;</span><br><span class="line">    <span class="keyword">const</span> LoopOnce = <span class="number">2200</span>;</span><br><span class="line">    <span class="keyword">const</span> LoopRepeat = <span class="number">2201</span>;</span><br><span class="line">    <span class="keyword">const</span> LoopPingPong = <span class="number">2202</span>;</span><br><span class="line">    <span class="keyword">const</span> InterpolateDiscrete = <span class="number">2300</span>;</span><br><span class="line">    <span class="keyword">const</span> InterpolateLinear = <span class="number">2301</span>;</span><br><span class="line">    <span class="keyword">const</span> InterpolateSmooth = <span class="number">2302</span>;</span><br><span class="line">    <span class="keyword">const</span> ZeroCurvatureEnding = <span class="number">2400</span>;</span><br><span class="line">    <span class="keyword">const</span> ZeroSlopeEnding = <span class="number">2401</span>;</span><br><span class="line">    <span class="keyword">const</span> WrapAroundEnding = <span class="number">2402</span>;</span><br><span class="line">    <span class="keyword">const</span> NormalAnimationBlendMode = <span class="number">2500</span>;</span><br><span class="line">    <span class="keyword">const</span> AdditiveAnimationBlendMode = <span class="number">2501</span>;</span><br><span class="line">    <span class="keyword">const</span> TrianglesDrawMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> TriangleStripDrawMode = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> TriangleFanDrawMode = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> LinearEncoding = <span class="number">3000</span>;</span><br><span class="line">    <span class="keyword">const</span> sRGBEncoding = <span class="number">3001</span>;</span><br><span class="line">    <span class="keyword">const</span> BasicDepthPacking = <span class="number">3200</span>;</span><br><span class="line">    <span class="keyword">const</span> RGBADepthPacking = <span class="number">3201</span>;</span><br><span class="line">    <span class="keyword">const</span> TangentSpaceNormalMap = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> ObjectSpaceNormalMap = <span class="number">1</span>; <span class="comment">// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> NoColorSpace = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> SRGBColorSpace = <span class="string">&#x27;srgb&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> LinearSRGBColorSpace = <span class="string">&#x27;srgb-linear&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> ZeroStencilOp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> KeepStencilOp = <span class="number">7680</span>;</span><br><span class="line">    <span class="keyword">const</span> ReplaceStencilOp = <span class="number">7681</span>;</span><br><span class="line">    <span class="keyword">const</span> IncrementStencilOp = <span class="number">7682</span>;</span><br><span class="line">    <span class="keyword">const</span> DecrementStencilOp = <span class="number">7683</span>;</span><br><span class="line">    <span class="keyword">const</span> IncrementWrapStencilOp = <span class="number">34055</span>;</span><br><span class="line">    <span class="keyword">const</span> DecrementWrapStencilOp = <span class="number">34056</span>;</span><br><span class="line">    <span class="keyword">const</span> InvertStencilOp = <span class="number">5386</span>;</span><br><span class="line">    <span class="keyword">const</span> NeverStencilFunc = <span class="number">512</span>;</span><br><span class="line">    <span class="keyword">const</span> LessStencilFunc = <span class="number">513</span>;</span><br><span class="line">    <span class="keyword">const</span> EqualStencilFunc = <span class="number">514</span>;</span><br><span class="line">    <span class="keyword">const</span> LessEqualStencilFunc = <span class="number">515</span>;</span><br><span class="line">    <span class="keyword">const</span> GreaterStencilFunc = <span class="number">516</span>;</span><br><span class="line">    <span class="keyword">const</span> NotEqualStencilFunc = <span class="number">517</span>;</span><br><span class="line">    <span class="keyword">const</span> GreaterEqualStencilFunc = <span class="number">518</span>;</span><br><span class="line">    <span class="keyword">const</span> AlwaysStencilFunc = <span class="number">519</span>;</span><br><span class="line">    <span class="keyword">const</span> StaticDrawUsage = <span class="number">35044</span>;</span><br><span class="line">    <span class="keyword">const</span> DynamicDrawUsage = <span class="number">35048</span>;</span><br><span class="line">    <span class="keyword">const</span> StreamDrawUsage = <span class="number">35040</span>;</span><br><span class="line">    <span class="keyword">const</span> StaticReadUsage = <span class="number">35045</span>;</span><br><span class="line">    <span class="keyword">const</span> DynamicReadUsage = <span class="number">35049</span>;</span><br><span class="line">    <span class="keyword">const</span> StreamReadUsage = <span class="number">35041</span>;</span><br><span class="line">    <span class="keyword">const</span> StaticCopyUsage = <span class="number">35046</span>;</span><br><span class="line">    <span class="keyword">const</span> DynamicCopyUsage = <span class="number">35050</span>;</span><br><span class="line">    <span class="keyword">const</span> StreamCopyUsage = <span class="number">35042</span>;</span><br><span class="line">    <span class="keyword">const</span> GLSL1 = <span class="string">&#x27;100&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> GLSL3 = <span class="string">&#x27;300 es&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> _SRGBAFormat = <span class="number">1035</span>; <span class="comment">// fallback for WebGL 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * https://github.com/mrdoob/eventdispatcher.js/</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EventDispatcher</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">addEventListener</span>(<span class="params">type, listener</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._listeners === <span class="literal">undefined</span>) <span class="built_in">this</span>._listeners = &#123;&#125;;</span><br><span class="line">            <span class="keyword">const</span> listeners = <span class="built_in">this</span>._listeners;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (listeners[type] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                listeners[type] = [];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (listeners[type].indexOf(listener) === -<span class="number">1</span>) &#123;</span><br><span class="line">                listeners[type].push(listener);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">hasEventListener</span>(<span class="params">type, listener</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._listeners === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">const</span> listeners = <span class="built_in">this</span>._listeners;</span><br><span class="line">            <span class="keyword">return</span> listeners[type] !== <span class="literal">undefined</span> &amp;&amp; listeners[type].indexOf(listener) !== -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">removeEventListener</span>(<span class="params">type, listener</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._listeners === <span class="literal">undefined</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">const</span> listeners = <span class="built_in">this</span>._listeners;</span><br><span class="line">            <span class="keyword">const</span> listenerArray = listeners[type];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (listenerArray !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> index = listenerArray.indexOf(listener);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">                    listenerArray.splice(index, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dispatchEvent</span>(<span class="params">event</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._listeners === <span class="literal">undefined</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">const</span> listeners = <span class="built_in">this</span>._listeners;</span><br><span class="line">            <span class="keyword">const</span> listenerArray = listeners[event.type];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (listenerArray !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                event.target = <span class="built_in">this</span>; <span class="comment">// Make a copy, in case listeners are removed while iterating.</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> array = listenerArray.slice(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = array.length; i &lt; l; i++) &#123;</span><br><span class="line">                    array[i].call(<span class="built_in">this</span>, event);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                event.target = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _lut = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        _lut[i] = (i &lt; <span class="number">16</span> ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;&#x27;</span>) + i.toString(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> _seed = <span class="number">1234567</span>;</span><br><span class="line">    <span class="keyword">const</span> DEG2RAD = <span class="built_in">Math</span>.PI / <span class="number">180</span>;</span><br><span class="line">    <span class="keyword">const</span> RAD2DEG = <span class="number">180</span> / <span class="built_in">Math</span>.PI; <span class="comment">// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">generateUUID</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> d0 = <span class="built_in">Math</span>.random() * <span class="number">0xffffffff</span> | <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> d1 = <span class="built_in">Math</span>.random() * <span class="number">0xffffffff</span> | <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> d2 = <span class="built_in">Math</span>.random() * <span class="number">0xffffffff</span> | <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> d3 = <span class="built_in">Math</span>.random() * <span class="number">0xffffffff</span> | <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> uuid = _lut[d0 &amp; <span class="number">0xff</span>] + _lut[d0 &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xff</span>] + _lut[d0 &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xff</span>] + _lut[d0 &gt;&gt; <span class="number">24</span> &amp; <span class="number">0xff</span>] + <span class="string">&#x27;-&#x27;</span> + _lut[d1 &amp; <span class="number">0xff</span>] + _lut[d1 &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xff</span>] + <span class="string">&#x27;-&#x27;</span> + _lut[d1 &gt;&gt; <span class="number">16</span> &amp; <span class="number">0x0f</span> | <span class="number">0x40</span>] + _lut[d1 &gt;&gt; <span class="number">24</span> &amp; <span class="number">0xff</span>] + <span class="string">&#x27;-&#x27;</span> + _lut[d2 &amp; <span class="number">0x3f</span> | <span class="number">0x80</span>] + _lut[d2 &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xff</span>] + <span class="string">&#x27;-&#x27;</span> + _lut[d2 &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xff</span>] + _lut[d2 &gt;&gt; <span class="number">24</span> &amp; <span class="number">0xff</span>] + _lut[d3 &amp; <span class="number">0xff</span>] + _lut[d3 &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xff</span>] + _lut[d3 &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xff</span>] + _lut[d3 &gt;&gt; <span class="number">24</span> &amp; <span class="number">0xff</span>]; <span class="comment">// .toLowerCase() here flattens concatenated strings to save heap memory space.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> uuid.toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">clamp</span>(<span class="params">value, min, max</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.max(min, <span class="built_in">Math</span>.min(max, value));</span><br><span class="line">    &#125; <span class="comment">// compute euclidean modulo of m % n</span></span><br><span class="line">    <span class="comment">// https://en.wikipedia.org/wiki/Modulo_operation</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">euclideanModulo</span>(<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (n % m + m) % m;</span><br><span class="line">    &#125; <span class="comment">// Linear mapping from range &lt;a1, a2&gt; to range &lt;b1, b2&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mapLinear</span>(<span class="params">x, a1, a2, b1, b2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b1 + (x - a1) * (b2 - b1) / (a2 - a1);</span><br><span class="line">    &#125; <span class="comment">// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inverseLerp</span>(<span class="params">x, y, value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x !== y) &#123;</span><br><span class="line">            <span class="keyword">return</span> (value - x) / (y - x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// https://en.wikipedia.org/wiki/Linear_interpolation</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">lerp</span>(<span class="params">x, y, t</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> - t) * x + t * y;</span><br><span class="line">    &#125; <span class="comment">// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">damp</span>(<span class="params">x, y, lambda, dt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lerp(x, y, <span class="number">1</span> - <span class="built_in">Math</span>.exp(-lambda * dt));</span><br><span class="line">    &#125; <span class="comment">// https://www.desmos.com/calculator/vcsjnyz7x4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pingpong</span>(<span class="params">x, length = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length - <span class="built_in">Math</span>.abs(euclideanModulo(x, length * <span class="number">2</span>) - length);</span><br><span class="line">    &#125; <span class="comment">// http://en.wikipedia.org/wiki/Smoothstep</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">smoothstep</span>(<span class="params">x, min, max</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= min) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= max) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        x = (x - min) / (max - min);</span><br><span class="line">        <span class="keyword">return</span> x * x * (<span class="number">3</span> - <span class="number">2</span> * x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">smootherstep</span>(<span class="params">x, min, max</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= min) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= max) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        x = (x - min) / (max - min);</span><br><span class="line">        <span class="keyword">return</span> x * x * x * (x * (x * <span class="number">6</span> - <span class="number">15</span>) + <span class="number">10</span>);</span><br><span class="line">    &#125; <span class="comment">// Random integer from &lt;low, high&gt; interval</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">randInt</span>(<span class="params">low, high</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> low + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (high - low + <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="comment">// Random float from &lt;low, high&gt; interval</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">randFloat</span>(<span class="params">low, high</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> low + <span class="built_in">Math</span>.random() * (high - low);</span><br><span class="line">    &#125; <span class="comment">// Random float from &lt;-range/2, range/2&gt; interval</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">randFloatSpread</span>(<span class="params">range</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> range * (<span class="number">0.5</span> - <span class="built_in">Math</span>.random());</span><br><span class="line">    &#125; <span class="comment">// Deterministic pseudo-random float in the interval [ 0, 1 ]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">seededRandom</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s !== <span class="literal">undefined</span>) _seed = s; <span class="comment">// Mulberry32 generator</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> t = _seed += <span class="number">0x6D2B79F5</span>;</span><br><span class="line">        t = <span class="built_in">Math</span>.imul(t ^ t &gt;&gt;&gt; <span class="number">15</span>, t | <span class="number">1</span>);</span><br><span class="line">        t ^= t + <span class="built_in">Math</span>.imul(t ^ t &gt;&gt;&gt; <span class="number">7</span>, t | <span class="number">61</span>);</span><br><span class="line">        <span class="keyword">return</span> ((t ^ t &gt;&gt;&gt; <span class="number">14</span>) &gt;&gt;&gt; <span class="number">0</span>) / <span class="number">4294967296</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">degToRad</span>(<span class="params">degrees</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> degrees * DEG2RAD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">radToDeg</span>(<span class="params">radians</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> radians * RAD2DEG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isPowerOfTwo</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (value &amp; value - <span class="number">1</span>) === <span class="number">0</span> &amp;&amp; value !== <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ceilPowerOfTwo</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.log(value) / <span class="built_in">Math</span>.LN2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">floorPowerOfTwo</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.log(value) / <span class="built_in">Math</span>.LN2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setQuaternionFromProperEuler</span>(<span class="params">q, a, b, c, order</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles</span></span><br><span class="line">        <span class="comment">// rotations are applied to the axes in the order specified by &#x27;order&#x27;</span></span><br><span class="line">        <span class="comment">// rotation by angle &#x27;a&#x27; is applied first, then by angle &#x27;b&#x27;, then by angle &#x27;c&#x27;</span></span><br><span class="line">        <span class="comment">// angles are in radians</span></span><br><span class="line">        <span class="keyword">const</span> cos = <span class="built_in">Math</span>.cos;</span><br><span class="line">        <span class="keyword">const</span> sin = <span class="built_in">Math</span>.sin;</span><br><span class="line">        <span class="keyword">const</span> c2 = cos(b / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">const</span> s2 = sin(b / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">const</span> c13 = cos((a + c) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">const</span> s13 = sin((a + c) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">const</span> c1_3 = cos((a - c) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">const</span> s1_3 = sin((a - c) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">const</span> c3_1 = cos((c - a) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">const</span> s3_1 = sin((c - a) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (order) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;XYX&#x27;</span>:</span><br><span class="line">                q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;YZY&#x27;</span>:</span><br><span class="line">                q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;ZXZ&#x27;</span>:</span><br><span class="line">                q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;XZX&#x27;</span>:</span><br><span class="line">                q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;YXY&#x27;</span>:</span><br><span class="line">                q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;ZYZ&#x27;</span>:</span><br><span class="line">                q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: &#x27;</span> + order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">denormalize$1</span>(<span class="params">value, array</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (array.constructor) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">Float32Array</span>:</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">Uint16Array</span>:</span><br><span class="line">                <span class="keyword">return</span> value / <span class="number">65535.0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">Uint8Array</span>:</span><br><span class="line">                <span class="keyword">return</span> value / <span class="number">255.0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">Int16Array</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Math</span>.max(value / <span class="number">32767.0</span>, -<span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">Int8Array</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Math</span>.max(value / <span class="number">127.0</span>, -<span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Invalid component type.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">normalize</span>(<span class="params">value, array</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (array.constructor) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">Float32Array</span>:</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">Uint16Array</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Math</span>.round(value * <span class="number">65535.0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">Uint8Array</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Math</span>.round(value * <span class="number">255.0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">Int16Array</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Math</span>.round(value * <span class="number">32767.0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">Int8Array</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Math</span>.round(value * <span class="number">127.0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Invalid component type.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> MathUtils = <span class="comment">/*#__PURE__*/</span><span class="built_in">Object</span>.freeze(&#123;</span><br><span class="line">        <span class="attr">__proto__</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">DEG2RAD</span>: DEG2RAD,</span><br><span class="line">        <span class="attr">RAD2DEG</span>: RAD2DEG,</span><br><span class="line">        <span class="attr">generateUUID</span>: generateUUID,</span><br><span class="line">        <span class="attr">clamp</span>: clamp,</span><br><span class="line">        <span class="attr">euclideanModulo</span>: euclideanModulo,</span><br><span class="line">        <span class="attr">mapLinear</span>: mapLinear,</span><br><span class="line">        <span class="attr">inverseLerp</span>: inverseLerp,</span><br><span class="line">        <span class="attr">lerp</span>: lerp,</span><br><span class="line">        <span class="attr">damp</span>: damp,</span><br><span class="line">        <span class="attr">pingpong</span>: pingpong,</span><br><span class="line">        <span class="attr">smoothstep</span>: smoothstep,</span><br><span class="line">        <span class="attr">smootherstep</span>: smootherstep,</span><br><span class="line">        <span class="attr">randInt</span>: randInt,</span><br><span class="line">        <span class="attr">randFloat</span>: randFloat,</span><br><span class="line">        <span class="attr">randFloatSpread</span>: randFloatSpread,</span><br><span class="line">        <span class="attr">seededRandom</span>: seededRandom,</span><br><span class="line">        <span class="attr">degToRad</span>: degToRad,</span><br><span class="line">        <span class="attr">radToDeg</span>: radToDeg,</span><br><span class="line">        <span class="attr">isPowerOfTwo</span>: isPowerOfTwo,</span><br><span class="line">        <span class="attr">ceilPowerOfTwo</span>: ceilPowerOfTwo,</span><br><span class="line">        <span class="attr">floorPowerOfTwo</span>: floorPowerOfTwo,</span><br><span class="line">        <span class="attr">setQuaternionFromProperEuler</span>: setQuaternionFromProperEuler,</span><br><span class="line">        <span class="attr">normalize</span>: normalize,</span><br><span class="line">        <span class="attr">denormalize</span>: denormalize$<span class="number">1</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Vector2</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = x;</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">width</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">width</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">height</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">height</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.y = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = x;</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setScalar</span>(<span class="params">scalar</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = scalar;</span><br><span class="line">            <span class="built_in">this</span>.y = scalar;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setX</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = x;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setY</span>(<span class="params">y</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setComponent</span>(<span class="params">index, value</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (index) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="built_in">this</span>.x = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="built_in">this</span>.y = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;index is out of range: &#x27;</span> + index);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getComponent</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (index) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.y;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;index is out of range: &#x27;</span> + index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor(<span class="built_in">this</span>.x, <span class="built_in">this</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = v.x;</span><br><span class="line">            <span class="built_in">this</span>.y = v.y;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params">v, w</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (w !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.addVectors(v, w);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.x += v.x;</span><br><span class="line">            <span class="built_in">this</span>.y += v.y;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">addScalar</span>(<span class="params">s</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x += s;</span><br><span class="line">            <span class="built_in">this</span>.y += s;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">addVectors</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = a.x + b.x;</span><br><span class="line">            <span class="built_in">this</span>.y = a.y + b.y;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">addScaledVector</span>(<span class="params">v, s</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x += v.x * s;</span><br><span class="line">            <span class="built_in">this</span>.y += v.y * s;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">sub</span>(<span class="params">v, w</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (w !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.subVectors(v, w);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.x -= v.x;</span><br><span class="line">            <span class="built_in">this</span>.y -= v.y;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">subScalar</span>(<span class="params">s</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x -= s;</span><br><span class="line">            <span class="built_in">this</span>.y -= s;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">subVectors</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = a.x - b.x;</span><br><span class="line">            <span class="built_in">this</span>.y = a.y - b.y;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">multiply</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x *= v.x;</span><br><span class="line">            <span class="built_in">this</span>.y *= v.y;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">multiplyScalar</span>(<span class="params">scalar</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x *= scalar;</span><br><span class="line">            <span class="built_in">this</span>.y *= scalar;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">divide</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x /= v.x;</span><br><span class="line">            <span class="built_in">this</span>.y /= v.y;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">divideScalar</span>(<span class="params">scalar</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.multiplyScalar(<span class="number">1</span> / scalar);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">applyMatrix3</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> x = <span class="built_in">this</span>.x,</span><br><span class="line">                y = <span class="built_in">this</span>.y;</span><br><span class="line">            <span class="keyword">const</span> e = m.elements;</span><br><span class="line">            <span class="built_in">this</span>.x = e[<span class="number">0</span>] * x + e[<span class="number">3</span>] * y + e[<span class="number">6</span>];</span><br><span class="line">            <span class="built_in">this</span>.y = e[<span class="number">1</span>] * x + e[<span class="number">4</span>] * y + e[<span class="number">7</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">min</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">Math</span>.min(<span class="built_in">this</span>.x, v.x);</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.min(<span class="built_in">this</span>.y, v.y);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">max</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">Math</span>.max(<span class="built_in">this</span>.x, v.x);</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.max(<span class="built_in">this</span>.y, v.y);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clamp</span>(<span class="params">min, max</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// assumes min &lt; max, componentwise</span></span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">Math</span>.max(min.x, <span class="built_in">Math</span>.min(max.x, <span class="built_in">this</span>.x));</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.max(min.y, <span class="built_in">Math</span>.min(max.y, <span class="built_in">this</span>.y));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clampScalar</span>(<span class="params">minVal, maxVal</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">Math</span>.max(minVal, <span class="built_in">Math</span>.min(maxVal, <span class="built_in">this</span>.x));</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.max(minVal, <span class="built_in">Math</span>.min(maxVal, <span class="built_in">this</span>.y));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clampLength</span>(<span class="params">min, max</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> length = <span class="built_in">this</span>.length();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.divideScalar(length || <span class="number">1</span>).multiplyScalar(<span class="built_in">Math</span>.max(min, <span class="built_in">Math</span>.min(max, length)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">floor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">Math</span>.floor(<span class="built_in">this</span>.x);</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.floor(<span class="built_in">this</span>.y);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">ceil</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">Math</span>.ceil(<span class="built_in">this</span>.x);</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.ceil(<span class="built_in">this</span>.y);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">round</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">Math</span>.round(<span class="built_in">this</span>.x);</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.round(<span class="built_in">this</span>.y);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">roundToZero</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">this</span>.x &lt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(<span class="built_in">this</span>.x) : <span class="built_in">Math</span>.floor(<span class="built_in">this</span>.x);</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">this</span>.y &lt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(<span class="built_in">this</span>.y) : <span class="built_in">Math</span>.floor(<span class="built_in">this</span>.y);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">negate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = -<span class="built_in">this</span>.x;</span><br><span class="line">            <span class="built_in">this</span>.y = -<span class="built_in">this</span>.y;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dot</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.x * v.x + <span class="built_in">this</span>.y * v.y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">cross</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.x * v.y - <span class="built_in">this</span>.y * v.x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">lengthSq</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.x * <span class="built_in">this</span>.x + <span class="built_in">this</span>.y * <span class="built_in">this</span>.y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">length</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="built_in">this</span>.x * <span class="built_in">this</span>.x + <span class="built_in">this</span>.y * <span class="built_in">this</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">manhattanLength</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.abs(<span class="built_in">this</span>.x) + <span class="built_in">Math</span>.abs(<span class="built_in">this</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">normalize</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.divideScalar(<span class="built_in">this</span>.length() || <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">angle</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// computes the angle in radians with respect to the positive x-axis</span></span><br><span class="line">            <span class="keyword">const</span> angle = <span class="built_in">Math</span>.atan2(-<span class="built_in">this</span>.y, -<span class="built_in">this</span>.x) + <span class="built_in">Math</span>.PI;</span><br><span class="line">            <span class="keyword">return</span> angle;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">distanceTo</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="built_in">this</span>.distanceToSquared(v));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">distanceToSquared</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> dx = <span class="built_in">this</span>.x - v.x,</span><br><span class="line">                dy = <span class="built_in">this</span>.y - v.y;</span><br><span class="line">            <span class="keyword">return</span> dx * dx + dy * dy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">manhattanDistanceTo</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.abs(<span class="built_in">this</span>.x - v.x) + <span class="built_in">Math</span>.abs(<span class="built_in">this</span>.y - v.y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setLength</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.normalize().multiplyScalar(length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">lerp</span>(<span class="params">v, alpha</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x += (v.x - <span class="built_in">this</span>.x) * alpha;</span><br><span class="line">            <span class="built_in">this</span>.y += (v.y - <span class="built_in">this</span>.y) * alpha;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">lerpVectors</span>(<span class="params">v1, v2, alpha</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = v1.x + (v2.x - v1.x) * alpha;</span><br><span class="line">            <span class="built_in">this</span>.y = v1.y + (v2.y - v1.y) * alpha;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">equals</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> v.x === <span class="built_in">this</span>.x &amp;&amp; v.y === <span class="built_in">this</span>.y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromArray</span>(<span class="params">array, offset = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = array[offset];</span><br><span class="line">            <span class="built_in">this</span>.y = array[offset + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toArray</span>(<span class="params">array = [], offset = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            array[offset] = <span class="built_in">this</span>.x;</span><br><span class="line">            array[offset + <span class="number">1</span>] = <span class="built_in">this</span>.y;</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromBufferAttribute</span>(<span class="params">attribute, index, offset</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (offset !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Vector2: offset has been removed from .fromBufferAttribute().&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.x = attribute.getX(index);</span><br><span class="line">            <span class="built_in">this</span>.y = attribute.getY(index);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">rotateAround</span>(<span class="params">center, angle</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> c = <span class="built_in">Math</span>.cos(angle),</span><br><span class="line">                s = <span class="built_in">Math</span>.sin(angle);</span><br><span class="line">            <span class="keyword">const</span> x = <span class="built_in">this</span>.x - center.x;</span><br><span class="line">            <span class="keyword">const</span> y = <span class="built_in">this</span>.y - center.y;</span><br><span class="line">            <span class="built_in">this</span>.x = x * c - y * s + center.x;</span><br><span class="line">            <span class="built_in">this</span>.y = x * s + y * c + center.y;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">random</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">Math</span>.random();</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.random();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="built_in">this</span>.x;</span><br><span class="line">            <span class="keyword">yield</span> <span class="built_in">this</span>.y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector2.prototype.isVector2 = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Matrix3</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.elements = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">n11, n12, n13, n21, n22, n23, n31, n32, n33</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            te[<span class="number">0</span>] = n11;</span><br><span class="line">            te[<span class="number">1</span>] = n21;</span><br><span class="line">            te[<span class="number">2</span>] = n31;</span><br><span class="line">            te[<span class="number">3</span>] = n12;</span><br><span class="line">            te[<span class="number">4</span>] = n22;</span><br><span class="line">            te[<span class="number">5</span>] = n32;</span><br><span class="line">            te[<span class="number">6</span>] = n13;</span><br><span class="line">            te[<span class="number">7</span>] = n23;</span><br><span class="line">            te[<span class="number">8</span>] = n33;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">identity</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.set(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            <span class="keyword">const</span> me = m.elements;</span><br><span class="line">            te[<span class="number">0</span>] = me[<span class="number">0</span>];</span><br><span class="line">            te[<span class="number">1</span>] = me[<span class="number">1</span>];</span><br><span class="line">            te[<span class="number">2</span>] = me[<span class="number">2</span>];</span><br><span class="line">            te[<span class="number">3</span>] = me[<span class="number">3</span>];</span><br><span class="line">            te[<span class="number">4</span>] = me[<span class="number">4</span>];</span><br><span class="line">            te[<span class="number">5</span>] = me[<span class="number">5</span>];</span><br><span class="line">            te[<span class="number">6</span>] = me[<span class="number">6</span>];</span><br><span class="line">            te[<span class="number">7</span>] = me[<span class="number">7</span>];</span><br><span class="line">            te[<span class="number">8</span>] = me[<span class="number">8</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">extractBasis</span>(<span class="params">xAxis, yAxis, zAxis</span>)</span> &#123;</span><br><span class="line">            xAxis.setFromMatrix3Column(<span class="built_in">this</span>, <span class="number">0</span>);</span><br><span class="line">            yAxis.setFromMatrix3Column(<span class="built_in">this</span>, <span class="number">1</span>);</span><br><span class="line">            zAxis.setFromMatrix3Column(<span class="built_in">this</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromMatrix4</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> me = m.elements;</span><br><span class="line">            <span class="built_in">this</span>.set(me[<span class="number">0</span>], me[<span class="number">4</span>], me[<span class="number">8</span>], me[<span class="number">1</span>], me[<span class="number">5</span>], me[<span class="number">9</span>], me[<span class="number">2</span>], me[<span class="number">6</span>], me[<span class="number">10</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">multiply</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.multiplyMatrices(<span class="built_in">this</span>, m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">premultiply</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.multiplyMatrices(m, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">multiplyMatrices</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> ae = a.elements;</span><br><span class="line">            <span class="keyword">const</span> be = b.elements;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            <span class="keyword">const</span> a11 = ae[<span class="number">0</span>],</span><br><span class="line">                a12 = ae[<span class="number">3</span>],</span><br><span class="line">                a13 = ae[<span class="number">6</span>];</span><br><span class="line">            <span class="keyword">const</span> a21 = ae[<span class="number">1</span>],</span><br><span class="line">                a22 = ae[<span class="number">4</span>],</span><br><span class="line">                a23 = ae[<span class="number">7</span>];</span><br><span class="line">            <span class="keyword">const</span> a31 = ae[<span class="number">2</span>],</span><br><span class="line">                a32 = ae[<span class="number">5</span>],</span><br><span class="line">                a33 = ae[<span class="number">8</span>];</span><br><span class="line">            <span class="keyword">const</span> b11 = be[<span class="number">0</span>],</span><br><span class="line">                b12 = be[<span class="number">3</span>],</span><br><span class="line">                b13 = be[<span class="number">6</span>];</span><br><span class="line">            <span class="keyword">const</span> b21 = be[<span class="number">1</span>],</span><br><span class="line">                b22 = be[<span class="number">4</span>],</span><br><span class="line">                b23 = be[<span class="number">7</span>];</span><br><span class="line">            <span class="keyword">const</span> b31 = be[<span class="number">2</span>],</span><br><span class="line">                b32 = be[<span class="number">5</span>],</span><br><span class="line">                b33 = be[<span class="number">8</span>];</span><br><span class="line">            te[<span class="number">0</span>] = a11 * b11 + a12 * b21 + a13 * b31;</span><br><span class="line">            te[<span class="number">3</span>] = a11 * b12 + a12 * b22 + a13 * b32;</span><br><span class="line">            te[<span class="number">6</span>] = a11 * b13 + a12 * b23 + a13 * b33;</span><br><span class="line">            te[<span class="number">1</span>] = a21 * b11 + a22 * b21 + a23 * b31;</span><br><span class="line">            te[<span class="number">4</span>] = a21 * b12 + a22 * b22 + a23 * b32;</span><br><span class="line">            te[<span class="number">7</span>] = a21 * b13 + a22 * b23 + a23 * b33;</span><br><span class="line">            te[<span class="number">2</span>] = a31 * b11 + a32 * b21 + a33 * b31;</span><br><span class="line">            te[<span class="number">5</span>] = a31 * b12 + a32 * b22 + a33 * b32;</span><br><span class="line">            te[<span class="number">8</span>] = a31 * b13 + a32 * b23 + a33 * b33;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">multiplyScalar</span>(<span class="params">s</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            te[<span class="number">0</span>] *= s;</span><br><span class="line">            te[<span class="number">3</span>] *= s;</span><br><span class="line">            te[<span class="number">6</span>] *= s;</span><br><span class="line">            te[<span class="number">1</span>] *= s;</span><br><span class="line">            te[<span class="number">4</span>] *= s;</span><br><span class="line">            te[<span class="number">7</span>] *= s;</span><br><span class="line">            te[<span class="number">2</span>] *= s;</span><br><span class="line">            te[<span class="number">5</span>] *= s;</span><br><span class="line">            te[<span class="number">8</span>] *= s;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">determinant</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            <span class="keyword">const</span> a = te[<span class="number">0</span>],</span><br><span class="line">                b = te[<span class="number">1</span>],</span><br><span class="line">                c = te[<span class="number">2</span>],</span><br><span class="line">                d = te[<span class="number">3</span>],</span><br><span class="line">                e = te[<span class="number">4</span>],</span><br><span class="line">                f = te[<span class="number">5</span>],</span><br><span class="line">                g = te[<span class="number">6</span>],</span><br><span class="line">                h = te[<span class="number">7</span>],</span><br><span class="line">                i = te[<span class="number">8</span>];</span><br><span class="line">            <span class="keyword">return</span> a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">invert</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements,</span><br><span class="line">                n11 = te[<span class="number">0</span>],</span><br><span class="line">                n21 = te[<span class="number">1</span>],</span><br><span class="line">                n31 = te[<span class="number">2</span>],</span><br><span class="line">                n12 = te[<span class="number">3</span>],</span><br><span class="line">                n22 = te[<span class="number">4</span>],</span><br><span class="line">                n32 = te[<span class="number">5</span>],</span><br><span class="line">                n13 = te[<span class="number">6</span>],</span><br><span class="line">                n23 = te[<span class="number">7</span>],</span><br><span class="line">                n33 = te[<span class="number">8</span>],</span><br><span class="line">                t11 = n33 * n22 - n32 * n23,</span><br><span class="line">                t12 = n32 * n13 - n33 * n12,</span><br><span class="line">                t13 = n23 * n12 - n22 * n13,</span><br><span class="line">                det = n11 * t11 + n21 * t12 + n31 * t13;</span><br><span class="line">            <span class="keyword">if</span> (det === <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">this</span>.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">const</span> detInv = <span class="number">1</span> / det;</span><br><span class="line">            te[<span class="number">0</span>] = t11 * detInv;</span><br><span class="line">            te[<span class="number">1</span>] = (n31 * n23 - n33 * n21) * detInv;</span><br><span class="line">            te[<span class="number">2</span>] = (n32 * n21 - n31 * n22) * detInv;</span><br><span class="line">            te[<span class="number">3</span>] = t12 * detInv;</span><br><span class="line">            te[<span class="number">4</span>] = (n33 * n11 - n31 * n13) * detInv;</span><br><span class="line">            te[<span class="number">5</span>] = (n31 * n12 - n32 * n11) * detInv;</span><br><span class="line">            te[<span class="number">6</span>] = t13 * detInv;</span><br><span class="line">            te[<span class="number">7</span>] = (n21 * n13 - n23 * n11) * detInv;</span><br><span class="line">            te[<span class="number">8</span>] = (n22 * n11 - n21 * n12) * detInv;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">transpose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> tmp;</span><br><span class="line">            <span class="keyword">const</span> m = <span class="built_in">this</span>.elements;</span><br><span class="line">            tmp = m[<span class="number">1</span>];</span><br><span class="line">            m[<span class="number">1</span>] = m[<span class="number">3</span>];</span><br><span class="line">            m[<span class="number">3</span>] = tmp;</span><br><span class="line">            tmp = m[<span class="number">2</span>];</span><br><span class="line">            m[<span class="number">2</span>] = m[<span class="number">6</span>];</span><br><span class="line">            m[<span class="number">6</span>] = tmp;</span><br><span class="line">            tmp = m[<span class="number">5</span>];</span><br><span class="line">            m[<span class="number">5</span>] = m[<span class="number">7</span>];</span><br><span class="line">            m[<span class="number">7</span>] = tmp;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getNormalMatrix</span>(<span class="params">matrix4</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.setFromMatrix4(matrix4).invert().transpose();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">transposeIntoArray</span>(<span class="params">r</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> m = <span class="built_in">this</span>.elements;</span><br><span class="line">            r[<span class="number">0</span>] = m[<span class="number">0</span>];</span><br><span class="line">            r[<span class="number">1</span>] = m[<span class="number">3</span>];</span><br><span class="line">            r[<span class="number">2</span>] = m[<span class="number">6</span>];</span><br><span class="line">            r[<span class="number">3</span>] = m[<span class="number">1</span>];</span><br><span class="line">            r[<span class="number">4</span>] = m[<span class="number">4</span>];</span><br><span class="line">            r[<span class="number">5</span>] = m[<span class="number">7</span>];</span><br><span class="line">            r[<span class="number">6</span>] = m[<span class="number">2</span>];</span><br><span class="line">            r[<span class="number">7</span>] = m[<span class="number">5</span>];</span><br><span class="line">            r[<span class="number">8</span>] = m[<span class="number">8</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setUvTransform</span>(<span class="params">tx, ty, sx, sy, rotation, cx, cy</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> c = <span class="built_in">Math</span>.cos(rotation);</span><br><span class="line">            <span class="keyword">const</span> s = <span class="built_in">Math</span>.sin(rotation);</span><br><span class="line">            <span class="built_in">this</span>.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">scale</span>(<span class="params">sx, sy</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            te[<span class="number">0</span>] *= sx;</span><br><span class="line">            te[<span class="number">3</span>] *= sx;</span><br><span class="line">            te[<span class="number">6</span>] *= sx;</span><br><span class="line">            te[<span class="number">1</span>] *= sy;</span><br><span class="line">            te[<span class="number">4</span>] *= sy;</span><br><span class="line">            te[<span class="number">7</span>] *= sy;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">rotate</span>(<span class="params">theta</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> c = <span class="built_in">Math</span>.cos(theta);</span><br><span class="line">            <span class="keyword">const</span> s = <span class="built_in">Math</span>.sin(theta);</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            <span class="keyword">const</span> a11 = te[<span class="number">0</span>],</span><br><span class="line">                a12 = te[<span class="number">3</span>],</span><br><span class="line">                a13 = te[<span class="number">6</span>];</span><br><span class="line">            <span class="keyword">const</span> a21 = te[<span class="number">1</span>],</span><br><span class="line">                a22 = te[<span class="number">4</span>],</span><br><span class="line">                a23 = te[<span class="number">7</span>];</span><br><span class="line">            te[<span class="number">0</span>] = c * a11 + s * a21;</span><br><span class="line">            te[<span class="number">3</span>] = c * a12 + s * a22;</span><br><span class="line">            te[<span class="number">6</span>] = c * a13 + s * a23;</span><br><span class="line">            te[<span class="number">1</span>] = -s * a11 + c * a21;</span><br><span class="line">            te[<span class="number">4</span>] = -s * a12 + c * a22;</span><br><span class="line">            te[<span class="number">7</span>] = -s * a13 + c * a23;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">translate</span>(<span class="params">tx, ty</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            te[<span class="number">0</span>] += tx * te[<span class="number">2</span>];</span><br><span class="line">            te[<span class="number">3</span>] += tx * te[<span class="number">5</span>];</span><br><span class="line">            te[<span class="number">6</span>] += tx * te[<span class="number">8</span>];</span><br><span class="line">            te[<span class="number">1</span>] += ty * te[<span class="number">2</span>];</span><br><span class="line">            te[<span class="number">4</span>] += ty * te[<span class="number">5</span>];</span><br><span class="line">            te[<span class="number">7</span>] += ty * te[<span class="number">8</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">equals</span>(<span class="params">matrix</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            <span class="keyword">const</span> me = matrix.elements;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (te[i] !== me[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromArray</span>(<span class="params">array, offset = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.elements[i] = array[i + offset];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toArray</span>(<span class="params">array = [], offset = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            array[offset] = te[<span class="number">0</span>];</span><br><span class="line">            array[offset + <span class="number">1</span>] = te[<span class="number">1</span>];</span><br><span class="line">            array[offset + <span class="number">2</span>] = te[<span class="number">2</span>];</span><br><span class="line">            array[offset + <span class="number">3</span>] = te[<span class="number">3</span>];</span><br><span class="line">            array[offset + <span class="number">4</span>] = te[<span class="number">4</span>];</span><br><span class="line">            array[offset + <span class="number">5</span>] = te[<span class="number">5</span>];</span><br><span class="line">            array[offset + <span class="number">6</span>] = te[<span class="number">6</span>];</span><br><span class="line">            array[offset + <span class="number">7</span>] = te[<span class="number">7</span>];</span><br><span class="line">            array[offset + <span class="number">8</span>] = te[<span class="number">8</span>];</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor().fromArray(<span class="built_in">this</span>.elements);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Matrix3.prototype.isMatrix3 = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">arrayNeedsUint32</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// assumes larger values usually on last</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; <span class="number">65535</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> TYPED_ARRAYS = &#123;</span><br><span class="line">        <span class="attr">Int8Array</span>: <span class="built_in">Int8Array</span>,</span><br><span class="line">        <span class="attr">Uint8Array</span>: <span class="built_in">Uint8Array</span>,</span><br><span class="line">        <span class="attr">Uint8ClampedArray</span>: <span class="built_in">Uint8ClampedArray</span>,</span><br><span class="line">        <span class="attr">Int16Array</span>: <span class="built_in">Int16Array</span>,</span><br><span class="line">        <span class="attr">Uint16Array</span>: <span class="built_in">Uint16Array</span>,</span><br><span class="line">        <span class="attr">Int32Array</span>: <span class="built_in">Int32Array</span>,</span><br><span class="line">        <span class="attr">Uint32Array</span>: <span class="built_in">Uint32Array</span>,</span><br><span class="line">        <span class="attr">Float32Array</span>: <span class="built_in">Float32Array</span>,</span><br><span class="line">        <span class="attr">Float64Array</span>: <span class="built_in">Float64Array</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getTypedArray</span>(<span class="params">type, buffer</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TYPED_ARRAYS[type](buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createElementNS</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">document</span>.createElementNS(<span class="string">&#x27;http://www.w3.org/1999/xhtml&#x27;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">SRGBToLinear</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; <span class="number">0.04045</span> ? c * <span class="number">0.0773993808</span> : <span class="built_in">Math</span>.pow(c * <span class="number">0.9478672986</span> + <span class="number">0.0521327014</span>, <span class="number">2.4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">LinearToSRGB</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; <span class="number">0.0031308</span> ? c * <span class="number">12.92</span> : <span class="number">1.055</span> * <span class="built_in">Math</span>.pow(c, <span class="number">0.41666</span>) - <span class="number">0.055</span>;</span><br><span class="line">    &#125; <span class="comment">// JavaScript RGB-to-RGB transforms, defined as</span></span><br><span class="line">    <span class="comment">// FN[InputColorSpace][OutputColorSpace] callback functions.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> FN = &#123;</span><br><span class="line">        [SRGBColorSpace]: &#123;</span><br><span class="line">            [LinearSRGBColorSpace]: SRGBToLinear</span><br><span class="line">        &#125;,</span><br><span class="line">        [LinearSRGBColorSpace]: &#123;</span><br><span class="line">            [SRGBColorSpace]: LinearToSRGB</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> ColorManagement = &#123;</span><br><span class="line">        <span class="attr">legacyMode</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">workingColorSpace</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> LinearSRGBColorSpace;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">workingColorSpace</span>(<span class="params">colorSpace</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.ColorManagement: .workingColorSpace is readonly.&#x27;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="attr">convert</span>: <span class="function"><span class="keyword">function</span> (<span class="params">color, sourceColorSpace, targetColorSpace</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.legacyMode || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) &#123;</span><br><span class="line">                <span class="keyword">return</span> color;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (FN[sourceColorSpace] &amp;&amp; FN[sourceColorSpace][targetColorSpace] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> fn = FN[sourceColorSpace][targetColorSpace];</span><br><span class="line">                color.r = fn(color.r);</span><br><span class="line">                color.g = fn(color.g);</span><br><span class="line">                color.b = fn(color.b);</span><br><span class="line">                <span class="keyword">return</span> color;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Unsupported color space conversion.&#x27;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">fromWorkingColorSpace</span>: <span class="function"><span class="keyword">function</span> (<span class="params">color, targetColorSpace</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.convert(color, <span class="built_in">this</span>.workingColorSpace, targetColorSpace);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">toWorkingColorSpace</span>: <span class="function"><span class="keyword">function</span> (<span class="params">color, sourceColorSpace</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.convert(color, sourceColorSpace, <span class="built_in">this</span>.workingColorSpace);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _colorKeywords = &#123;</span><br><span class="line">        <span class="string">&#x27;aliceblue&#x27;</span>: <span class="number">0xF0F8FF</span>,</span><br><span class="line">        <span class="string">&#x27;antiquewhite&#x27;</span>: <span class="number">0xFAEBD7</span>,</span><br><span class="line">        <span class="string">&#x27;aqua&#x27;</span>: <span class="number">0x00FFFF</span>,</span><br><span class="line">        <span class="string">&#x27;aquamarine&#x27;</span>: <span class="number">0x7FFFD4</span>,</span><br><span class="line">        <span class="string">&#x27;azure&#x27;</span>: <span class="number">0xF0FFFF</span>,</span><br><span class="line">        <span class="string">&#x27;beige&#x27;</span>: <span class="number">0xF5F5DC</span>,</span><br><span class="line">        <span class="string">&#x27;bisque&#x27;</span>: <span class="number">0xFFE4C4</span>,</span><br><span class="line">        <span class="string">&#x27;black&#x27;</span>: <span class="number">0x000000</span>,</span><br><span class="line">        <span class="string">&#x27;blanchedalmond&#x27;</span>: <span class="number">0xFFEBCD</span>,</span><br><span class="line">        <span class="string">&#x27;blue&#x27;</span>: <span class="number">0x0000FF</span>,</span><br><span class="line">        <span class="string">&#x27;blueviolet&#x27;</span>: <span class="number">0x8A2BE2</span>,</span><br><span class="line">        <span class="string">&#x27;brown&#x27;</span>: <span class="number">0xA52A2A</span>,</span><br><span class="line">        <span class="string">&#x27;burlywood&#x27;</span>: <span class="number">0xDEB887</span>,</span><br><span class="line">        <span class="string">&#x27;cadetblue&#x27;</span>: <span class="number">0x5F9EA0</span>,</span><br><span class="line">        <span class="string">&#x27;chartreuse&#x27;</span>: <span class="number">0x7FFF00</span>,</span><br><span class="line">        <span class="string">&#x27;chocolate&#x27;</span>: <span class="number">0xD2691E</span>,</span><br><span class="line">        <span class="string">&#x27;coral&#x27;</span>: <span class="number">0xFF7F50</span>,</span><br><span class="line">        <span class="string">&#x27;cornflowerblue&#x27;</span>: <span class="number">0x6495ED</span>,</span><br><span class="line">        <span class="string">&#x27;cornsilk&#x27;</span>: <span class="number">0xFFF8DC</span>,</span><br><span class="line">        <span class="string">&#x27;crimson&#x27;</span>: <span class="number">0xDC143C</span>,</span><br><span class="line">        <span class="string">&#x27;cyan&#x27;</span>: <span class="number">0x00FFFF</span>,</span><br><span class="line">        <span class="string">&#x27;darkblue&#x27;</span>: <span class="number">0x00008B</span>,</span><br><span class="line">        <span class="string">&#x27;darkcyan&#x27;</span>: <span class="number">0x008B8B</span>,</span><br><span class="line">        <span class="string">&#x27;darkgoldenrod&#x27;</span>: <span class="number">0xB8860B</span>,</span><br><span class="line">        <span class="string">&#x27;darkgray&#x27;</span>: <span class="number">0xA9A9A9</span>,</span><br><span class="line">        <span class="string">&#x27;darkgreen&#x27;</span>: <span class="number">0x006400</span>,</span><br><span class="line">        <span class="string">&#x27;darkgrey&#x27;</span>: <span class="number">0xA9A9A9</span>,</span><br><span class="line">        <span class="string">&#x27;darkkhaki&#x27;</span>: <span class="number">0xBDB76B</span>,</span><br><span class="line">        <span class="string">&#x27;darkmagenta&#x27;</span>: <span class="number">0x8B008B</span>,</span><br><span class="line">        <span class="string">&#x27;darkolivegreen&#x27;</span>: <span class="number">0x556B2F</span>,</span><br><span class="line">        <span class="string">&#x27;darkorange&#x27;</span>: <span class="number">0xFF8C00</span>,</span><br><span class="line">        <span class="string">&#x27;darkorchid&#x27;</span>: <span class="number">0x9932CC</span>,</span><br><span class="line">        <span class="string">&#x27;darkred&#x27;</span>: <span class="number">0x8B0000</span>,</span><br><span class="line">        <span class="string">&#x27;darksalmon&#x27;</span>: <span class="number">0xE9967A</span>,</span><br><span class="line">        <span class="string">&#x27;darkseagreen&#x27;</span>: <span class="number">0x8FBC8F</span>,</span><br><span class="line">        <span class="string">&#x27;darkslateblue&#x27;</span>: <span class="number">0x483D8B</span>,</span><br><span class="line">        <span class="string">&#x27;darkslategray&#x27;</span>: <span class="number">0x2F4F4F</span>,</span><br><span class="line">        <span class="string">&#x27;darkslategrey&#x27;</span>: <span class="number">0x2F4F4F</span>,</span><br><span class="line">        <span class="string">&#x27;darkturquoise&#x27;</span>: <span class="number">0x00CED1</span>,</span><br><span class="line">        <span class="string">&#x27;darkviolet&#x27;</span>: <span class="number">0x9400D3</span>,</span><br><span class="line">        <span class="string">&#x27;deeppink&#x27;</span>: <span class="number">0xFF1493</span>,</span><br><span class="line">        <span class="string">&#x27;deepskyblue&#x27;</span>: <span class="number">0x00BFFF</span>,</span><br><span class="line">        <span class="string">&#x27;dimgray&#x27;</span>: <span class="number">0x696969</span>,</span><br><span class="line">        <span class="string">&#x27;dimgrey&#x27;</span>: <span class="number">0x696969</span>,</span><br><span class="line">        <span class="string">&#x27;dodgerblue&#x27;</span>: <span class="number">0x1E90FF</span>,</span><br><span class="line">        <span class="string">&#x27;firebrick&#x27;</span>: <span class="number">0xB22222</span>,</span><br><span class="line">        <span class="string">&#x27;floralwhite&#x27;</span>: <span class="number">0xFFFAF0</span>,</span><br><span class="line">        <span class="string">&#x27;forestgreen&#x27;</span>: <span class="number">0x228B22</span>,</span><br><span class="line">        <span class="string">&#x27;fuchsia&#x27;</span>: <span class="number">0xFF00FF</span>,</span><br><span class="line">        <span class="string">&#x27;gainsboro&#x27;</span>: <span class="number">0xDCDCDC</span>,</span><br><span class="line">        <span class="string">&#x27;ghostwhite&#x27;</span>: <span class="number">0xF8F8FF</span>,</span><br><span class="line">        <span class="string">&#x27;gold&#x27;</span>: <span class="number">0xFFD700</span>,</span><br><span class="line">        <span class="string">&#x27;goldenrod&#x27;</span>: <span class="number">0xDAA520</span>,</span><br><span class="line">        <span class="string">&#x27;gray&#x27;</span>: <span class="number">0x808080</span>,</span><br><span class="line">        <span class="string">&#x27;green&#x27;</span>: <span class="number">0x008000</span>,</span><br><span class="line">        <span class="string">&#x27;greenyellow&#x27;</span>: <span class="number">0xADFF2F</span>,</span><br><span class="line">        <span class="string">&#x27;grey&#x27;</span>: <span class="number">0x808080</span>,</span><br><span class="line">        <span class="string">&#x27;honeydew&#x27;</span>: <span class="number">0xF0FFF0</span>,</span><br><span class="line">        <span class="string">&#x27;hotpink&#x27;</span>: <span class="number">0xFF69B4</span>,</span><br><span class="line">        <span class="string">&#x27;indianred&#x27;</span>: <span class="number">0xCD5C5C</span>,</span><br><span class="line">        <span class="string">&#x27;indigo&#x27;</span>: <span class="number">0x4B0082</span>,</span><br><span class="line">        <span class="string">&#x27;ivory&#x27;</span>: <span class="number">0xFFFFF0</span>,</span><br><span class="line">        <span class="string">&#x27;khaki&#x27;</span>: <span class="number">0xF0E68C</span>,</span><br><span class="line">        <span class="string">&#x27;lavender&#x27;</span>: <span class="number">0xE6E6FA</span>,</span><br><span class="line">        <span class="string">&#x27;lavenderblush&#x27;</span>: <span class="number">0xFFF0F5</span>,</span><br><span class="line">        <span class="string">&#x27;lawngreen&#x27;</span>: <span class="number">0x7CFC00</span>,</span><br><span class="line">        <span class="string">&#x27;lemonchiffon&#x27;</span>: <span class="number">0xFFFACD</span>,</span><br><span class="line">        <span class="string">&#x27;lightblue&#x27;</span>: <span class="number">0xADD8E6</span>,</span><br><span class="line">        <span class="string">&#x27;lightcoral&#x27;</span>: <span class="number">0xF08080</span>,</span><br><span class="line">        <span class="string">&#x27;lightcyan&#x27;</span>: <span class="number">0xE0FFFF</span>,</span><br><span class="line">        <span class="string">&#x27;lightgoldenrodyellow&#x27;</span>: <span class="number">0xFAFAD2</span>,</span><br><span class="line">        <span class="string">&#x27;lightgray&#x27;</span>: <span class="number">0xD3D3D3</span>,</span><br><span class="line">        <span class="string">&#x27;lightgreen&#x27;</span>: <span class="number">0x90EE90</span>,</span><br><span class="line">        <span class="string">&#x27;lightgrey&#x27;</span>: <span class="number">0xD3D3D3</span>,</span><br><span class="line">        <span class="string">&#x27;lightpink&#x27;</span>: <span class="number">0xFFB6C1</span>,</span><br><span class="line">        <span class="string">&#x27;lightsalmon&#x27;</span>: <span class="number">0xFFA07A</span>,</span><br><span class="line">        <span class="string">&#x27;lightseagreen&#x27;</span>: <span class="number">0x20B2AA</span>,</span><br><span class="line">        <span class="string">&#x27;lightskyblue&#x27;</span>: <span class="number">0x87CEFA</span>,</span><br><span class="line">        <span class="string">&#x27;lightslategray&#x27;</span>: <span class="number">0x778899</span>,</span><br><span class="line">        <span class="string">&#x27;lightslategrey&#x27;</span>: <span class="number">0x778899</span>,</span><br><span class="line">        <span class="string">&#x27;lightsteelblue&#x27;</span>: <span class="number">0xB0C4DE</span>,</span><br><span class="line">        <span class="string">&#x27;lightyellow&#x27;</span>: <span class="number">0xFFFFE0</span>,</span><br><span class="line">        <span class="string">&#x27;lime&#x27;</span>: <span class="number">0x00FF00</span>,</span><br><span class="line">        <span class="string">&#x27;limegreen&#x27;</span>: <span class="number">0x32CD32</span>,</span><br><span class="line">        <span class="string">&#x27;linen&#x27;</span>: <span class="number">0xFAF0E6</span>,</span><br><span class="line">        <span class="string">&#x27;magenta&#x27;</span>: <span class="number">0xFF00FF</span>,</span><br><span class="line">        <span class="string">&#x27;maroon&#x27;</span>: <span class="number">0x800000</span>,</span><br><span class="line">        <span class="string">&#x27;mediumaquamarine&#x27;</span>: <span class="number">0x66CDAA</span>,</span><br><span class="line">        <span class="string">&#x27;mediumblue&#x27;</span>: <span class="number">0x0000CD</span>,</span><br><span class="line">        <span class="string">&#x27;mediumorchid&#x27;</span>: <span class="number">0xBA55D3</span>,</span><br><span class="line">        <span class="string">&#x27;mediumpurple&#x27;</span>: <span class="number">0x9370DB</span>,</span><br><span class="line">        <span class="string">&#x27;mediumseagreen&#x27;</span>: <span class="number">0x3CB371</span>,</span><br><span class="line">        <span class="string">&#x27;mediumslateblue&#x27;</span>: <span class="number">0x7B68EE</span>,</span><br><span class="line">        <span class="string">&#x27;mediumspringgreen&#x27;</span>: <span class="number">0x00FA9A</span>,</span><br><span class="line">        <span class="string">&#x27;mediumturquoise&#x27;</span>: <span class="number">0x48D1CC</span>,</span><br><span class="line">        <span class="string">&#x27;mediumvioletred&#x27;</span>: <span class="number">0xC71585</span>,</span><br><span class="line">        <span class="string">&#x27;midnightblue&#x27;</span>: <span class="number">0x191970</span>,</span><br><span class="line">        <span class="string">&#x27;mintcream&#x27;</span>: <span class="number">0xF5FFFA</span>,</span><br><span class="line">        <span class="string">&#x27;mistyrose&#x27;</span>: <span class="number">0xFFE4E1</span>,</span><br><span class="line">        <span class="string">&#x27;moccasin&#x27;</span>: <span class="number">0xFFE4B5</span>,</span><br><span class="line">        <span class="string">&#x27;navajowhite&#x27;</span>: <span class="number">0xFFDEAD</span>,</span><br><span class="line">        <span class="string">&#x27;navy&#x27;</span>: <span class="number">0x000080</span>,</span><br><span class="line">        <span class="string">&#x27;oldlace&#x27;</span>: <span class="number">0xFDF5E6</span>,</span><br><span class="line">        <span class="string">&#x27;olive&#x27;</span>: <span class="number">0x808000</span>,</span><br><span class="line">        <span class="string">&#x27;olivedrab&#x27;</span>: <span class="number">0x6B8E23</span>,</span><br><span class="line">        <span class="string">&#x27;orange&#x27;</span>: <span class="number">0xFFA500</span>,</span><br><span class="line">        <span class="string">&#x27;orangered&#x27;</span>: <span class="number">0xFF4500</span>,</span><br><span class="line">        <span class="string">&#x27;orchid&#x27;</span>: <span class="number">0xDA70D6</span>,</span><br><span class="line">        <span class="string">&#x27;palegoldenrod&#x27;</span>: <span class="number">0xEEE8AA</span>,</span><br><span class="line">        <span class="string">&#x27;palegreen&#x27;</span>: <span class="number">0x98FB98</span>,</span><br><span class="line">        <span class="string">&#x27;paleturquoise&#x27;</span>: <span class="number">0xAFEEEE</span>,</span><br><span class="line">        <span class="string">&#x27;palevioletred&#x27;</span>: <span class="number">0xDB7093</span>,</span><br><span class="line">        <span class="string">&#x27;papayawhip&#x27;</span>: <span class="number">0xFFEFD5</span>,</span><br><span class="line">        <span class="string">&#x27;peachpuff&#x27;</span>: <span class="number">0xFFDAB9</span>,</span><br><span class="line">        <span class="string">&#x27;peru&#x27;</span>: <span class="number">0xCD853F</span>,</span><br><span class="line">        <span class="string">&#x27;pink&#x27;</span>: <span class="number">0xFFC0CB</span>,</span><br><span class="line">        <span class="string">&#x27;plum&#x27;</span>: <span class="number">0xDDA0DD</span>,</span><br><span class="line">        <span class="string">&#x27;powderblue&#x27;</span>: <span class="number">0xB0E0E6</span>,</span><br><span class="line">        <span class="string">&#x27;purple&#x27;</span>: <span class="number">0x800080</span>,</span><br><span class="line">        <span class="string">&#x27;rebeccapurple&#x27;</span>: <span class="number">0x663399</span>,</span><br><span class="line">        <span class="string">&#x27;red&#x27;</span>: <span class="number">0xFF0000</span>,</span><br><span class="line">        <span class="string">&#x27;rosybrown&#x27;</span>: <span class="number">0xBC8F8F</span>,</span><br><span class="line">        <span class="string">&#x27;royalblue&#x27;</span>: <span class="number">0x4169E1</span>,</span><br><span class="line">        <span class="string">&#x27;saddlebrown&#x27;</span>: <span class="number">0x8B4513</span>,</span><br><span class="line">        <span class="string">&#x27;salmon&#x27;</span>: <span class="number">0xFA8072</span>,</span><br><span class="line">        <span class="string">&#x27;sandybrown&#x27;</span>: <span class="number">0xF4A460</span>,</span><br><span class="line">        <span class="string">&#x27;seagreen&#x27;</span>: <span class="number">0x2E8B57</span>,</span><br><span class="line">        <span class="string">&#x27;seashell&#x27;</span>: <span class="number">0xFFF5EE</span>,</span><br><span class="line">        <span class="string">&#x27;sienna&#x27;</span>: <span class="number">0xA0522D</span>,</span><br><span class="line">        <span class="string">&#x27;silver&#x27;</span>: <span class="number">0xC0C0C0</span>,</span><br><span class="line">        <span class="string">&#x27;skyblue&#x27;</span>: <span class="number">0x87CEEB</span>,</span><br><span class="line">        <span class="string">&#x27;slateblue&#x27;</span>: <span class="number">0x6A5ACD</span>,</span><br><span class="line">        <span class="string">&#x27;slategray&#x27;</span>: <span class="number">0x708090</span>,</span><br><span class="line">        <span class="string">&#x27;slategrey&#x27;</span>: <span class="number">0x708090</span>,</span><br><span class="line">        <span class="string">&#x27;snow&#x27;</span>: <span class="number">0xFFFAFA</span>,</span><br><span class="line">        <span class="string">&#x27;springgreen&#x27;</span>: <span class="number">0x00FF7F</span>,</span><br><span class="line">        <span class="string">&#x27;steelblue&#x27;</span>: <span class="number">0x4682B4</span>,</span><br><span class="line">        <span class="string">&#x27;tan&#x27;</span>: <span class="number">0xD2B48C</span>,</span><br><span class="line">        <span class="string">&#x27;teal&#x27;</span>: <span class="number">0x008080</span>,</span><br><span class="line">        <span class="string">&#x27;thistle&#x27;</span>: <span class="number">0xD8BFD8</span>,</span><br><span class="line">        <span class="string">&#x27;tomato&#x27;</span>: <span class="number">0xFF6347</span>,</span><br><span class="line">        <span class="string">&#x27;turquoise&#x27;</span>: <span class="number">0x40E0D0</span>,</span><br><span class="line">        <span class="string">&#x27;violet&#x27;</span>: <span class="number">0xEE82EE</span>,</span><br><span class="line">        <span class="string">&#x27;wheat&#x27;</span>: <span class="number">0xF5DEB3</span>,</span><br><span class="line">        <span class="string">&#x27;white&#x27;</span>: <span class="number">0xFFFFFF</span>,</span><br><span class="line">        <span class="string">&#x27;whitesmoke&#x27;</span>: <span class="number">0xF5F5F5</span>,</span><br><span class="line">        <span class="string">&#x27;yellow&#x27;</span>: <span class="number">0xFFFF00</span>,</span><br><span class="line">        <span class="string">&#x27;yellowgreen&#x27;</span>: <span class="number">0x9ACD32</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> _rgb = &#123;</span><br><span class="line">        <span class="attr">r</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">g</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">b</span>: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> _hslA = &#123;</span><br><span class="line">        <span class="attr">h</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">s</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">l</span>: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> _hslB = &#123;</span><br><span class="line">        <span class="attr">h</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">s</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">l</span>: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hue2rgb</span>(<span class="params">p, q, t</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">1</span>) t -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">1</span> / <span class="number">6</span>) <span class="keyword">return</span> p + (q - p) * <span class="number">6</span> * t;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">1</span> / <span class="number">2</span>) <span class="keyword">return</span> q;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">2</span> / <span class="number">3</span>) <span class="keyword">return</span> p + (q - p) * <span class="number">6</span> * (<span class="number">2</span> / <span class="number">3</span> - t);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">toComponents</span>(<span class="params">source, target</span>) </span>&#123;</span><br><span class="line">        target.r = source.r;</span><br><span class="line">        target.g = source.g;</span><br><span class="line">        target.b = source.b;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">r, g, b</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (g === <span class="literal">undefined</span> &amp;&amp; b === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="comment">// r is THREE.Color, hex or string</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.set(r);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.setRGB(r, g, b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &amp;&amp; value.isColor) &#123;</span><br><span class="line">                <span class="built_in">this</span>.copy(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.setHex(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.setStyle(value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setScalar</span>(<span class="params">scalar</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.r = scalar;</span><br><span class="line">            <span class="built_in">this</span>.g = scalar;</span><br><span class="line">            <span class="built_in">this</span>.b = scalar;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setHex</span>(<span class="params">hex, colorSpace = SRGBColorSpace</span>)</span> &#123;</span><br><span class="line">            hex = <span class="built_in">Math</span>.floor(hex);</span><br><span class="line">            <span class="built_in">this</span>.r = (hex &gt;&gt; <span class="number">16</span> &amp; <span class="number">255</span>) / <span class="number">255</span>;</span><br><span class="line">            <span class="built_in">this</span>.g = (hex &gt;&gt; <span class="number">8</span> &amp; <span class="number">255</span>) / <span class="number">255</span>;</span><br><span class="line">            <span class="built_in">this</span>.b = (hex &amp; <span class="number">255</span>) / <span class="number">255</span>;</span><br><span class="line">            ColorManagement.toWorkingColorSpace(<span class="built_in">this</span>, colorSpace);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setRGB</span>(<span class="params">r, g, b, colorSpace = LinearSRGBColorSpace</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.r = r;</span><br><span class="line">            <span class="built_in">this</span>.g = g;</span><br><span class="line">            <span class="built_in">this</span>.b = b;</span><br><span class="line">            ColorManagement.toWorkingColorSpace(<span class="built_in">this</span>, colorSpace);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setHSL</span>(<span class="params">h, s, l, colorSpace = LinearSRGBColorSpace</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// h,s,l ranges are in 0.0 - 1.0</span></span><br><span class="line">            h = euclideanModulo(h, <span class="number">1</span>);</span><br><span class="line">            s = clamp(s, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            l = clamp(l, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.r = <span class="built_in">this</span>.g = <span class="built_in">this</span>.b = l;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> p = l &lt;= <span class="number">0.5</span> ? l * (<span class="number">1</span> + s) : l + s - l * s;</span><br><span class="line">                <span class="keyword">const</span> q = <span class="number">2</span> * l - p;</span><br><span class="line">                <span class="built_in">this</span>.r = hue2rgb(q, p, h + <span class="number">1</span> / <span class="number">3</span>);</span><br><span class="line">                <span class="built_in">this</span>.g = hue2rgb(q, p, h);</span><br><span class="line">                <span class="built_in">this</span>.b = hue2rgb(q, p, h - <span class="number">1</span> / <span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ColorManagement.toWorkingColorSpace(<span class="built_in">this</span>, colorSpace);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setStyle</span>(<span class="params">style, colorSpace = SRGBColorSpace</span>)</span> &#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">handleAlpha</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (string === <span class="literal">undefined</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">parseFloat</span>(string) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Color: Alpha component of &#x27;</span> + style + <span class="string">&#x27; will be ignored.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> m;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m = <span class="regexp">/^((?:rgb|hsl)a?)\(([^\)]*)\)/</span>.exec(style)) &#123;</span><br><span class="line">                <span class="comment">// rgb / hsl</span></span><br><span class="line">                <span class="keyword">let</span> color;</span><br><span class="line">                <span class="keyword">const</span> name = m[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">const</span> components = m[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;rgb&#x27;</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;rgba&#x27;</span>:</span><br><span class="line">                        <span class="keyword">if</span> (color = <span class="regexp">/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/</span>.exec(components)) &#123;</span><br><span class="line">                            <span class="comment">// rgb(255,0,0) rgba(255,0,0,0.5)</span></span><br><span class="line">                            <span class="built_in">this</span>.r = <span class="built_in">Math</span>.min(<span class="number">255</span>, <span class="built_in">parseInt</span>(color[<span class="number">1</span>], <span class="number">10</span>)) / <span class="number">255</span>;</span><br><span class="line">                            <span class="built_in">this</span>.g = <span class="built_in">Math</span>.min(<span class="number">255</span>, <span class="built_in">parseInt</span>(color[<span class="number">2</span>], <span class="number">10</span>)) / <span class="number">255</span>;</span><br><span class="line">                            <span class="built_in">this</span>.b = <span class="built_in">Math</span>.min(<span class="number">255</span>, <span class="built_in">parseInt</span>(color[<span class="number">3</span>], <span class="number">10</span>)) / <span class="number">255</span>;</span><br><span class="line">                            ColorManagement.toWorkingColorSpace(<span class="built_in">this</span>, colorSpace);</span><br><span class="line">                            handleAlpha(color[<span class="number">4</span>]);</span><br><span class="line">                            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (color = <span class="regexp">/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/</span>.exec(components)) &#123;</span><br><span class="line">                            <span class="comment">// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)</span></span><br><span class="line">                            <span class="built_in">this</span>.r = <span class="built_in">Math</span>.min(<span class="number">100</span>, <span class="built_in">parseInt</span>(color[<span class="number">1</span>], <span class="number">10</span>)) / <span class="number">100</span>;</span><br><span class="line">                            <span class="built_in">this</span>.g = <span class="built_in">Math</span>.min(<span class="number">100</span>, <span class="built_in">parseInt</span>(color[<span class="number">2</span>], <span class="number">10</span>)) / <span class="number">100</span>;</span><br><span class="line">                            <span class="built_in">this</span>.b = <span class="built_in">Math</span>.min(<span class="number">100</span>, <span class="built_in">parseInt</span>(color[<span class="number">3</span>], <span class="number">10</span>)) / <span class="number">100</span>;</span><br><span class="line">                            ColorManagement.toWorkingColorSpace(<span class="built_in">this</span>, colorSpace);</span><br><span class="line">                            handleAlpha(color[<span class="number">4</span>]);</span><br><span class="line">                            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;hsl&#x27;</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;hsla&#x27;</span>:</span><br><span class="line">                        <span class="keyword">if</span> (color = <span class="regexp">/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/</span>.exec(components)) &#123;</span><br><span class="line">                            <span class="comment">// hsl(120,50%,50%) hsla(120,50%,50%,0.5)</span></span><br><span class="line">                            <span class="keyword">const</span> h = <span class="built_in">parseFloat</span>(color[<span class="number">1</span>]) / <span class="number">360</span>;</span><br><span class="line">                            <span class="keyword">const</span> s = <span class="built_in">parseInt</span>(color[<span class="number">2</span>], <span class="number">10</span>) / <span class="number">100</span>;</span><br><span class="line">                            <span class="keyword">const</span> l = <span class="built_in">parseInt</span>(color[<span class="number">3</span>], <span class="number">10</span>) / <span class="number">100</span>;</span><br><span class="line">                            handleAlpha(color[<span class="number">4</span>]);</span><br><span class="line">                            <span class="keyword">return</span> <span class="built_in">this</span>.setHSL(h, s, l, colorSpace);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m = <span class="regexp">/^\#([A-Fa-f\d]+)$/</span>.exec(style)) &#123;</span><br><span class="line">                <span class="comment">// hex color</span></span><br><span class="line">                <span class="keyword">const</span> hex = m[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">const</span> size = hex.length;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (size === <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="comment">// #ff0</span></span><br><span class="line">                    <span class="built_in">this</span>.r = <span class="built_in">parseInt</span>(hex.charAt(<span class="number">0</span>) + hex.charAt(<span class="number">0</span>), <span class="number">16</span>) / <span class="number">255</span>;</span><br><span class="line">                    <span class="built_in">this</span>.g = <span class="built_in">parseInt</span>(hex.charAt(<span class="number">1</span>) + hex.charAt(<span class="number">1</span>), <span class="number">16</span>) / <span class="number">255</span>;</span><br><span class="line">                    <span class="built_in">this</span>.b = <span class="built_in">parseInt</span>(hex.charAt(<span class="number">2</span>) + hex.charAt(<span class="number">2</span>), <span class="number">16</span>) / <span class="number">255</span>;</span><br><span class="line">                    ColorManagement.toWorkingColorSpace(<span class="built_in">this</span>, colorSpace);</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size === <span class="number">6</span>) &#123;</span><br><span class="line">                    <span class="comment">// #ff0000</span></span><br><span class="line">                    <span class="built_in">this</span>.r = <span class="built_in">parseInt</span>(hex.charAt(<span class="number">0</span>) + hex.charAt(<span class="number">1</span>), <span class="number">16</span>) / <span class="number">255</span>;</span><br><span class="line">                    <span class="built_in">this</span>.g = <span class="built_in">parseInt</span>(hex.charAt(<span class="number">2</span>) + hex.charAt(<span class="number">3</span>), <span class="number">16</span>) / <span class="number">255</span>;</span><br><span class="line">                    <span class="built_in">this</span>.b = <span class="built_in">parseInt</span>(hex.charAt(<span class="number">4</span>) + hex.charAt(<span class="number">5</span>), <span class="number">16</span>) / <span class="number">255</span>;</span><br><span class="line">                    ColorManagement.toWorkingColorSpace(<span class="built_in">this</span>, colorSpace);</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (style &amp;&amp; style.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.setColorName(style, colorSpace);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setColorName</span>(<span class="params">style, colorSpace = SRGBColorSpace</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// color keywords</span></span><br><span class="line">            <span class="keyword">const</span> hex = _colorKeywords[style.toLowerCase()];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hex !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="comment">// red</span></span><br><span class="line">                <span class="built_in">this</span>.setHex(hex, colorSpace);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// unknown color</span></span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Color: Unknown color &#x27;</span> + style);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor(<span class="built_in">this</span>.r, <span class="built_in">this</span>.g, <span class="built_in">this</span>.b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">color</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.r = color.r;</span><br><span class="line">            <span class="built_in">this</span>.g = color.g;</span><br><span class="line">            <span class="built_in">this</span>.b = color.b;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copySRGBToLinear</span>(<span class="params">color</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.r = SRGBToLinear(color.r);</span><br><span class="line">            <span class="built_in">this</span>.g = SRGBToLinear(color.g);</span><br><span class="line">            <span class="built_in">this</span>.b = SRGBToLinear(color.b);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copyLinearToSRGB</span>(<span class="params">color</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.r = LinearToSRGB(color.r);</span><br><span class="line">            <span class="built_in">this</span>.g = LinearToSRGB(color.g);</span><br><span class="line">            <span class="built_in">this</span>.b = LinearToSRGB(color.b);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">convertSRGBToLinear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.copySRGBToLinear(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">convertLinearToSRGB</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.copyLinearToSRGB(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getHex</span>(<span class="params">colorSpace = SRGBColorSpace</span>)</span> &#123;</span><br><span class="line">            ColorManagement.fromWorkingColorSpace(toComponents(<span class="built_in">this</span>, _rgb), colorSpace);</span><br><span class="line">            <span class="keyword">return</span> clamp(_rgb.r * <span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>) &lt;&lt; <span class="number">16</span> ^ clamp(_rgb.g * <span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>) &lt;&lt; <span class="number">8</span> ^ clamp(_rgb.b * <span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>) &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getHexString</span>(<span class="params">colorSpace = SRGBColorSpace</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="string">&#x27;000000&#x27;</span> + <span class="built_in">this</span>.getHex(colorSpace).toString(<span class="number">16</span>)).slice(-<span class="number">6</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getHSL</span>(<span class="params">target, colorSpace = LinearSRGBColorSpace</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// h,s,l ranges are in 0.0 - 1.0</span></span><br><span class="line">            ColorManagement.fromWorkingColorSpace(toComponents(<span class="built_in">this</span>, _rgb), colorSpace);</span><br><span class="line">            <span class="keyword">const</span> r = _rgb.r,</span><br><span class="line">                g = _rgb.g,</span><br><span class="line">                b = _rgb.b;</span><br><span class="line">            <span class="keyword">const</span> max = <span class="built_in">Math</span>.max(r, g, b);</span><br><span class="line">            <span class="keyword">const</span> min = <span class="built_in">Math</span>.min(r, g, b);</span><br><span class="line">            <span class="keyword">let</span> hue, saturation;</span><br><span class="line">            <span class="keyword">const</span> lightness = (min + max) / <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (min === max) &#123;</span><br><span class="line">                hue = <span class="number">0</span>;</span><br><span class="line">                saturation = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> delta = max - min;</span><br><span class="line">                saturation = lightness &lt;= <span class="number">0.5</span> ? delta / (max + min) : delta / (<span class="number">2</span> - max - min);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (max) &#123;</span><br><span class="line">                    <span class="keyword">case</span> r:</span><br><span class="line">                        hue = (g - b) / delta + (g &lt; b ? <span class="number">6</span> : <span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> g:</span><br><span class="line">                        hue = (b - r) / delta + <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> b:</span><br><span class="line">                        hue = (r - g) / delta + <span class="number">4</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                hue /= <span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            target.h = hue;</span><br><span class="line">            target.s = saturation;</span><br><span class="line">            target.l = lightness;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getRGB</span>(<span class="params">target, colorSpace = LinearSRGBColorSpace</span>)</span> &#123;</span><br><span class="line">            ColorManagement.fromWorkingColorSpace(toComponents(<span class="built_in">this</span>, _rgb), colorSpace);</span><br><span class="line">            target.r = _rgb.r;</span><br><span class="line">            target.g = _rgb.g;</span><br><span class="line">            target.b = _rgb.b;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getStyle</span>(<span class="params">colorSpace = SRGBColorSpace</span>)</span> &#123;</span><br><span class="line">            ColorManagement.fromWorkingColorSpace(toComponents(<span class="built_in">this</span>, _rgb), colorSpace);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorSpace !== SRGBColorSpace) &#123;</span><br><span class="line">                <span class="comment">// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">`color(<span class="subst">$&#123;colorSpace&#125;</span> <span class="subst">$&#123;_rgb.r&#125;</span> <span class="subst">$&#123;_rgb.g&#125;</span> <span class="subst">$&#123;_rgb.b&#125;</span>)`</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="string">`rgb(<span class="subst">$&#123;_rgb.r * <span class="number">255</span> | <span class="number">0</span>&#125;</span>,<span class="subst">$&#123;_rgb.g * <span class="number">255</span> | <span class="number">0</span>&#125;</span>,<span class="subst">$&#123;_rgb.b * <span class="number">255</span> | <span class="number">0</span>&#125;</span>)`</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">offsetHSL</span>(<span class="params">h, s, l</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.getHSL(_hslA);</span><br><span class="line">            _hslA.h += h;</span><br><span class="line">            _hslA.s += s;</span><br><span class="line">            _hslA.l += l;</span><br><span class="line">            <span class="built_in">this</span>.setHSL(_hslA.h, _hslA.s, _hslA.l);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params">color</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.r += color.r;</span><br><span class="line">            <span class="built_in">this</span>.g += color.g;</span><br><span class="line">            <span class="built_in">this</span>.b += color.b;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">addColors</span>(<span class="params">color1, color2</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.r = color1.r + color2.r;</span><br><span class="line">            <span class="built_in">this</span>.g = color1.g + color2.g;</span><br><span class="line">            <span class="built_in">this</span>.b = color1.b + color2.b;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">addScalar</span>(<span class="params">s</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.r += s;</span><br><span class="line">            <span class="built_in">this</span>.g += s;</span><br><span class="line">            <span class="built_in">this</span>.b += s;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">sub</span>(<span class="params">color</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.r = <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="built_in">this</span>.r - color.r);</span><br><span class="line">            <span class="built_in">this</span>.g = <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="built_in">this</span>.g - color.g);</span><br><span class="line">            <span class="built_in">this</span>.b = <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="built_in">this</span>.b - color.b);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">multiply</span>(<span class="params">color</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.r *= color.r;</span><br><span class="line">            <span class="built_in">this</span>.g *= color.g;</span><br><span class="line">            <span class="built_in">this</span>.b *= color.b;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">multiplyScalar</span>(<span class="params">s</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.r *= s;</span><br><span class="line">            <span class="built_in">this</span>.g *= s;</span><br><span class="line">            <span class="built_in">this</span>.b *= s;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">lerp</span>(<span class="params">color, alpha</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.r += (color.r - <span class="built_in">this</span>.r) * alpha;</span><br><span class="line">            <span class="built_in">this</span>.g += (color.g - <span class="built_in">this</span>.g) * alpha;</span><br><span class="line">            <span class="built_in">this</span>.b += (color.b - <span class="built_in">this</span>.b) * alpha;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">lerpColors</span>(<span class="params">color1, color2, alpha</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.r = color1.r + (color2.r - color1.r) * alpha;</span><br><span class="line">            <span class="built_in">this</span>.g = color1.g + (color2.g - color1.g) * alpha;</span><br><span class="line">            <span class="built_in">this</span>.b = color1.b + (color2.b - color1.b) * alpha;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">lerpHSL</span>(<span class="params">color, alpha</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.getHSL(_hslA);</span><br><span class="line">            color.getHSL(_hslB);</span><br><span class="line">            <span class="keyword">const</span> h = lerp(_hslA.h, _hslB.h, alpha);</span><br><span class="line">            <span class="keyword">const</span> s = lerp(_hslA.s, _hslB.s, alpha);</span><br><span class="line">            <span class="keyword">const</span> l = lerp(_hslA.l, _hslB.l, alpha);</span><br><span class="line">            <span class="built_in">this</span>.setHSL(h, s, l);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">equals</span>(<span class="params">c</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> c.r === <span class="built_in">this</span>.r &amp;&amp; c.g === <span class="built_in">this</span>.g &amp;&amp; c.b === <span class="built_in">this</span>.b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromArray</span>(<span class="params">array, offset = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.r = array[offset];</span><br><span class="line">            <span class="built_in">this</span>.g = array[offset + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">this</span>.b = array[offset + <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toArray</span>(<span class="params">array = [], offset = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            array[offset] = <span class="built_in">this</span>.r;</span><br><span class="line">            array[offset + <span class="number">1</span>] = <span class="built_in">this</span>.g;</span><br><span class="line">            array[offset + <span class="number">2</span>] = <span class="built_in">this</span>.b;</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromBufferAttribute</span>(<span class="params">attribute, index</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.r = attribute.getX(index);</span><br><span class="line">            <span class="built_in">this</span>.g = attribute.getY(index);</span><br><span class="line">            <span class="built_in">this</span>.b = attribute.getZ(index);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (attribute.normalized === <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// assuming Uint8Array</span></span><br><span class="line">                <span class="built_in">this</span>.r /= <span class="number">255</span>;</span><br><span class="line">                <span class="built_in">this</span>.g /= <span class="number">255</span>;</span><br><span class="line">                <span class="built_in">this</span>.b /= <span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.getHex();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Color.NAMES = _colorKeywords;</span><br><span class="line">    Color.prototype.isColor = <span class="literal">true</span>;</span><br><span class="line">    Color.prototype.r = <span class="number">1</span>;</span><br><span class="line">    Color.prototype.g = <span class="number">1</span>;</span><br><span class="line">    Color.prototype.b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> _canvas;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ImageUtils</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">getDataURL</span>(<span class="params">image</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="regexp">/^data:/i</span>.test(image.src)) &#123;</span><br><span class="line">                <span class="keyword">return</span> image.src;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> HTMLCanvasElement == <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> image.src;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> canvas;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (image <span class="keyword">instanceof</span> HTMLCanvasElement) &#123;</span><br><span class="line">                canvas = image;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (_canvas === <span class="literal">undefined</span>) _canvas = createElementNS(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">                _canvas.width = image.width;</span><br><span class="line">                _canvas.height = image.height;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> context = _canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (image <span class="keyword">instanceof</span> ImageData) &#123;</span><br><span class="line">                    context.putImageData(image, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    context.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, image.width, image.height);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                canvas = _canvas;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (canvas.width &gt; <span class="number">2048</span> || canvas.height &gt; <span class="number">2048</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons&#x27;</span>, image);</span><br><span class="line">                <span class="keyword">return</span> canvas.toDataURL(<span class="string">&#x27;image/jpeg&#x27;</span>, <span class="number">0.6</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> canvas.toDataURL(<span class="string">&#x27;image/png&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">sRGBToLinear</span>(<span class="params">image</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> HTMLImageElement !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; image <span class="keyword">instanceof</span> HTMLImageElement || <span class="keyword">typeof</span> HTMLCanvasElement !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; image <span class="keyword">instanceof</span> HTMLCanvasElement || <span class="keyword">typeof</span> ImageBitmap !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; image <span class="keyword">instanceof</span> ImageBitmap) &#123;</span><br><span class="line">                <span class="keyword">const</span> canvas = createElementNS(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">                canvas.width = image.width;</span><br><span class="line">                canvas.height = image.height;</span><br><span class="line">                <span class="keyword">const</span> context = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">                context.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, image.width, image.height);</span><br><span class="line">                <span class="keyword">const</span> imageData = context.getImageData(<span class="number">0</span>, <span class="number">0</span>, image.width, image.height);</span><br><span class="line">                <span class="keyword">const</span> data = imageData.data;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">                    data[i] = SRGBToLinear(data[i] / <span class="number">255</span>) * <span class="number">255</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                context.putImageData(imageData, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> canvas;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (image.data) &#123;</span><br><span class="line">                <span class="keyword">const</span> data = image.data.slice(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (data <span class="keyword">instanceof</span> <span class="built_in">Uint8Array</span> || data <span class="keyword">instanceof</span> <span class="built_in">Uint8ClampedArray</span>) &#123;</span><br><span class="line">                        data[i] = <span class="built_in">Math</span>.floor(SRGBToLinear(data[i] / <span class="number">255</span>) * <span class="number">255</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// assuming float</span></span><br><span class="line">                        data[i] = SRGBToLinear(data[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">data</span>: data,</span><br><span class="line">                    <span class="attr">width</span>: image.width,</span><br><span class="line">                    <span class="attr">height</span>: image.height</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> image;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">data = <span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.uuid = generateUUID();</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">            <span class="built_in">this</span>.version = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">needsUpdate</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value === <span class="literal">true</span>) <span class="built_in">this</span>.version++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params">meta</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> isRootObject = meta === <span class="literal">undefined</span> || <span class="keyword">typeof</span> meta === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isRootObject &amp;&amp; meta.images[<span class="built_in">this</span>.uuid] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> meta.images[<span class="built_in">this</span>.uuid];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> output = &#123;</span><br><span class="line">                <span class="attr">uuid</span>: <span class="built_in">this</span>.uuid,</span><br><span class="line">                <span class="attr">url</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">this</span>.data;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (data !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> url;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(data)) &#123;</span><br><span class="line">                    <span class="comment">// cube texture</span></span><br><span class="line">                    url = [];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = data.length; i &lt; l; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (data[i].isDataTexture) &#123;</span><br><span class="line">                            url.push(serializeImage(data[i].image));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            url.push(serializeImage(data[i]));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// texture</span></span><br><span class="line">                    url = serializeImage(data);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                output.url = url;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isRootObject) &#123;</span><br><span class="line">                meta.images[<span class="built_in">this</span>.uuid] = output;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> output;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">serializeImage</span>(<span class="params">image</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> HTMLImageElement !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; image <span class="keyword">instanceof</span> HTMLImageElement || <span class="keyword">typeof</span> HTMLCanvasElement !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; image <span class="keyword">instanceof</span> HTMLCanvasElement || <span class="keyword">typeof</span> ImageBitmap !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; image <span class="keyword">instanceof</span> ImageBitmap) &#123;</span><br><span class="line">            <span class="comment">// default images</span></span><br><span class="line">            <span class="keyword">return</span> ImageUtils.getDataURL(image);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (image.data) &#123;</span><br><span class="line">                <span class="comment">// images of DataTexture</span></span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">data</span>: <span class="built_in">Array</span>.prototype.slice.call(image.data),</span><br><span class="line">                    <span class="attr">width</span>: image.width,</span><br><span class="line">                    <span class="attr">height</span>: image.height,</span><br><span class="line">                    <span class="attr">type</span>: image.data.constructor.name</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Texture: Unable to serialize Texture.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Source.prototype.isSource = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> textureId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Texture</span> <span class="keyword">extends</span> <span class="title">EventDispatcher</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = <span class="number">1</span>, encoding = LinearEncoding</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, <span class="string">&#x27;id&#x27;</span>, &#123;</span><br><span class="line">                <span class="attr">value</span>: textureId++</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">this</span>.uuid = generateUUID();</span><br><span class="line">            <span class="built_in">this</span>.name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.source = <span class="keyword">new</span> Source(image);</span><br><span class="line">            <span class="built_in">this</span>.mipmaps = [];</span><br><span class="line">            <span class="built_in">this</span>.mapping = mapping;</span><br><span class="line">            <span class="built_in">this</span>.wrapS = wrapS;</span><br><span class="line">            <span class="built_in">this</span>.wrapT = wrapT;</span><br><span class="line">            <span class="built_in">this</span>.magFilter = magFilter;</span><br><span class="line">            <span class="built_in">this</span>.minFilter = minFilter;</span><br><span class="line">            <span class="built_in">this</span>.anisotropy = anisotropy;</span><br><span class="line">            <span class="built_in">this</span>.format = format;</span><br><span class="line">            <span class="built_in">this</span>.internalFormat = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.type = type;</span><br><span class="line">            <span class="built_in">this</span>.offset = <span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">this</span>.repeat = <span class="keyword">new</span> Vector2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.center = <span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">this</span>.rotation = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.matrixAutoUpdate = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.matrix = <span class="keyword">new</span> Matrix3();</span><br><span class="line">            <span class="built_in">this</span>.generateMipmaps = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.premultiplyAlpha = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.flipY = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.unpackAlignment = <span class="number">4</span>; <span class="comment">// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)</span></span><br><span class="line">            <span class="comment">// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Also changing the encoding after already used by a Material will not automatically make the Material</span></span><br><span class="line">            <span class="comment">// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.encoding = encoding;</span><br><span class="line">            <span class="built_in">this</span>.userData = &#123;&#125;;</span><br><span class="line">            <span class="built_in">this</span>.version = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.onUpdate = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.isRenderTargetTexture = <span class="literal">false</span>; <span class="comment">// indicates whether a texture belongs to a render target or not</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.needsPMREMUpdate = <span class="literal">false</span>; <span class="comment">// indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">image</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.source.data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">image</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.source.data = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">updateMatrix</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.matrix.setUvTransform(<span class="built_in">this</span>.offset.x, <span class="built_in">this</span>.offset.y, <span class="built_in">this</span>.repeat.x, <span class="built_in">this</span>.repeat.y, <span class="built_in">this</span>.rotation, <span class="built_in">this</span>.center.x, <span class="built_in">this</span>.center.y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor().copy(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = source.name;</span><br><span class="line">            <span class="built_in">this</span>.source = source.source;</span><br><span class="line">            <span class="built_in">this</span>.mipmaps = source.mipmaps.slice(<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">this</span>.mapping = source.mapping;</span><br><span class="line">            <span class="built_in">this</span>.wrapS = source.wrapS;</span><br><span class="line">            <span class="built_in">this</span>.wrapT = source.wrapT;</span><br><span class="line">            <span class="built_in">this</span>.magFilter = source.magFilter;</span><br><span class="line">            <span class="built_in">this</span>.minFilter = source.minFilter;</span><br><span class="line">            <span class="built_in">this</span>.anisotropy = source.anisotropy;</span><br><span class="line">            <span class="built_in">this</span>.format = source.format;</span><br><span class="line">            <span class="built_in">this</span>.internalFormat = source.internalFormat;</span><br><span class="line">            <span class="built_in">this</span>.type = source.type;</span><br><span class="line">            <span class="built_in">this</span>.offset.copy(source.offset);</span><br><span class="line">            <span class="built_in">this</span>.repeat.copy(source.repeat);</span><br><span class="line">            <span class="built_in">this</span>.center.copy(source.center);</span><br><span class="line">            <span class="built_in">this</span>.rotation = source.rotation;</span><br><span class="line">            <span class="built_in">this</span>.matrixAutoUpdate = source.matrixAutoUpdate;</span><br><span class="line">            <span class="built_in">this</span>.matrix.copy(source.matrix);</span><br><span class="line">            <span class="built_in">this</span>.generateMipmaps = source.generateMipmaps;</span><br><span class="line">            <span class="built_in">this</span>.premultiplyAlpha = source.premultiplyAlpha;</span><br><span class="line">            <span class="built_in">this</span>.flipY = source.flipY;</span><br><span class="line">            <span class="built_in">this</span>.unpackAlignment = source.unpackAlignment;</span><br><span class="line">            <span class="built_in">this</span>.encoding = source.encoding;</span><br><span class="line">            <span class="built_in">this</span>.userData = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(source.userData));</span><br><span class="line">            <span class="built_in">this</span>.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params">meta</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> isRootObject = meta === <span class="literal">undefined</span> || <span class="keyword">typeof</span> meta === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isRootObject &amp;&amp; meta.textures[<span class="built_in">this</span>.uuid] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> meta.textures[<span class="built_in">this</span>.uuid];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> output = &#123;</span><br><span class="line">                <span class="attr">metadata</span>: &#123;</span><br><span class="line">                    <span class="attr">version</span>: <span class="number">4.5</span>,</span><br><span class="line">                    <span class="attr">type</span>: <span class="string">&#x27;Texture&#x27;</span>,</span><br><span class="line">                    <span class="attr">generator</span>: <span class="string">&#x27;Texture.toJSON&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">uuid</span>: <span class="built_in">this</span>.uuid,</span><br><span class="line">                <span class="attr">name</span>: <span class="built_in">this</span>.name,</span><br><span class="line">                <span class="attr">image</span>: <span class="built_in">this</span>.source.toJSON(meta).uuid,</span><br><span class="line">                <span class="attr">mapping</span>: <span class="built_in">this</span>.mapping,</span><br><span class="line">                <span class="attr">repeat</span>: [<span class="built_in">this</span>.repeat.x, <span class="built_in">this</span>.repeat.y],</span><br><span class="line">                <span class="attr">offset</span>: [<span class="built_in">this</span>.offset.x, <span class="built_in">this</span>.offset.y],</span><br><span class="line">                <span class="attr">center</span>: [<span class="built_in">this</span>.center.x, <span class="built_in">this</span>.center.y],</span><br><span class="line">                <span class="attr">rotation</span>: <span class="built_in">this</span>.rotation,</span><br><span class="line">                <span class="attr">wrap</span>: [<span class="built_in">this</span>.wrapS, <span class="built_in">this</span>.wrapT],</span><br><span class="line">                <span class="attr">format</span>: <span class="built_in">this</span>.format,</span><br><span class="line">                <span class="attr">type</span>: <span class="built_in">this</span>.type,</span><br><span class="line">                <span class="attr">encoding</span>: <span class="built_in">this</span>.encoding,</span><br><span class="line">                <span class="attr">minFilter</span>: <span class="built_in">this</span>.minFilter,</span><br><span class="line">                <span class="attr">magFilter</span>: <span class="built_in">this</span>.magFilter,</span><br><span class="line">                <span class="attr">anisotropy</span>: <span class="built_in">this</span>.anisotropy,</span><br><span class="line">                <span class="attr">flipY</span>: <span class="built_in">this</span>.flipY,</span><br><span class="line">                <span class="attr">premultiplyAlpha</span>: <span class="built_in">this</span>.premultiplyAlpha,</span><br><span class="line">                <span class="attr">unpackAlignment</span>: <span class="built_in">this</span>.unpackAlignment</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.userData) !== <span class="string">&#x27;&#123;&#125;&#x27;</span>) output.userData = <span class="built_in">this</span>.userData;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isRootObject) &#123;</span><br><span class="line">                meta.textures[<span class="built_in">this</span>.uuid] = output;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> output;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dispose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.dispatchEvent(&#123;</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;dispose&#x27;</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">transformUv</span>(<span class="params">uv</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.mapping !== UVMapping) <span class="keyword">return</span> uv;</span><br><span class="line">            uv.applyMatrix3(<span class="built_in">this</span>.matrix);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (uv.x &lt; <span class="number">0</span> || uv.x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (<span class="built_in">this</span>.wrapS) &#123;</span><br><span class="line">                    <span class="keyword">case</span> RepeatWrapping:</span><br><span class="line">                        uv.x = uv.x - <span class="built_in">Math</span>.floor(uv.x);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> ClampToEdgeWrapping:</span><br><span class="line">                        uv.x = uv.x &lt; <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> MirroredRepeatWrapping:</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(<span class="built_in">Math</span>.floor(uv.x) % <span class="number">2</span>) === <span class="number">1</span>) &#123;</span><br><span class="line">                            uv.x = <span class="built_in">Math</span>.ceil(uv.x) - uv.x;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            uv.x = uv.x - <span class="built_in">Math</span>.floor(uv.x);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (uv.y &lt; <span class="number">0</span> || uv.y &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (<span class="built_in">this</span>.wrapT) &#123;</span><br><span class="line">                    <span class="keyword">case</span> RepeatWrapping:</span><br><span class="line">                        uv.y = uv.y - <span class="built_in">Math</span>.floor(uv.y);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> ClampToEdgeWrapping:</span><br><span class="line">                        uv.y = uv.y &lt; <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> MirroredRepeatWrapping:</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(<span class="built_in">Math</span>.floor(uv.y) % <span class="number">2</span>) === <span class="number">1</span>) &#123;</span><br><span class="line">                            uv.y = <span class="built_in">Math</span>.ceil(uv.y) - uv.y;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            uv.y = uv.y - <span class="built_in">Math</span>.floor(uv.y);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.flipY) &#123;</span><br><span class="line">                uv.y = <span class="number">1</span> - uv.y;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> uv;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">needsUpdate</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value === <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.version++;</span><br><span class="line">                <span class="built_in">this</span>.source.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Texture.DEFAULT_IMAGE = <span class="literal">null</span>;</span><br><span class="line">    Texture.DEFAULT_MAPPING = UVMapping;</span><br><span class="line">    Texture.prototype.isTexture = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Vector4</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>, w = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = x;</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">            <span class="built_in">this</span>.z = z;</span><br><span class="line">            <span class="built_in">this</span>.w = w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">width</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.z;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">width</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.z = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">height</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">height</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.w = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">x, y, z, w</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = x;</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">            <span class="built_in">this</span>.z = z;</span><br><span class="line">            <span class="built_in">this</span>.w = w;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setScalar</span>(<span class="params">scalar</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = scalar;</span><br><span class="line">            <span class="built_in">this</span>.y = scalar;</span><br><span class="line">            <span class="built_in">this</span>.z = scalar;</span><br><span class="line">            <span class="built_in">this</span>.w = scalar;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setX</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = x;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setY</span>(<span class="params">y</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setZ</span>(<span class="params">z</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.z = z;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setW</span>(<span class="params">w</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.w = w;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setComponent</span>(<span class="params">index, value</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (index) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="built_in">this</span>.x = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="built_in">this</span>.y = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="built_in">this</span>.z = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    <span class="built_in">this</span>.w = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;index is out of range: &#x27;</span> + index);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getComponent</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (index) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.y;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.z;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.w;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;index is out of range: &#x27;</span> + index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor(<span class="built_in">this</span>.x, <span class="built_in">this</span>.y, <span class="built_in">this</span>.z, <span class="built_in">this</span>.w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = v.x;</span><br><span class="line">            <span class="built_in">this</span>.y = v.y;</span><br><span class="line">            <span class="built_in">this</span>.z = v.z;</span><br><span class="line">            <span class="built_in">this</span>.w = v.w !== <span class="literal">undefined</span> ? v.w : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params">v, w</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (w !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.addVectors(v, w);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.x += v.x;</span><br><span class="line">            <span class="built_in">this</span>.y += v.y;</span><br><span class="line">            <span class="built_in">this</span>.z += v.z;</span><br><span class="line">            <span class="built_in">this</span>.w += v.w;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">addScalar</span>(<span class="params">s</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x += s;</span><br><span class="line">            <span class="built_in">this</span>.y += s;</span><br><span class="line">            <span class="built_in">this</span>.z += s;</span><br><span class="line">            <span class="built_in">this</span>.w += s;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">addVectors</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = a.x + b.x;</span><br><span class="line">            <span class="built_in">this</span>.y = a.y + b.y;</span><br><span class="line">            <span class="built_in">this</span>.z = a.z + b.z;</span><br><span class="line">            <span class="built_in">this</span>.w = a.w + b.w;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">addScaledVector</span>(<span class="params">v, s</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x += v.x * s;</span><br><span class="line">            <span class="built_in">this</span>.y += v.y * s;</span><br><span class="line">            <span class="built_in">this</span>.z += v.z * s;</span><br><span class="line">            <span class="built_in">this</span>.w += v.w * s;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">sub</span>(<span class="params">v, w</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (w !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.subVectors(v, w);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.x -= v.x;</span><br><span class="line">            <span class="built_in">this</span>.y -= v.y;</span><br><span class="line">            <span class="built_in">this</span>.z -= v.z;</span><br><span class="line">            <span class="built_in">this</span>.w -= v.w;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">subScalar</span>(<span class="params">s</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x -= s;</span><br><span class="line">            <span class="built_in">this</span>.y -= s;</span><br><span class="line">            <span class="built_in">this</span>.z -= s;</span><br><span class="line">            <span class="built_in">this</span>.w -= s;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">subVectors</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = a.x - b.x;</span><br><span class="line">            <span class="built_in">this</span>.y = a.y - b.y;</span><br><span class="line">            <span class="built_in">this</span>.z = a.z - b.z;</span><br><span class="line">            <span class="built_in">this</span>.w = a.w - b.w;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">multiply</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x *= v.x;</span><br><span class="line">            <span class="built_in">this</span>.y *= v.y;</span><br><span class="line">            <span class="built_in">this</span>.z *= v.z;</span><br><span class="line">            <span class="built_in">this</span>.w *= v.w;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">multiplyScalar</span>(<span class="params">scalar</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x *= scalar;</span><br><span class="line">            <span class="built_in">this</span>.y *= scalar;</span><br><span class="line">            <span class="built_in">this</span>.z *= scalar;</span><br><span class="line">            <span class="built_in">this</span>.w *= scalar;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">applyMatrix4</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> x = <span class="built_in">this</span>.x,</span><br><span class="line">                y = <span class="built_in">this</span>.y,</span><br><span class="line">                z = <span class="built_in">this</span>.z,</span><br><span class="line">                w = <span class="built_in">this</span>.w;</span><br><span class="line">            <span class="keyword">const</span> e = m.elements;</span><br><span class="line">            <span class="built_in">this</span>.x = e[<span class="number">0</span>] * x + e[<span class="number">4</span>] * y + e[<span class="number">8</span>] * z + e[<span class="number">12</span>] * w;</span><br><span class="line">            <span class="built_in">this</span>.y = e[<span class="number">1</span>] * x + e[<span class="number">5</span>] * y + e[<span class="number">9</span>] * z + e[<span class="number">13</span>] * w;</span><br><span class="line">            <span class="built_in">this</span>.z = e[<span class="number">2</span>] * x + e[<span class="number">6</span>] * y + e[<span class="number">10</span>] * z + e[<span class="number">14</span>] * w;</span><br><span class="line">            <span class="built_in">this</span>.w = e[<span class="number">3</span>] * x + e[<span class="number">7</span>] * y + e[<span class="number">11</span>] * z + e[<span class="number">15</span>] * w;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">divideScalar</span>(<span class="params">scalar</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.multiplyScalar(<span class="number">1</span> / scalar);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setAxisAngleFromQuaternion</span>(<span class="params">q</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm</span></span><br><span class="line">            <span class="comment">// q is assumed to be normalized</span></span><br><span class="line">            <span class="built_in">this</span>.w = <span class="number">2</span> * <span class="built_in">Math</span>.acos(q.w);</span><br><span class="line">            <span class="keyword">const</span> s = <span class="built_in">Math</span>.sqrt(<span class="number">1</span> - q.w * q.w);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s &lt; <span class="number">0.0001</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.x = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">this</span>.y = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">this</span>.z = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.x = q.x / s;</span><br><span class="line">                <span class="built_in">this</span>.y = q.y / s;</span><br><span class="line">                <span class="built_in">this</span>.z = q.z / s;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setAxisAngleFromRotationMatrix</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm</span></span><br><span class="line">            <span class="comment">// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)</span></span><br><span class="line">            <span class="keyword">let</span> angle, x, y, z; <span class="comment">// variables for result</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> epsilon = <span class="number">0.01</span>,</span><br><span class="line">                <span class="comment">// margin to allow for rounding errors</span></span><br><span class="line">                epsilon2 = <span class="number">0.1</span>,</span><br><span class="line">                <span class="comment">// margin to distinguish between 0 and 180 degrees</span></span><br><span class="line">                te = m.elements,</span><br><span class="line">                m11 = te[<span class="number">0</span>],</span><br><span class="line">                m12 = te[<span class="number">4</span>],</span><br><span class="line">                m13 = te[<span class="number">8</span>],</span><br><span class="line">                m21 = te[<span class="number">1</span>],</span><br><span class="line">                m22 = te[<span class="number">5</span>],</span><br><span class="line">                m23 = te[<span class="number">9</span>],</span><br><span class="line">                m31 = te[<span class="number">2</span>],</span><br><span class="line">                m32 = te[<span class="number">6</span>],</span><br><span class="line">                m33 = te[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(m12 - m21) &lt; epsilon &amp;&amp; <span class="built_in">Math</span>.abs(m13 - m31) &lt; epsilon &amp;&amp; <span class="built_in">Math</span>.abs(m23 - m32) &lt; epsilon) &#123;</span><br><span class="line">                <span class="comment">// singularity found</span></span><br><span class="line">                <span class="comment">// first check for identity matrix which must have +1 for all terms</span></span><br><span class="line">                <span class="comment">// in leading diagonal and zero in other terms</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(m12 + m21) &lt; epsilon2 &amp;&amp; <span class="built_in">Math</span>.abs(m13 + m31) &lt; epsilon2 &amp;&amp; <span class="built_in">Math</span>.abs(m23 + m32) &lt; epsilon2 &amp;&amp; <span class="built_in">Math</span>.abs(m11 + m22 + m33 - <span class="number">3</span>) &lt; epsilon2) &#123;</span><br><span class="line">                    <span class="comment">// this singularity is identity matrix so angle = 0</span></span><br><span class="line">                    <span class="built_in">this</span>.set(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>; <span class="comment">// zero angle, arbitrary axis</span></span><br><span class="line">                &#125; <span class="comment">// otherwise this singularity is angle = 180</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                angle = <span class="built_in">Math</span>.PI;</span><br><span class="line">                <span class="keyword">const</span> xx = (m11 + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">const</span> yy = (m22 + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">const</span> zz = (m33 + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">const</span> xy = (m12 + m21) / <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">const</span> xz = (m13 + m31) / <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">const</span> yz = (m23 + m32) / <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (xx &gt; yy &amp;&amp; xx &gt; zz) &#123;</span><br><span class="line">                    <span class="comment">// m11 is the largest diagonal term</span></span><br><span class="line">                    <span class="keyword">if</span> (xx &lt; epsilon) &#123;</span><br><span class="line">                        x = <span class="number">0</span>;</span><br><span class="line">                        y = <span class="number">0.707106781</span>;</span><br><span class="line">                        z = <span class="number">0.707106781</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        x = <span class="built_in">Math</span>.sqrt(xx);</span><br><span class="line">                        y = xy / x;</span><br><span class="line">                        z = xz / x;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (yy &gt; zz) &#123;</span><br><span class="line">                    <span class="comment">// m22 is the largest diagonal term</span></span><br><span class="line">                    <span class="keyword">if</span> (yy &lt; epsilon) &#123;</span><br><span class="line">                        x = <span class="number">0.707106781</span>;</span><br><span class="line">                        y = <span class="number">0</span>;</span><br><span class="line">                        z = <span class="number">0.707106781</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        y = <span class="built_in">Math</span>.sqrt(yy);</span><br><span class="line">                        x = xy / y;</span><br><span class="line">                        z = yz / y;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// m33 is the largest diagonal term so base result on this</span></span><br><span class="line">                    <span class="keyword">if</span> (zz &lt; epsilon) &#123;</span><br><span class="line">                        x = <span class="number">0.707106781</span>;</span><br><span class="line">                        y = <span class="number">0.707106781</span>;</span><br><span class="line">                        z = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        z = <span class="built_in">Math</span>.sqrt(zz);</span><br><span class="line">                        x = xz / z;</span><br><span class="line">                        y = yz / z;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.set(x, y, z, angle);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>; <span class="comment">// return 180 deg rotation</span></span><br><span class="line">            &#125; <span class="comment">// as we have reached here there are no singularities so we can handle normally</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> s = <span class="built_in">Math</span>.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); <span class="comment">// used to normalize</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(s) &lt; <span class="number">0.001</span>) s = <span class="number">1</span>; <span class="comment">// prevent divide by zero, should not happen if matrix is orthogonal and should be</span></span><br><span class="line">            <span class="comment">// caught by singularity test above, but I&#x27;ve left it in just in case</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.x = (m32 - m23) / s;</span><br><span class="line">            <span class="built_in">this</span>.y = (m13 - m31) / s;</span><br><span class="line">            <span class="built_in">this</span>.z = (m21 - m12) / s;</span><br><span class="line">            <span class="built_in">this</span>.w = <span class="built_in">Math</span>.acos((m11 + m22 + m33 - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">min</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">Math</span>.min(<span class="built_in">this</span>.x, v.x);</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.min(<span class="built_in">this</span>.y, v.y);</span><br><span class="line">            <span class="built_in">this</span>.z = <span class="built_in">Math</span>.min(<span class="built_in">this</span>.z, v.z);</span><br><span class="line">            <span class="built_in">this</span>.w = <span class="built_in">Math</span>.min(<span class="built_in">this</span>.w, v.w);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">max</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">Math</span>.max(<span class="built_in">this</span>.x, v.x);</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.max(<span class="built_in">this</span>.y, v.y);</span><br><span class="line">            <span class="built_in">this</span>.z = <span class="built_in">Math</span>.max(<span class="built_in">this</span>.z, v.z);</span><br><span class="line">            <span class="built_in">this</span>.w = <span class="built_in">Math</span>.max(<span class="built_in">this</span>.w, v.w);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clamp</span>(<span class="params">min, max</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// assumes min &lt; max, componentwise</span></span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">Math</span>.max(min.x, <span class="built_in">Math</span>.min(max.x, <span class="built_in">this</span>.x));</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.max(min.y, <span class="built_in">Math</span>.min(max.y, <span class="built_in">this</span>.y));</span><br><span class="line">            <span class="built_in">this</span>.z = <span class="built_in">Math</span>.max(min.z, <span class="built_in">Math</span>.min(max.z, <span class="built_in">this</span>.z));</span><br><span class="line">            <span class="built_in">this</span>.w = <span class="built_in">Math</span>.max(min.w, <span class="built_in">Math</span>.min(max.w, <span class="built_in">this</span>.w));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clampScalar</span>(<span class="params">minVal, maxVal</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">Math</span>.max(minVal, <span class="built_in">Math</span>.min(maxVal, <span class="built_in">this</span>.x));</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.max(minVal, <span class="built_in">Math</span>.min(maxVal, <span class="built_in">this</span>.y));</span><br><span class="line">            <span class="built_in">this</span>.z = <span class="built_in">Math</span>.max(minVal, <span class="built_in">Math</span>.min(maxVal, <span class="built_in">this</span>.z));</span><br><span class="line">            <span class="built_in">this</span>.w = <span class="built_in">Math</span>.max(minVal, <span class="built_in">Math</span>.min(maxVal, <span class="built_in">this</span>.w));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clampLength</span>(<span class="params">min, max</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> length = <span class="built_in">this</span>.length();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.divideScalar(length || <span class="number">1</span>).multiplyScalar(<span class="built_in">Math</span>.max(min, <span class="built_in">Math</span>.min(max, length)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">floor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">Math</span>.floor(<span class="built_in">this</span>.x);</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.floor(<span class="built_in">this</span>.y);</span><br><span class="line">            <span class="built_in">this</span>.z = <span class="built_in">Math</span>.floor(<span class="built_in">this</span>.z);</span><br><span class="line">            <span class="built_in">this</span>.w = <span class="built_in">Math</span>.floor(<span class="built_in">this</span>.w);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">ceil</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">Math</span>.ceil(<span class="built_in">this</span>.x);</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.ceil(<span class="built_in">this</span>.y);</span><br><span class="line">            <span class="built_in">this</span>.z = <span class="built_in">Math</span>.ceil(<span class="built_in">this</span>.z);</span><br><span class="line">            <span class="built_in">this</span>.w = <span class="built_in">Math</span>.ceil(<span class="built_in">this</span>.w);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">round</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">Math</span>.round(<span class="built_in">this</span>.x);</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.round(<span class="built_in">this</span>.y);</span><br><span class="line">            <span class="built_in">this</span>.z = <span class="built_in">Math</span>.round(<span class="built_in">this</span>.z);</span><br><span class="line">            <span class="built_in">this</span>.w = <span class="built_in">Math</span>.round(<span class="built_in">this</span>.w);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">roundToZero</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">this</span>.x &lt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(<span class="built_in">this</span>.x) : <span class="built_in">Math</span>.floor(<span class="built_in">this</span>.x);</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">this</span>.y &lt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(<span class="built_in">this</span>.y) : <span class="built_in">Math</span>.floor(<span class="built_in">this</span>.y);</span><br><span class="line">            <span class="built_in">this</span>.z = <span class="built_in">this</span>.z &lt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(<span class="built_in">this</span>.z) : <span class="built_in">Math</span>.floor(<span class="built_in">this</span>.z);</span><br><span class="line">            <span class="built_in">this</span>.w = <span class="built_in">this</span>.w &lt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(<span class="built_in">this</span>.w) : <span class="built_in">Math</span>.floor(<span class="built_in">this</span>.w);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">negate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = -<span class="built_in">this</span>.x;</span><br><span class="line">            <span class="built_in">this</span>.y = -<span class="built_in">this</span>.y;</span><br><span class="line">            <span class="built_in">this</span>.z = -<span class="built_in">this</span>.z;</span><br><span class="line">            <span class="built_in">this</span>.w = -<span class="built_in">this</span>.w;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dot</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.x * v.x + <span class="built_in">this</span>.y * v.y + <span class="built_in">this</span>.z * v.z + <span class="built_in">this</span>.w * v.w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">lengthSq</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.x * <span class="built_in">this</span>.x + <span class="built_in">this</span>.y * <span class="built_in">this</span>.y + <span class="built_in">this</span>.z * <span class="built_in">this</span>.z + <span class="built_in">this</span>.w * <span class="built_in">this</span>.w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">length</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="built_in">this</span>.x * <span class="built_in">this</span>.x + <span class="built_in">this</span>.y * <span class="built_in">this</span>.y + <span class="built_in">this</span>.z * <span class="built_in">this</span>.z + <span class="built_in">this</span>.w * <span class="built_in">this</span>.w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">manhattanLength</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.abs(<span class="built_in">this</span>.x) + <span class="built_in">Math</span>.abs(<span class="built_in">this</span>.y) + <span class="built_in">Math</span>.abs(<span class="built_in">this</span>.z) + <span class="built_in">Math</span>.abs(<span class="built_in">this</span>.w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">normalize</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.divideScalar(<span class="built_in">this</span>.length() || <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setLength</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.normalize().multiplyScalar(length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">lerp</span>(<span class="params">v, alpha</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x += (v.x - <span class="built_in">this</span>.x) * alpha;</span><br><span class="line">            <span class="built_in">this</span>.y += (v.y - <span class="built_in">this</span>.y) * alpha;</span><br><span class="line">            <span class="built_in">this</span>.z += (v.z - <span class="built_in">this</span>.z) * alpha;</span><br><span class="line">            <span class="built_in">this</span>.w += (v.w - <span class="built_in">this</span>.w) * alpha;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">lerpVectors</span>(<span class="params">v1, v2, alpha</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = v1.x + (v2.x - v1.x) * alpha;</span><br><span class="line">            <span class="built_in">this</span>.y = v1.y + (v2.y - v1.y) * alpha;</span><br><span class="line">            <span class="built_in">this</span>.z = v1.z + (v2.z - v1.z) * alpha;</span><br><span class="line">            <span class="built_in">this</span>.w = v1.w + (v2.w - v1.w) * alpha;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">equals</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> v.x === <span class="built_in">this</span>.x &amp;&amp; v.y === <span class="built_in">this</span>.y &amp;&amp; v.z === <span class="built_in">this</span>.z &amp;&amp; v.w === <span class="built_in">this</span>.w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromArray</span>(<span class="params">array, offset = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = array[offset];</span><br><span class="line">            <span class="built_in">this</span>.y = array[offset + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">this</span>.z = array[offset + <span class="number">2</span>];</span><br><span class="line">            <span class="built_in">this</span>.w = array[offset + <span class="number">3</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toArray</span>(<span class="params">array = [], offset = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            array[offset] = <span class="built_in">this</span>.x;</span><br><span class="line">            array[offset + <span class="number">1</span>] = <span class="built_in">this</span>.y;</span><br><span class="line">            array[offset + <span class="number">2</span>] = <span class="built_in">this</span>.z;</span><br><span class="line">            array[offset + <span class="number">3</span>] = <span class="built_in">this</span>.w;</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromBufferAttribute</span>(<span class="params">attribute, index, offset</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (offset !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Vector4: offset has been removed from .fromBufferAttribute().&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.x = attribute.getX(index);</span><br><span class="line">            <span class="built_in">this</span>.y = attribute.getY(index);</span><br><span class="line">            <span class="built_in">this</span>.z = attribute.getZ(index);</span><br><span class="line">            <span class="built_in">this</span>.w = attribute.getW(index);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">random</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">Math</span>.random();</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.random();</span><br><span class="line">            <span class="built_in">this</span>.z = <span class="built_in">Math</span>.random();</span><br><span class="line">            <span class="built_in">this</span>.w = <span class="built_in">Math</span>.random();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="built_in">this</span>.x;</span><br><span class="line">            <span class="keyword">yield</span> <span class="built_in">this</span>.y;</span><br><span class="line">            <span class="keyword">yield</span> <span class="built_in">this</span>.z;</span><br><span class="line">            <span class="keyword">yield</span> <span class="built_in">this</span>.w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector4.prototype.isVector4 = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 In options, we can specify:</span></span><br><span class="line"><span class="comment">	 * Texture parameters for an auto-generated target texture</span></span><br><span class="line"><span class="comment">	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WebGLRenderTarget</span> <span class="keyword">extends</span> <span class="title">EventDispatcher</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">width, height, options = &#123;&#125;</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.width = width;</span><br><span class="line">            <span class="built_in">this</span>.height = height;</span><br><span class="line">            <span class="built_in">this</span>.depth = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.scissor = <span class="keyword">new</span> Vector4(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">            <span class="built_in">this</span>.scissorTest = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.viewport = <span class="keyword">new</span> Vector4(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">            <span class="keyword">const</span> image = &#123;</span><br><span class="line">                <span class="attr">width</span>: width,</span><br><span class="line">                <span class="attr">height</span>: height,</span><br><span class="line">                <span class="attr">depth</span>: <span class="number">1</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">this</span>.texture = <span class="keyword">new</span> Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);</span><br><span class="line">            <span class="built_in">this</span>.texture.isRenderTargetTexture = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.texture.flipY = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.texture.generateMipmaps = options.generateMipmaps !== <span class="literal">undefined</span> ? options.generateMipmaps : <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.texture.internalFormat = options.internalFormat !== <span class="literal">undefined</span> ? options.internalFormat : <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.texture.minFilter = options.minFilter !== <span class="literal">undefined</span> ? options.minFilter : LinearFilter;</span><br><span class="line">            <span class="built_in">this</span>.depthBuffer = options.depthBuffer !== <span class="literal">undefined</span> ? options.depthBuffer : <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.stencilBuffer = options.stencilBuffer !== <span class="literal">undefined</span> ? options.stencilBuffer : <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.depthTexture = options.depthTexture !== <span class="literal">undefined</span> ? options.depthTexture : <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.samples = options.samples !== <span class="literal">undefined</span> ? options.samples : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setSize</span>(<span class="params">width, height, depth = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.width !== width || <span class="built_in">this</span>.height !== height || <span class="built_in">this</span>.depth !== depth) &#123;</span><br><span class="line">                <span class="built_in">this</span>.width = width;</span><br><span class="line">                <span class="built_in">this</span>.height = height;</span><br><span class="line">                <span class="built_in">this</span>.depth = depth;</span><br><span class="line">                <span class="built_in">this</span>.texture.image.width = width;</span><br><span class="line">                <span class="built_in">this</span>.texture.image.height = height;</span><br><span class="line">                <span class="built_in">this</span>.texture.image.depth = depth;</span><br><span class="line">                <span class="built_in">this</span>.dispose();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.viewport.set(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">            <span class="built_in">this</span>.scissor.set(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor().copy(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.width = source.width;</span><br><span class="line">            <span class="built_in">this</span>.height = source.height;</span><br><span class="line">            <span class="built_in">this</span>.depth = source.depth;</span><br><span class="line">            <span class="built_in">this</span>.viewport.copy(source.viewport);</span><br><span class="line">            <span class="built_in">this</span>.texture = source.texture.clone();</span><br><span class="line">            <span class="built_in">this</span>.texture.isRenderTargetTexture = <span class="literal">true</span>; <span class="comment">// ensure image object is not shared, see #20328</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.texture.image = <span class="built_in">Object</span>.assign(&#123;&#125;, source.texture.image);</span><br><span class="line">            <span class="built_in">this</span>.depthBuffer = source.depthBuffer;</span><br><span class="line">            <span class="built_in">this</span>.stencilBuffer = source.stencilBuffer;</span><br><span class="line">            <span class="keyword">if</span> (source.depthTexture !== <span class="literal">null</span>) <span class="built_in">this</span>.depthTexture = source.depthTexture.clone();</span><br><span class="line">            <span class="built_in">this</span>.samples = source.samples;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dispose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.dispatchEvent(&#123;</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;dispose&#x27;</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WebGLRenderTarget.prototype.isWebGLRenderTarget = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DataArrayTexture</span> <span class="keyword">extends</span> <span class="title">Texture</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">data = <span class="literal">null</span>, width = <span class="number">1</span>, height = <span class="number">1</span>, depth = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="literal">null</span>);</span><br><span class="line">            <span class="built_in">this</span>.image = &#123;</span><br><span class="line">                data,</span><br><span class="line">                width,</span><br><span class="line">                height,</span><br><span class="line">                depth</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">this</span>.magFilter = NearestFilter;</span><br><span class="line">            <span class="built_in">this</span>.minFilter = NearestFilter;</span><br><span class="line">            <span class="built_in">this</span>.wrapR = ClampToEdgeWrapping;</span><br><span class="line">            <span class="built_in">this</span>.generateMipmaps = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.flipY = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.unpackAlignment = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DataArrayTexture.prototype.isDataArrayTexture = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WebGLArrayRenderTarget</span> <span class="keyword">extends</span> <span class="title">WebGLRenderTarget</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">width, height, depth</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(width, height);</span><br><span class="line">            <span class="built_in">this</span>.depth = depth;</span><br><span class="line">            <span class="built_in">this</span>.texture = <span class="keyword">new</span> DataArrayTexture(<span class="literal">null</span>, width, height, depth);</span><br><span class="line">            <span class="built_in">this</span>.texture.isRenderTargetTexture = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WebGLArrayRenderTarget.prototype.isWebGLArrayRenderTarget = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Data3DTexture</span> <span class="keyword">extends</span> <span class="title">Texture</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">data = <span class="literal">null</span>, width = <span class="number">1</span>, height = <span class="number">1</span>, depth = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// We&#x27;re going to add .setXXX() methods for setting properties later.</span></span><br><span class="line">            <span class="comment">// Users can still set in DataTexture3D directly.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">//	const texture = new THREE.DataTexture3D( data, width, height, depth );</span></span><br><span class="line">            <span class="comment">// 	texture.anisotropy = 16;</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// See #14839</span></span><br><span class="line">            <span class="built_in">super</span>(<span class="literal">null</span>);</span><br><span class="line">            <span class="built_in">this</span>.image = &#123;</span><br><span class="line">                data,</span><br><span class="line">                width,</span><br><span class="line">                height,</span><br><span class="line">                depth</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">this</span>.magFilter = NearestFilter;</span><br><span class="line">            <span class="built_in">this</span>.minFilter = NearestFilter;</span><br><span class="line">            <span class="built_in">this</span>.wrapR = ClampToEdgeWrapping;</span><br><span class="line">            <span class="built_in">this</span>.generateMipmaps = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.flipY = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.unpackAlignment = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Data3DTexture.prototype.isData3DTexture = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WebGL3DRenderTarget</span> <span class="keyword">extends</span> <span class="title">WebGLRenderTarget</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">width, height, depth</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(width, height);</span><br><span class="line">            <span class="built_in">this</span>.depth = depth;</span><br><span class="line">            <span class="built_in">this</span>.texture = <span class="keyword">new</span> Data3DTexture(<span class="literal">null</span>, width, height, depth);</span><br><span class="line">            <span class="built_in">this</span>.texture.isRenderTargetTexture = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WebGL3DRenderTarget.prototype.isWebGL3DRenderTarget = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WebGLMultipleRenderTargets</span> <span class="keyword">extends</span> <span class="title">WebGLRenderTarget</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">width, height, count, options = &#123;&#125;</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(width, height, options);</span><br><span class="line">            <span class="keyword">const</span> texture = <span class="built_in">this</span>.texture;</span><br><span class="line">            <span class="built_in">this</span>.texture = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.texture[i] = texture.clone();</span><br><span class="line">                <span class="built_in">this</span>.texture[i].isRenderTargetTexture = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setSize</span>(<span class="params">width, height, depth = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.width !== width || <span class="built_in">this</span>.height !== height || <span class="built_in">this</span>.depth !== depth) &#123;</span><br><span class="line">                <span class="built_in">this</span>.width = width;</span><br><span class="line">                <span class="built_in">this</span>.height = height;</span><br><span class="line">                <span class="built_in">this</span>.depth = depth;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = <span class="built_in">this</span>.texture.length; i &lt; il; i++) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.texture[i].image.width = width;</span><br><span class="line">                    <span class="built_in">this</span>.texture[i].image.height = height;</span><br><span class="line">                    <span class="built_in">this</span>.texture[i].image.depth = depth;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.dispose();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.viewport.set(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">            <span class="built_in">this</span>.scissor.set(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.dispose();</span><br><span class="line">            <span class="built_in">this</span>.width = source.width;</span><br><span class="line">            <span class="built_in">this</span>.height = source.height;</span><br><span class="line">            <span class="built_in">this</span>.depth = source.depth;</span><br><span class="line">            <span class="built_in">this</span>.viewport.set(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">this</span>.width, <span class="built_in">this</span>.height);</span><br><span class="line">            <span class="built_in">this</span>.scissor.set(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">this</span>.width, <span class="built_in">this</span>.height);</span><br><span class="line">            <span class="built_in">this</span>.depthBuffer = source.depthBuffer;</span><br><span class="line">            <span class="built_in">this</span>.stencilBuffer = source.stencilBuffer;</span><br><span class="line">            <span class="built_in">this</span>.depthTexture = source.depthTexture;</span><br><span class="line">            <span class="built_in">this</span>.texture.length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = source.texture.length; i &lt; il; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.texture[i] = source.texture[i].clone();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Quaternion</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>, w = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._x = x;</span><br><span class="line">            <span class="built_in">this</span>._y = y;</span><br><span class="line">            <span class="built_in">this</span>._z = z;</span><br><span class="line">            <span class="built_in">this</span>._w = w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">slerp</span>(<span class="params">qa, qb, qm, t</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> qm.slerpQuaternions(qa, qb, t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">slerpFlat</span>(<span class="params">dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// fuzz-free, array-based Quaternion SLERP operation</span></span><br><span class="line">            <span class="keyword">let</span> x0 = src0[srcOffset0 + <span class="number">0</span>],</span><br><span class="line">                y0 = src0[srcOffset0 + <span class="number">1</span>],</span><br><span class="line">                z0 = src0[srcOffset0 + <span class="number">2</span>],</span><br><span class="line">                w0 = src0[srcOffset0 + <span class="number">3</span>];</span><br><span class="line">            <span class="keyword">const</span> x1 = src1[srcOffset1 + <span class="number">0</span>],</span><br><span class="line">                y1 = src1[srcOffset1 + <span class="number">1</span>],</span><br><span class="line">                z1 = src1[srcOffset1 + <span class="number">2</span>],</span><br><span class="line">                w1 = src1[srcOffset1 + <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t === <span class="number">0</span>) &#123;</span><br><span class="line">                dst[dstOffset + <span class="number">0</span>] = x0;</span><br><span class="line">                dst[dstOffset + <span class="number">1</span>] = y0;</span><br><span class="line">                dst[dstOffset + <span class="number">2</span>] = z0;</span><br><span class="line">                dst[dstOffset + <span class="number">3</span>] = w0;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t === <span class="number">1</span>) &#123;</span><br><span class="line">                dst[dstOffset + <span class="number">0</span>] = x1;</span><br><span class="line">                dst[dstOffset + <span class="number">1</span>] = y1;</span><br><span class="line">                dst[dstOffset + <span class="number">2</span>] = z1;</span><br><span class="line">                dst[dstOffset + <span class="number">3</span>] = w1;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) &#123;</span><br><span class="line">                <span class="keyword">let</span> s = <span class="number">1</span> - t;</span><br><span class="line">                <span class="keyword">const</span> cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,</span><br><span class="line">                    dir = cos &gt;= <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>,</span><br><span class="line">                    sqrSin = <span class="number">1</span> - cos * cos; <span class="comment">// Skip the Slerp for tiny steps to avoid numeric problems:</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sqrSin &gt; <span class="built_in">Number</span>.EPSILON) &#123;</span><br><span class="line">                    <span class="keyword">const</span> sin = <span class="built_in">Math</span>.sqrt(sqrSin),</span><br><span class="line">                        len = <span class="built_in">Math</span>.atan2(sin, cos * dir);</span><br><span class="line">                    s = <span class="built_in">Math</span>.sin(s * len) / sin;</span><br><span class="line">                    t = <span class="built_in">Math</span>.sin(t * len) / sin;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> tDir = t * dir;</span><br><span class="line">                x0 = x0 * s + x1 * tDir;</span><br><span class="line">                y0 = y0 * s + y1 * tDir;</span><br><span class="line">                z0 = z0 * s + z1 * tDir;</span><br><span class="line">                w0 = w0 * s + w1 * tDir; <span class="comment">// Normalize in case we just did a lerp:</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (s === <span class="number">1</span> - t) &#123;</span><br><span class="line">                    <span class="keyword">const</span> f = <span class="number">1</span> / <span class="built_in">Math</span>.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);</span><br><span class="line">                    x0 *= f;</span><br><span class="line">                    y0 *= f;</span><br><span class="line">                    z0 *= f;</span><br><span class="line">                    w0 *= f;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dst[dstOffset] = x0;</span><br><span class="line">            dst[dstOffset + <span class="number">1</span>] = y0;</span><br><span class="line">            dst[dstOffset + <span class="number">2</span>] = z0;</span><br><span class="line">            dst[dstOffset + <span class="number">3</span>] = w0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">multiplyQuaternionsFlat</span>(<span class="params">dst, dstOffset, src0, srcOffset0, src1, srcOffset1</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> x0 = src0[srcOffset0];</span><br><span class="line">            <span class="keyword">const</span> y0 = src0[srcOffset0 + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">const</span> z0 = src0[srcOffset0 + <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">const</span> w0 = src0[srcOffset0 + <span class="number">3</span>];</span><br><span class="line">            <span class="keyword">const</span> x1 = src1[srcOffset1];</span><br><span class="line">            <span class="keyword">const</span> y1 = src1[srcOffset1 + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">const</span> z1 = src1[srcOffset1 + <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">const</span> w1 = src1[srcOffset1 + <span class="number">3</span>];</span><br><span class="line">            dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;</span><br><span class="line">            dst[dstOffset + <span class="number">1</span>] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;</span><br><span class="line">            dst[dstOffset + <span class="number">2</span>] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;</span><br><span class="line">            dst[dstOffset + <span class="number">3</span>] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;</span><br><span class="line">            <span class="keyword">return</span> dst;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">x</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">x</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>._x = value;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._onChangeCallback();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">y</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">y</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>._y = value;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._onChangeCallback();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">z</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._z;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">z</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>._z = value;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._onChangeCallback();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">w</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">w</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>._w = value;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._onChangeCallback();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">x, y, z, w</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._x = x;</span><br><span class="line">            <span class="built_in">this</span>._y = y;</span><br><span class="line">            <span class="built_in">this</span>._z = z;</span><br><span class="line">            <span class="built_in">this</span>._w = w;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._onChangeCallback();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor(<span class="built_in">this</span>._x, <span class="built_in">this</span>._y, <span class="built_in">this</span>._z, <span class="built_in">this</span>._w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">quaternion</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._x = quaternion.x;</span><br><span class="line">            <span class="built_in">this</span>._y = quaternion.y;</span><br><span class="line">            <span class="built_in">this</span>._z = quaternion.z;</span><br><span class="line">            <span class="built_in">this</span>._w = quaternion.w;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._onChangeCallback();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromEuler</span>(<span class="params">euler, update</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(euler &amp;&amp; euler.isEuler)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> x = euler._x,</span><br><span class="line">                y = euler._y,</span><br><span class="line">                z = euler._z,</span><br><span class="line">                order = euler._order; <span class="comment">// http://www.mathworks.com/matlabcentral/fileexchange/</span></span><br><span class="line">            <span class="comment">// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/</span></span><br><span class="line">            <span class="comment">//	content/SpinCalc.m</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> cos = <span class="built_in">Math</span>.cos;</span><br><span class="line">            <span class="keyword">const</span> sin = <span class="built_in">Math</span>.sin;</span><br><span class="line">            <span class="keyword">const</span> c1 = cos(x / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">const</span> c2 = cos(y / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">const</span> c3 = cos(z / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">const</span> s1 = sin(x / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">const</span> s2 = sin(y / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">const</span> s3 = sin(z / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (order) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;XYZ&#x27;</span>:</span><br><span class="line">                    <span class="built_in">this</span>._x = s1 * c2 * c3 + c1 * s2 * s3;</span><br><span class="line">                    <span class="built_in">this</span>._y = c1 * s2 * c3 - s1 * c2 * s3;</span><br><span class="line">                    <span class="built_in">this</span>._z = c1 * c2 * s3 + s1 * s2 * c3;</span><br><span class="line">                    <span class="built_in">this</span>._w = c1 * c2 * c3 - s1 * s2 * s3;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;YXZ&#x27;</span>:</span><br><span class="line">                    <span class="built_in">this</span>._x = s1 * c2 * c3 + c1 * s2 * s3;</span><br><span class="line">                    <span class="built_in">this</span>._y = c1 * s2 * c3 - s1 * c2 * s3;</span><br><span class="line">                    <span class="built_in">this</span>._z = c1 * c2 * s3 - s1 * s2 * c3;</span><br><span class="line">                    <span class="built_in">this</span>._w = c1 * c2 * c3 + s1 * s2 * s3;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;ZXY&#x27;</span>:</span><br><span class="line">                    <span class="built_in">this</span>._x = s1 * c2 * c3 - c1 * s2 * s3;</span><br><span class="line">                    <span class="built_in">this</span>._y = c1 * s2 * c3 + s1 * c2 * s3;</span><br><span class="line">                    <span class="built_in">this</span>._z = c1 * c2 * s3 + s1 * s2 * c3;</span><br><span class="line">                    <span class="built_in">this</span>._w = c1 * c2 * c3 - s1 * s2 * s3;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;ZYX&#x27;</span>:</span><br><span class="line">                    <span class="built_in">this</span>._x = s1 * c2 * c3 - c1 * s2 * s3;</span><br><span class="line">                    <span class="built_in">this</span>._y = c1 * s2 * c3 + s1 * c2 * s3;</span><br><span class="line">                    <span class="built_in">this</span>._z = c1 * c2 * s3 - s1 * s2 * c3;</span><br><span class="line">                    <span class="built_in">this</span>._w = c1 * c2 * c3 + s1 * s2 * s3;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;YZX&#x27;</span>:</span><br><span class="line">                    <span class="built_in">this</span>._x = s1 * c2 * c3 + c1 * s2 * s3;</span><br><span class="line">                    <span class="built_in">this</span>._y = c1 * s2 * c3 + s1 * c2 * s3;</span><br><span class="line">                    <span class="built_in">this</span>._z = c1 * c2 * s3 - s1 * s2 * c3;</span><br><span class="line">                    <span class="built_in">this</span>._w = c1 * c2 * c3 - s1 * s2 * s3;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;XZY&#x27;</span>:</span><br><span class="line">                    <span class="built_in">this</span>._x = s1 * c2 * c3 - c1 * s2 * s3;</span><br><span class="line">                    <span class="built_in">this</span>._y = c1 * s2 * c3 - s1 * c2 * s3;</span><br><span class="line">                    <span class="built_in">this</span>._z = c1 * c2 * s3 + s1 * s2 * c3;</span><br><span class="line">                    <span class="built_in">this</span>._w = c1 * c2 * c3 + s1 * s2 * s3;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Quaternion: .setFromEuler() encountered an unknown order: &#x27;</span> + order);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (update !== <span class="literal">false</span>) <span class="built_in">this</span>._onChangeCallback();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromAxisAngle</span>(<span class="params">axis, angle</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm</span></span><br><span class="line">            <span class="comment">// assumes axis is normalized</span></span><br><span class="line">            <span class="keyword">const</span> halfAngle = angle / <span class="number">2</span>,</span><br><span class="line">                s = <span class="built_in">Math</span>.sin(halfAngle);</span><br><span class="line">            <span class="built_in">this</span>._x = axis.x * s;</span><br><span class="line">            <span class="built_in">this</span>._y = axis.y * s;</span><br><span class="line">            <span class="built_in">this</span>._z = axis.z * s;</span><br><span class="line">            <span class="built_in">this</span>._w = <span class="built_in">Math</span>.cos(halfAngle);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._onChangeCallback();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromRotationMatrix</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm</span></span><br><span class="line">            <span class="comment">// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)</span></span><br><span class="line">            <span class="keyword">const</span> te = m.elements,</span><br><span class="line">                m11 = te[<span class="number">0</span>],</span><br><span class="line">                m12 = te[<span class="number">4</span>],</span><br><span class="line">                m13 = te[<span class="number">8</span>],</span><br><span class="line">                m21 = te[<span class="number">1</span>],</span><br><span class="line">                m22 = te[<span class="number">5</span>],</span><br><span class="line">                m23 = te[<span class="number">9</span>],</span><br><span class="line">                m31 = te[<span class="number">2</span>],</span><br><span class="line">                m32 = te[<span class="number">6</span>],</span><br><span class="line">                m33 = te[<span class="number">10</span>],</span><br><span class="line">                trace = m11 + m22 + m33;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (trace &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> s = <span class="number">0.5</span> / <span class="built_in">Math</span>.sqrt(trace + <span class="number">1.0</span>);</span><br><span class="line">                <span class="built_in">this</span>._w = <span class="number">0.25</span> / s;</span><br><span class="line">                <span class="built_in">this</span>._x = (m32 - m23) * s;</span><br><span class="line">                <span class="built_in">this</span>._y = (m13 - m31) * s;</span><br><span class="line">                <span class="built_in">this</span>._z = (m21 - m12) * s;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m11 &gt; m22 &amp;&amp; m11 &gt; m33) &#123;</span><br><span class="line">                <span class="keyword">const</span> s = <span class="number">2.0</span> * <span class="built_in">Math</span>.sqrt(<span class="number">1.0</span> + m11 - m22 - m33);</span><br><span class="line">                <span class="built_in">this</span>._w = (m32 - m23) / s;</span><br><span class="line">                <span class="built_in">this</span>._x = <span class="number">0.25</span> * s;</span><br><span class="line">                <span class="built_in">this</span>._y = (m12 + m21) / s;</span><br><span class="line">                <span class="built_in">this</span>._z = (m13 + m31) / s;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m22 &gt; m33) &#123;</span><br><span class="line">                <span class="keyword">const</span> s = <span class="number">2.0</span> * <span class="built_in">Math</span>.sqrt(<span class="number">1.0</span> + m22 - m11 - m33);</span><br><span class="line">                <span class="built_in">this</span>._w = (m13 - m31) / s;</span><br><span class="line">                <span class="built_in">this</span>._x = (m12 + m21) / s;</span><br><span class="line">                <span class="built_in">this</span>._y = <span class="number">0.25</span> * s;</span><br><span class="line">                <span class="built_in">this</span>._z = (m23 + m32) / s;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> s = <span class="number">2.0</span> * <span class="built_in">Math</span>.sqrt(<span class="number">1.0</span> + m33 - m11 - m22);</span><br><span class="line">                <span class="built_in">this</span>._w = (m21 - m12) / s;</span><br><span class="line">                <span class="built_in">this</span>._x = (m13 + m31) / s;</span><br><span class="line">                <span class="built_in">this</span>._y = (m23 + m32) / s;</span><br><span class="line">                <span class="built_in">this</span>._z = <span class="number">0.25</span> * s;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._onChangeCallback();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromUnitVectors</span>(<span class="params">vFrom, vTo</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// assumes direction vectors vFrom and vTo are normalized</span></span><br><span class="line">            <span class="keyword">let</span> r = vFrom.dot(vTo) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r &lt; <span class="built_in">Number</span>.EPSILON) &#123;</span><br><span class="line">                <span class="comment">// vFrom and vTo point in opposite directions</span></span><br><span class="line">                r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(vFrom.x) &gt; <span class="built_in">Math</span>.abs(vFrom.z)) &#123;</span><br><span class="line">                    <span class="built_in">this</span>._x = -vFrom.y;</span><br><span class="line">                    <span class="built_in">this</span>._y = vFrom.x;</span><br><span class="line">                    <span class="built_in">this</span>._z = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">this</span>._w = r;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>._x = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">this</span>._y = -vFrom.z;</span><br><span class="line">                    <span class="built_in">this</span>._z = vFrom.y;</span><br><span class="line">                    <span class="built_in">this</span>._w = r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3</span></span><br><span class="line">                <span class="built_in">this</span>._x = vFrom.y * vTo.z - vFrom.z * vTo.y;</span><br><span class="line">                <span class="built_in">this</span>._y = vFrom.z * vTo.x - vFrom.x * vTo.z;</span><br><span class="line">                <span class="built_in">this</span>._z = vFrom.x * vTo.y - vFrom.y * vTo.x;</span><br><span class="line">                <span class="built_in">this</span>._w = r;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.normalize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">angleTo</span>(<span class="params">q</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">Math</span>.acos(<span class="built_in">Math</span>.abs(clamp(<span class="built_in">this</span>.dot(q), -<span class="number">1</span>, <span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">rotateTowards</span>(<span class="params">q, step</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> angle = <span class="built_in">this</span>.angleTo(q);</span><br><span class="line">            <span class="keyword">if</span> (angle === <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">const</span> t = <span class="built_in">Math</span>.min(<span class="number">1</span>, step / angle);</span><br><span class="line">            <span class="built_in">this</span>.slerp(q, t);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">identity</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">invert</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// quaternion is assumed to have unit length</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.conjugate();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">conjugate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._x *= -<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>._y *= -<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>._z *= -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._onChangeCallback();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dot</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._x * v._x + <span class="built_in">this</span>._y * v._y + <span class="built_in">this</span>._z * v._z + <span class="built_in">this</span>._w * v._w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">lengthSq</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._x * <span class="built_in">this</span>._x + <span class="built_in">this</span>._y * <span class="built_in">this</span>._y + <span class="built_in">this</span>._z * <span class="built_in">this</span>._z + <span class="built_in">this</span>._w * <span class="built_in">this</span>._w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">length</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="built_in">this</span>._x * <span class="built_in">this</span>._x + <span class="built_in">this</span>._y * <span class="built_in">this</span>._y + <span class="built_in">this</span>._z * <span class="built_in">this</span>._z + <span class="built_in">this</span>._w * <span class="built_in">this</span>._w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">normalize</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> l = <span class="built_in">this</span>.length();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>._x = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">this</span>._y = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">this</span>._z = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">this</span>._w = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = <span class="number">1</span> / l;</span><br><span class="line">                <span class="built_in">this</span>._x = <span class="built_in">this</span>._x * l;</span><br><span class="line">                <span class="built_in">this</span>._y = <span class="built_in">this</span>._y * l;</span><br><span class="line">                <span class="built_in">this</span>._z = <span class="built_in">this</span>._z * l;</span><br><span class="line">                <span class="built_in">this</span>._w = <span class="built_in">this</span>._w * l;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._onChangeCallback();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">multiply</span>(<span class="params">q, p</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.multiplyQuaternions(q, p);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.multiplyQuaternions(<span class="built_in">this</span>, q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">premultiply</span>(<span class="params">q</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.multiplyQuaternions(q, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">multiplyQuaternions</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm</span></span><br><span class="line">            <span class="keyword">const</span> qax = a._x,</span><br><span class="line">                qay = a._y,</span><br><span class="line">                qaz = a._z,</span><br><span class="line">                qaw = a._w;</span><br><span class="line">            <span class="keyword">const</span> qbx = b._x,</span><br><span class="line">                qby = b._y,</span><br><span class="line">                qbz = b._z,</span><br><span class="line">                qbw = b._w;</span><br><span class="line">            <span class="built_in">this</span>._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;</span><br><span class="line">            <span class="built_in">this</span>._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;</span><br><span class="line">            <span class="built_in">this</span>._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;</span><br><span class="line">            <span class="built_in">this</span>._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._onChangeCallback();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">slerp</span>(<span class="params">qb, t</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (t === <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">if</span> (t === <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">this</span>.copy(qb);</span><br><span class="line">            <span class="keyword">const</span> x = <span class="built_in">this</span>._x,</span><br><span class="line">                y = <span class="built_in">this</span>._y,</span><br><span class="line">                z = <span class="built_in">this</span>._z,</span><br><span class="line">                w = <span class="built_in">this</span>._w; <span class="comment">// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cosHalfTheta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>._w = -qb._w;</span><br><span class="line">                <span class="built_in">this</span>._x = -qb._x;</span><br><span class="line">                <span class="built_in">this</span>._y = -qb._y;</span><br><span class="line">                <span class="built_in">this</span>._z = -qb._z;</span><br><span class="line">                cosHalfTheta = -cosHalfTheta;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.copy(qb);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cosHalfTheta &gt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>._w = w;</span><br><span class="line">                <span class="built_in">this</span>._x = x;</span><br><span class="line">                <span class="built_in">this</span>._y = y;</span><br><span class="line">                <span class="built_in">this</span>._z = z;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> sqrSinHalfTheta = <span class="number">1.0</span> - cosHalfTheta * cosHalfTheta;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sqrSinHalfTheta &lt;= <span class="built_in">Number</span>.EPSILON) &#123;</span><br><span class="line">                <span class="keyword">const</span> s = <span class="number">1</span> - t;</span><br><span class="line">                <span class="built_in">this</span>._w = s * w + t * <span class="built_in">this</span>._w;</span><br><span class="line">                <span class="built_in">this</span>._x = s * x + t * <span class="built_in">this</span>._x;</span><br><span class="line">                <span class="built_in">this</span>._y = s * y + t * <span class="built_in">this</span>._y;</span><br><span class="line">                <span class="built_in">this</span>._z = s * z + t * <span class="built_in">this</span>._z;</span><br><span class="line">                <span class="built_in">this</span>.normalize();</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>._onChangeCallback();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> sinHalfTheta = <span class="built_in">Math</span>.sqrt(sqrSinHalfTheta);</span><br><span class="line">            <span class="keyword">const</span> halfTheta = <span class="built_in">Math</span>.atan2(sinHalfTheta, cosHalfTheta);</span><br><span class="line">            <span class="keyword">const</span> ratioA = <span class="built_in">Math</span>.sin((<span class="number">1</span> - t) * halfTheta) / sinHalfTheta,</span><br><span class="line">                ratioB = <span class="built_in">Math</span>.sin(t * halfTheta) / sinHalfTheta;</span><br><span class="line">            <span class="built_in">this</span>._w = w * ratioA + <span class="built_in">this</span>._w * ratioB;</span><br><span class="line">            <span class="built_in">this</span>._x = x * ratioA + <span class="built_in">this</span>._x * ratioB;</span><br><span class="line">            <span class="built_in">this</span>._y = y * ratioA + <span class="built_in">this</span>._y * ratioB;</span><br><span class="line">            <span class="built_in">this</span>._z = z * ratioA + <span class="built_in">this</span>._z * ratioB;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._onChangeCallback();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">slerpQuaternions</span>(<span class="params">qa, qb, t</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.copy(qa).slerp(qb, t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">random</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// Derived from http://planning.cs.uiuc.edu/node198.html</span></span><br><span class="line">            <span class="comment">// Note, this source uses w, x, y, z ordering,</span></span><br><span class="line">            <span class="comment">// so we swap the order below.</span></span><br><span class="line">            <span class="keyword">const</span> u1 = <span class="built_in">Math</span>.random();</span><br><span class="line">            <span class="keyword">const</span> sqrt1u1 = <span class="built_in">Math</span>.sqrt(<span class="number">1</span> - u1);</span><br><span class="line">            <span class="keyword">const</span> sqrtu1 = <span class="built_in">Math</span>.sqrt(u1);</span><br><span class="line">            <span class="keyword">const</span> u2 = <span class="number">2</span> * <span class="built_in">Math</span>.PI * <span class="built_in">Math</span>.random();</span><br><span class="line">            <span class="keyword">const</span> u3 = <span class="number">2</span> * <span class="built_in">Math</span>.PI * <span class="built_in">Math</span>.random();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.set(sqrt1u1 * <span class="built_in">Math</span>.cos(u2), sqrtu1 * <span class="built_in">Math</span>.sin(u3), sqrtu1 * <span class="built_in">Math</span>.cos(u3), sqrt1u1 * <span class="built_in">Math</span>.sin(u2));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">equals</span>(<span class="params">quaternion</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> quaternion._x === <span class="built_in">this</span>._x &amp;&amp; quaternion._y === <span class="built_in">this</span>._y &amp;&amp; quaternion._z === <span class="built_in">this</span>._z &amp;&amp; quaternion._w === <span class="built_in">this</span>._w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromArray</span>(<span class="params">array, offset = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._x = array[offset];</span><br><span class="line">            <span class="built_in">this</span>._y = array[offset + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">this</span>._z = array[offset + <span class="number">2</span>];</span><br><span class="line">            <span class="built_in">this</span>._w = array[offset + <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._onChangeCallback();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toArray</span>(<span class="params">array = [], offset = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            array[offset] = <span class="built_in">this</span>._x;</span><br><span class="line">            array[offset + <span class="number">1</span>] = <span class="built_in">this</span>._y;</span><br><span class="line">            array[offset + <span class="number">2</span>] = <span class="built_in">this</span>._z;</span><br><span class="line">            array[offset + <span class="number">3</span>] = <span class="built_in">this</span>._w;</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromBufferAttribute</span>(<span class="params">attribute, index</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._x = attribute.getX(index);</span><br><span class="line">            <span class="built_in">this</span>._y = attribute.getY(index);</span><br><span class="line">            <span class="built_in">this</span>._z = attribute.getZ(index);</span><br><span class="line">            <span class="built_in">this</span>._w = attribute.getW(index);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_onChange</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._onChangeCallback = callback;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_onChangeCallback</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Quaternion.prototype.isQuaternion = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Vector3</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = x;</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">            <span class="built_in">this</span>.z = z;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">x, y, z</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (z === <span class="literal">undefined</span>) z = <span class="built_in">this</span>.z; <span class="comment">// sprite.scale.set(x,y)</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.x = x;</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">            <span class="built_in">this</span>.z = z;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setScalar</span>(<span class="params">scalar</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = scalar;</span><br><span class="line">            <span class="built_in">this</span>.y = scalar;</span><br><span class="line">            <span class="built_in">this</span>.z = scalar;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setX</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = x;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setY</span>(<span class="params">y</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setZ</span>(<span class="params">z</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.z = z;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setComponent</span>(<span class="params">index, value</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (index) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="built_in">this</span>.x = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="built_in">this</span>.y = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="built_in">this</span>.z = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;index is out of range: &#x27;</span> + index);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getComponent</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (index) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.y;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.z;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;index is out of range: &#x27;</span> + index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor(<span class="built_in">this</span>.x, <span class="built_in">this</span>.y, <span class="built_in">this</span>.z);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = v.x;</span><br><span class="line">            <span class="built_in">this</span>.y = v.y;</span><br><span class="line">            <span class="built_in">this</span>.z = v.z;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params">v, w</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (w !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.addVectors(v, w);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.x += v.x;</span><br><span class="line">            <span class="built_in">this</span>.y += v.y;</span><br><span class="line">            <span class="built_in">this</span>.z += v.z;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">addScalar</span>(<span class="params">s</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x += s;</span><br><span class="line">            <span class="built_in">this</span>.y += s;</span><br><span class="line">            <span class="built_in">this</span>.z += s;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">addVectors</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = a.x + b.x;</span><br><span class="line">            <span class="built_in">this</span>.y = a.y + b.y;</span><br><span class="line">            <span class="built_in">this</span>.z = a.z + b.z;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">addScaledVector</span>(<span class="params">v, s</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x += v.x * s;</span><br><span class="line">            <span class="built_in">this</span>.y += v.y * s;</span><br><span class="line">            <span class="built_in">this</span>.z += v.z * s;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">sub</span>(<span class="params">v, w</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (w !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.subVectors(v, w);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.x -= v.x;</span><br><span class="line">            <span class="built_in">this</span>.y -= v.y;</span><br><span class="line">            <span class="built_in">this</span>.z -= v.z;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">subScalar</span>(<span class="params">s</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x -= s;</span><br><span class="line">            <span class="built_in">this</span>.y -= s;</span><br><span class="line">            <span class="built_in">this</span>.z -= s;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">subVectors</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = a.x - b.x;</span><br><span class="line">            <span class="built_in">this</span>.y = a.y - b.y;</span><br><span class="line">            <span class="built_in">this</span>.z = a.z - b.z;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">multiply</span>(<span class="params">v, w</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (w !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.multiplyVectors(v, w);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.x *= v.x;</span><br><span class="line">            <span class="built_in">this</span>.y *= v.y;</span><br><span class="line">            <span class="built_in">this</span>.z *= v.z;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">multiplyScalar</span>(<span class="params">scalar</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x *= scalar;</span><br><span class="line">            <span class="built_in">this</span>.y *= scalar;</span><br><span class="line">            <span class="built_in">this</span>.z *= scalar;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">multiplyVectors</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = a.x * b.x;</span><br><span class="line">            <span class="built_in">this</span>.y = a.y * b.y;</span><br><span class="line">            <span class="built_in">this</span>.z = a.z * b.z;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">applyEuler</span>(<span class="params">euler</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(euler &amp;&amp; euler.isEuler)) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.applyQuaternion(_quaternion$<span class="number">4.</span>setFromEuler(euler));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">applyAxisAngle</span>(<span class="params">axis, angle</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.applyQuaternion(_quaternion$<span class="number">4.</span>setFromAxisAngle(axis, angle));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">applyMatrix3</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> x = <span class="built_in">this</span>.x,</span><br><span class="line">                y = <span class="built_in">this</span>.y,</span><br><span class="line">                z = <span class="built_in">this</span>.z;</span><br><span class="line">            <span class="keyword">const</span> e = m.elements;</span><br><span class="line">            <span class="built_in">this</span>.x = e[<span class="number">0</span>] * x + e[<span class="number">3</span>] * y + e[<span class="number">6</span>] * z;</span><br><span class="line">            <span class="built_in">this</span>.y = e[<span class="number">1</span>] * x + e[<span class="number">4</span>] * y + e[<span class="number">7</span>] * z;</span><br><span class="line">            <span class="built_in">this</span>.z = e[<span class="number">2</span>] * x + e[<span class="number">5</span>] * y + e[<span class="number">8</span>] * z;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">applyNormalMatrix</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.applyMatrix3(m).normalize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">applyMatrix4</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> x = <span class="built_in">this</span>.x,</span><br><span class="line">                y = <span class="built_in">this</span>.y,</span><br><span class="line">                z = <span class="built_in">this</span>.z;</span><br><span class="line">            <span class="keyword">const</span> e = m.elements;</span><br><span class="line">            <span class="keyword">const</span> w = <span class="number">1</span> / (e[<span class="number">3</span>] * x + e[<span class="number">7</span>] * y + e[<span class="number">11</span>] * z + e[<span class="number">15</span>]);</span><br><span class="line">            <span class="built_in">this</span>.x = (e[<span class="number">0</span>] * x + e[<span class="number">4</span>] * y + e[<span class="number">8</span>] * z + e[<span class="number">12</span>]) * w;</span><br><span class="line">            <span class="built_in">this</span>.y = (e[<span class="number">1</span>] * x + e[<span class="number">5</span>] * y + e[<span class="number">9</span>] * z + e[<span class="number">13</span>]) * w;</span><br><span class="line">            <span class="built_in">this</span>.z = (e[<span class="number">2</span>] * x + e[<span class="number">6</span>] * y + e[<span class="number">10</span>] * z + e[<span class="number">14</span>]) * w;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">applyQuaternion</span>(<span class="params">q</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> x = <span class="built_in">this</span>.x,</span><br><span class="line">                y = <span class="built_in">this</span>.y,</span><br><span class="line">                z = <span class="built_in">this</span>.z;</span><br><span class="line">            <span class="keyword">const</span> qx = q.x,</span><br><span class="line">                qy = q.y,</span><br><span class="line">                qz = q.z,</span><br><span class="line">                qw = q.w; <span class="comment">// calculate quat * vector</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> ix = qw * x + qy * z - qz * y;</span><br><span class="line">            <span class="keyword">const</span> iy = qw * y + qz * x - qx * z;</span><br><span class="line">            <span class="keyword">const</span> iz = qw * z + qx * y - qy * x;</span><br><span class="line">            <span class="keyword">const</span> iw = -qx * x - qy * y - qz * z; <span class="comment">// calculate result * inverse quat</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;</span><br><span class="line">            <span class="built_in">this</span>.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;</span><br><span class="line">            <span class="built_in">this</span>.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">project</span>(<span class="params">camera</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">unproject</span>(<span class="params">camera</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">transformDirection</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// input: THREE.Matrix4 affine matrix</span></span><br><span class="line">            <span class="comment">// vector interpreted as a direction</span></span><br><span class="line">            <span class="keyword">const</span> x = <span class="built_in">this</span>.x,</span><br><span class="line">                y = <span class="built_in">this</span>.y,</span><br><span class="line">                z = <span class="built_in">this</span>.z;</span><br><span class="line">            <span class="keyword">const</span> e = m.elements;</span><br><span class="line">            <span class="built_in">this</span>.x = e[<span class="number">0</span>] * x + e[<span class="number">4</span>] * y + e[<span class="number">8</span>] * z;</span><br><span class="line">            <span class="built_in">this</span>.y = e[<span class="number">1</span>] * x + e[<span class="number">5</span>] * y + e[<span class="number">9</span>] * z;</span><br><span class="line">            <span class="built_in">this</span>.z = e[<span class="number">2</span>] * x + e[<span class="number">6</span>] * y + e[<span class="number">10</span>] * z;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.normalize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">divide</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x /= v.x;</span><br><span class="line">            <span class="built_in">this</span>.y /= v.y;</span><br><span class="line">            <span class="built_in">this</span>.z /= v.z;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">divideScalar</span>(<span class="params">scalar</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.multiplyScalar(<span class="number">1</span> / scalar);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">min</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">Math</span>.min(<span class="built_in">this</span>.x, v.x);</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.min(<span class="built_in">this</span>.y, v.y);</span><br><span class="line">            <span class="built_in">this</span>.z = <span class="built_in">Math</span>.min(<span class="built_in">this</span>.z, v.z);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">max</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">Math</span>.max(<span class="built_in">this</span>.x, v.x);</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.max(<span class="built_in">this</span>.y, v.y);</span><br><span class="line">            <span class="built_in">this</span>.z = <span class="built_in">Math</span>.max(<span class="built_in">this</span>.z, v.z);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clamp</span>(<span class="params">min, max</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// assumes min &lt; max, componentwise</span></span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">Math</span>.max(min.x, <span class="built_in">Math</span>.min(max.x, <span class="built_in">this</span>.x));</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.max(min.y, <span class="built_in">Math</span>.min(max.y, <span class="built_in">this</span>.y));</span><br><span class="line">            <span class="built_in">this</span>.z = <span class="built_in">Math</span>.max(min.z, <span class="built_in">Math</span>.min(max.z, <span class="built_in">this</span>.z));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clampScalar</span>(<span class="params">minVal, maxVal</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">Math</span>.max(minVal, <span class="built_in">Math</span>.min(maxVal, <span class="built_in">this</span>.x));</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.max(minVal, <span class="built_in">Math</span>.min(maxVal, <span class="built_in">this</span>.y));</span><br><span class="line">            <span class="built_in">this</span>.z = <span class="built_in">Math</span>.max(minVal, <span class="built_in">Math</span>.min(maxVal, <span class="built_in">this</span>.z));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clampLength</span>(<span class="params">min, max</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> length = <span class="built_in">this</span>.length();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.divideScalar(length || <span class="number">1</span>).multiplyScalar(<span class="built_in">Math</span>.max(min, <span class="built_in">Math</span>.min(max, length)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">floor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">Math</span>.floor(<span class="built_in">this</span>.x);</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.floor(<span class="built_in">this</span>.y);</span><br><span class="line">            <span class="built_in">this</span>.z = <span class="built_in">Math</span>.floor(<span class="built_in">this</span>.z);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">ceil</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">Math</span>.ceil(<span class="built_in">this</span>.x);</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.ceil(<span class="built_in">this</span>.y);</span><br><span class="line">            <span class="built_in">this</span>.z = <span class="built_in">Math</span>.ceil(<span class="built_in">this</span>.z);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">round</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">Math</span>.round(<span class="built_in">this</span>.x);</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.round(<span class="built_in">this</span>.y);</span><br><span class="line">            <span class="built_in">this</span>.z = <span class="built_in">Math</span>.round(<span class="built_in">this</span>.z);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">roundToZero</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">this</span>.x &lt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(<span class="built_in">this</span>.x) : <span class="built_in">Math</span>.floor(<span class="built_in">this</span>.x);</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">this</span>.y &lt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(<span class="built_in">this</span>.y) : <span class="built_in">Math</span>.floor(<span class="built_in">this</span>.y);</span><br><span class="line">            <span class="built_in">this</span>.z = <span class="built_in">this</span>.z &lt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(<span class="built_in">this</span>.z) : <span class="built_in">Math</span>.floor(<span class="built_in">this</span>.z);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">negate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = -<span class="built_in">this</span>.x;</span><br><span class="line">            <span class="built_in">this</span>.y = -<span class="built_in">this</span>.y;</span><br><span class="line">            <span class="built_in">this</span>.z = -<span class="built_in">this</span>.z;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dot</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.x * v.x + <span class="built_in">this</span>.y * v.y + <span class="built_in">this</span>.z * v.z;</span><br><span class="line">        &#125; <span class="comment">// TODO lengthSquared?</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">lengthSq</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.x * <span class="built_in">this</span>.x + <span class="built_in">this</span>.y * <span class="built_in">this</span>.y + <span class="built_in">this</span>.z * <span class="built_in">this</span>.z;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">length</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="built_in">this</span>.x * <span class="built_in">this</span>.x + <span class="built_in">this</span>.y * <span class="built_in">this</span>.y + <span class="built_in">this</span>.z * <span class="built_in">this</span>.z);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">manhattanLength</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.abs(<span class="built_in">this</span>.x) + <span class="built_in">Math</span>.abs(<span class="built_in">this</span>.y) + <span class="built_in">Math</span>.abs(<span class="built_in">this</span>.z);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">normalize</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.divideScalar(<span class="built_in">this</span>.length() || <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setLength</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.normalize().multiplyScalar(length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">lerp</span>(<span class="params">v, alpha</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x += (v.x - <span class="built_in">this</span>.x) * alpha;</span><br><span class="line">            <span class="built_in">this</span>.y += (v.y - <span class="built_in">this</span>.y) * alpha;</span><br><span class="line">            <span class="built_in">this</span>.z += (v.z - <span class="built_in">this</span>.z) * alpha;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">lerpVectors</span>(<span class="params">v1, v2, alpha</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = v1.x + (v2.x - v1.x) * alpha;</span><br><span class="line">            <span class="built_in">this</span>.y = v1.y + (v2.y - v1.y) * alpha;</span><br><span class="line">            <span class="built_in">this</span>.z = v1.z + (v2.z - v1.z) * alpha;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">cross</span>(<span class="params">v, w</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (w !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.crossVectors(v, w);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.crossVectors(<span class="built_in">this</span>, v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">crossVectors</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> ax = a.x,</span><br><span class="line">                ay = a.y,</span><br><span class="line">                az = a.z;</span><br><span class="line">            <span class="keyword">const</span> bx = b.x,</span><br><span class="line">                by = b.y,</span><br><span class="line">                bz = b.z;</span><br><span class="line">            <span class="built_in">this</span>.x = ay * bz - az * by;</span><br><span class="line">            <span class="built_in">this</span>.y = az * bx - ax * bz;</span><br><span class="line">            <span class="built_in">this</span>.z = ax * by - ay * bx;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">projectOnVector</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> denominator = v.lengthSq();</span><br><span class="line">            <span class="keyword">if</span> (denominator === <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">this</span>.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">const</span> scalar = v.dot(<span class="built_in">this</span>) / denominator;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.copy(v).multiplyScalar(scalar);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">projectOnPlane</span>(<span class="params">planeNormal</span>)</span> &#123;</span><br><span class="line">            _vector$c.copy(<span class="built_in">this</span>).projectOnVector(planeNormal);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.sub(_vector$c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">reflect</span>(<span class="params">normal</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// reflect incident vector off plane orthogonal to normal</span></span><br><span class="line">            <span class="comment">// normal is assumed to have unit length</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.sub(_vector$c.copy(normal).multiplyScalar(<span class="number">2</span> * <span class="built_in">this</span>.dot(normal)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">angleTo</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> denominator = <span class="built_in">Math</span>.sqrt(<span class="built_in">this</span>.lengthSq() * v.lengthSq());</span><br><span class="line">            <span class="keyword">if</span> (denominator === <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">Math</span>.PI / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">const</span> theta = <span class="built_in">this</span>.dot(v) / denominator; <span class="comment">// clamp, to handle numerical problems</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.acos(clamp(theta, -<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">distanceTo</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="built_in">this</span>.distanceToSquared(v));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">distanceToSquared</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> dx = <span class="built_in">this</span>.x - v.x,</span><br><span class="line">                dy = <span class="built_in">this</span>.y - v.y,</span><br><span class="line">                dz = <span class="built_in">this</span>.z - v.z;</span><br><span class="line">            <span class="keyword">return</span> dx * dx + dy * dy + dz * dz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">manhattanDistanceTo</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.abs(<span class="built_in">this</span>.x - v.x) + <span class="built_in">Math</span>.abs(<span class="built_in">this</span>.y - v.y) + <span class="built_in">Math</span>.abs(<span class="built_in">this</span>.z - v.z);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromSpherical</span>(<span class="params">s</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.setFromSphericalCoords(s.radius, s.phi, s.theta);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromSphericalCoords</span>(<span class="params">radius, phi, theta</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> sinPhiRadius = <span class="built_in">Math</span>.sin(phi) * radius;</span><br><span class="line">            <span class="built_in">this</span>.x = sinPhiRadius * <span class="built_in">Math</span>.sin(theta);</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.cos(phi) * radius;</span><br><span class="line">            <span class="built_in">this</span>.z = sinPhiRadius * <span class="built_in">Math</span>.cos(theta);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromCylindrical</span>(<span class="params">c</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.setFromCylindricalCoords(c.radius, c.theta, c.y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromCylindricalCoords</span>(<span class="params">radius, theta, y</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = radius * <span class="built_in">Math</span>.sin(theta);</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">            <span class="built_in">this</span>.z = radius * <span class="built_in">Math</span>.cos(theta);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromMatrixPosition</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> e = m.elements;</span><br><span class="line">            <span class="built_in">this</span>.x = e[<span class="number">12</span>];</span><br><span class="line">            <span class="built_in">this</span>.y = e[<span class="number">13</span>];</span><br><span class="line">            <span class="built_in">this</span>.z = e[<span class="number">14</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromMatrixScale</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> sx = <span class="built_in">this</span>.setFromMatrixColumn(m, <span class="number">0</span>).length();</span><br><span class="line">            <span class="keyword">const</span> sy = <span class="built_in">this</span>.setFromMatrixColumn(m, <span class="number">1</span>).length();</span><br><span class="line">            <span class="keyword">const</span> sz = <span class="built_in">this</span>.setFromMatrixColumn(m, <span class="number">2</span>).length();</span><br><span class="line">            <span class="built_in">this</span>.x = sx;</span><br><span class="line">            <span class="built_in">this</span>.y = sy;</span><br><span class="line">            <span class="built_in">this</span>.z = sz;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromMatrixColumn</span>(<span class="params">m, index</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.fromArray(m.elements, index * <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromMatrix3Column</span>(<span class="params">m, index</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.fromArray(m.elements, index * <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromEuler</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = e._x;</span><br><span class="line">            <span class="built_in">this</span>.y = e._y;</span><br><span class="line">            <span class="built_in">this</span>.z = e._z;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">equals</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> v.x === <span class="built_in">this</span>.x &amp;&amp; v.y === <span class="built_in">this</span>.y &amp;&amp; v.z === <span class="built_in">this</span>.z;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromArray</span>(<span class="params">array, offset = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = array[offset];</span><br><span class="line">            <span class="built_in">this</span>.y = array[offset + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">this</span>.z = array[offset + <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toArray</span>(<span class="params">array = [], offset = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            array[offset] = <span class="built_in">this</span>.x;</span><br><span class="line">            array[offset + <span class="number">1</span>] = <span class="built_in">this</span>.y;</span><br><span class="line">            array[offset + <span class="number">2</span>] = <span class="built_in">this</span>.z;</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromBufferAttribute</span>(<span class="params">attribute, index, offset</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (offset !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Vector3: offset has been removed from .fromBufferAttribute().&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.x = attribute.getX(index);</span><br><span class="line">            <span class="built_in">this</span>.y = attribute.getY(index);</span><br><span class="line">            <span class="built_in">this</span>.z = attribute.getZ(index);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">random</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = <span class="built_in">Math</span>.random();</span><br><span class="line">            <span class="built_in">this</span>.y = <span class="built_in">Math</span>.random();</span><br><span class="line">            <span class="built_in">this</span>.z = <span class="built_in">Math</span>.random();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">randomDirection</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// Derived from https://mathworld.wolfram.com/SpherePointPicking.html</span></span><br><span class="line">            <span class="keyword">const</span> u = (<span class="built_in">Math</span>.random() - <span class="number">0.5</span>) * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">const</span> t = <span class="built_in">Math</span>.random() * <span class="built_in">Math</span>.PI * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">const</span> f = <span class="built_in">Math</span>.sqrt(<span class="number">1</span> - u ** <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">this</span>.x = f * <span class="built_in">Math</span>.cos(t);</span><br><span class="line">            <span class="built_in">this</span>.y = f * <span class="built_in">Math</span>.sin(t);</span><br><span class="line">            <span class="built_in">this</span>.z = u;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="built_in">this</span>.x;</span><br><span class="line">            <span class="keyword">yield</span> <span class="built_in">this</span>.y;</span><br><span class="line">            <span class="keyword">yield</span> <span class="built_in">this</span>.z;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector3.prototype.isVector3 = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vector$c = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _quaternion$<span class="number">4</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Quaternion();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Box3</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">min = <span class="keyword">new</span> Vector3(+<span class="literal">Infinity</span>, +<span class="literal">Infinity</span>, +<span class="literal">Infinity</span>), max = <span class="keyword">new</span> Vector3(-<span class="literal">Infinity</span>, -<span class="literal">Infinity</span>, -<span class="literal">Infinity</span>)</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.min = min;</span><br><span class="line">            <span class="built_in">this</span>.max = max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">min, max</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.min.copy(min);</span><br><span class="line">            <span class="built_in">this</span>.max.copy(max);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromArray</span>(<span class="params">array</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> minX = +<span class="literal">Infinity</span>;</span><br><span class="line">            <span class="keyword">let</span> minY = +<span class="literal">Infinity</span>;</span><br><span class="line">            <span class="keyword">let</span> minZ = +<span class="literal">Infinity</span>;</span><br><span class="line">            <span class="keyword">let</span> maxX = -<span class="literal">Infinity</span>;</span><br><span class="line">            <span class="keyword">let</span> maxY = -<span class="literal">Infinity</span>;</span><br><span class="line">            <span class="keyword">let</span> maxZ = -<span class="literal">Infinity</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = array.length; i &lt; l; i += <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> x = array[i];</span><br><span class="line">                <span class="keyword">const</span> y = array[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">const</span> z = array[i + <span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span> (x &lt; minX) minX = x;</span><br><span class="line">                <span class="keyword">if</span> (y &lt; minY) minY = y;</span><br><span class="line">                <span class="keyword">if</span> (z &lt; minZ) minZ = z;</span><br><span class="line">                <span class="keyword">if</span> (x &gt; maxX) maxX = x;</span><br><span class="line">                <span class="keyword">if</span> (y &gt; maxY) maxY = y;</span><br><span class="line">                <span class="keyword">if</span> (z &gt; maxZ) maxZ = z;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.min.set(minX, minY, minZ);</span><br><span class="line">            <span class="built_in">this</span>.max.set(maxX, maxY, maxZ);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromBufferAttribute</span>(<span class="params">attribute</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> minX = +<span class="literal">Infinity</span>;</span><br><span class="line">            <span class="keyword">let</span> minY = +<span class="literal">Infinity</span>;</span><br><span class="line">            <span class="keyword">let</span> minZ = +<span class="literal">Infinity</span>;</span><br><span class="line">            <span class="keyword">let</span> maxX = -<span class="literal">Infinity</span>;</span><br><span class="line">            <span class="keyword">let</span> maxY = -<span class="literal">Infinity</span>;</span><br><span class="line">            <span class="keyword">let</span> maxZ = -<span class="literal">Infinity</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = attribute.count; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> x = attribute.getX(i);</span><br><span class="line">                <span class="keyword">const</span> y = attribute.getY(i);</span><br><span class="line">                <span class="keyword">const</span> z = attribute.getZ(i);</span><br><span class="line">                <span class="keyword">if</span> (x &lt; minX) minX = x;</span><br><span class="line">                <span class="keyword">if</span> (y &lt; minY) minY = y;</span><br><span class="line">                <span class="keyword">if</span> (z &lt; minZ) minZ = z;</span><br><span class="line">                <span class="keyword">if</span> (x &gt; maxX) maxX = x;</span><br><span class="line">                <span class="keyword">if</span> (y &gt; maxY) maxY = y;</span><br><span class="line">                <span class="keyword">if</span> (z &gt; maxZ) maxZ = z;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.min.set(minX, minY, minZ);</span><br><span class="line">            <span class="built_in">this</span>.max.set(maxX, maxY, maxZ);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromPoints</span>(<span class="params">points</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.makeEmpty();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = points.length; i &lt; il; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.expandByPoint(points[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromCenterAndSize</span>(<span class="params">center, size</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> halfSize = _vector$b.copy(size).multiplyScalar(<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.min.copy(center).sub(halfSize);</span><br><span class="line">            <span class="built_in">this</span>.max.copy(center).add(halfSize);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromObject</span>(<span class="params">object, precise = <span class="literal">false</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.makeEmpty();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.expandByObject(object, precise);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor().copy(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">box</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.min.copy(box.min);</span><br><span class="line">            <span class="built_in">this</span>.max.copy(box.max);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">makeEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.min.x = <span class="built_in">this</span>.min.y = <span class="built_in">this</span>.min.z = +<span class="literal">Infinity</span>;</span><br><span class="line">            <span class="built_in">this</span>.max.x = <span class="built_in">this</span>.max.y = <span class="built_in">this</span>.max.z = -<span class="literal">Infinity</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// this is a more robust check for empty than ( volume &lt;= 0 ) because volume can get positive with two negative axes</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.max.x &lt; <span class="built_in">this</span>.min.x || <span class="built_in">this</span>.max.y &lt; <span class="built_in">this</span>.min.y || <span class="built_in">this</span>.max.z &lt; <span class="built_in">this</span>.min.z;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getCenter</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.isEmpty() ? target.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) : target.addVectors(<span class="built_in">this</span>.min, <span class="built_in">this</span>.max).multiplyScalar(<span class="number">0.5</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getSize</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.isEmpty() ? target.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) : target.subVectors(<span class="built_in">this</span>.max, <span class="built_in">this</span>.min);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">expandByPoint</span>(<span class="params">point</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.min.min(point);</span><br><span class="line">            <span class="built_in">this</span>.max.max(point);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">expandByVector</span>(<span class="params">vector</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.min.sub(vector);</span><br><span class="line">            <span class="built_in">this</span>.max.add(vector);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">expandByScalar</span>(<span class="params">scalar</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.min.addScalar(-scalar);</span><br><span class="line">            <span class="built_in">this</span>.max.addScalar(scalar);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">expandByObject</span>(<span class="params">object, precise = <span class="literal">false</span></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// Computes the world-axis-aligned bounding box of an object (including its children),</span></span><br><span class="line">            <span class="comment">// accounting for both the object&#x27;s, and children&#x27;s, world transforms</span></span><br><span class="line">            object.updateWorldMatrix(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">const</span> geometry = object.geometry;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (geometry !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (precise &amp;&amp; geometry.attributes != <span class="literal">undefined</span> &amp;&amp; geometry.attributes.position !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> position = geometry.attributes.position;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = position.count; i &lt; l; i++) &#123;</span><br><span class="line">                        _vector$b.fromBufferAttribute(position, i).applyMatrix4(object.matrixWorld);</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">this</span>.expandByPoint(_vector$b);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (geometry.boundingBox === <span class="literal">null</span>) &#123;</span><br><span class="line">                        geometry.computeBoundingBox();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    _box$<span class="number">3.</span>copy(geometry.boundingBox);</span><br><span class="line"></span><br><span class="line">                    _box$<span class="number">3.</span>applyMatrix4(object.matrixWorld);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">this</span>.union(_box$<span class="number">3</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> children = object.children;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = children.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.expandByObject(children[i], precise);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">containsPoint</span>(<span class="params">point</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> point.x &lt; <span class="built_in">this</span>.min.x || point.x &gt; <span class="built_in">this</span>.max.x || point.y &lt; <span class="built_in">this</span>.min.y || point.y &gt; <span class="built_in">this</span>.max.y || point.z &lt; <span class="built_in">this</span>.min.z || point.z &gt; <span class="built_in">this</span>.max.z ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">containsBox</span>(<span class="params">box</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.min.x &lt;= box.min.x &amp;&amp; box.max.x &lt;= <span class="built_in">this</span>.max.x &amp;&amp; <span class="built_in">this</span>.min.y &lt;= box.min.y &amp;&amp; box.max.y &lt;= <span class="built_in">this</span>.max.y &amp;&amp; <span class="built_in">this</span>.min.z &lt;= box.min.z &amp;&amp; box.max.z &lt;= <span class="built_in">this</span>.max.z;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getParameter</span>(<span class="params">point, target</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// This can potentially have a divide by zero if the box</span></span><br><span class="line">            <span class="comment">// has a size dimension of 0.</span></span><br><span class="line">            <span class="keyword">return</span> target.set((point.x - <span class="built_in">this</span>.min.x) / (<span class="built_in">this</span>.max.x - <span class="built_in">this</span>.min.x), (point.y - <span class="built_in">this</span>.min.y) / (<span class="built_in">this</span>.max.y - <span class="built_in">this</span>.min.y), (point.z - <span class="built_in">this</span>.min.z) / (<span class="built_in">this</span>.max.z - <span class="built_in">this</span>.min.z));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectsBox</span>(<span class="params">box</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// using 6 splitting planes to rule out intersections.</span></span><br><span class="line">            <span class="keyword">return</span> box.max.x &lt; <span class="built_in">this</span>.min.x || box.min.x &gt; <span class="built_in">this</span>.max.x || box.max.y &lt; <span class="built_in">this</span>.min.y || box.min.y &gt; <span class="built_in">this</span>.max.y || box.max.z &lt; <span class="built_in">this</span>.min.z || box.min.z &gt; <span class="built_in">this</span>.max.z ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectsSphere</span>(<span class="params">sphere</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// Find the point on the AABB closest to the sphere center.</span></span><br><span class="line">            <span class="built_in">this</span>.clampPoint(sphere.center, _vector$b); <span class="comment">// If that point is inside the sphere, the AABB and sphere intersect.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> _vector$b.distanceToSquared(sphere.center) &lt;= sphere.radius * sphere.radius;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectsPlane</span>(<span class="params">plane</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// We compute the minimum and maximum dot product values. If those values</span></span><br><span class="line">            <span class="comment">// are on the same side (back or front) of the plane, then there is no intersection.</span></span><br><span class="line">            <span class="keyword">let</span> min, max;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (plane.normal.x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                min = plane.normal.x * <span class="built_in">this</span>.min.x;</span><br><span class="line">                max = plane.normal.x * <span class="built_in">this</span>.max.x;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                min = plane.normal.x * <span class="built_in">this</span>.max.x;</span><br><span class="line">                max = plane.normal.x * <span class="built_in">this</span>.min.x;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (plane.normal.y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                min += plane.normal.y * <span class="built_in">this</span>.min.y;</span><br><span class="line">                max += plane.normal.y * <span class="built_in">this</span>.max.y;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                min += plane.normal.y * <span class="built_in">this</span>.max.y;</span><br><span class="line">                max += plane.normal.y * <span class="built_in">this</span>.min.y;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (plane.normal.z &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                min += plane.normal.z * <span class="built_in">this</span>.min.z;</span><br><span class="line">                max += plane.normal.z * <span class="built_in">this</span>.max.z;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                min += plane.normal.z * <span class="built_in">this</span>.max.z;</span><br><span class="line">                max += plane.normal.z * <span class="built_in">this</span>.min.z;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> min &lt;= -plane.constant &amp;&amp; max &gt;= -plane.constant;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectsTriangle</span>(<span class="params">triangle</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="comment">// compute box center and extents</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.getCenter(_center);</span><br><span class="line"></span><br><span class="line">            _extents.subVectors(<span class="built_in">this</span>.max, _center); <span class="comment">// translate triangle to aabb origin</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            _v0$<span class="number">2.</span>subVectors(triangle.a, _center);</span><br><span class="line"></span><br><span class="line">            _v1$<span class="number">7.</span>subVectors(triangle.b, _center);</span><br><span class="line"></span><br><span class="line">            _v2$<span class="number">3.</span>subVectors(triangle.c, _center); <span class="comment">// compute edge vectors for triangle</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            _f0.subVectors(_v1$<span class="number">7</span>, _v0$<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            _f1.subVectors(_v2$<span class="number">3</span>, _v1$<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">            _f2.subVectors(_v0$<span class="number">2</span>, _v2$<span class="number">3</span>); <span class="comment">// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb</span></span><br><span class="line">            <span class="comment">// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation</span></span><br><span class="line">            <span class="comment">// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> axes = [<span class="number">0</span>, -_f0.z, _f0.y, <span class="number">0</span>, -_f1.z, _f1.y, <span class="number">0</span>, -_f2.z, _f2.y, _f0.z, <span class="number">0</span>, -_f0.x, _f1.z, <span class="number">0</span>, -_f1.x, _f2.z, <span class="number">0</span>, -_f2.x, -_f0.y, _f0.x, <span class="number">0</span>, -_f1.y, _f1.x, <span class="number">0</span>, -_f2.y, _f2.x, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!satForAxes(axes, _v0$<span class="number">2</span>, _v1$<span class="number">7</span>, _v2$<span class="number">3</span>, _extents)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="comment">// test 3 face normals from the aabb</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            axes = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!satForAxes(axes, _v0$<span class="number">2</span>, _v1$<span class="number">7</span>, _v2$<span class="number">3</span>, _extents)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="comment">// finally testing the face normal of the triangle</span></span><br><span class="line">            <span class="comment">// use already existing triangle edge vectors here</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            _triangleNormal.crossVectors(_f0, _f1);</span><br><span class="line"></span><br><span class="line">            axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];</span><br><span class="line">            <span class="keyword">return</span> satForAxes(axes, _v0$<span class="number">2</span>, _v1$<span class="number">7</span>, _v2$<span class="number">3</span>, _extents);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clampPoint</span>(<span class="params">point, target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> target.copy(point).clamp(<span class="built_in">this</span>.min, <span class="built_in">this</span>.max);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">distanceToPoint</span>(<span class="params">point</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> clampedPoint = _vector$b.copy(point).clamp(<span class="built_in">this</span>.min, <span class="built_in">this</span>.max);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> clampedPoint.sub(point).length();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getBoundingSphere</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.getCenter(target.center);</span><br><span class="line">            target.radius = <span class="built_in">this</span>.getSize(_vector$b).length() * <span class="number">0.5</span>;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersect</span>(<span class="params">box</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.min.max(box.min);</span><br><span class="line">            <span class="built_in">this</span>.max.min(box.max); <span class="comment">// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) <span class="built_in">this</span>.makeEmpty();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">union</span>(<span class="params">box</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.min.min(box.min);</span><br><span class="line">            <span class="built_in">this</span>.max.max(box.max);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">applyMatrix4</span>(<span class="params">matrix</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// transform of empty box is an empty box.</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) <span class="keyword">return</span> <span class="built_in">this</span>; <span class="comment">// <span class="doctag">NOTE:</span> I am using a binary pattern to specify all 2^3 combinations below</span></span><br><span class="line"></span><br><span class="line">            _points[<span class="number">0</span>].set(<span class="built_in">this</span>.min.x, <span class="built_in">this</span>.min.y, <span class="built_in">this</span>.min.z).applyMatrix4(matrix); <span class="comment">// 000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            _points[<span class="number">1</span>].set(<span class="built_in">this</span>.min.x, <span class="built_in">this</span>.min.y, <span class="built_in">this</span>.max.z).applyMatrix4(matrix); <span class="comment">// 001</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            _points[<span class="number">2</span>].set(<span class="built_in">this</span>.min.x, <span class="built_in">this</span>.max.y, <span class="built_in">this</span>.min.z).applyMatrix4(matrix); <span class="comment">// 010</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            _points[<span class="number">3</span>].set(<span class="built_in">this</span>.min.x, <span class="built_in">this</span>.max.y, <span class="built_in">this</span>.max.z).applyMatrix4(matrix); <span class="comment">// 011</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            _points[<span class="number">4</span>].set(<span class="built_in">this</span>.max.x, <span class="built_in">this</span>.min.y, <span class="built_in">this</span>.min.z).applyMatrix4(matrix); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            _points[<span class="number">5</span>].set(<span class="built_in">this</span>.max.x, <span class="built_in">this</span>.min.y, <span class="built_in">this</span>.max.z).applyMatrix4(matrix); <span class="comment">// 101</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            _points[<span class="number">6</span>].set(<span class="built_in">this</span>.max.x, <span class="built_in">this</span>.max.y, <span class="built_in">this</span>.min.z).applyMatrix4(matrix); <span class="comment">// 110</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            _points[<span class="number">7</span>].set(<span class="built_in">this</span>.max.x, <span class="built_in">this</span>.max.y, <span class="built_in">this</span>.max.z).applyMatrix4(matrix); <span class="comment">// 111</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setFromPoints(_points);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">translate</span>(<span class="params">offset</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.min.add(offset);</span><br><span class="line">            <span class="built_in">this</span>.max.add(offset);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">equals</span>(<span class="params">box</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> box.min.equals(<span class="built_in">this</span>.min) &amp;&amp; box.max.equals(<span class="built_in">this</span>.max);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Box3.prototype.isBox3 = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> _points = [<span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3(), <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3(), <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3(), <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3(), <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3(), <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3(), <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3(), <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3()];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vector$b = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _box$<span class="number">3</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Box3(); <span class="comment">// triangle centered vertices</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _v0$<span class="number">2</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _v1$<span class="number">7</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _v2$<span class="number">3</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3(); <span class="comment">// triangle edge vectors</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _f0 = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _f1 = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _f2 = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _center = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _extents = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _triangleNormal = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _testAxis = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">satForAxes</span>(<span class="params">axes, v0, v1, v2, extents</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = axes.length - <span class="number">3</span>; i &lt;= j; i += <span class="number">3</span>) &#123;</span><br><span class="line">            _testAxis.fromArray(axes, i); <span class="comment">// project the aabb onto the separating axis</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> r = extents.x * <span class="built_in">Math</span>.abs(_testAxis.x) + extents.y * <span class="built_in">Math</span>.abs(_testAxis.y) + extents.z * <span class="built_in">Math</span>.abs(_testAxis.z); <span class="comment">// project all 3 vertices of the triangle onto the separating axis</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> p0 = v0.dot(_testAxis);</span><br><span class="line">            <span class="keyword">const</span> p1 = v1.dot(_testAxis);</span><br><span class="line">            <span class="keyword">const</span> p2 = v2.dot(_testAxis); <span class="comment">// actual test, basically see if either of the most extreme of the triangle points intersects r</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Math</span>.max(-<span class="built_in">Math</span>.max(p0, p1, p2), <span class="built_in">Math</span>.min(p0, p1, p2)) &gt; r) &#123;</span><br><span class="line">                <span class="comment">// points of the projected triangle are outside the projected half-length of the aabb</span></span><br><span class="line">                <span class="comment">// the axis is separating and we can exit</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _box$<span class="number">2</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Box3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _v1$<span class="number">6</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _toFarthestPoint = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _toPoint = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Sphere</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">center = <span class="keyword">new</span> Vector3(), radius = -<span class="number">1</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.center = center;</span><br><span class="line">            <span class="built_in">this</span>.radius = radius;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">center, radius</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.center.copy(center);</span><br><span class="line">            <span class="built_in">this</span>.radius = radius;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromPoints</span>(<span class="params">points, optionalCenter</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> center = <span class="built_in">this</span>.center;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (optionalCenter !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                center.copy(optionalCenter);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _box$<span class="number">2.</span>setFromPoints(points).getCenter(center);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> maxRadiusSq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = points.length; i &lt; il; i++) &#123;</span><br><span class="line">                maxRadiusSq = <span class="built_in">Math</span>.max(maxRadiusSq, center.distanceToSquared(points[i]));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.radius = <span class="built_in">Math</span>.sqrt(maxRadiusSq);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">sphere</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.center.copy(sphere.center);</span><br><span class="line">            <span class="built_in">this</span>.radius = sphere.radius;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.radius &lt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">makeEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.center.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">this</span>.radius = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">containsPoint</span>(<span class="params">point</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> point.distanceToSquared(<span class="built_in">this</span>.center) &lt;= <span class="built_in">this</span>.radius * <span class="built_in">this</span>.radius;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">distanceToPoint</span>(<span class="params">point</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> point.distanceTo(<span class="built_in">this</span>.center) - <span class="built_in">this</span>.radius;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectsSphere</span>(<span class="params">sphere</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> radiusSum = <span class="built_in">this</span>.radius + sphere.radius;</span><br><span class="line">            <span class="keyword">return</span> sphere.center.distanceToSquared(<span class="built_in">this</span>.center) &lt;= radiusSum * radiusSum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectsBox</span>(<span class="params">box</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> box.intersectsSphere(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectsPlane</span>(<span class="params">plane</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.abs(plane.distanceToPoint(<span class="built_in">this</span>.center)) &lt;= <span class="built_in">this</span>.radius;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clampPoint</span>(<span class="params">point, target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> deltaLengthSq = <span class="built_in">this</span>.center.distanceToSquared(point);</span><br><span class="line">            target.copy(point);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (deltaLengthSq &gt; <span class="built_in">this</span>.radius * <span class="built_in">this</span>.radius) &#123;</span><br><span class="line">                target.sub(<span class="built_in">this</span>.center).normalize();</span><br><span class="line">                target.multiplyScalar(<span class="built_in">this</span>.radius).add(<span class="built_in">this</span>.center);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getBoundingBox</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// Empty sphere produces empty bounding box</span></span><br><span class="line">                target.makeEmpty();</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            target.set(<span class="built_in">this</span>.center, <span class="built_in">this</span>.center);</span><br><span class="line">            target.expandByScalar(<span class="built_in">this</span>.radius);</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">applyMatrix4</span>(<span class="params">matrix</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.center.applyMatrix4(matrix);</span><br><span class="line">            <span class="built_in">this</span>.radius = <span class="built_in">this</span>.radius * matrix.getMaxScaleOnAxis();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">translate</span>(<span class="params">offset</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.center.add(offset);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">expandByPoint</span>(<span class="params">point</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671</span></span><br><span class="line">            _toPoint.subVectors(point, <span class="built_in">this</span>.center);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> lengthSq = _toPoint.lengthSq();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (lengthSq &gt; <span class="built_in">this</span>.radius * <span class="built_in">this</span>.radius) &#123;</span><br><span class="line">                <span class="keyword">const</span> length = <span class="built_in">Math</span>.sqrt(lengthSq);</span><br><span class="line">                <span class="keyword">const</span> missingRadiusHalf = (length - <span class="built_in">this</span>.radius) * <span class="number">0.5</span>; <span class="comment">// Nudge this sphere towards the target point. Add half the missing distance to radius,</span></span><br><span class="line">                <span class="comment">// and the other half to position. This gives a tighter enclosure, instead of if</span></span><br><span class="line">                <span class="comment">// the whole missing distance were just added to radius.</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));</span><br><span class="line">                <span class="built_in">this</span>.radius += missingRadiusHalf;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">union</span>(<span class="params">sphere</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769</span></span><br><span class="line">            <span class="comment">// To enclose another sphere into this sphere, we only need to enclose two points:</span></span><br><span class="line">            <span class="comment">// 1) Enclose the farthest point on the other sphere into this sphere.</span></span><br><span class="line">            <span class="comment">// 2) Enclose the opposite point of the farthest point into this sphere.</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.center.equals(sphere.center) === <span class="literal">true</span>) &#123;</span><br><span class="line">                _toFarthestPoint.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>).multiplyScalar(sphere.radius);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _toFarthestPoint.subVectors(sphere.center, <span class="built_in">this</span>.center).normalize().multiplyScalar(sphere.radius);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.expandByPoint(_v1$<span class="number">6.</span>copy(sphere.center).add(_toFarthestPoint));</span><br><span class="line">            <span class="built_in">this</span>.expandByPoint(_v1$<span class="number">6.</span>copy(sphere.center).sub(_toFarthestPoint));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">equals</span>(<span class="params">sphere</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sphere.center.equals(<span class="built_in">this</span>.center) &amp;&amp; sphere.radius === <span class="built_in">this</span>.radius;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor().copy(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vector$a = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _segCenter = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _segDir = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _diff = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _edge1 = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _edge2 = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _normal$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Ray</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">origin = <span class="keyword">new</span> Vector3(), direction = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>)</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.origin = origin;</span><br><span class="line">            <span class="built_in">this</span>.direction = direction;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">origin, direction</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.origin.copy(origin);</span><br><span class="line">            <span class="built_in">this</span>.direction.copy(direction);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">ray</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.origin.copy(ray.origin);</span><br><span class="line">            <span class="built_in">this</span>.direction.copy(ray.direction);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">at</span>(<span class="params">t, target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> target.copy(<span class="built_in">this</span>.direction).multiplyScalar(t).add(<span class="built_in">this</span>.origin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">lookAt</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.direction.copy(v).sub(<span class="built_in">this</span>.origin).normalize();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">recast</span>(<span class="params">t</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.origin.copy(<span class="built_in">this</span>.at(t, _vector$a));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">closestPointToPoint</span>(<span class="params">point, target</span>)</span> &#123;</span><br><span class="line">            target.subVectors(point, <span class="built_in">this</span>.origin);</span><br><span class="line">            <span class="keyword">const</span> directionDistance = target.dot(<span class="built_in">this</span>.direction);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (directionDistance &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> target.copy(<span class="built_in">this</span>.origin);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> target.copy(<span class="built_in">this</span>.direction).multiplyScalar(directionDistance).add(<span class="built_in">this</span>.origin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">distanceToPoint</span>(<span class="params">point</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="built_in">this</span>.distanceSqToPoint(point));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">distanceSqToPoint</span>(<span class="params">point</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> directionDistance = _vector$a.subVectors(point, <span class="built_in">this</span>.origin).dot(<span class="built_in">this</span>.direction); <span class="comment">// point behind the ray</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (directionDistance &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.origin.distanceToSquared(point);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _vector$a.copy(<span class="built_in">this</span>.direction).multiplyScalar(directionDistance).add(<span class="built_in">this</span>.origin);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> _vector$a.distanceToSquared(point);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">distanceSqToSegment</span>(<span class="params">v0, v1, optionalPointOnRay, optionalPointOnSegment</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h</span></span><br><span class="line">            <span class="comment">// It returns the min distance between the ray and the segment</span></span><br><span class="line">            <span class="comment">// defined by v0 and v1</span></span><br><span class="line">            <span class="comment">// It can also set two optional targets :</span></span><br><span class="line">            <span class="comment">// - The closest point on the ray</span></span><br><span class="line">            <span class="comment">// - The closest point on the segment</span></span><br><span class="line">            _segCenter.copy(v0).add(v1).multiplyScalar(<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">            _segDir.copy(v1).sub(v0).normalize();</span><br><span class="line"></span><br><span class="line">            _diff.copy(<span class="built_in">this</span>.origin).sub(_segCenter);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> segExtent = v0.distanceTo(v1) * <span class="number">0.5</span>;</span><br><span class="line">            <span class="keyword">const</span> a01 = -<span class="built_in">this</span>.direction.dot(_segDir);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> b0 = _diff.dot(<span class="built_in">this</span>.direction);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> b1 = -_diff.dot(_segDir);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> c = _diff.lengthSq();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> det = <span class="built_in">Math</span>.abs(<span class="number">1</span> - a01 * a01);</span><br><span class="line">            <span class="keyword">let</span> s0, s1, sqrDist, extDet;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (det &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// The ray and segment are not parallel.</span></span><br><span class="line">                s0 = a01 * b1 - b0;</span><br><span class="line">                s1 = a01 * b0 - b1;</span><br><span class="line">                extDet = segExtent * det;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (s0 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s1 &gt;= -extDet) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (s1 &lt;= extDet) &#123;</span><br><span class="line">                            <span class="comment">// region 0</span></span><br><span class="line">                            <span class="comment">// Minimum at interior points of ray and segment.</span></span><br><span class="line">                            <span class="keyword">const</span> invDet = <span class="number">1</span> / det;</span><br><span class="line">                            s0 *= invDet;</span><br><span class="line">                            s1 *= invDet;</span><br><span class="line">                            sqrDist = s0 * (s0 + a01 * s1 + <span class="number">2</span> * b0) + s1 * (a01 * s0 + s1 + <span class="number">2</span> * b1) + c;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// region 1</span></span><br><span class="line">                            s1 = segExtent;</span><br><span class="line">                            s0 = <span class="built_in">Math</span>.max(<span class="number">0</span>, -(a01 * s1 + b0));</span><br><span class="line">                            sqrDist = -s0 * s0 + s1 * (s1 + <span class="number">2</span> * b1) + c;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// region 5</span></span><br><span class="line">                        s1 = -segExtent;</span><br><span class="line">                        s0 = <span class="built_in">Math</span>.max(<span class="number">0</span>, -(a01 * s1 + b0));</span><br><span class="line">                        sqrDist = -s0 * s0 + s1 * (s1 + <span class="number">2</span> * b1) + c;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s1 &lt;= -extDet) &#123;</span><br><span class="line">                        <span class="comment">// region 4</span></span><br><span class="line">                        s0 = <span class="built_in">Math</span>.max(<span class="number">0</span>, -(-a01 * segExtent + b0));</span><br><span class="line">                        s1 = s0 &gt; <span class="number">0</span> ? -segExtent : <span class="built_in">Math</span>.min(<span class="built_in">Math</span>.max(-segExtent, -b1), segExtent);</span><br><span class="line">                        sqrDist = -s0 * s0 + s1 * (s1 + <span class="number">2</span> * b1) + c;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s1 &lt;= extDet) &#123;</span><br><span class="line">                        <span class="comment">// region 3</span></span><br><span class="line">                        s0 = <span class="number">0</span>;</span><br><span class="line">                        s1 = <span class="built_in">Math</span>.min(<span class="built_in">Math</span>.max(-segExtent, -b1), segExtent);</span><br><span class="line">                        sqrDist = s1 * (s1 + <span class="number">2</span> * b1) + c;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// region 2</span></span><br><span class="line">                        s0 = <span class="built_in">Math</span>.max(<span class="number">0</span>, -(a01 * segExtent + b0));</span><br><span class="line">                        s1 = s0 &gt; <span class="number">0</span> ? segExtent : <span class="built_in">Math</span>.min(<span class="built_in">Math</span>.max(-segExtent, -b1), segExtent);</span><br><span class="line">                        sqrDist = -s0 * s0 + s1 * (s1 + <span class="number">2</span> * b1) + c;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Ray and segment are parallel.</span></span><br><span class="line">                s1 = a01 &gt; <span class="number">0</span> ? -segExtent : segExtent;</span><br><span class="line">                s0 = <span class="built_in">Math</span>.max(<span class="number">0</span>, -(a01 * s1 + b0));</span><br><span class="line">                sqrDist = -s0 * s0 + s1 * (s1 + <span class="number">2</span> * b1) + c;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (optionalPointOnRay) &#123;</span><br><span class="line">                optionalPointOnRay.copy(<span class="built_in">this</span>.direction).multiplyScalar(s0).add(<span class="built_in">this</span>.origin);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (optionalPointOnSegment) &#123;</span><br><span class="line">                optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> sqrDist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectSphere</span>(<span class="params">sphere, target</span>)</span> &#123;</span><br><span class="line">            _vector$a.subVectors(sphere.center, <span class="built_in">this</span>.origin);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> tca = _vector$a.dot(<span class="built_in">this</span>.direction);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> d2 = _vector$a.dot(_vector$a) - tca * tca;</span><br><span class="line">            <span class="keyword">const</span> radius2 = sphere.radius * sphere.radius;</span><br><span class="line">            <span class="keyword">if</span> (d2 &gt; radius2) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">const</span> thc = <span class="built_in">Math</span>.sqrt(radius2 - d2); <span class="comment">// t0 = first intersect point - entrance on front of sphere</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> t0 = tca - thc; <span class="comment">// t1 = second intersect point - exit point on back of sphere</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> t1 = tca + thc; <span class="comment">// test to see if both t0 and t1 are behind the ray - if so, return null</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t0 &lt; <span class="number">0</span> &amp;&amp; t1 &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// test to see if t0 is behind the ray:</span></span><br><span class="line">            <span class="comment">// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,</span></span><br><span class="line">            <span class="comment">// in order to always return an intersect point that is in front of the ray.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t0 &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">this</span>.at(t1, target); <span class="comment">// else t0 is in front of the ray, so return the first collision point scaled by t0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.at(t0, target);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectsSphere</span>(<span class="params">sphere</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.distanceSqToPoint(sphere.center) &lt;= sphere.radius * sphere.radius;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">distanceToPlane</span>(<span class="params">plane</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> denominator = plane.normal.dot(<span class="built_in">this</span>.direction);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (denominator === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// line is coplanar, return origin</span></span><br><span class="line">                <span class="keyword">if</span> (plane.distanceToPoint(<span class="built_in">this</span>.origin) === <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="comment">// Null is preferable to undefined since undefined means.... it is undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> t = -(<span class="built_in">this</span>.origin.dot(plane.normal) + plane.constant) / denominator; <span class="comment">// Return if the ray never intersects the plane</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> t &gt;= <span class="number">0</span> ? t : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectPlane</span>(<span class="params">plane, target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> t = <span class="built_in">this</span>.distanceToPlane(plane);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.at(t, target);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectsPlane</span>(<span class="params">plane</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// check if the ray lies on the plane first</span></span><br><span class="line">            <span class="keyword">const</span> distToPoint = plane.distanceToPoint(<span class="built_in">this</span>.origin);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (distToPoint === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> denominator = plane.normal.dot(<span class="built_in">this</span>.direction);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (denominator * distToPoint &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="comment">// ray origin is behind the plane (and is pointing behind it)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectBox</span>(<span class="params">box, target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> tmin, tmax, tymin, tymax, tzmin, tzmax;</span><br><span class="line">            <span class="keyword">const</span> invdirx = <span class="number">1</span> / <span class="built_in">this</span>.direction.x,</span><br><span class="line">                invdiry = <span class="number">1</span> / <span class="built_in">this</span>.direction.y,</span><br><span class="line">                invdirz = <span class="number">1</span> / <span class="built_in">this</span>.direction.z;</span><br><span class="line">            <span class="keyword">const</span> origin = <span class="built_in">this</span>.origin;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (invdirx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                tmin = (box.min.x - origin.x) * invdirx;</span><br><span class="line">                tmax = (box.max.x - origin.x) * invdirx;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmin = (box.max.x - origin.x) * invdirx;</span><br><span class="line">                tmax = (box.min.x - origin.x) * invdirx;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (invdiry &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                tymin = (box.min.y - origin.y) * invdiry;</span><br><span class="line">                tymax = (box.max.y - origin.y) * invdiry;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tymin = (box.max.y - origin.y) * invdiry;</span><br><span class="line">                tymax = (box.min.y - origin.y) * invdiry;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmin &gt; tymax || tymin &gt; tmax) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// These lines also handle the case where tmin or tmax is NaN</span></span><br><span class="line">            <span class="comment">// (result of 0 * Infinity). x !== x returns true if x is NaN</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tymin &gt; tmin || tmin !== tmin) tmin = tymin;</span><br><span class="line">            <span class="keyword">if</span> (tymax &lt; tmax || tmax !== tmax) tmax = tymax;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (invdirz &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                tzmin = (box.min.z - origin.z) * invdirz;</span><br><span class="line">                tzmax = (box.max.z - origin.z) * invdirz;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tzmin = (box.max.z - origin.z) * invdirz;</span><br><span class="line">                tzmax = (box.min.z - origin.z) * invdirz;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmin &gt; tzmax || tzmin &gt; tmax) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (tzmin &gt; tmin || tmin !== tmin) tmin = tzmin;</span><br><span class="line">            <span class="keyword">if</span> (tzmax &lt; tmax || tmax !== tmax) tmax = tzmax; <span class="comment">//return point closest to the ray (positive side)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmax &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.at(tmin &gt;= <span class="number">0</span> ? tmin : tmax, target);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectsBox</span>(<span class="params">box</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.intersectBox(box, _vector$a) !== <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectTriangle</span>(<span class="params">a, b, c, backfaceCulling, target</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// Compute the offset origin, edges, and normal.</span></span><br><span class="line">            <span class="comment">// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h</span></span><br><span class="line">            _edge1.subVectors(b, a);</span><br><span class="line"></span><br><span class="line">            _edge2.subVectors(c, a);</span><br><span class="line"></span><br><span class="line">            _normal$<span class="number">1.</span>crossVectors(_edge1, _edge2); <span class="comment">// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,</span></span><br><span class="line">            <span class="comment">// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by</span></span><br><span class="line">            <span class="comment">//	 |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))</span></span><br><span class="line">            <span class="comment">//	 |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))</span></span><br><span class="line">            <span class="comment">//	 |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> DdN = <span class="built_in">this</span>.direction.dot(_normal$<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">let</span> sign;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DdN &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (backfaceCulling) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DdN &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                sign = -<span class="number">1</span>;</span><br><span class="line">                DdN = -DdN;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _diff.subVectors(<span class="built_in">this</span>.origin, a);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> DdQxE2 = sign * <span class="built_in">this</span>.direction.dot(_edge2.crossVectors(_diff, _edge2)); <span class="comment">// b1 &lt; 0, no intersection</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DdQxE2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> DdE1xQ = sign * <span class="built_in">this</span>.direction.dot(_edge1.cross(_diff)); <span class="comment">// b2 &lt; 0, no intersection</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DdE1xQ &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="comment">// b1+b2 &gt; 1, no intersection</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DdQxE2 + DdE1xQ &gt; DdN) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="comment">// Line intersects triangle, check if ray does.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> QdN = -sign * _diff.dot(_normal$<span class="number">1</span>); <span class="comment">// t &lt; 0, no intersection</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (QdN &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="comment">// Ray intersects triangle.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.at(QdN / DdN, target);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">applyMatrix4</span>(<span class="params">matrix4</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.origin.applyMatrix4(matrix4);</span><br><span class="line">            <span class="built_in">this</span>.direction.transformDirection(matrix4);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">equals</span>(<span class="params">ray</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ray.origin.equals(<span class="built_in">this</span>.origin) &amp;&amp; ray.direction.equals(<span class="built_in">this</span>.direction);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor().copy(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Matrix4</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.elements = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            te[<span class="number">0</span>] = n11;</span><br><span class="line">            te[<span class="number">4</span>] = n12;</span><br><span class="line">            te[<span class="number">8</span>] = n13;</span><br><span class="line">            te[<span class="number">12</span>] = n14;</span><br><span class="line">            te[<span class="number">1</span>] = n21;</span><br><span class="line">            te[<span class="number">5</span>] = n22;</span><br><span class="line">            te[<span class="number">9</span>] = n23;</span><br><span class="line">            te[<span class="number">13</span>] = n24;</span><br><span class="line">            te[<span class="number">2</span>] = n31;</span><br><span class="line">            te[<span class="number">6</span>] = n32;</span><br><span class="line">            te[<span class="number">10</span>] = n33;</span><br><span class="line">            te[<span class="number">14</span>] = n34;</span><br><span class="line">            te[<span class="number">3</span>] = n41;</span><br><span class="line">            te[<span class="number">7</span>] = n42;</span><br><span class="line">            te[<span class="number">11</span>] = n43;</span><br><span class="line">            te[<span class="number">15</span>] = n44;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">identity</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.set(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Matrix4().fromArray(<span class="built_in">this</span>.elements);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            <span class="keyword">const</span> me = m.elements;</span><br><span class="line">            te[<span class="number">0</span>] = me[<span class="number">0</span>];</span><br><span class="line">            te[<span class="number">1</span>] = me[<span class="number">1</span>];</span><br><span class="line">            te[<span class="number">2</span>] = me[<span class="number">2</span>];</span><br><span class="line">            te[<span class="number">3</span>] = me[<span class="number">3</span>];</span><br><span class="line">            te[<span class="number">4</span>] = me[<span class="number">4</span>];</span><br><span class="line">            te[<span class="number">5</span>] = me[<span class="number">5</span>];</span><br><span class="line">            te[<span class="number">6</span>] = me[<span class="number">6</span>];</span><br><span class="line">            te[<span class="number">7</span>] = me[<span class="number">7</span>];</span><br><span class="line">            te[<span class="number">8</span>] = me[<span class="number">8</span>];</span><br><span class="line">            te[<span class="number">9</span>] = me[<span class="number">9</span>];</span><br><span class="line">            te[<span class="number">10</span>] = me[<span class="number">10</span>];</span><br><span class="line">            te[<span class="number">11</span>] = me[<span class="number">11</span>];</span><br><span class="line">            te[<span class="number">12</span>] = me[<span class="number">12</span>];</span><br><span class="line">            te[<span class="number">13</span>] = me[<span class="number">13</span>];</span><br><span class="line">            te[<span class="number">14</span>] = me[<span class="number">14</span>];</span><br><span class="line">            te[<span class="number">15</span>] = me[<span class="number">15</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copyPosition</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements,</span><br><span class="line">                me = m.elements;</span><br><span class="line">            te[<span class="number">12</span>] = me[<span class="number">12</span>];</span><br><span class="line">            te[<span class="number">13</span>] = me[<span class="number">13</span>];</span><br><span class="line">            te[<span class="number">14</span>] = me[<span class="number">14</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromMatrix3</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> me = m.elements;</span><br><span class="line">            <span class="built_in">this</span>.set(me[<span class="number">0</span>], me[<span class="number">3</span>], me[<span class="number">6</span>], <span class="number">0</span>, me[<span class="number">1</span>], me[<span class="number">4</span>], me[<span class="number">7</span>], <span class="number">0</span>, me[<span class="number">2</span>], me[<span class="number">5</span>], me[<span class="number">8</span>], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">extractBasis</span>(<span class="params">xAxis, yAxis, zAxis</span>)</span> &#123;</span><br><span class="line">            xAxis.setFromMatrixColumn(<span class="built_in">this</span>, <span class="number">0</span>);</span><br><span class="line">            yAxis.setFromMatrixColumn(<span class="built_in">this</span>, <span class="number">1</span>);</span><br><span class="line">            zAxis.setFromMatrixColumn(<span class="built_in">this</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">makeBasis</span>(<span class="params">xAxis, yAxis, zAxis</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.set(xAxis.x, yAxis.x, zAxis.x, <span class="number">0</span>, xAxis.y, yAxis.y, zAxis.y, <span class="number">0</span>, xAxis.z, yAxis.z, zAxis.z, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">extractRotation</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// this method does not support reflection matrices</span></span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            <span class="keyword">const</span> me = m.elements;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> scaleX = <span class="number">1</span> / _v1$<span class="number">5.</span>setFromMatrixColumn(m, <span class="number">0</span>).length();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> scaleY = <span class="number">1</span> / _v1$<span class="number">5.</span>setFromMatrixColumn(m, <span class="number">1</span>).length();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> scaleZ = <span class="number">1</span> / _v1$<span class="number">5.</span>setFromMatrixColumn(m, <span class="number">2</span>).length();</span><br><span class="line"></span><br><span class="line">            te[<span class="number">0</span>] = me[<span class="number">0</span>] * scaleX;</span><br><span class="line">            te[<span class="number">1</span>] = me[<span class="number">1</span>] * scaleX;</span><br><span class="line">            te[<span class="number">2</span>] = me[<span class="number">2</span>] * scaleX;</span><br><span class="line">            te[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">4</span>] = me[<span class="number">4</span>] * scaleY;</span><br><span class="line">            te[<span class="number">5</span>] = me[<span class="number">5</span>] * scaleY;</span><br><span class="line">            te[<span class="number">6</span>] = me[<span class="number">6</span>] * scaleY;</span><br><span class="line">            te[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">8</span>] = me[<span class="number">8</span>] * scaleZ;</span><br><span class="line">            te[<span class="number">9</span>] = me[<span class="number">9</span>] * scaleZ;</span><br><span class="line">            te[<span class="number">10</span>] = me[<span class="number">10</span>] * scaleZ;</span><br><span class="line">            te[<span class="number">11</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">12</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">13</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">14</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">15</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">makeRotationFromEuler</span>(<span class="params">euler</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(euler &amp;&amp; euler.isEuler)) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            <span class="keyword">const</span> x = euler.x,</span><br><span class="line">                y = euler.y,</span><br><span class="line">                z = euler.z;</span><br><span class="line">            <span class="keyword">const</span> a = <span class="built_in">Math</span>.cos(x),</span><br><span class="line">                b = <span class="built_in">Math</span>.sin(x);</span><br><span class="line">            <span class="keyword">const</span> c = <span class="built_in">Math</span>.cos(y),</span><br><span class="line">                d = <span class="built_in">Math</span>.sin(y);</span><br><span class="line">            <span class="keyword">const</span> e = <span class="built_in">Math</span>.cos(z),</span><br><span class="line">                f = <span class="built_in">Math</span>.sin(z);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (euler.order === <span class="string">&#x27;XYZ&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> ae = a * e,</span><br><span class="line">                    af = a * f,</span><br><span class="line">                    be = b * e,</span><br><span class="line">                    bf = b * f;</span><br><span class="line">                te[<span class="number">0</span>] = c * e;</span><br><span class="line">                te[<span class="number">4</span>] = -c * f;</span><br><span class="line">                te[<span class="number">8</span>] = d;</span><br><span class="line">                te[<span class="number">1</span>] = af + be * d;</span><br><span class="line">                te[<span class="number">5</span>] = ae - bf * d;</span><br><span class="line">                te[<span class="number">9</span>] = -b * c;</span><br><span class="line">                te[<span class="number">2</span>] = bf - ae * d;</span><br><span class="line">                te[<span class="number">6</span>] = be + af * d;</span><br><span class="line">                te[<span class="number">10</span>] = a * c;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (euler.order === <span class="string">&#x27;YXZ&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> ce = c * e,</span><br><span class="line">                    cf = c * f,</span><br><span class="line">                    de = d * e,</span><br><span class="line">                    df = d * f;</span><br><span class="line">                te[<span class="number">0</span>] = ce + df * b;</span><br><span class="line">                te[<span class="number">4</span>] = de * b - cf;</span><br><span class="line">                te[<span class="number">8</span>] = a * d;</span><br><span class="line">                te[<span class="number">1</span>] = a * f;</span><br><span class="line">                te[<span class="number">5</span>] = a * e;</span><br><span class="line">                te[<span class="number">9</span>] = -b;</span><br><span class="line">                te[<span class="number">2</span>] = cf * b - de;</span><br><span class="line">                te[<span class="number">6</span>] = df + ce * b;</span><br><span class="line">                te[<span class="number">10</span>] = a * c;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (euler.order === <span class="string">&#x27;ZXY&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> ce = c * e,</span><br><span class="line">                    cf = c * f,</span><br><span class="line">                    de = d * e,</span><br><span class="line">                    df = d * f;</span><br><span class="line">                te[<span class="number">0</span>] = ce - df * b;</span><br><span class="line">                te[<span class="number">4</span>] = -a * f;</span><br><span class="line">                te[<span class="number">8</span>] = de + cf * b;</span><br><span class="line">                te[<span class="number">1</span>] = cf + de * b;</span><br><span class="line">                te[<span class="number">5</span>] = a * e;</span><br><span class="line">                te[<span class="number">9</span>] = df - ce * b;</span><br><span class="line">                te[<span class="number">2</span>] = -a * d;</span><br><span class="line">                te[<span class="number">6</span>] = b;</span><br><span class="line">                te[<span class="number">10</span>] = a * c;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (euler.order === <span class="string">&#x27;ZYX&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> ae = a * e,</span><br><span class="line">                    af = a * f,</span><br><span class="line">                    be = b * e,</span><br><span class="line">                    bf = b * f;</span><br><span class="line">                te[<span class="number">0</span>] = c * e;</span><br><span class="line">                te[<span class="number">4</span>] = be * d - af;</span><br><span class="line">                te[<span class="number">8</span>] = ae * d + bf;</span><br><span class="line">                te[<span class="number">1</span>] = c * f;</span><br><span class="line">                te[<span class="number">5</span>] = bf * d + ae;</span><br><span class="line">                te[<span class="number">9</span>] = af * d - be;</span><br><span class="line">                te[<span class="number">2</span>] = -d;</span><br><span class="line">                te[<span class="number">6</span>] = b * c;</span><br><span class="line">                te[<span class="number">10</span>] = a * c;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (euler.order === <span class="string">&#x27;YZX&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> ac = a * c,</span><br><span class="line">                    ad = a * d,</span><br><span class="line">                    bc = b * c,</span><br><span class="line">                    bd = b * d;</span><br><span class="line">                te[<span class="number">0</span>] = c * e;</span><br><span class="line">                te[<span class="number">4</span>] = bd - ac * f;</span><br><span class="line">                te[<span class="number">8</span>] = bc * f + ad;</span><br><span class="line">                te[<span class="number">1</span>] = f;</span><br><span class="line">                te[<span class="number">5</span>] = a * e;</span><br><span class="line">                te[<span class="number">9</span>] = -b * e;</span><br><span class="line">                te[<span class="number">2</span>] = -d * e;</span><br><span class="line">                te[<span class="number">6</span>] = ad * f + bc;</span><br><span class="line">                te[<span class="number">10</span>] = ac - bd * f;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (euler.order === <span class="string">&#x27;XZY&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> ac = a * c,</span><br><span class="line">                    ad = a * d,</span><br><span class="line">                    bc = b * c,</span><br><span class="line">                    bd = b * d;</span><br><span class="line">                te[<span class="number">0</span>] = c * e;</span><br><span class="line">                te[<span class="number">4</span>] = -f;</span><br><span class="line">                te[<span class="number">8</span>] = d * e;</span><br><span class="line">                te[<span class="number">1</span>] = ac * f + bd;</span><br><span class="line">                te[<span class="number">5</span>] = a * e;</span><br><span class="line">                te[<span class="number">9</span>] = ad * f - bc;</span><br><span class="line">                te[<span class="number">2</span>] = bc * f - ad;</span><br><span class="line">                te[<span class="number">6</span>] = b * e;</span><br><span class="line">                te[<span class="number">10</span>] = bd * f + ac;</span><br><span class="line">            &#125; <span class="comment">// bottom row</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            te[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">11</span>] = <span class="number">0</span>; <span class="comment">// last column</span></span><br><span class="line"></span><br><span class="line">            te[<span class="number">12</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">13</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">14</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">15</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">makeRotationFromQuaternion</span>(<span class="params">q</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.compose(_zero, q, _one);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">lookAt</span>(<span class="params">eye, target, up</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line"></span><br><span class="line">            _z.subVectors(eye, target);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_z.lengthSq() === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// eye and target are in the same position</span></span><br><span class="line">                _z.z = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _z.normalize();</span><br><span class="line"></span><br><span class="line">            _x.crossVectors(up, _z);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_x.lengthSq() === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// up and z are parallel</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(up.z) === <span class="number">1</span>) &#123;</span><br><span class="line">                    _z.x += <span class="number">0.0001</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    _z.z += <span class="number">0.0001</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                _z.normalize();</span><br><span class="line"></span><br><span class="line">                _x.crossVectors(up, _z);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _x.normalize();</span><br><span class="line"></span><br><span class="line">            _y.crossVectors(_z, _x);</span><br><span class="line"></span><br><span class="line">            te[<span class="number">0</span>] = _x.x;</span><br><span class="line">            te[<span class="number">4</span>] = _y.x;</span><br><span class="line">            te[<span class="number">8</span>] = _z.x;</span><br><span class="line">            te[<span class="number">1</span>] = _x.y;</span><br><span class="line">            te[<span class="number">5</span>] = _y.y;</span><br><span class="line">            te[<span class="number">9</span>] = _z.y;</span><br><span class="line">            te[<span class="number">2</span>] = _x.z;</span><br><span class="line">            te[<span class="number">6</span>] = _y.z;</span><br><span class="line">            te[<span class="number">10</span>] = _z.z;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">multiply</span>(<span class="params">m, n</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (n !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.multiplyMatrices(m, n);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.multiplyMatrices(<span class="built_in">this</span>, m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">premultiply</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.multiplyMatrices(m, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">multiplyMatrices</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> ae = a.elements;</span><br><span class="line">            <span class="keyword">const</span> be = b.elements;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            <span class="keyword">const</span> a11 = ae[<span class="number">0</span>],</span><br><span class="line">                a12 = ae[<span class="number">4</span>],</span><br><span class="line">                a13 = ae[<span class="number">8</span>],</span><br><span class="line">                a14 = ae[<span class="number">12</span>];</span><br><span class="line">            <span class="keyword">const</span> a21 = ae[<span class="number">1</span>],</span><br><span class="line">                a22 = ae[<span class="number">5</span>],</span><br><span class="line">                a23 = ae[<span class="number">9</span>],</span><br><span class="line">                a24 = ae[<span class="number">13</span>];</span><br><span class="line">            <span class="keyword">const</span> a31 = ae[<span class="number">2</span>],</span><br><span class="line">                a32 = ae[<span class="number">6</span>],</span><br><span class="line">                a33 = ae[<span class="number">10</span>],</span><br><span class="line">                a34 = ae[<span class="number">14</span>];</span><br><span class="line">            <span class="keyword">const</span> a41 = ae[<span class="number">3</span>],</span><br><span class="line">                a42 = ae[<span class="number">7</span>],</span><br><span class="line">                a43 = ae[<span class="number">11</span>],</span><br><span class="line">                a44 = ae[<span class="number">15</span>];</span><br><span class="line">            <span class="keyword">const</span> b11 = be[<span class="number">0</span>],</span><br><span class="line">                b12 = be[<span class="number">4</span>],</span><br><span class="line">                b13 = be[<span class="number">8</span>],</span><br><span class="line">                b14 = be[<span class="number">12</span>];</span><br><span class="line">            <span class="keyword">const</span> b21 = be[<span class="number">1</span>],</span><br><span class="line">                b22 = be[<span class="number">5</span>],</span><br><span class="line">                b23 = be[<span class="number">9</span>],</span><br><span class="line">                b24 = be[<span class="number">13</span>];</span><br><span class="line">            <span class="keyword">const</span> b31 = be[<span class="number">2</span>],</span><br><span class="line">                b32 = be[<span class="number">6</span>],</span><br><span class="line">                b33 = be[<span class="number">10</span>],</span><br><span class="line">                b34 = be[<span class="number">14</span>];</span><br><span class="line">            <span class="keyword">const</span> b41 = be[<span class="number">3</span>],</span><br><span class="line">                b42 = be[<span class="number">7</span>],</span><br><span class="line">                b43 = be[<span class="number">11</span>],</span><br><span class="line">                b44 = be[<span class="number">15</span>];</span><br><span class="line">            te[<span class="number">0</span>] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;</span><br><span class="line">            te[<span class="number">4</span>] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;</span><br><span class="line">            te[<span class="number">8</span>] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;</span><br><span class="line">            te[<span class="number">12</span>] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;</span><br><span class="line">            te[<span class="number">1</span>] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;</span><br><span class="line">            te[<span class="number">5</span>] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;</span><br><span class="line">            te[<span class="number">9</span>] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;</span><br><span class="line">            te[<span class="number">13</span>] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;</span><br><span class="line">            te[<span class="number">2</span>] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;</span><br><span class="line">            te[<span class="number">6</span>] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;</span><br><span class="line">            te[<span class="number">10</span>] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;</span><br><span class="line">            te[<span class="number">14</span>] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;</span><br><span class="line">            te[<span class="number">3</span>] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;</span><br><span class="line">            te[<span class="number">7</span>] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;</span><br><span class="line">            te[<span class="number">11</span>] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;</span><br><span class="line">            te[<span class="number">15</span>] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">multiplyScalar</span>(<span class="params">s</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            te[<span class="number">0</span>] *= s;</span><br><span class="line">            te[<span class="number">4</span>] *= s;</span><br><span class="line">            te[<span class="number">8</span>] *= s;</span><br><span class="line">            te[<span class="number">12</span>] *= s;</span><br><span class="line">            te[<span class="number">1</span>] *= s;</span><br><span class="line">            te[<span class="number">5</span>] *= s;</span><br><span class="line">            te[<span class="number">9</span>] *= s;</span><br><span class="line">            te[<span class="number">13</span>] *= s;</span><br><span class="line">            te[<span class="number">2</span>] *= s;</span><br><span class="line">            te[<span class="number">6</span>] *= s;</span><br><span class="line">            te[<span class="number">10</span>] *= s;</span><br><span class="line">            te[<span class="number">14</span>] *= s;</span><br><span class="line">            te[<span class="number">3</span>] *= s;</span><br><span class="line">            te[<span class="number">7</span>] *= s;</span><br><span class="line">            te[<span class="number">11</span>] *= s;</span><br><span class="line">            te[<span class="number">15</span>] *= s;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">determinant</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            <span class="keyword">const</span> n11 = te[<span class="number">0</span>],</span><br><span class="line">                n12 = te[<span class="number">4</span>],</span><br><span class="line">                n13 = te[<span class="number">8</span>],</span><br><span class="line">                n14 = te[<span class="number">12</span>];</span><br><span class="line">            <span class="keyword">const</span> n21 = te[<span class="number">1</span>],</span><br><span class="line">                n22 = te[<span class="number">5</span>],</span><br><span class="line">                n23 = te[<span class="number">9</span>],</span><br><span class="line">                n24 = te[<span class="number">13</span>];</span><br><span class="line">            <span class="keyword">const</span> n31 = te[<span class="number">2</span>],</span><br><span class="line">                n32 = te[<span class="number">6</span>],</span><br><span class="line">                n33 = te[<span class="number">10</span>],</span><br><span class="line">                n34 = te[<span class="number">14</span>];</span><br><span class="line">            <span class="keyword">const</span> n41 = te[<span class="number">3</span>],</span><br><span class="line">                n42 = te[<span class="number">7</span>],</span><br><span class="line">                n43 = te[<span class="number">11</span>],</span><br><span class="line">                n44 = te[<span class="number">15</span>]; <span class="comment">//<span class="doctag">TODO:</span> make this more efficient</span></span><br><span class="line">            <span class="comment">//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">transpose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            <span class="keyword">let</span> tmp;</span><br><span class="line">            tmp = te[<span class="number">1</span>];</span><br><span class="line">            te[<span class="number">1</span>] = te[<span class="number">4</span>];</span><br><span class="line">            te[<span class="number">4</span>] = tmp;</span><br><span class="line">            tmp = te[<span class="number">2</span>];</span><br><span class="line">            te[<span class="number">2</span>] = te[<span class="number">8</span>];</span><br><span class="line">            te[<span class="number">8</span>] = tmp;</span><br><span class="line">            tmp = te[<span class="number">6</span>];</span><br><span class="line">            te[<span class="number">6</span>] = te[<span class="number">9</span>];</span><br><span class="line">            te[<span class="number">9</span>] = tmp;</span><br><span class="line">            tmp = te[<span class="number">3</span>];</span><br><span class="line">            te[<span class="number">3</span>] = te[<span class="number">12</span>];</span><br><span class="line">            te[<span class="number">12</span>] = tmp;</span><br><span class="line">            tmp = te[<span class="number">7</span>];</span><br><span class="line">            te[<span class="number">7</span>] = te[<span class="number">13</span>];</span><br><span class="line">            te[<span class="number">13</span>] = tmp;</span><br><span class="line">            tmp = te[<span class="number">11</span>];</span><br><span class="line">            te[<span class="number">11</span>] = te[<span class="number">14</span>];</span><br><span class="line">            te[<span class="number">14</span>] = tmp;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setPosition</span>(<span class="params">x, y, z</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x.isVector3) &#123;</span><br><span class="line">                te[<span class="number">12</span>] = x.x;</span><br><span class="line">                te[<span class="number">13</span>] = x.y;</span><br><span class="line">                te[<span class="number">14</span>] = x.z;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                te[<span class="number">12</span>] = x;</span><br><span class="line">                te[<span class="number">13</span>] = y;</span><br><span class="line">                te[<span class="number">14</span>] = z;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">invert</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm</span></span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements,</span><br><span class="line">                n11 = te[<span class="number">0</span>],</span><br><span class="line">                n21 = te[<span class="number">1</span>],</span><br><span class="line">                n31 = te[<span class="number">2</span>],</span><br><span class="line">                n41 = te[<span class="number">3</span>],</span><br><span class="line">                n12 = te[<span class="number">4</span>],</span><br><span class="line">                n22 = te[<span class="number">5</span>],</span><br><span class="line">                n32 = te[<span class="number">6</span>],</span><br><span class="line">                n42 = te[<span class="number">7</span>],</span><br><span class="line">                n13 = te[<span class="number">8</span>],</span><br><span class="line">                n23 = te[<span class="number">9</span>],</span><br><span class="line">                n33 = te[<span class="number">10</span>],</span><br><span class="line">                n43 = te[<span class="number">11</span>],</span><br><span class="line">                n14 = te[<span class="number">12</span>],</span><br><span class="line">                n24 = te[<span class="number">13</span>],</span><br><span class="line">                n34 = te[<span class="number">14</span>],</span><br><span class="line">                n44 = te[<span class="number">15</span>],</span><br><span class="line">                t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,</span><br><span class="line">                t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,</span><br><span class="line">                t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,</span><br><span class="line">                t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;</span><br><span class="line">            <span class="keyword">const</span> det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;</span><br><span class="line">            <span class="keyword">if</span> (det === <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">this</span>.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">const</span> detInv = <span class="number">1</span> / det;</span><br><span class="line">            te[<span class="number">0</span>] = t11 * detInv;</span><br><span class="line">            te[<span class="number">1</span>] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;</span><br><span class="line">            te[<span class="number">2</span>] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;</span><br><span class="line">            te[<span class="number">3</span>] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;</span><br><span class="line">            te[<span class="number">4</span>] = t12 * detInv;</span><br><span class="line">            te[<span class="number">5</span>] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;</span><br><span class="line">            te[<span class="number">6</span>] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;</span><br><span class="line">            te[<span class="number">7</span>] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;</span><br><span class="line">            te[<span class="number">8</span>] = t13 * detInv;</span><br><span class="line">            te[<span class="number">9</span>] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;</span><br><span class="line">            te[<span class="number">10</span>] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;</span><br><span class="line">            te[<span class="number">11</span>] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;</span><br><span class="line">            te[<span class="number">12</span>] = t14 * detInv;</span><br><span class="line">            te[<span class="number">13</span>] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;</span><br><span class="line">            te[<span class="number">14</span>] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;</span><br><span class="line">            te[<span class="number">15</span>] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">scale</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            <span class="keyword">const</span> x = v.x,</span><br><span class="line">                y = v.y,</span><br><span class="line">                z = v.z;</span><br><span class="line">            te[<span class="number">0</span>] *= x;</span><br><span class="line">            te[<span class="number">4</span>] *= y;</span><br><span class="line">            te[<span class="number">8</span>] *= z;</span><br><span class="line">            te[<span class="number">1</span>] *= x;</span><br><span class="line">            te[<span class="number">5</span>] *= y;</span><br><span class="line">            te[<span class="number">9</span>] *= z;</span><br><span class="line">            te[<span class="number">2</span>] *= x;</span><br><span class="line">            te[<span class="number">6</span>] *= y;</span><br><span class="line">            te[<span class="number">10</span>] *= z;</span><br><span class="line">            te[<span class="number">3</span>] *= x;</span><br><span class="line">            te[<span class="number">7</span>] *= y;</span><br><span class="line">            te[<span class="number">11</span>] *= z;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getMaxScaleOnAxis</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            <span class="keyword">const</span> scaleXSq = te[<span class="number">0</span>] * te[<span class="number">0</span>] + te[<span class="number">1</span>] * te[<span class="number">1</span>] + te[<span class="number">2</span>] * te[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">const</span> scaleYSq = te[<span class="number">4</span>] * te[<span class="number">4</span>] + te[<span class="number">5</span>] * te[<span class="number">5</span>] + te[<span class="number">6</span>] * te[<span class="number">6</span>];</span><br><span class="line">            <span class="keyword">const</span> scaleZSq = te[<span class="number">8</span>] * te[<span class="number">8</span>] + te[<span class="number">9</span>] * te[<span class="number">9</span>] + te[<span class="number">10</span>] * te[<span class="number">10</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="built_in">Math</span>.max(scaleXSq, scaleYSq, scaleZSq));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">makeTranslation</span>(<span class="params">x, y, z</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.set(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, x, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, y, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, z, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">makeRotationX</span>(<span class="params">theta</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> c = <span class="built_in">Math</span>.cos(theta),</span><br><span class="line">                s = <span class="built_in">Math</span>.sin(theta);</span><br><span class="line">            <span class="built_in">this</span>.set(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, c, -s, <span class="number">0</span>, <span class="number">0</span>, s, c, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">makeRotationY</span>(<span class="params">theta</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> c = <span class="built_in">Math</span>.cos(theta),</span><br><span class="line">                s = <span class="built_in">Math</span>.sin(theta);</span><br><span class="line">            <span class="built_in">this</span>.set(c, <span class="number">0</span>, s, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -s, <span class="number">0</span>, c, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">makeRotationZ</span>(<span class="params">theta</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> c = <span class="built_in">Math</span>.cos(theta),</span><br><span class="line">                s = <span class="built_in">Math</span>.sin(theta);</span><br><span class="line">            <span class="built_in">this</span>.set(c, -s, <span class="number">0</span>, <span class="number">0</span>, s, c, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">makeRotationAxis</span>(<span class="params">axis, angle</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// Based on http://www.gamedev.net/reference/articles/article1199.asp</span></span><br><span class="line">            <span class="keyword">const</span> c = <span class="built_in">Math</span>.cos(angle);</span><br><span class="line">            <span class="keyword">const</span> s = <span class="built_in">Math</span>.sin(angle);</span><br><span class="line">            <span class="keyword">const</span> t = <span class="number">1</span> - c;</span><br><span class="line">            <span class="keyword">const</span> x = axis.x,</span><br><span class="line">                y = axis.y,</span><br><span class="line">                z = axis.z;</span><br><span class="line">            <span class="keyword">const</span> tx = t * x,</span><br><span class="line">                ty = t * y;</span><br><span class="line">            <span class="built_in">this</span>.set(tx * x + c, tx * y - s * z, tx * z + s * y, <span class="number">0</span>, tx * y + s * z, ty * y + c, ty * z - s * x, <span class="number">0</span>, tx * z - s * y, ty * z + s * x, t * z * z + c, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">makeScale</span>(<span class="params">x, y, z</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.set(x, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, y, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, z, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">makeShear</span>(<span class="params">xy, xz, yx, yz, zx, zy</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.set(<span class="number">1</span>, yx, zx, <span class="number">0</span>, xy, <span class="number">1</span>, zy, <span class="number">0</span>, xz, yz, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">compose</span>(<span class="params">position, quaternion, scale</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            <span class="keyword">const</span> x = quaternion._x,</span><br><span class="line">                y = quaternion._y,</span><br><span class="line">                z = quaternion._z,</span><br><span class="line">                w = quaternion._w;</span><br><span class="line">            <span class="keyword">const</span> x2 = x + x,</span><br><span class="line">                y2 = y + y,</span><br><span class="line">                z2 = z + z;</span><br><span class="line">            <span class="keyword">const</span> xx = x * x2,</span><br><span class="line">                xy = x * y2,</span><br><span class="line">                xz = x * z2;</span><br><span class="line">            <span class="keyword">const</span> yy = y * y2,</span><br><span class="line">                yz = y * z2,</span><br><span class="line">                zz = z * z2;</span><br><span class="line">            <span class="keyword">const</span> wx = w * x2,</span><br><span class="line">                wy = w * y2,</span><br><span class="line">                wz = w * z2;</span><br><span class="line">            <span class="keyword">const</span> sx = scale.x,</span><br><span class="line">                sy = scale.y,</span><br><span class="line">                sz = scale.z;</span><br><span class="line">            te[<span class="number">0</span>] = (<span class="number">1</span> - (yy + zz)) * sx;</span><br><span class="line">            te[<span class="number">1</span>] = (xy + wz) * sx;</span><br><span class="line">            te[<span class="number">2</span>] = (xz - wy) * sx;</span><br><span class="line">            te[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">4</span>] = (xy - wz) * sy;</span><br><span class="line">            te[<span class="number">5</span>] = (<span class="number">1</span> - (xx + zz)) * sy;</span><br><span class="line">            te[<span class="number">6</span>] = (yz + wx) * sy;</span><br><span class="line">            te[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">8</span>] = (xz + wy) * sz;</span><br><span class="line">            te[<span class="number">9</span>] = (yz - wx) * sz;</span><br><span class="line">            te[<span class="number">10</span>] = (<span class="number">1</span> - (xx + yy)) * sz;</span><br><span class="line">            te[<span class="number">11</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">12</span>] = position.x;</span><br><span class="line">            te[<span class="number">13</span>] = position.y;</span><br><span class="line">            te[<span class="number">14</span>] = position.z;</span><br><span class="line">            te[<span class="number">15</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">decompose</span>(<span class="params">position, quaternion, scale</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> sx = _v1$<span class="number">5.</span>set(te[<span class="number">0</span>], te[<span class="number">1</span>], te[<span class="number">2</span>]).length();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> sy = _v1$<span class="number">5.</span>set(te[<span class="number">4</span>], te[<span class="number">5</span>], te[<span class="number">6</span>]).length();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> sz = _v1$<span class="number">5.</span>set(te[<span class="number">8</span>], te[<span class="number">9</span>], te[<span class="number">10</span>]).length(); <span class="comment">// if determine is negative, we need to invert one scale</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> det = <span class="built_in">this</span>.determinant();</span><br><span class="line">            <span class="keyword">if</span> (det &lt; <span class="number">0</span>) sx = -sx;</span><br><span class="line">            position.x = te[<span class="number">12</span>];</span><br><span class="line">            position.y = te[<span class="number">13</span>];</span><br><span class="line">            position.z = te[<span class="number">14</span>]; <span class="comment">// scale the rotation part</span></span><br><span class="line"></span><br><span class="line">            _m1$<span class="number">2.</span>copy(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> invSX = <span class="number">1</span> / sx;</span><br><span class="line">            <span class="keyword">const</span> invSY = <span class="number">1</span> / sy;</span><br><span class="line">            <span class="keyword">const</span> invSZ = <span class="number">1</span> / sz;</span><br><span class="line">            _m1$<span class="number">2.</span>elements[<span class="number">0</span>] *= invSX;</span><br><span class="line">            _m1$<span class="number">2.</span>elements[<span class="number">1</span>] *= invSX;</span><br><span class="line">            _m1$<span class="number">2.</span>elements[<span class="number">2</span>] *= invSX;</span><br><span class="line">            _m1$<span class="number">2.</span>elements[<span class="number">4</span>] *= invSY;</span><br><span class="line">            _m1$<span class="number">2.</span>elements[<span class="number">5</span>] *= invSY;</span><br><span class="line">            _m1$<span class="number">2.</span>elements[<span class="number">6</span>] *= invSY;</span><br><span class="line">            _m1$<span class="number">2.</span>elements[<span class="number">8</span>] *= invSZ;</span><br><span class="line">            _m1$<span class="number">2.</span>elements[<span class="number">9</span>] *= invSZ;</span><br><span class="line">            _m1$<span class="number">2.</span>elements[<span class="number">10</span>] *= invSZ;</span><br><span class="line">            quaternion.setFromRotationMatrix(_m1$<span class="number">2</span>);</span><br><span class="line">            scale.x = sx;</span><br><span class="line">            scale.y = sy;</span><br><span class="line">            scale.z = sz;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">makePerspective</span>(<span class="params">left, right, top, bottom, near, far</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (far === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            <span class="keyword">const</span> x = <span class="number">2</span> * near / (right - left);</span><br><span class="line">            <span class="keyword">const</span> y = <span class="number">2</span> * near / (top - bottom);</span><br><span class="line">            <span class="keyword">const</span> a = (right + left) / (right - left);</span><br><span class="line">            <span class="keyword">const</span> b = (top + bottom) / (top - bottom);</span><br><span class="line">            <span class="keyword">const</span> c = -(far + near) / (far - near);</span><br><span class="line">            <span class="keyword">const</span> d = -<span class="number">2</span> * far * near / (far - near);</span><br><span class="line">            te[<span class="number">0</span>] = x;</span><br><span class="line">            te[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">8</span>] = a;</span><br><span class="line">            te[<span class="number">12</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">5</span>] = y;</span><br><span class="line">            te[<span class="number">9</span>] = b;</span><br><span class="line">            te[<span class="number">13</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">10</span>] = c;</span><br><span class="line">            te[<span class="number">14</span>] = d;</span><br><span class="line">            te[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">11</span>] = -<span class="number">1</span>;</span><br><span class="line">            te[<span class="number">15</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">makeOrthographic</span>(<span class="params">left, right, top, bottom, near, far</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            <span class="keyword">const</span> w = <span class="number">1.0</span> / (right - left);</span><br><span class="line">            <span class="keyword">const</span> h = <span class="number">1.0</span> / (top - bottom);</span><br><span class="line">            <span class="keyword">const</span> p = <span class="number">1.0</span> / (far - near);</span><br><span class="line">            <span class="keyword">const</span> x = (right + left) * w;</span><br><span class="line">            <span class="keyword">const</span> y = (top + bottom) * h;</span><br><span class="line">            <span class="keyword">const</span> z = (far + near) * p;</span><br><span class="line">            te[<span class="number">0</span>] = <span class="number">2</span> * w;</span><br><span class="line">            te[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">12</span>] = -x;</span><br><span class="line">            te[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">5</span>] = <span class="number">2</span> * h;</span><br><span class="line">            te[<span class="number">9</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">13</span>] = -y;</span><br><span class="line">            te[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">10</span>] = -<span class="number">2</span> * p;</span><br><span class="line">            te[<span class="number">14</span>] = -z;</span><br><span class="line">            te[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">11</span>] = <span class="number">0</span>;</span><br><span class="line">            te[<span class="number">15</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">equals</span>(<span class="params">matrix</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            <span class="keyword">const</span> me = matrix.elements;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (te[i] !== me[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromArray</span>(<span class="params">array, offset = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.elements[i] = array[i + offset];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toArray</span>(<span class="params">array = [], offset = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> te = <span class="built_in">this</span>.elements;</span><br><span class="line">            array[offset] = te[<span class="number">0</span>];</span><br><span class="line">            array[offset + <span class="number">1</span>] = te[<span class="number">1</span>];</span><br><span class="line">            array[offset + <span class="number">2</span>] = te[<span class="number">2</span>];</span><br><span class="line">            array[offset + <span class="number">3</span>] = te[<span class="number">3</span>];</span><br><span class="line">            array[offset + <span class="number">4</span>] = te[<span class="number">4</span>];</span><br><span class="line">            array[offset + <span class="number">5</span>] = te[<span class="number">5</span>];</span><br><span class="line">            array[offset + <span class="number">6</span>] = te[<span class="number">6</span>];</span><br><span class="line">            array[offset + <span class="number">7</span>] = te[<span class="number">7</span>];</span><br><span class="line">            array[offset + <span class="number">8</span>] = te[<span class="number">8</span>];</span><br><span class="line">            array[offset + <span class="number">9</span>] = te[<span class="number">9</span>];</span><br><span class="line">            array[offset + <span class="number">10</span>] = te[<span class="number">10</span>];</span><br><span class="line">            array[offset + <span class="number">11</span>] = te[<span class="number">11</span>];</span><br><span class="line">            array[offset + <span class="number">12</span>] = te[<span class="number">12</span>];</span><br><span class="line">            array[offset + <span class="number">13</span>] = te[<span class="number">13</span>];</span><br><span class="line">            array[offset + <span class="number">14</span>] = te[<span class="number">14</span>];</span><br><span class="line">            array[offset + <span class="number">15</span>] = te[<span class="number">15</span>];</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Matrix4.prototype.isMatrix4 = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _v1$<span class="number">5</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _m1$<span class="number">2</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Matrix4();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _zero = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _one = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _x = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _y = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _z = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _matrix$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Matrix4();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _quaternion$<span class="number">3</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Quaternion();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Euler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>, order = Euler.DefaultOrder</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._x = x;</span><br><span class="line">            <span class="built_in">this</span>._y = y;</span><br><span class="line">            <span class="built_in">this</span>._z = z;</span><br><span class="line">            <span class="built_in">this</span>._order = order;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">x</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">x</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>._x = value;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._onChangeCallback();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">y</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">y</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>._y = value;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._onChangeCallback();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">z</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._z;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">z</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>._z = value;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._onChangeCallback();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">order</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._order;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">order</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>._order = value;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._onChangeCallback();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">x, y, z, order = <span class="built_in">this</span>._order</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._x = x;</span><br><span class="line">            <span class="built_in">this</span>._y = y;</span><br><span class="line">            <span class="built_in">this</span>._z = z;</span><br><span class="line">            <span class="built_in">this</span>._order = order;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._onChangeCallback();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor(<span class="built_in">this</span>._x, <span class="built_in">this</span>._y, <span class="built_in">this</span>._z, <span class="built_in">this</span>._order);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">euler</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._x = euler._x;</span><br><span class="line">            <span class="built_in">this</span>._y = euler._y;</span><br><span class="line">            <span class="built_in">this</span>._z = euler._z;</span><br><span class="line">            <span class="built_in">this</span>._order = euler._order;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._onChangeCallback();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromRotationMatrix</span>(<span class="params">m, order = <span class="built_in">this</span>._order, update = <span class="literal">true</span></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)</span></span><br><span class="line">            <span class="keyword">const</span> te = m.elements;</span><br><span class="line">            <span class="keyword">const</span> m11 = te[<span class="number">0</span>],</span><br><span class="line">                m12 = te[<span class="number">4</span>],</span><br><span class="line">                m13 = te[<span class="number">8</span>];</span><br><span class="line">            <span class="keyword">const</span> m21 = te[<span class="number">1</span>],</span><br><span class="line">                m22 = te[<span class="number">5</span>],</span><br><span class="line">                m23 = te[<span class="number">9</span>];</span><br><span class="line">            <span class="keyword">const</span> m31 = te[<span class="number">2</span>],</span><br><span class="line">                m32 = te[<span class="number">6</span>],</span><br><span class="line">                m33 = te[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (order) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;XYZ&#x27;</span>:</span><br><span class="line">                    <span class="built_in">this</span>._y = <span class="built_in">Math</span>.asin(clamp(m13, -<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(m13) &lt; <span class="number">0.9999999</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>._x = <span class="built_in">Math</span>.atan2(-m23, m33);</span><br><span class="line">                        <span class="built_in">this</span>._z = <span class="built_in">Math</span>.atan2(-m12, m11);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>._x = <span class="built_in">Math</span>.atan2(m32, m22);</span><br><span class="line">                        <span class="built_in">this</span>._z = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;YXZ&#x27;</span>:</span><br><span class="line">                    <span class="built_in">this</span>._x = <span class="built_in">Math</span>.asin(-clamp(m23, -<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(m23) &lt; <span class="number">0.9999999</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>._y = <span class="built_in">Math</span>.atan2(m13, m33);</span><br><span class="line">                        <span class="built_in">this</span>._z = <span class="built_in">Math</span>.atan2(m21, m22);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>._y = <span class="built_in">Math</span>.atan2(-m31, m11);</span><br><span class="line">                        <span class="built_in">this</span>._z = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;ZXY&#x27;</span>:</span><br><span class="line">                    <span class="built_in">this</span>._x = <span class="built_in">Math</span>.asin(clamp(m32, -<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(m32) &lt; <span class="number">0.9999999</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>._y = <span class="built_in">Math</span>.atan2(-m31, m33);</span><br><span class="line">                        <span class="built_in">this</span>._z = <span class="built_in">Math</span>.atan2(-m12, m22);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>._y = <span class="number">0</span>;</span><br><span class="line">                        <span class="built_in">this</span>._z = <span class="built_in">Math</span>.atan2(m21, m11);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;ZYX&#x27;</span>:</span><br><span class="line">                    <span class="built_in">this</span>._y = <span class="built_in">Math</span>.asin(-clamp(m31, -<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(m31) &lt; <span class="number">0.9999999</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>._x = <span class="built_in">Math</span>.atan2(m32, m33);</span><br><span class="line">                        <span class="built_in">this</span>._z = <span class="built_in">Math</span>.atan2(m21, m11);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>._x = <span class="number">0</span>;</span><br><span class="line">                        <span class="built_in">this</span>._z = <span class="built_in">Math</span>.atan2(-m12, m22);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;YZX&#x27;</span>:</span><br><span class="line">                    <span class="built_in">this</span>._z = <span class="built_in">Math</span>.asin(clamp(m21, -<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(m21) &lt; <span class="number">0.9999999</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>._x = <span class="built_in">Math</span>.atan2(-m23, m22);</span><br><span class="line">                        <span class="built_in">this</span>._y = <span class="built_in">Math</span>.atan2(-m31, m11);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>._x = <span class="number">0</span>;</span><br><span class="line">                        <span class="built_in">this</span>._y = <span class="built_in">Math</span>.atan2(m13, m33);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;XZY&#x27;</span>:</span><br><span class="line">                    <span class="built_in">this</span>._z = <span class="built_in">Math</span>.asin(-clamp(m12, -<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(m12) &lt; <span class="number">0.9999999</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>._x = <span class="built_in">Math</span>.atan2(m32, m22);</span><br><span class="line">                        <span class="built_in">this</span>._y = <span class="built_in">Math</span>.atan2(m13, m11);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>._x = <span class="built_in">Math</span>.atan2(-m23, m33);</span><br><span class="line">                        <span class="built_in">this</span>._y = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Euler: .setFromRotationMatrix() encountered an unknown order: &#x27;</span> + order);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._order = order;</span><br><span class="line">            <span class="keyword">if</span> (update === <span class="literal">true</span>) <span class="built_in">this</span>._onChangeCallback();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromQuaternion</span>(<span class="params">q, order, update</span>)</span> &#123;</span><br><span class="line">            _matrix$<span class="number">1.</span>makeRotationFromQuaternion(q);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.setFromRotationMatrix(_matrix$<span class="number">1</span>, order, update);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromVector3</span>(<span class="params">v, order = <span class="built_in">this</span>._order</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.set(v.x, v.y, v.z, order);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">reorder</span>(<span class="params">newOrder</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// WARNING: this discards revolution information -bhouston</span></span><br><span class="line">            _quaternion$<span class="number">3.</span>setFromEuler(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.setFromQuaternion(_quaternion$<span class="number">3</span>, newOrder);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">equals</span>(<span class="params">euler</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> euler._x === <span class="built_in">this</span>._x &amp;&amp; euler._y === <span class="built_in">this</span>._y &amp;&amp; euler._z === <span class="built_in">this</span>._z &amp;&amp; euler._order === <span class="built_in">this</span>._order;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromArray</span>(<span class="params">array</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._x = array[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">this</span>._y = array[<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">this</span>._z = array[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (array[<span class="number">3</span>] !== <span class="literal">undefined</span>) <span class="built_in">this</span>._order = array[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._onChangeCallback();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toArray</span>(<span class="params">array = [], offset = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            array[offset] = <span class="built_in">this</span>._x;</span><br><span class="line">            array[offset + <span class="number">1</span>] = <span class="built_in">this</span>._y;</span><br><span class="line">            array[offset + <span class="number">2</span>] = <span class="built_in">this</span>._z;</span><br><span class="line">            array[offset + <span class="number">3</span>] = <span class="built_in">this</span>._order;</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_onChange</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._onChangeCallback = callback;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_onChangeCallback</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Euler.prototype.isEuler = <span class="literal">true</span>;</span><br><span class="line">    Euler.DefaultOrder = <span class="string">&#x27;XYZ&#x27;</span>;</span><br><span class="line">    Euler.RotationOrders = [<span class="string">&#x27;XYZ&#x27;</span>, <span class="string">&#x27;YZX&#x27;</span>, <span class="string">&#x27;ZXY&#x27;</span>, <span class="string">&#x27;XZY&#x27;</span>, <span class="string">&#x27;YXZ&#x27;</span>, <span class="string">&#x27;ZYX&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Layers</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.mask = <span class="number">1</span> | <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">channel</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.mask = (<span class="number">1</span> &lt;&lt; channel | <span class="number">0</span>) &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">enable</span>(<span class="params">channel</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.mask |= <span class="number">1</span> &lt;&lt; channel | <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">enableAll</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.mask = <span class="number">0xffffffff</span> | <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toggle</span>(<span class="params">channel</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.mask ^= <span class="number">1</span> &lt;&lt; channel | <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">disable</span>(<span class="params">channel</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.mask &amp;= ~(<span class="number">1</span> &lt;&lt; channel | <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">disableAll</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.mask = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">test</span>(<span class="params">layers</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">this</span>.mask &amp; layers.mask) !== <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">isEnabled</span>(<span class="params">channel</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">this</span>.mask &amp; (<span class="number">1</span> &lt;&lt; channel | <span class="number">0</span>)) !== <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> _object3DId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _v1$<span class="number">4</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _q1 = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Quaternion();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _m1$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Matrix4();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _target = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _position$<span class="number">3</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _scale$<span class="number">2</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _quaternion$<span class="number">2</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Quaternion();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _xAxis = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _yAxis = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _zAxis = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _addedEvent = &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;added&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> _removedEvent = &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;removed&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Object3D</span> <span class="keyword">extends</span> <span class="title">EventDispatcher</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, <span class="string">&#x27;id&#x27;</span>, &#123;</span><br><span class="line">                <span class="attr">value</span>: _object3DId++</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">this</span>.uuid = generateUUID();</span><br><span class="line">            <span class="built_in">this</span>.name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;Object3D&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.parent = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.children = [];</span><br><span class="line">            <span class="built_in">this</span>.up = Object3D.DefaultUp.clone();</span><br><span class="line">            <span class="keyword">const</span> position = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> rotation = <span class="keyword">new</span> Euler();</span><br><span class="line">            <span class="keyword">const</span> quaternion = <span class="keyword">new</span> Quaternion();</span><br><span class="line">            <span class="keyword">const</span> scale = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">onRotationChange</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                quaternion.setFromEuler(rotation, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">onQuaternionChange</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                rotation.setFromQuaternion(quaternion, <span class="literal">undefined</span>, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rotation._onChange(onRotationChange);</span><br><span class="line"></span><br><span class="line">            quaternion._onChange(onQuaternionChange);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">Object</span>.defineProperties(<span class="built_in">this</span>, &#123;</span><br><span class="line">                <span class="attr">position</span>: &#123;</span><br><span class="line">                    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">value</span>: position</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">rotation</span>: &#123;</span><br><span class="line">                    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">value</span>: rotation</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">quaternion</span>: &#123;</span><br><span class="line">                    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">value</span>: quaternion</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">scale</span>: &#123;</span><br><span class="line">                    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">value</span>: scale</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">modelViewMatrix</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="keyword">new</span> Matrix4()</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">normalMatrix</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="keyword">new</span> Matrix3()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">this</span>.matrix = <span class="keyword">new</span> Matrix4();</span><br><span class="line">            <span class="built_in">this</span>.matrixWorld = <span class="keyword">new</span> Matrix4();</span><br><span class="line">            <span class="built_in">this</span>.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;</span><br><span class="line">            <span class="built_in">this</span>.matrixWorldNeedsUpdate = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.layers = <span class="keyword">new</span> Layers();</span><br><span class="line">            <span class="built_in">this</span>.visible = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.castShadow = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.receiveShadow = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.frustumCulled = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.renderOrder = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.animations = [];</span><br><span class="line">            <span class="built_in">this</span>.userData = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">onBeforeRender</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">onAfterRender</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">applyMatrix4</span>(<span class="params">matrix</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.matrixAutoUpdate) <span class="built_in">this</span>.updateMatrix();</span><br><span class="line">            <span class="built_in">this</span>.matrix.premultiply(matrix);</span><br><span class="line">            <span class="built_in">this</span>.matrix.decompose(<span class="built_in">this</span>.position, <span class="built_in">this</span>.quaternion, <span class="built_in">this</span>.scale);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">applyQuaternion</span>(<span class="params">q</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.quaternion.premultiply(q);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setRotationFromAxisAngle</span>(<span class="params">axis, angle</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// assumes axis is normalized</span></span><br><span class="line">            <span class="built_in">this</span>.quaternion.setFromAxisAngle(axis, angle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setRotationFromEuler</span>(<span class="params">euler</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.quaternion.setFromEuler(euler, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setRotationFromMatrix</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)</span></span><br><span class="line">            <span class="built_in">this</span>.quaternion.setFromRotationMatrix(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setRotationFromQuaternion</span>(<span class="params">q</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// assumes q is normalized</span></span><br><span class="line">            <span class="built_in">this</span>.quaternion.copy(q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">rotateOnAxis</span>(<span class="params">axis, angle</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// rotate object on axis in object space</span></span><br><span class="line">            <span class="comment">// axis is assumed to be normalized</span></span><br><span class="line">            _q1.setFromAxisAngle(axis, angle);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.quaternion.multiply(_q1);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">rotateOnWorldAxis</span>(<span class="params">axis, angle</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// rotate object on axis in world space</span></span><br><span class="line">            <span class="comment">// axis is assumed to be normalized</span></span><br><span class="line">            <span class="comment">// method assumes no rotated parent</span></span><br><span class="line">            _q1.setFromAxisAngle(axis, angle);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.quaternion.premultiply(_q1);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">rotateX</span>(<span class="params">angle</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.rotateOnAxis(_xAxis, angle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">rotateY</span>(<span class="params">angle</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.rotateOnAxis(_yAxis, angle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">rotateZ</span>(<span class="params">angle</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.rotateOnAxis(_zAxis, angle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">translateOnAxis</span>(<span class="params">axis, distance</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// translate object by distance along axis in object space</span></span><br><span class="line">            <span class="comment">// axis is assumed to be normalized</span></span><br><span class="line">            _v1$<span class="number">4.</span>copy(axis).applyQuaternion(<span class="built_in">this</span>.quaternion);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.position.add(_v1$<span class="number">4.</span>multiplyScalar(distance));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">translateX</span>(<span class="params">distance</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.translateOnAxis(_xAxis, distance);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">translateY</span>(<span class="params">distance</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.translateOnAxis(_yAxis, distance);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">translateZ</span>(<span class="params">distance</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.translateOnAxis(_zAxis, distance);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">localToWorld</span>(<span class="params">vector</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> vector.applyMatrix4(<span class="built_in">this</span>.matrixWorld);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">worldToLocal</span>(<span class="params">vector</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> vector.applyMatrix4(_m1$<span class="number">1.</span>copy(<span class="built_in">this</span>.matrixWorld).invert());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">lookAt</span>(<span class="params">x, y, z</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// This method does not support objects having non-uniformly-scaled parent(s)</span></span><br><span class="line">            <span class="keyword">if</span> (x.isVector3) &#123;</span><br><span class="line">                _target.copy(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _target.set(x, y, z);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> parent = <span class="built_in">this</span>.parent;</span><br><span class="line">            <span class="built_in">this</span>.updateWorldMatrix(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            _position$<span class="number">3.</span>setFromMatrixPosition(<span class="built_in">this</span>.matrixWorld);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isCamera || <span class="built_in">this</span>.isLight) &#123;</span><br><span class="line">                _m1$<span class="number">1.</span>lookAt(_position$<span class="number">3</span>, _target, <span class="built_in">this</span>.up);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _m1$<span class="number">1.</span>lookAt(_target, _position$<span class="number">3</span>, <span class="built_in">this</span>.up);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.quaternion.setFromRotationMatrix(_m1$<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">                _m1$<span class="number">1.</span>extractRotation(parent.matrixWorld);</span><br><span class="line"></span><br><span class="line">                _q1.setFromRotationMatrix(_m1$<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.quaternion.premultiply(_q1.invert());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params">object</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.add(<span class="built_in">arguments</span>[i]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (object === <span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Object3D.add: object can\&#x27;t be added as a child of itself.&#x27;</span>, object);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (object &amp;&amp; object.isObject3D) &#123;</span><br><span class="line">                <span class="keyword">if</span> (object.parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    object.parent.remove(object);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                object.parent = <span class="built_in">this</span>;</span><br><span class="line">                <span class="built_in">this</span>.children.push(object);</span><br><span class="line">                object.dispatchEvent(_addedEvent);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Object3D.add: object not an instance of THREE.Object3D.&#x27;</span>, object);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">remove</span>(<span class="params">object</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.remove(<span class="built_in">arguments</span>[i]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> index = <span class="built_in">this</span>.children.indexOf(object);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">                object.parent = <span class="literal">null</span>;</span><br><span class="line">                <span class="built_in">this</span>.children.splice(index, <span class="number">1</span>);</span><br><span class="line">                object.dispatchEvent(_removedEvent);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">removeFromParent</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> parent = <span class="built_in">this</span>.parent;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">                parent.remove(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.children.length; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> object = <span class="built_in">this</span>.children[i];</span><br><span class="line">                object.parent = <span class="literal">null</span>;</span><br><span class="line">                object.dispatchEvent(_removedEvent);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.children.length = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">attach</span>(<span class="params">object</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// adds object as a child of this, while maintaining the object&#x27;s world transform</span></span><br><span class="line">            <span class="comment">// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)</span></span><br><span class="line">            <span class="built_in">this</span>.updateWorldMatrix(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            _m1$<span class="number">1.</span>copy(<span class="built_in">this</span>.matrixWorld).invert();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (object.parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">                object.parent.updateWorldMatrix(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">                _m1$<span class="number">1.</span>multiply(object.parent.matrixWorld);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            object.applyMatrix4(_m1$<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.add(object);</span><br><span class="line">            object.updateWorldMatrix(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getObjectById</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.getObjectByProperty(<span class="string">&#x27;id&#x27;</span>, id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getObjectByName</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.getObjectByProperty(<span class="string">&#x27;name&#x27;</span>, name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getObjectByProperty</span>(<span class="params">name, value</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>[name] === value) <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">this</span>.children.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> child = <span class="built_in">this</span>.children[i];</span><br><span class="line">                <span class="keyword">const</span> object = child.getObjectByProperty(name, value);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (object !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> object;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getWorldPosition</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.updateWorldMatrix(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span> target.setFromMatrixPosition(<span class="built_in">this</span>.matrixWorld);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getWorldQuaternion</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.updateWorldMatrix(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="built_in">this</span>.matrixWorld.decompose(_position$<span class="number">3</span>, target, _scale$<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getWorldScale</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.updateWorldMatrix(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="built_in">this</span>.matrixWorld.decompose(_position$<span class="number">3</span>, _quaternion$<span class="number">2</span>, target);</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getWorldDirection</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.updateWorldMatrix(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">const</span> e = <span class="built_in">this</span>.matrixWorld.elements;</span><br><span class="line">            <span class="keyword">return</span> target.set(e[<span class="number">8</span>], e[<span class="number">9</span>], e[<span class="number">10</span>]).normalize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">raycast</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">traverse</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">            callback(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">const</span> children = <span class="built_in">this</span>.children;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = children.length; i &lt; l; i++) &#123;</span><br><span class="line">                children[i].traverse(callback);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">traverseVisible</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.visible === <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line">            callback(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">const</span> children = <span class="built_in">this</span>.children;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = children.length; i &lt; l; i++) &#123;</span><br><span class="line">                children[i].traverseVisible(callback);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">traverseAncestors</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> parent = <span class="built_in">this</span>.parent;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">                callback(parent);</span><br><span class="line">                parent.traverseAncestors(callback);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">updateMatrix</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.matrix.compose(<span class="built_in">this</span>.position, <span class="built_in">this</span>.quaternion, <span class="built_in">this</span>.scale);</span><br><span class="line">            <span class="built_in">this</span>.matrixWorldNeedsUpdate = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">updateMatrixWorld</span>(<span class="params">force</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.matrixAutoUpdate) <span class="built_in">this</span>.updateMatrix();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.matrixWorldNeedsUpdate || force) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.parent === <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.matrixWorld.copy(<span class="built_in">this</span>.matrix);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.matrixWorld.multiplyMatrices(<span class="built_in">this</span>.parent.matrixWorld, <span class="built_in">this</span>.matrix);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.matrixWorldNeedsUpdate = <span class="literal">false</span>;</span><br><span class="line">                force = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="comment">// update children</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> children = <span class="built_in">this</span>.children;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = children.length; i &lt; l; i++) &#123;</span><br><span class="line">                children[i].updateMatrixWorld(force);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">updateWorldMatrix</span>(<span class="params">updateParents, updateChildren</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> parent = <span class="built_in">this</span>.parent;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (updateParents === <span class="literal">true</span> &amp;&amp; parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">                parent.updateWorldMatrix(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.matrixAutoUpdate) <span class="built_in">this</span>.updateMatrix();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.parent === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.matrixWorld.copy(<span class="built_in">this</span>.matrix);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.matrixWorld.multiplyMatrices(<span class="built_in">this</span>.parent.matrixWorld, <span class="built_in">this</span>.matrix);</span><br><span class="line">            &#125; <span class="comment">// update children</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (updateChildren === <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> children = <span class="built_in">this</span>.children;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = children.length; i &lt; l; i++) &#123;</span><br><span class="line">                    children[i].updateWorldMatrix(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params">meta</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// meta is a string when called from JSON.stringify</span></span><br><span class="line">            <span class="keyword">const</span> isRootObject = meta === <span class="literal">undefined</span> || <span class="keyword">typeof</span> meta === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">            <span class="keyword">const</span> output = &#123;&#125;; <span class="comment">// meta is a hash used to collect geometries, materials.</span></span><br><span class="line">            <span class="comment">// not providing it implies that this is the root object</span></span><br><span class="line">            <span class="comment">// being serialized.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isRootObject) &#123;</span><br><span class="line">                <span class="comment">// initialize meta obj</span></span><br><span class="line">                meta = &#123;</span><br><span class="line">                    <span class="attr">geometries</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">materials</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">textures</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">images</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">shapes</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">skeletons</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">animations</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">nodes</span>: &#123;&#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                output.metadata = &#123;</span><br><span class="line">                    <span class="attr">version</span>: <span class="number">4.5</span>,</span><br><span class="line">                    <span class="attr">type</span>: <span class="string">&#x27;Object&#x27;</span>,</span><br><span class="line">                    <span class="attr">generator</span>: <span class="string">&#x27;Object3D.toJSON&#x27;</span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125; <span class="comment">// standard Object3D serialization</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> object = &#123;&#125;;</span><br><span class="line">            object.uuid = <span class="built_in">this</span>.uuid;</span><br><span class="line">            object.type = <span class="built_in">this</span>.type;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.name !== <span class="string">&#x27;&#x27;</span>) object.name = <span class="built_in">this</span>.name;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.castShadow === <span class="literal">true</span>) object.castShadow = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.receiveShadow === <span class="literal">true</span>) object.receiveShadow = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.visible === <span class="literal">false</span>) object.visible = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.frustumCulled === <span class="literal">false</span>) object.frustumCulled = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.renderOrder !== <span class="number">0</span>) object.renderOrder = <span class="built_in">this</span>.renderOrder;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.userData) !== <span class="string">&#x27;&#123;&#125;&#x27;</span>) object.userData = <span class="built_in">this</span>.userData;</span><br><span class="line">            object.layers = <span class="built_in">this</span>.layers.mask;</span><br><span class="line">            object.matrix = <span class="built_in">this</span>.matrix.toArray();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.matrixAutoUpdate === <span class="literal">false</span>) object.matrixAutoUpdate = <span class="literal">false</span>; <span class="comment">// object specific properties</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isInstancedMesh) &#123;</span><br><span class="line">                object.type = <span class="string">&#x27;InstancedMesh&#x27;</span>;</span><br><span class="line">                object.count = <span class="built_in">this</span>.count;</span><br><span class="line">                object.instanceMatrix = <span class="built_in">this</span>.instanceMatrix.toJSON();</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.instanceColor !== <span class="literal">null</span>) object.instanceColor = <span class="built_in">this</span>.instanceColor.toJSON();</span><br><span class="line">            &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">serialize</span>(<span class="params">library, element</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (library[element.uuid] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    library[element.uuid] = element.toJSON(meta);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> element.uuid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isScene) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.background) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">this</span>.background.isColor) &#123;</span><br><span class="line">                        object.background = <span class="built_in">this</span>.background.toJSON();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.background.isTexture) &#123;</span><br><span class="line">                        object.background = <span class="built_in">this</span>.background.toJSON(meta).uuid;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.environment &amp;&amp; <span class="built_in">this</span>.environment.isTexture) &#123;</span><br><span class="line">                    object.environment = <span class="built_in">this</span>.environment.toJSON(meta).uuid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.isMesh || <span class="built_in">this</span>.isLine || <span class="built_in">this</span>.isPoints) &#123;</span><br><span class="line">                object.geometry = serialize(meta.geometries, <span class="built_in">this</span>.geometry);</span><br><span class="line">                <span class="keyword">const</span> parameters = <span class="built_in">this</span>.geometry.parameters;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (parameters !== <span class="literal">undefined</span> &amp;&amp; parameters.shapes !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> shapes = parameters.shapes;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(shapes)) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = shapes.length; i &lt; l; i++) &#123;</span><br><span class="line">                            <span class="keyword">const</span> shape = shapes[i];</span><br><span class="line">                            serialize(meta.shapes, shape);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        serialize(meta.shapes, shapes);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isSkinnedMesh) &#123;</span><br><span class="line">                object.bindMode = <span class="built_in">this</span>.bindMode;</span><br><span class="line">                object.bindMatrix = <span class="built_in">this</span>.bindMatrix.toArray();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.skeleton !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    serialize(meta.skeletons, <span class="built_in">this</span>.skeleton);</span><br><span class="line">                    object.skeleton = <span class="built_in">this</span>.skeleton.uuid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.material !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(<span class="built_in">this</span>.material)) &#123;</span><br><span class="line">                    <span class="keyword">const</span> uuids = [];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">this</span>.material.length; i &lt; l; i++) &#123;</span><br><span class="line">                        uuids.push(serialize(meta.materials, <span class="built_in">this</span>.material[i]));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    object.material = uuids;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    object.material = serialize(meta.materials, <span class="built_in">this</span>.material);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.children.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                object.children = [];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.children.length; i++) &#123;</span><br><span class="line">                    object.children.push(<span class="built_in">this</span>.children[i].toJSON(meta).object);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.animations.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                object.animations = [];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.animations.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> animation = <span class="built_in">this</span>.animations[i];</span><br><span class="line">                    object.animations.push(serialize(meta.animations, animation));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isRootObject) &#123;</span><br><span class="line">                <span class="keyword">const</span> geometries = extractFromCache(meta.geometries);</span><br><span class="line">                <span class="keyword">const</span> materials = extractFromCache(meta.materials);</span><br><span class="line">                <span class="keyword">const</span> textures = extractFromCache(meta.textures);</span><br><span class="line">                <span class="keyword">const</span> images = extractFromCache(meta.images);</span><br><span class="line">                <span class="keyword">const</span> shapes = extractFromCache(meta.shapes);</span><br><span class="line">                <span class="keyword">const</span> skeletons = extractFromCache(meta.skeletons);</span><br><span class="line">                <span class="keyword">const</span> animations = extractFromCache(meta.animations);</span><br><span class="line">                <span class="keyword">const</span> nodes = extractFromCache(meta.nodes);</span><br><span class="line">                <span class="keyword">if</span> (geometries.length &gt; <span class="number">0</span>) output.geometries = geometries;</span><br><span class="line">                <span class="keyword">if</span> (materials.length &gt; <span class="number">0</span>) output.materials = materials;</span><br><span class="line">                <span class="keyword">if</span> (textures.length &gt; <span class="number">0</span>) output.textures = textures;</span><br><span class="line">                <span class="keyword">if</span> (images.length &gt; <span class="number">0</span>) output.images = images;</span><br><span class="line">                <span class="keyword">if</span> (shapes.length &gt; <span class="number">0</span>) output.shapes = shapes;</span><br><span class="line">                <span class="keyword">if</span> (skeletons.length &gt; <span class="number">0</span>) output.skeletons = skeletons;</span><br><span class="line">                <span class="keyword">if</span> (animations.length &gt; <span class="number">0</span>) output.animations = animations;</span><br><span class="line">                <span class="keyword">if</span> (nodes.length &gt; <span class="number">0</span>) output.nodes = nodes;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            output.object = object;</span><br><span class="line">            <span class="keyword">return</span> output; <span class="comment">// extract data from the cache hash</span></span><br><span class="line">            <span class="comment">// remove metadata on each item</span></span><br><span class="line">            <span class="comment">// and return as array</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">extractFromCache</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> values = [];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> cache) &#123;</span><br><span class="line">                    <span class="keyword">const</span> data = cache[key];</span><br><span class="line">                    <span class="keyword">delete</span> data.metadata;</span><br><span class="line">                    values.push(data);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> values;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params">recursive</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor().copy(<span class="built_in">this</span>, recursive);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source, recursive = <span class="literal">true</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = source.name;</span><br><span class="line">            <span class="built_in">this</span>.up.copy(source.up);</span><br><span class="line">            <span class="built_in">this</span>.position.copy(source.position);</span><br><span class="line">            <span class="built_in">this</span>.rotation.order = source.rotation.order;</span><br><span class="line">            <span class="built_in">this</span>.quaternion.copy(source.quaternion);</span><br><span class="line">            <span class="built_in">this</span>.scale.copy(source.scale);</span><br><span class="line">            <span class="built_in">this</span>.matrix.copy(source.matrix);</span><br><span class="line">            <span class="built_in">this</span>.matrixWorld.copy(source.matrixWorld);</span><br><span class="line">            <span class="built_in">this</span>.matrixAutoUpdate = source.matrixAutoUpdate;</span><br><span class="line">            <span class="built_in">this</span>.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;</span><br><span class="line">            <span class="built_in">this</span>.layers.mask = source.layers.mask;</span><br><span class="line">            <span class="built_in">this</span>.visible = source.visible;</span><br><span class="line">            <span class="built_in">this</span>.castShadow = source.castShadow;</span><br><span class="line">            <span class="built_in">this</span>.receiveShadow = source.receiveShadow;</span><br><span class="line">            <span class="built_in">this</span>.frustumCulled = source.frustumCulled;</span><br><span class="line">            <span class="built_in">this</span>.renderOrder = source.renderOrder;</span><br><span class="line">            <span class="built_in">this</span>.userData = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(source.userData));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (recursive === <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; source.children.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> child = source.children[i];</span><br><span class="line">                    <span class="built_in">this</span>.add(child.clone());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object3D.DefaultUp = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    Object3D.DefaultMatrixAutoUpdate = <span class="literal">true</span>;</span><br><span class="line">    Object3D.prototype.isObject3D = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _v0$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _v1$<span class="number">3</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _v2$<span class="number">2</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _v3$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vab = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vac = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vbc = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vap = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vbp = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vcp = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">a = <span class="keyword">new</span> Vector3(), b = <span class="keyword">new</span> Vector3(), c = <span class="keyword">new</span> Vector3()</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.a = a;</span><br><span class="line">            <span class="built_in">this</span>.b = b;</span><br><span class="line">            <span class="built_in">this</span>.c = c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">getNormal</span>(<span class="params">a, b, c, target</span>)</span> &#123;</span><br><span class="line">            target.subVectors(c, b);</span><br><span class="line"></span><br><span class="line">            _v0$<span class="number">1.</span>subVectors(a, b);</span><br><span class="line"></span><br><span class="line">            target.cross(_v0$<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">const</span> targetLengthSq = target.lengthSq();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (targetLengthSq &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> target.multiplyScalar(<span class="number">1</span> / <span class="built_in">Math</span>.sqrt(targetLengthSq));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> target.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="comment">// static/instance method to calculate barycentric coordinates</span></span><br><span class="line">        <span class="comment">// based on: http://www.blackpawn.com/texts/pointinpoly/default.html</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">getBarycoord</span>(<span class="params">point, a, b, c, target</span>)</span> &#123;</span><br><span class="line">            _v0$<span class="number">1.</span>subVectors(c, a);</span><br><span class="line"></span><br><span class="line">            _v1$<span class="number">3.</span>subVectors(b, a);</span><br><span class="line"></span><br><span class="line">            _v2$<span class="number">2.</span>subVectors(point, a);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> dot00 = _v0$<span class="number">1.</span>dot(_v0$<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> dot01 = _v0$<span class="number">1.</span>dot(_v1$<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> dot02 = _v0$<span class="number">1.</span>dot(_v2$<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> dot11 = _v1$<span class="number">3.</span>dot(_v1$<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> dot12 = _v1$<span class="number">3.</span>dot(_v2$<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> denom = dot00 * dot11 - dot01 * dot01; <span class="comment">// collinear or singular triangle</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (denom === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// arbitrary location outside of triangle?</span></span><br><span class="line">                <span class="comment">// not sure if this is the best idea, maybe should be returning undefined</span></span><br><span class="line">                <span class="keyword">return</span> target.set(-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> invDenom = <span class="number">1</span> / denom;</span><br><span class="line">            <span class="keyword">const</span> u = (dot11 * dot02 - dot01 * dot12) * invDenom;</span><br><span class="line">            <span class="keyword">const</span> v = (dot00 * dot12 - dot01 * dot02) * invDenom; <span class="comment">// barycentric coordinates must always sum to 1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> target.set(<span class="number">1</span> - u - v, v, u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">containsPoint</span>(<span class="params">point, a, b, c</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.getBarycoord(point, a, b, c, _v3$<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> _v3$<span class="number">1.</span>x &gt;= <span class="number">0</span> &amp;&amp; _v3$<span class="number">1.</span>y &gt;= <span class="number">0</span> &amp;&amp; _v3$<span class="number">1.</span>x + _v3$<span class="number">1.</span>y &lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">getUV</span>(<span class="params">point, p1, p2, p3, uv1, uv2, uv3, target</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.getBarycoord(point, p1, p2, p3, _v3$<span class="number">1</span>);</span><br><span class="line">            target.set(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            target.addScaledVector(uv1, _v3$<span class="number">1.</span>x);</span><br><span class="line">            target.addScaledVector(uv2, _v3$<span class="number">1.</span>y);</span><br><span class="line">            target.addScaledVector(uv3, _v3$<span class="number">1.</span>z);</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">isFrontFacing</span>(<span class="params">a, b, c, direction</span>)</span> &#123;</span><br><span class="line">            _v0$<span class="number">1.</span>subVectors(c, b);</span><br><span class="line"></span><br><span class="line">            _v1$<span class="number">3.</span>subVectors(a, b); <span class="comment">// strictly front facing</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> _v0$<span class="number">1.</span>cross(_v1$<span class="number">3</span>).dot(direction) &lt; <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">a, b, c</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.a.copy(a);</span><br><span class="line">            <span class="built_in">this</span>.b.copy(b);</span><br><span class="line">            <span class="built_in">this</span>.c.copy(c);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromPointsAndIndices</span>(<span class="params">points, i0, i1, i2</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.a.copy(points[i0]);</span><br><span class="line">            <span class="built_in">this</span>.b.copy(points[i1]);</span><br><span class="line">            <span class="built_in">this</span>.c.copy(points[i2]);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromAttributeAndIndices</span>(<span class="params">attribute, i0, i1, i2</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.a.fromBufferAttribute(attribute, i0);</span><br><span class="line">            <span class="built_in">this</span>.b.fromBufferAttribute(attribute, i1);</span><br><span class="line">            <span class="built_in">this</span>.c.fromBufferAttribute(attribute, i2);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor().copy(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">triangle</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.a.copy(triangle.a);</span><br><span class="line">            <span class="built_in">this</span>.b.copy(triangle.b);</span><br><span class="line">            <span class="built_in">this</span>.c.copy(triangle.c);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getArea</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            _v0$<span class="number">1.</span>subVectors(<span class="built_in">this</span>.c, <span class="built_in">this</span>.b);</span><br><span class="line"></span><br><span class="line">            _v1$<span class="number">3.</span>subVectors(<span class="built_in">this</span>.a, <span class="built_in">this</span>.b);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> _v0$<span class="number">1.</span>cross(_v1$<span class="number">3</span>).length() * <span class="number">0.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getMidpoint</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> target.addVectors(<span class="built_in">this</span>.a, <span class="built_in">this</span>.b).add(<span class="built_in">this</span>.c).multiplyScalar(<span class="number">1</span> / <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getNormal</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Triangle.getNormal(<span class="built_in">this</span>.a, <span class="built_in">this</span>.b, <span class="built_in">this</span>.c, target);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getPlane</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> target.setFromCoplanarPoints(<span class="built_in">this</span>.a, <span class="built_in">this</span>.b, <span class="built_in">this</span>.c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getBarycoord</span>(<span class="params">point, target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Triangle.getBarycoord(point, <span class="built_in">this</span>.a, <span class="built_in">this</span>.b, <span class="built_in">this</span>.c, target);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getUV</span>(<span class="params">point, uv1, uv2, uv3, target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Triangle.getUV(point, <span class="built_in">this</span>.a, <span class="built_in">this</span>.b, <span class="built_in">this</span>.c, uv1, uv2, uv3, target);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">containsPoint</span>(<span class="params">point</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Triangle.containsPoint(point, <span class="built_in">this</span>.a, <span class="built_in">this</span>.b, <span class="built_in">this</span>.c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">isFrontFacing</span>(<span class="params">direction</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Triangle.isFrontFacing(<span class="built_in">this</span>.a, <span class="built_in">this</span>.b, <span class="built_in">this</span>.c, direction);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectsBox</span>(<span class="params">box</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> box.intersectsTriangle(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">closestPointToPoint</span>(<span class="params">p, target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> a = <span class="built_in">this</span>.a,</span><br><span class="line">                b = <span class="built_in">this</span>.b,</span><br><span class="line">                c = <span class="built_in">this</span>.c;</span><br><span class="line">            <span class="keyword">let</span> v, w; <span class="comment">// algorithm thanks to Real-Time Collision Detection by Christer Ericson,</span></span><br><span class="line">            <span class="comment">// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,</span></span><br><span class="line">            <span class="comment">// under the accompanying license; see chapter 5.1.5 for detailed explanation.</span></span><br><span class="line">            <span class="comment">// basically, we&#x27;re distinguishing which of the voronoi regions of the triangle</span></span><br><span class="line">            <span class="comment">// the point lies in with the minimum amount of redundant computation.</span></span><br><span class="line"></span><br><span class="line">            _vab.subVectors(b, a);</span><br><span class="line"></span><br><span class="line">            _vac.subVectors(c, a);</span><br><span class="line"></span><br><span class="line">            _vap.subVectors(p, a);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> d1 = _vab.dot(_vap);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> d2 = _vac.dot(_vap);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (d1 &lt;= <span class="number">0</span> &amp;&amp; d2 &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// vertex region of A; barycentric coords (1, 0, 0)</span></span><br><span class="line">                <span class="keyword">return</span> target.copy(a);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _vbp.subVectors(p, b);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> d3 = _vab.dot(_vbp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> d4 = _vac.dot(_vbp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (d3 &gt;= <span class="number">0</span> &amp;&amp; d4 &lt;= d3) &#123;</span><br><span class="line">                <span class="comment">// vertex region of B; barycentric coords (0, 1, 0)</span></span><br><span class="line">                <span class="keyword">return</span> target.copy(b);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> vc = d1 * d4 - d3 * d2;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (vc &lt;= <span class="number">0</span> &amp;&amp; d1 &gt;= <span class="number">0</span> &amp;&amp; d3 &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                v = d1 / (d1 - d3); <span class="comment">// edge region of AB; barycentric coords (1-v, v, 0)</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> target.copy(a).addScaledVector(_vab, v);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _vcp.subVectors(p, c);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> d5 = _vab.dot(_vcp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> d6 = _vac.dot(_vcp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (d6 &gt;= <span class="number">0</span> &amp;&amp; d5 &lt;= d6) &#123;</span><br><span class="line">                <span class="comment">// vertex region of C; barycentric coords (0, 0, 1)</span></span><br><span class="line">                <span class="keyword">return</span> target.copy(c);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> vb = d5 * d2 - d1 * d6;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (vb &lt;= <span class="number">0</span> &amp;&amp; d2 &gt;= <span class="number">0</span> &amp;&amp; d6 &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                w = d2 / (d2 - d6); <span class="comment">// edge region of AC; barycentric coords (1-w, 0, w)</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> target.copy(a).addScaledVector(_vac, w);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> va = d3 * d6 - d5 * d4;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (va &lt;= <span class="number">0</span> &amp;&amp; d4 - d3 &gt;= <span class="number">0</span> &amp;&amp; d5 - d6 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                _vbc.subVectors(c, b);</span><br><span class="line"></span><br><span class="line">                w = (d4 - d3) / (d4 - d3 + (d5 - d6)); <span class="comment">// edge region of BC; barycentric coords (0, 1-w, w)</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> target.copy(b).addScaledVector(_vbc, w); <span class="comment">// edge region of BC</span></span><br><span class="line">            &#125; <span class="comment">// face region</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> denom = <span class="number">1</span> / (va + vb + vc); <span class="comment">// u = va * denom</span></span><br><span class="line"></span><br><span class="line">            v = vb * denom;</span><br><span class="line">            w = vc * denom;</span><br><span class="line">            <span class="keyword">return</span> target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">equals</span>(<span class="params">triangle</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> triangle.a.equals(<span class="built_in">this</span>.a) &amp;&amp; triangle.b.equals(<span class="built_in">this</span>.b) &amp;&amp; triangle.c.equals(<span class="built_in">this</span>.c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> materialId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Material</span> <span class="keyword">extends</span> <span class="title">EventDispatcher</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, <span class="string">&#x27;id&#x27;</span>, &#123;</span><br><span class="line">                <span class="attr">value</span>: materialId++</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">this</span>.uuid = generateUUID();</span><br><span class="line">            <span class="built_in">this</span>.name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;Material&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.fog = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.blending = NormalBlending;</span><br><span class="line">            <span class="built_in">this</span>.side = FrontSide;</span><br><span class="line">            <span class="built_in">this</span>.vertexColors = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.opacity = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.transparent = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.blendSrc = SrcAlphaFactor;</span><br><span class="line">            <span class="built_in">this</span>.blendDst = OneMinusSrcAlphaFactor;</span><br><span class="line">            <span class="built_in">this</span>.blendEquation = AddEquation;</span><br><span class="line">            <span class="built_in">this</span>.blendSrcAlpha = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.blendDstAlpha = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.blendEquationAlpha = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.depthFunc = LessEqualDepth;</span><br><span class="line">            <span class="built_in">this</span>.depthTest = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.depthWrite = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.stencilWriteMask = <span class="number">0xff</span>;</span><br><span class="line">            <span class="built_in">this</span>.stencilFunc = AlwaysStencilFunc;</span><br><span class="line">            <span class="built_in">this</span>.stencilRef = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.stencilFuncMask = <span class="number">0xff</span>;</span><br><span class="line">            <span class="built_in">this</span>.stencilFail = KeepStencilOp;</span><br><span class="line">            <span class="built_in">this</span>.stencilZFail = KeepStencilOp;</span><br><span class="line">            <span class="built_in">this</span>.stencilZPass = KeepStencilOp;</span><br><span class="line">            <span class="built_in">this</span>.stencilWrite = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.clippingPlanes = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.clipIntersection = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.clipShadows = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.shadowSide = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.colorWrite = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.precision = <span class="literal">null</span>; <span class="comment">// override the renderer&#x27;s default precision for this material</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.polygonOffset = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.polygonOffsetFactor = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.polygonOffsetUnits = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.dithering = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.alphaToCoverage = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.premultipliedAlpha = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.visible = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.toneMapped = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.userData = &#123;&#125;;</span><br><span class="line">            <span class="built_in">this</span>.version = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>._alphaTest = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">alphaTest</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._alphaTest;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">alphaTest</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._alphaTest &gt; <span class="number">0</span> !== value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.version++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._alphaTest = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">onBuild</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">onBeforeRender</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">onBeforeCompile</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">customProgramCacheKey</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.onBeforeCompile.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setValues</span>(<span class="params">values</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (values === <span class="literal">undefined</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> values) &#123;</span><br><span class="line">                <span class="keyword">const</span> newValue = values[key];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (newValue === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Material: \&#x27;&#x27;</span> + key + <span class="string">&#x27;\&#x27; parameter is undefined.&#x27;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="comment">// for backward compatibility if shading is set in the constructor</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key === <span class="string">&#x27;shading&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.&#x27;</span> + <span class="built_in">this</span>.type + <span class="string">&#x27;: .shading has been removed. Use the boolean .flatShading instead.&#x27;</span>);</span><br><span class="line">                    <span class="built_in">this</span>.flatShading = newValue === FlatShading ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> currentValue = <span class="built_in">this</span>[key];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (currentValue === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.&#x27;</span> + <span class="built_in">this</span>.type + <span class="string">&#x27;: \&#x27;&#x27;</span> + key + <span class="string">&#x27;\&#x27; is not a property of this material.&#x27;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (currentValue &amp;&amp; currentValue.isColor) &#123;</span><br><span class="line">                    currentValue.set(newValue);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentValue &amp;&amp; currentValue.isVector3 &amp;&amp; newValue &amp;&amp; newValue.isVector3) &#123;</span><br><span class="line">                    currentValue.copy(newValue);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>[key] = newValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params">meta</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> isRootObject = meta === <span class="literal">undefined</span> || <span class="keyword">typeof</span> meta === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isRootObject) &#123;</span><br><span class="line">                meta = &#123;</span><br><span class="line">                    <span class="attr">textures</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">images</span>: &#123;&#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> data = &#123;</span><br><span class="line">                <span class="attr">metadata</span>: &#123;</span><br><span class="line">                    <span class="attr">version</span>: <span class="number">4.5</span>,</span><br><span class="line">                    <span class="attr">type</span>: <span class="string">&#x27;Material&#x27;</span>,</span><br><span class="line">                    <span class="attr">generator</span>: <span class="string">&#x27;Material.toJSON&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;; <span class="comment">// standard Material serialization</span></span><br><span class="line"></span><br><span class="line">            data.uuid = <span class="built_in">this</span>.uuid;</span><br><span class="line">            data.type = <span class="built_in">this</span>.type;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.name !== <span class="string">&#x27;&#x27;</span>) data.name = <span class="built_in">this</span>.name;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.color &amp;&amp; <span class="built_in">this</span>.color.isColor) data.color = <span class="built_in">this</span>.color.getHex();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.roughness !== <span class="literal">undefined</span>) data.roughness = <span class="built_in">this</span>.roughness;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.metalness !== <span class="literal">undefined</span>) data.metalness = <span class="built_in">this</span>.metalness;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.sheen !== <span class="literal">undefined</span>) data.sheen = <span class="built_in">this</span>.sheen;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.sheenColor &amp;&amp; <span class="built_in">this</span>.sheenColor.isColor) data.sheenColor = <span class="built_in">this</span>.sheenColor.getHex();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.sheenRoughness !== <span class="literal">undefined</span>) data.sheenRoughness = <span class="built_in">this</span>.sheenRoughness;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.emissive &amp;&amp; <span class="built_in">this</span>.emissive.isColor) data.emissive = <span class="built_in">this</span>.emissive.getHex();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.emissiveIntensity &amp;&amp; <span class="built_in">this</span>.emissiveIntensity !== <span class="number">1</span>) data.emissiveIntensity = <span class="built_in">this</span>.emissiveIntensity;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.specular &amp;&amp; <span class="built_in">this</span>.specular.isColor) data.specular = <span class="built_in">this</span>.specular.getHex();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.specularIntensity !== <span class="literal">undefined</span>) data.specularIntensity = <span class="built_in">this</span>.specularIntensity;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.specularColor &amp;&amp; <span class="built_in">this</span>.specularColor.isColor) data.specularColor = <span class="built_in">this</span>.specularColor.getHex();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.shininess !== <span class="literal">undefined</span>) data.shininess = <span class="built_in">this</span>.shininess;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.clearcoat !== <span class="literal">undefined</span>) data.clearcoat = <span class="built_in">this</span>.clearcoat;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.clearcoatRoughness !== <span class="literal">undefined</span>) data.clearcoatRoughness = <span class="built_in">this</span>.clearcoatRoughness;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.clearcoatMap &amp;&amp; <span class="built_in">this</span>.clearcoatMap.isTexture) &#123;</span><br><span class="line">                data.clearcoatMap = <span class="built_in">this</span>.clearcoatMap.toJSON(meta).uuid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.clearcoatRoughnessMap &amp;&amp; <span class="built_in">this</span>.clearcoatRoughnessMap.isTexture) &#123;</span><br><span class="line">                data.clearcoatRoughnessMap = <span class="built_in">this</span>.clearcoatRoughnessMap.toJSON(meta).uuid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.clearcoatNormalMap &amp;&amp; <span class="built_in">this</span>.clearcoatNormalMap.isTexture) &#123;</span><br><span class="line">                data.clearcoatNormalMap = <span class="built_in">this</span>.clearcoatNormalMap.toJSON(meta).uuid;</span><br><span class="line">                data.clearcoatNormalScale = <span class="built_in">this</span>.clearcoatNormalScale.toArray();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.map &amp;&amp; <span class="built_in">this</span>.map.isTexture) data.map = <span class="built_in">this</span>.map.toJSON(meta).uuid;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.matcap &amp;&amp; <span class="built_in">this</span>.matcap.isTexture) data.matcap = <span class="built_in">this</span>.matcap.toJSON(meta).uuid;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.alphaMap &amp;&amp; <span class="built_in">this</span>.alphaMap.isTexture) data.alphaMap = <span class="built_in">this</span>.alphaMap.toJSON(meta).uuid;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.lightMap &amp;&amp; <span class="built_in">this</span>.lightMap.isTexture) &#123;</span><br><span class="line">                data.lightMap = <span class="built_in">this</span>.lightMap.toJSON(meta).uuid;</span><br><span class="line">                data.lightMapIntensity = <span class="built_in">this</span>.lightMapIntensity;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.aoMap &amp;&amp; <span class="built_in">this</span>.aoMap.isTexture) &#123;</span><br><span class="line">                data.aoMap = <span class="built_in">this</span>.aoMap.toJSON(meta).uuid;</span><br><span class="line">                data.aoMapIntensity = <span class="built_in">this</span>.aoMapIntensity;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.bumpMap &amp;&amp; <span class="built_in">this</span>.bumpMap.isTexture) &#123;</span><br><span class="line">                data.bumpMap = <span class="built_in">this</span>.bumpMap.toJSON(meta).uuid;</span><br><span class="line">                data.bumpScale = <span class="built_in">this</span>.bumpScale;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.normalMap &amp;&amp; <span class="built_in">this</span>.normalMap.isTexture) &#123;</span><br><span class="line">                data.normalMap = <span class="built_in">this</span>.normalMap.toJSON(meta).uuid;</span><br><span class="line">                data.normalMapType = <span class="built_in">this</span>.normalMapType;</span><br><span class="line">                data.normalScale = <span class="built_in">this</span>.normalScale.toArray();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.displacementMap &amp;&amp; <span class="built_in">this</span>.displacementMap.isTexture) &#123;</span><br><span class="line">                data.displacementMap = <span class="built_in">this</span>.displacementMap.toJSON(meta).uuid;</span><br><span class="line">                data.displacementScale = <span class="built_in">this</span>.displacementScale;</span><br><span class="line">                data.displacementBias = <span class="built_in">this</span>.displacementBias;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.roughnessMap &amp;&amp; <span class="built_in">this</span>.roughnessMap.isTexture) data.roughnessMap = <span class="built_in">this</span>.roughnessMap.toJSON(meta).uuid;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.metalnessMap &amp;&amp; <span class="built_in">this</span>.metalnessMap.isTexture) data.metalnessMap = <span class="built_in">this</span>.metalnessMap.toJSON(meta).uuid;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.emissiveMap &amp;&amp; <span class="built_in">this</span>.emissiveMap.isTexture) data.emissiveMap = <span class="built_in">this</span>.emissiveMap.toJSON(meta).uuid;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.specularMap &amp;&amp; <span class="built_in">this</span>.specularMap.isTexture) data.specularMap = <span class="built_in">this</span>.specularMap.toJSON(meta).uuid;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.specularIntensityMap &amp;&amp; <span class="built_in">this</span>.specularIntensityMap.isTexture) data.specularIntensityMap = <span class="built_in">this</span>.specularIntensityMap.toJSON(meta).uuid;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.specularColorMap &amp;&amp; <span class="built_in">this</span>.specularColorMap.isTexture) data.specularColorMap = <span class="built_in">this</span>.specularColorMap.toJSON(meta).uuid;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.envMap &amp;&amp; <span class="built_in">this</span>.envMap.isTexture) &#123;</span><br><span class="line">                data.envMap = <span class="built_in">this</span>.envMap.toJSON(meta).uuid;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.combine !== <span class="literal">undefined</span>) data.combine = <span class="built_in">this</span>.combine;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.envMapIntensity !== <span class="literal">undefined</span>) data.envMapIntensity = <span class="built_in">this</span>.envMapIntensity;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.reflectivity !== <span class="literal">undefined</span>) data.reflectivity = <span class="built_in">this</span>.reflectivity;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.refractionRatio !== <span class="literal">undefined</span>) data.refractionRatio = <span class="built_in">this</span>.refractionRatio;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.gradientMap &amp;&amp; <span class="built_in">this</span>.gradientMap.isTexture) &#123;</span><br><span class="line">                data.gradientMap = <span class="built_in">this</span>.gradientMap.toJSON(meta).uuid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.transmission !== <span class="literal">undefined</span>) data.transmission = <span class="built_in">this</span>.transmission;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.transmissionMap &amp;&amp; <span class="built_in">this</span>.transmissionMap.isTexture) data.transmissionMap = <span class="built_in">this</span>.transmissionMap.toJSON(meta).uuid;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.thickness !== <span class="literal">undefined</span>) data.thickness = <span class="built_in">this</span>.thickness;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.thicknessMap &amp;&amp; <span class="built_in">this</span>.thicknessMap.isTexture) data.thicknessMap = <span class="built_in">this</span>.thicknessMap.toJSON(meta).uuid;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.attenuationDistance !== <span class="literal">undefined</span>) data.attenuationDistance = <span class="built_in">this</span>.attenuationDistance;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.attenuationColor !== <span class="literal">undefined</span>) data.attenuationColor = <span class="built_in">this</span>.attenuationColor.getHex();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.size !== <span class="literal">undefined</span>) data.size = <span class="built_in">this</span>.size;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.shadowSide !== <span class="literal">null</span>) data.shadowSide = <span class="built_in">this</span>.shadowSide;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.sizeAttenuation !== <span class="literal">undefined</span>) data.sizeAttenuation = <span class="built_in">this</span>.sizeAttenuation;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.blending !== NormalBlending) data.blending = <span class="built_in">this</span>.blending;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.side !== FrontSide) data.side = <span class="built_in">this</span>.side;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.vertexColors) data.vertexColors = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.opacity &lt; <span class="number">1</span>) data.opacity = <span class="built_in">this</span>.opacity;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.transparent === <span class="literal">true</span>) data.transparent = <span class="built_in">this</span>.transparent;</span><br><span class="line">            data.depthFunc = <span class="built_in">this</span>.depthFunc;</span><br><span class="line">            data.depthTest = <span class="built_in">this</span>.depthTest;</span><br><span class="line">            data.depthWrite = <span class="built_in">this</span>.depthWrite;</span><br><span class="line">            data.colorWrite = <span class="built_in">this</span>.colorWrite;</span><br><span class="line">            data.stencilWrite = <span class="built_in">this</span>.stencilWrite;</span><br><span class="line">            data.stencilWriteMask = <span class="built_in">this</span>.stencilWriteMask;</span><br><span class="line">            data.stencilFunc = <span class="built_in">this</span>.stencilFunc;</span><br><span class="line">            data.stencilRef = <span class="built_in">this</span>.stencilRef;</span><br><span class="line">            data.stencilFuncMask = <span class="built_in">this</span>.stencilFuncMask;</span><br><span class="line">            data.stencilFail = <span class="built_in">this</span>.stencilFail;</span><br><span class="line">            data.stencilZFail = <span class="built_in">this</span>.stencilZFail;</span><br><span class="line">            data.stencilZPass = <span class="built_in">this</span>.stencilZPass; <span class="comment">// rotation (SpriteMaterial)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.rotation !== <span class="literal">undefined</span> &amp;&amp; <span class="built_in">this</span>.rotation !== <span class="number">0</span>) data.rotation = <span class="built_in">this</span>.rotation;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.polygonOffset === <span class="literal">true</span>) data.polygonOffset = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.polygonOffsetFactor !== <span class="number">0</span>) data.polygonOffsetFactor = <span class="built_in">this</span>.polygonOffsetFactor;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.polygonOffsetUnits !== <span class="number">0</span>) data.polygonOffsetUnits = <span class="built_in">this</span>.polygonOffsetUnits;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.linewidth !== <span class="literal">undefined</span> &amp;&amp; <span class="built_in">this</span>.linewidth !== <span class="number">1</span>) data.linewidth = <span class="built_in">this</span>.linewidth;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.dashSize !== <span class="literal">undefined</span>) data.dashSize = <span class="built_in">this</span>.dashSize;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.gapSize !== <span class="literal">undefined</span>) data.gapSize = <span class="built_in">this</span>.gapSize;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.scale !== <span class="literal">undefined</span>) data.scale = <span class="built_in">this</span>.scale;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.dithering === <span class="literal">true</span>) data.dithering = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.alphaTest &gt; <span class="number">0</span>) data.alphaTest = <span class="built_in">this</span>.alphaTest;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.alphaToCoverage === <span class="literal">true</span>) data.alphaToCoverage = <span class="built_in">this</span>.alphaToCoverage;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.premultipliedAlpha === <span class="literal">true</span>) data.premultipliedAlpha = <span class="built_in">this</span>.premultipliedAlpha;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.wireframe === <span class="literal">true</span>) data.wireframe = <span class="built_in">this</span>.wireframe;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.wireframeLinewidth &gt; <span class="number">1</span>) data.wireframeLinewidth = <span class="built_in">this</span>.wireframeLinewidth;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.wireframeLinecap !== <span class="string">&#x27;round&#x27;</span>) data.wireframeLinecap = <span class="built_in">this</span>.wireframeLinecap;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.wireframeLinejoin !== <span class="string">&#x27;round&#x27;</span>) data.wireframeLinejoin = <span class="built_in">this</span>.wireframeLinejoin;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.flatShading === <span class="literal">true</span>) data.flatShading = <span class="built_in">this</span>.flatShading;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.visible === <span class="literal">false</span>) data.visible = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.toneMapped === <span class="literal">false</span>) data.toneMapped = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.userData) !== <span class="string">&#x27;&#123;&#125;&#x27;</span>) data.userData = <span class="built_in">this</span>.userData; <span class="comment">// <span class="doctag">TODO:</span> Copied from Object3D.toJSON</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">extractFromCache</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> values = [];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> cache) &#123;</span><br><span class="line">                    <span class="keyword">const</span> data = cache[key];</span><br><span class="line">                    <span class="keyword">delete</span> data.metadata;</span><br><span class="line">                    values.push(data);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> values;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isRootObject) &#123;</span><br><span class="line">                <span class="keyword">const</span> textures = extractFromCache(meta.textures);</span><br><span class="line">                <span class="keyword">const</span> images = extractFromCache(meta.images);</span><br><span class="line">                <span class="keyword">if</span> (textures.length &gt; <span class="number">0</span>) data.textures = textures;</span><br><span class="line">                <span class="keyword">if</span> (images.length &gt; <span class="number">0</span>) data.images = images;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor().copy(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = source.name;</span><br><span class="line">            <span class="built_in">this</span>.fog = source.fog;</span><br><span class="line">            <span class="built_in">this</span>.blending = source.blending;</span><br><span class="line">            <span class="built_in">this</span>.side = source.side;</span><br><span class="line">            <span class="built_in">this</span>.vertexColors = source.vertexColors;</span><br><span class="line">            <span class="built_in">this</span>.opacity = source.opacity;</span><br><span class="line">            <span class="built_in">this</span>.transparent = source.transparent;</span><br><span class="line">            <span class="built_in">this</span>.blendSrc = source.blendSrc;</span><br><span class="line">            <span class="built_in">this</span>.blendDst = source.blendDst;</span><br><span class="line">            <span class="built_in">this</span>.blendEquation = source.blendEquation;</span><br><span class="line">            <span class="built_in">this</span>.blendSrcAlpha = source.blendSrcAlpha;</span><br><span class="line">            <span class="built_in">this</span>.blendDstAlpha = source.blendDstAlpha;</span><br><span class="line">            <span class="built_in">this</span>.blendEquationAlpha = source.blendEquationAlpha;</span><br><span class="line">            <span class="built_in">this</span>.depthFunc = source.depthFunc;</span><br><span class="line">            <span class="built_in">this</span>.depthTest = source.depthTest;</span><br><span class="line">            <span class="built_in">this</span>.depthWrite = source.depthWrite;</span><br><span class="line">            <span class="built_in">this</span>.stencilWriteMask = source.stencilWriteMask;</span><br><span class="line">            <span class="built_in">this</span>.stencilFunc = source.stencilFunc;</span><br><span class="line">            <span class="built_in">this</span>.stencilRef = source.stencilRef;</span><br><span class="line">            <span class="built_in">this</span>.stencilFuncMask = source.stencilFuncMask;</span><br><span class="line">            <span class="built_in">this</span>.stencilFail = source.stencilFail;</span><br><span class="line">            <span class="built_in">this</span>.stencilZFail = source.stencilZFail;</span><br><span class="line">            <span class="built_in">this</span>.stencilZPass = source.stencilZPass;</span><br><span class="line">            <span class="built_in">this</span>.stencilWrite = source.stencilWrite;</span><br><span class="line">            <span class="keyword">const</span> srcPlanes = source.clippingPlanes;</span><br><span class="line">            <span class="keyword">let</span> dstPlanes = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (srcPlanes !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> n = srcPlanes.length;</span><br><span class="line">                dstPlanes = <span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i !== n; ++i) &#123;</span><br><span class="line">                    dstPlanes[i] = srcPlanes[i].clone();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.clippingPlanes = dstPlanes;</span><br><span class="line">            <span class="built_in">this</span>.clipIntersection = source.clipIntersection;</span><br><span class="line">            <span class="built_in">this</span>.clipShadows = source.clipShadows;</span><br><span class="line">            <span class="built_in">this</span>.shadowSide = source.shadowSide;</span><br><span class="line">            <span class="built_in">this</span>.colorWrite = source.colorWrite;</span><br><span class="line">            <span class="built_in">this</span>.precision = source.precision;</span><br><span class="line">            <span class="built_in">this</span>.polygonOffset = source.polygonOffset;</span><br><span class="line">            <span class="built_in">this</span>.polygonOffsetFactor = source.polygonOffsetFactor;</span><br><span class="line">            <span class="built_in">this</span>.polygonOffsetUnits = source.polygonOffsetUnits;</span><br><span class="line">            <span class="built_in">this</span>.dithering = source.dithering;</span><br><span class="line">            <span class="built_in">this</span>.alphaTest = source.alphaTest;</span><br><span class="line">            <span class="built_in">this</span>.alphaToCoverage = source.alphaToCoverage;</span><br><span class="line">            <span class="built_in">this</span>.premultipliedAlpha = source.premultipliedAlpha;</span><br><span class="line">            <span class="built_in">this</span>.visible = source.visible;</span><br><span class="line">            <span class="built_in">this</span>.toneMapped = source.toneMapped;</span><br><span class="line">            <span class="built_in">this</span>.userData = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(source.userData));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dispose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.dispatchEvent(&#123;</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;dispose&#x27;</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">needsUpdate</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value === <span class="literal">true</span>) <span class="built_in">this</span>.version++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Material.prototype.isMaterial = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    Material.fromType = <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">        /*<span class="title">type</span>*/</span></span><br><span class="line"><span class="function">        (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Behavior added in Materials.js</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MeshBasicMaterial</span> <span class="keyword">extends</span> <span class="title">Material</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameters</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;MeshBasicMaterial&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.color = <span class="keyword">new</span> Color(<span class="number">0xffffff</span>); <span class="comment">// emissive</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.map = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.lightMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.lightMapIntensity = <span class="number">1.0</span>;</span><br><span class="line">            <span class="built_in">this</span>.aoMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.aoMapIntensity = <span class="number">1.0</span>;</span><br><span class="line">            <span class="built_in">this</span>.specularMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.alphaMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.envMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.combine = MultiplyOperation;</span><br><span class="line">            <span class="built_in">this</span>.reflectivity = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.refractionRatio = <span class="number">0.98</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframe = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinewidth = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinecap = <span class="string">&#x27;round&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinejoin = <span class="string">&#x27;round&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.setValues(parameters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.color.copy(source.color);</span><br><span class="line">            <span class="built_in">this</span>.map = source.map;</span><br><span class="line">            <span class="built_in">this</span>.lightMap = source.lightMap;</span><br><span class="line">            <span class="built_in">this</span>.lightMapIntensity = source.lightMapIntensity;</span><br><span class="line">            <span class="built_in">this</span>.aoMap = source.aoMap;</span><br><span class="line">            <span class="built_in">this</span>.aoMapIntensity = source.aoMapIntensity;</span><br><span class="line">            <span class="built_in">this</span>.specularMap = source.specularMap;</span><br><span class="line">            <span class="built_in">this</span>.alphaMap = source.alphaMap;</span><br><span class="line">            <span class="built_in">this</span>.envMap = source.envMap;</span><br><span class="line">            <span class="built_in">this</span>.combine = source.combine;</span><br><span class="line">            <span class="built_in">this</span>.reflectivity = source.reflectivity;</span><br><span class="line">            <span class="built_in">this</span>.refractionRatio = source.refractionRatio;</span><br><span class="line">            <span class="built_in">this</span>.wireframe = source.wireframe;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinewidth = source.wireframeLinewidth;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinecap = source.wireframeLinecap;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinejoin = source.wireframeLinejoin;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MeshBasicMaterial.prototype.isMeshBasicMaterial = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vector$<span class="number">9</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vector2$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector2();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BufferAttribute</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array, itemSize, normalized</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(array)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;THREE.BufferAttribute: array should be a Typed Array.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.array = array;</span><br><span class="line">            <span class="built_in">this</span>.itemSize = itemSize;</span><br><span class="line">            <span class="built_in">this</span>.count = array !== <span class="literal">undefined</span> ? array.length / itemSize : <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.normalized = normalized === <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.usage = StaticDrawUsage;</span><br><span class="line">            <span class="built_in">this</span>.updateRange = &#123;</span><br><span class="line">                <span class="attr">offset</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">count</span>: -<span class="number">1</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">this</span>.version = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">onUploadCallback</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">needsUpdate</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value === <span class="literal">true</span>) <span class="built_in">this</span>.version++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setUsage</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.usage = value;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = source.name;</span><br><span class="line">            <span class="built_in">this</span>.array = <span class="keyword">new</span> source.array.constructor(source.array);</span><br><span class="line">            <span class="built_in">this</span>.itemSize = source.itemSize;</span><br><span class="line">            <span class="built_in">this</span>.count = source.count;</span><br><span class="line">            <span class="built_in">this</span>.normalized = source.normalized;</span><br><span class="line">            <span class="built_in">this</span>.usage = source.usage;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copyAt</span>(<span class="params">index1, attribute, index2</span>)</span> &#123;</span><br><span class="line">            index1 *= <span class="built_in">this</span>.itemSize;</span><br><span class="line">            index2 *= attribute.itemSize;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">this</span>.itemSize; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.array[index1 + i] = attribute.array[index2 + i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copyArray</span>(<span class="params">array</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.array.set(array);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copyColorsArray</span>(<span class="params">colors</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> array = <span class="built_in">this</span>.array;</span><br><span class="line">            <span class="keyword">let</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = colors.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">let</span> color = colors[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (color === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.BufferAttribute.copyColorsArray(): color is undefined&#x27;</span>, i);</span><br><span class="line">                    color = <span class="keyword">new</span> Color();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                array[offset++] = color.r;</span><br><span class="line">                array[offset++] = color.g;</span><br><span class="line">                array[offset++] = color.b;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copyVector2sArray</span>(<span class="params">vectors</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> array = <span class="built_in">this</span>.array;</span><br><span class="line">            <span class="keyword">let</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = vectors.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">let</span> vector = vectors[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (vector === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.BufferAttribute.copyVector2sArray(): vector is undefined&#x27;</span>, i);</span><br><span class="line">                    vector = <span class="keyword">new</span> Vector2();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                array[offset++] = vector.x;</span><br><span class="line">                array[offset++] = vector.y;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copyVector3sArray</span>(<span class="params">vectors</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> array = <span class="built_in">this</span>.array;</span><br><span class="line">            <span class="keyword">let</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = vectors.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">let</span> vector = vectors[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (vector === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.BufferAttribute.copyVector3sArray(): vector is undefined&#x27;</span>, i);</span><br><span class="line">                    vector = <span class="keyword">new</span> Vector3();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                array[offset++] = vector.x;</span><br><span class="line">                array[offset++] = vector.y;</span><br><span class="line">                array[offset++] = vector.z;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copyVector4sArray</span>(<span class="params">vectors</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> array = <span class="built_in">this</span>.array;</span><br><span class="line">            <span class="keyword">let</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = vectors.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">let</span> vector = vectors[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (vector === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.BufferAttribute.copyVector4sArray(): vector is undefined&#x27;</span>, i);</span><br><span class="line">                    vector = <span class="keyword">new</span> Vector4();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                array[offset++] = vector.x;</span><br><span class="line">                array[offset++] = vector.y;</span><br><span class="line">                array[offset++] = vector.z;</span><br><span class="line">                array[offset++] = vector.w;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">applyMatrix3</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.itemSize === <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">this</span>.count; i &lt; l; i++) &#123;</span><br><span class="line">                    _vector2$<span class="number">1.</span>fromBufferAttribute(<span class="built_in">this</span>, i);</span><br><span class="line"></span><br><span class="line">                    _vector2$<span class="number">1.</span>applyMatrix3(m);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">this</span>.setXY(i, _vector2$<span class="number">1.</span>x, _vector2$<span class="number">1.</span>y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.itemSize === <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">this</span>.count; i &lt; l; i++) &#123;</span><br><span class="line">                    _vector$<span class="number">9.</span>fromBufferAttribute(<span class="built_in">this</span>, i);</span><br><span class="line"></span><br><span class="line">                    _vector$<span class="number">9.</span>applyMatrix3(m);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">this</span>.setXYZ(i, _vector$<span class="number">9.</span>x, _vector$<span class="number">9.</span>y, _vector$<span class="number">9.</span>z);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">applyMatrix4</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">this</span>.count; i &lt; l; i++) &#123;</span><br><span class="line">                _vector$<span class="number">9.</span>fromBufferAttribute(<span class="built_in">this</span>, i);</span><br><span class="line"></span><br><span class="line">                _vector$<span class="number">9.</span>applyMatrix4(m);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.setXYZ(i, _vector$<span class="number">9.</span>x, _vector$<span class="number">9.</span>y, _vector$<span class="number">9.</span>z);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">applyNormalMatrix</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">this</span>.count; i &lt; l; i++) &#123;</span><br><span class="line">                _vector$<span class="number">9.</span>fromBufferAttribute(<span class="built_in">this</span>, i);</span><br><span class="line"></span><br><span class="line">                _vector$<span class="number">9.</span>applyNormalMatrix(m);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.setXYZ(i, _vector$<span class="number">9.</span>x, _vector$<span class="number">9.</span>y, _vector$<span class="number">9.</span>z);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">transformDirection</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">this</span>.count; i &lt; l; i++) &#123;</span><br><span class="line">                _vector$<span class="number">9.</span>fromBufferAttribute(<span class="built_in">this</span>, i);</span><br><span class="line"></span><br><span class="line">                _vector$<span class="number">9.</span>transformDirection(m);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.setXYZ(i, _vector$<span class="number">9.</span>x, _vector$<span class="number">9.</span>y, _vector$<span class="number">9.</span>z);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">value, offset = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.array.set(value, offset);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getX</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.array[index * <span class="built_in">this</span>.itemSize];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setX</span>(<span class="params">index, x</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.array[index * <span class="built_in">this</span>.itemSize] = x;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getY</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.array[index * <span class="built_in">this</span>.itemSize + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setY</span>(<span class="params">index, y</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.array[index * <span class="built_in">this</span>.itemSize + <span class="number">1</span>] = y;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getZ</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.array[index * <span class="built_in">this</span>.itemSize + <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setZ</span>(<span class="params">index, z</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.array[index * <span class="built_in">this</span>.itemSize + <span class="number">2</span>] = z;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getW</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.array[index * <span class="built_in">this</span>.itemSize + <span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setW</span>(<span class="params">index, w</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.array[index * <span class="built_in">this</span>.itemSize + <span class="number">3</span>] = w;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setXY</span>(<span class="params">index, x, y</span>)</span> &#123;</span><br><span class="line">            index *= <span class="built_in">this</span>.itemSize;</span><br><span class="line">            <span class="built_in">this</span>.array[index + <span class="number">0</span>] = x;</span><br><span class="line">            <span class="built_in">this</span>.array[index + <span class="number">1</span>] = y;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setXYZ</span>(<span class="params">index, x, y, z</span>)</span> &#123;</span><br><span class="line">            index *= <span class="built_in">this</span>.itemSize;</span><br><span class="line">            <span class="built_in">this</span>.array[index + <span class="number">0</span>] = x;</span><br><span class="line">            <span class="built_in">this</span>.array[index + <span class="number">1</span>] = y;</span><br><span class="line">            <span class="built_in">this</span>.array[index + <span class="number">2</span>] = z;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setXYZW</span>(<span class="params">index, x, y, z, w</span>)</span> &#123;</span><br><span class="line">            index *= <span class="built_in">this</span>.itemSize;</span><br><span class="line">            <span class="built_in">this</span>.array[index + <span class="number">0</span>] = x;</span><br><span class="line">            <span class="built_in">this</span>.array[index + <span class="number">1</span>] = y;</span><br><span class="line">            <span class="built_in">this</span>.array[index + <span class="number">2</span>] = z;</span><br><span class="line">            <span class="built_in">this</span>.array[index + <span class="number">3</span>] = w;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">onUpload</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.onUploadCallback = callback;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor(<span class="built_in">this</span>.array, <span class="built_in">this</span>.itemSize).copy(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = &#123;</span><br><span class="line">                <span class="attr">itemSize</span>: <span class="built_in">this</span>.itemSize,</span><br><span class="line">                <span class="attr">type</span>: <span class="built_in">this</span>.array.constructor.name,</span><br><span class="line">                <span class="attr">array</span>: <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">this</span>.array),</span><br><span class="line">                <span class="attr">normalized</span>: <span class="built_in">this</span>.normalized</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.name !== <span class="string">&#x27;&#x27;</span>) data.name = <span class="built_in">this</span>.name;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.usage !== StaticDrawUsage) data.usage = <span class="built_in">this</span>.usage;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.updateRange.offset !== <span class="number">0</span> || <span class="built_in">this</span>.updateRange.count !== -<span class="number">1</span>) data.updateRange = <span class="built_in">this</span>.updateRange;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BufferAttribute.prototype.isBufferAttribute = <span class="literal">true</span>; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Int8BufferAttribute</span> <span class="keyword">extends</span> <span class="title">BufferAttribute</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array, itemSize, normalized</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="keyword">new</span> <span class="built_in">Int8Array</span>(array), itemSize, normalized);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Uint8BufferAttribute</span> <span class="keyword">extends</span> <span class="title">BufferAttribute</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array, itemSize, normalized</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(array), itemSize, normalized);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Uint8ClampedBufferAttribute</span> <span class="keyword">extends</span> <span class="title">BufferAttribute</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array, itemSize, normalized</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="keyword">new</span> <span class="built_in">Uint8ClampedArray</span>(array), itemSize, normalized);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Int16BufferAttribute</span> <span class="keyword">extends</span> <span class="title">BufferAttribute</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array, itemSize, normalized</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="keyword">new</span> <span class="built_in">Int16Array</span>(array), itemSize, normalized);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Uint16BufferAttribute</span> <span class="keyword">extends</span> <span class="title">BufferAttribute</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array, itemSize, normalized</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="keyword">new</span> <span class="built_in">Uint16Array</span>(array), itemSize, normalized);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Int32BufferAttribute</span> <span class="keyword">extends</span> <span class="title">BufferAttribute</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array, itemSize, normalized</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="keyword">new</span> <span class="built_in">Int32Array</span>(array), itemSize, normalized);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Uint32BufferAttribute</span> <span class="keyword">extends</span> <span class="title">BufferAttribute</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array, itemSize, normalized</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="keyword">new</span> <span class="built_in">Uint32Array</span>(array), itemSize, normalized);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Float16BufferAttribute</span> <span class="keyword">extends</span> <span class="title">BufferAttribute</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array, itemSize, normalized</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="keyword">new</span> <span class="built_in">Uint16Array</span>(array), itemSize, normalized);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Float16BufferAttribute.prototype.isFloat16BufferAttribute = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Float32BufferAttribute</span> <span class="keyword">extends</span> <span class="title">BufferAttribute</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array, itemSize, normalized</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="keyword">new</span> <span class="built_in">Float32Array</span>(array), itemSize, normalized);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Float64BufferAttribute</span> <span class="keyword">extends</span> <span class="title">BufferAttribute</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array, itemSize, normalized</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="keyword">new</span> <span class="built_in">Float64Array</span>(array), itemSize, normalized);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> _id$<span class="number">1</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _m1 = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Matrix4();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _obj = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Object3D();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _offset = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _box$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Box3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _boxMorphTargets = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Box3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vector$<span class="number">8</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BufferGeometry</span> <span class="keyword">extends</span> <span class="title">EventDispatcher</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, <span class="string">&#x27;id&#x27;</span>, &#123;</span><br><span class="line">                <span class="attr">value</span>: _id$<span class="number">1</span>++</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">this</span>.uuid = generateUUID();</span><br><span class="line">            <span class="built_in">this</span>.name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;BufferGeometry&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.index = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.attributes = &#123;&#125;;</span><br><span class="line">            <span class="built_in">this</span>.morphAttributes = &#123;&#125;;</span><br><span class="line">            <span class="built_in">this</span>.morphTargetsRelative = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.groups = [];</span><br><span class="line">            <span class="built_in">this</span>.boundingBox = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.boundingSphere = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.drawRange = &#123;</span><br><span class="line">                <span class="attr">start</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">count</span>: <span class="literal">Infinity</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">this</span>.userData = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getIndex</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setIndex</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(index)) &#123;</span><br><span class="line">                <span class="built_in">this</span>.index = <span class="keyword">new</span> (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.index = index;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getAttribute</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.attributes[name];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setAttribute</span>(<span class="params">name, attribute</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.attributes[name] = attribute;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">deleteAttribute</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>.attributes[name];</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">hasAttribute</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.attributes[name] !== <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">addGroup</span>(<span class="params">start, count, materialIndex = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.groups.push(&#123;</span><br><span class="line">                <span class="attr">start</span>: start,</span><br><span class="line">                <span class="attr">count</span>: count,</span><br><span class="line">                <span class="attr">materialIndex</span>: materialIndex</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clearGroups</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.groups = [];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setDrawRange</span>(<span class="params">start, count</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.drawRange.start = start;</span><br><span class="line">            <span class="built_in">this</span>.drawRange.count = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">applyMatrix4</span>(<span class="params">matrix</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> position = <span class="built_in">this</span>.attributes.position;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (position !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                position.applyMatrix4(matrix);</span><br><span class="line">                position.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> normal = <span class="built_in">this</span>.attributes.normal;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (normal !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> normalMatrix = <span class="keyword">new</span> Matrix3().getNormalMatrix(matrix);</span><br><span class="line">                normal.applyNormalMatrix(normalMatrix);</span><br><span class="line">                normal.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> tangent = <span class="built_in">this</span>.attributes.tangent;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tangent !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                tangent.transformDirection(matrix);</span><br><span class="line">                tangent.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.boundingBox !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.computeBoundingBox();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.boundingSphere !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.computeBoundingSphere();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">applyQuaternion</span>(<span class="params">q</span>)</span> &#123;</span><br><span class="line">            _m1.makeRotationFromQuaternion(q);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.applyMatrix4(_m1);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">rotateX</span>(<span class="params">angle</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// rotate geometry around world x-axis</span></span><br><span class="line">            _m1.makeRotationX(angle);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.applyMatrix4(_m1);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">rotateY</span>(<span class="params">angle</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// rotate geometry around world y-axis</span></span><br><span class="line">            _m1.makeRotationY(angle);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.applyMatrix4(_m1);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">rotateZ</span>(<span class="params">angle</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// rotate geometry around world z-axis</span></span><br><span class="line">            _m1.makeRotationZ(angle);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.applyMatrix4(_m1);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">translate</span>(<span class="params">x, y, z</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// translate geometry</span></span><br><span class="line">            _m1.makeTranslation(x, y, z);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.applyMatrix4(_m1);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">scale</span>(<span class="params">x, y, z</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// scale geometry</span></span><br><span class="line">            _m1.makeScale(x, y, z);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.applyMatrix4(_m1);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">lookAt</span>(<span class="params">vector</span>)</span> &#123;</span><br><span class="line">            _obj.lookAt(vector);</span><br><span class="line"></span><br><span class="line">            _obj.updateMatrix();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.applyMatrix4(_obj.matrix);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">center</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.computeBoundingBox();</span><br><span class="line">            <span class="built_in">this</span>.boundingBox.getCenter(_offset).negate();</span><br><span class="line">            <span class="built_in">this</span>.translate(_offset.x, _offset.y, _offset.z);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromPoints</span>(<span class="params">points</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> position = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = points.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> point = points[i];</span><br><span class="line">                position.push(point.x, point.y, point.z || <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(position, <span class="number">3</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">computeBoundingBox</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.boundingBox === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.boundingBox = <span class="keyword">new</span> Box3();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> position = <span class="built_in">this</span>.attributes.position;</span><br><span class="line">            <span class="keyword">const</span> morphAttributesPosition = <span class="built_in">this</span>.morphAttributes.position;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (position &amp;&amp; position.isGLBufferAttribute) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set &quot;mesh.frustumCulled&quot; to &quot;false&quot;.&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">                <span class="built_in">this</span>.boundingBox.set(<span class="keyword">new</span> Vector3(-<span class="literal">Infinity</span>, -<span class="literal">Infinity</span>, -<span class="literal">Infinity</span>), <span class="keyword">new</span> Vector3(+<span class="literal">Infinity</span>, +<span class="literal">Infinity</span>, +<span class="literal">Infinity</span>));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (position !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.boundingBox.setFromBufferAttribute(position); <span class="comment">// process morph attributes if present</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (morphAttributesPosition) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = morphAttributesPosition.length; i &lt; il; i++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> morphAttribute = morphAttributesPosition[i];</span><br><span class="line"></span><br><span class="line">                        _box$<span class="number">1.</span>setFromBufferAttribute(morphAttribute);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.morphTargetsRelative) &#123;</span><br><span class="line">                            _vector$<span class="number">8.</span>addVectors(<span class="built_in">this</span>.boundingBox.min, _box$<span class="number">1.</span>min);</span><br><span class="line"></span><br><span class="line">                            <span class="built_in">this</span>.boundingBox.expandByPoint(_vector$<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">                            _vector$<span class="number">8.</span>addVectors(<span class="built_in">this</span>.boundingBox.max, _box$<span class="number">1.</span>max);</span><br><span class="line"></span><br><span class="line">                            <span class="built_in">this</span>.boundingBox.expandByPoint(_vector$<span class="number">8</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="built_in">this</span>.boundingBox.expandByPoint(_box$<span class="number">1.</span>min);</span><br><span class="line">                            <span class="built_in">this</span>.boundingBox.expandByPoint(_box$<span class="number">1.</span>max);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.boundingBox.makeEmpty();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isNaN</span>(<span class="built_in">this</span>.boundingBox.min.x) || <span class="built_in">isNaN</span>(<span class="built_in">this</span>.boundingBox.min.y) || <span class="built_in">isNaN</span>(<span class="built_in">this</span>.boundingBox.min.z)) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The &quot;position&quot; attribute is likely to have NaN values.&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">computeBoundingSphere</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.boundingSphere === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.boundingSphere = <span class="keyword">new</span> Sphere();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> position = <span class="built_in">this</span>.attributes.position;</span><br><span class="line">            <span class="keyword">const</span> morphAttributesPosition = <span class="built_in">this</span>.morphAttributes.position;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (position &amp;&amp; position.isGLBufferAttribute) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set &quot;mesh.frustumCulled&quot; to &quot;false&quot;.&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">                <span class="built_in">this</span>.boundingSphere.set(<span class="keyword">new</span> Vector3(), <span class="literal">Infinity</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (position) &#123;</span><br><span class="line">                <span class="comment">// first, find the center of the bounding sphere</span></span><br><span class="line">                <span class="keyword">const</span> center = <span class="built_in">this</span>.boundingSphere.center;</span><br><span class="line"></span><br><span class="line">                _box$<span class="number">1.</span>setFromBufferAttribute(position); <span class="comment">// process morph attributes if present</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (morphAttributesPosition) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = morphAttributesPosition.length; i &lt; il; i++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> morphAttribute = morphAttributesPosition[i];</span><br><span class="line"></span><br><span class="line">                        _boxMorphTargets.setFromBufferAttribute(morphAttribute);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.morphTargetsRelative) &#123;</span><br><span class="line">                            _vector$<span class="number">8.</span>addVectors(_box$<span class="number">1.</span>min, _boxMorphTargets.min);</span><br><span class="line"></span><br><span class="line">                            _box$<span class="number">1.</span>expandByPoint(_vector$<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">                            _vector$<span class="number">8.</span>addVectors(_box$<span class="number">1.</span>max, _boxMorphTargets.max);</span><br><span class="line"></span><br><span class="line">                            _box$<span class="number">1.</span>expandByPoint(_vector$<span class="number">8</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            _box$<span class="number">1.</span>expandByPoint(_boxMorphTargets.min);</span><br><span class="line"></span><br><span class="line">                            _box$<span class="number">1.</span>expandByPoint(_boxMorphTargets.max);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                _box$<span class="number">1.</span>getCenter(center); <span class="comment">// second, try to find a boundingSphere with a radius smaller than the</span></span><br><span class="line">                <span class="comment">// boundingSphere of the boundingBox: sqrt(3) smaller in the best case</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> maxRadiusSq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = position.count; i &lt; il; i++) &#123;</span><br><span class="line">                    _vector$<span class="number">8.</span>fromBufferAttribute(position, i);</span><br><span class="line"></span><br><span class="line">                    maxRadiusSq = <span class="built_in">Math</span>.max(maxRadiusSq, center.distanceToSquared(_vector$<span class="number">8</span>));</span><br><span class="line">                &#125; <span class="comment">// process morph attributes if present</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (morphAttributesPosition) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = morphAttributesPosition.length; i &lt; il; i++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> morphAttribute = morphAttributesPosition[i];</span><br><span class="line">                        <span class="keyword">const</span> morphTargetsRelative = <span class="built_in">this</span>.morphTargetsRelative;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, jl = morphAttribute.count; j &lt; jl; j++) &#123;</span><br><span class="line">                            _vector$<span class="number">8.</span>fromBufferAttribute(morphAttribute, j);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (morphTargetsRelative) &#123;</span><br><span class="line">                                _offset.fromBufferAttribute(position, j);</span><br><span class="line"></span><br><span class="line">                                _vector$<span class="number">8.</span>add(_offset);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            maxRadiusSq = <span class="built_in">Math</span>.max(maxRadiusSq, center.distanceToSquared(_vector$<span class="number">8</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.boundingSphere.radius = <span class="built_in">Math</span>.sqrt(maxRadiusSq);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isNaN</span>(<span class="built_in">this</span>.boundingSphere.radius)) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The &quot;position&quot; attribute is likely to have NaN values.&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">computeTangents</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> index = <span class="built_in">this</span>.index;</span><br><span class="line">            <span class="keyword">const</span> attributes = <span class="built_in">this</span>.attributes; <span class="comment">// based on http://www.terathon.com/code/tangent.html</span></span><br><span class="line">            <span class="comment">// (per vertex tangents)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index === <span class="literal">null</span> || attributes.position === <span class="literal">undefined</span> || attributes.normal === <span class="literal">undefined</span> || attributes.uv === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> indices = index.array;</span><br><span class="line">            <span class="keyword">const</span> positions = attributes.position.array;</span><br><span class="line">            <span class="keyword">const</span> normals = attributes.normal.array;</span><br><span class="line">            <span class="keyword">const</span> uvs = attributes.uv.array;</span><br><span class="line">            <span class="keyword">const</span> nVertices = positions.length / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.hasAttribute(<span class="string">&#x27;tangent&#x27;</span>) === <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;tangent&#x27;</span>, <span class="keyword">new</span> BufferAttribute(<span class="keyword">new</span> <span class="built_in">Float32Array</span>(<span class="number">4</span> * nVertices), <span class="number">4</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> tangents = <span class="built_in">this</span>.getAttribute(<span class="string">&#x27;tangent&#x27;</span>).array;</span><br><span class="line">            <span class="keyword">const</span> tan1 = [],</span><br><span class="line">                tan2 = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nVertices; i++) &#123;</span><br><span class="line">                tan1[i] = <span class="keyword">new</span> Vector3();</span><br><span class="line">                tan2[i] = <span class="keyword">new</span> Vector3();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> vA = <span class="keyword">new</span> Vector3(),</span><br><span class="line">                vB = <span class="keyword">new</span> Vector3(),</span><br><span class="line">                vC = <span class="keyword">new</span> Vector3(),</span><br><span class="line">                uvA = <span class="keyword">new</span> Vector2(),</span><br><span class="line">                uvB = <span class="keyword">new</span> Vector2(),</span><br><span class="line">                uvC = <span class="keyword">new</span> Vector2(),</span><br><span class="line">                sdir = <span class="keyword">new</span> Vector3(),</span><br><span class="line">                tdir = <span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">handleTriangle</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">                vA.fromArray(positions, a * <span class="number">3</span>);</span><br><span class="line">                vB.fromArray(positions, b * <span class="number">3</span>);</span><br><span class="line">                vC.fromArray(positions, c * <span class="number">3</span>);</span><br><span class="line">                uvA.fromArray(uvs, a * <span class="number">2</span>);</span><br><span class="line">                uvB.fromArray(uvs, b * <span class="number">2</span>);</span><br><span class="line">                uvC.fromArray(uvs, c * <span class="number">2</span>);</span><br><span class="line">                vB.sub(vA);</span><br><span class="line">                vC.sub(vA);</span><br><span class="line">                uvB.sub(uvA);</span><br><span class="line">                uvC.sub(uvA);</span><br><span class="line">                <span class="keyword">const</span> r = <span class="number">1.0</span> / (uvB.x * uvC.y - uvC.x * uvB.y); <span class="comment">// silently ignore degenerate uv triangles having coincident or colinear vertices</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">isFinite</span>(r)) <span class="keyword">return</span>;</span><br><span class="line">                sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);</span><br><span class="line">                tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);</span><br><span class="line">                tan1[a].add(sdir);</span><br><span class="line">                tan1[b].add(sdir);</span><br><span class="line">                tan1[c].add(sdir);</span><br><span class="line">                tan2[a].add(tdir);</span><br><span class="line">                tan2[b].add(tdir);</span><br><span class="line">                tan2[c].add(tdir);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> groups = <span class="built_in">this</span>.groups;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (groups.length === <span class="number">0</span>) &#123;</span><br><span class="line">                groups = [&#123;</span><br><span class="line">                    <span class="attr">start</span>: <span class="number">0</span>,</span><br><span class="line">                    <span class="attr">count</span>: indices.length</span><br><span class="line">                &#125;];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = groups.length; i &lt; il; ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> group = groups[i];</span><br><span class="line">                <span class="keyword">const</span> start = group.start;</span><br><span class="line">                <span class="keyword">const</span> count = group.count;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> j = start, jl = start + count; j &lt; jl; j += <span class="number">3</span>) &#123;</span><br><span class="line">                    handleTriangle(indices[j + <span class="number">0</span>], indices[j + <span class="number">1</span>], indices[j + <span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> tmp = <span class="keyword">new</span> Vector3(),</span><br><span class="line">                tmp2 = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> n = <span class="keyword">new</span> Vector3(),</span><br><span class="line">                n2 = <span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">handleVertex</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">                n.fromArray(normals, v * <span class="number">3</span>);</span><br><span class="line">                n2.copy(n);</span><br><span class="line">                <span class="keyword">const</span> t = tan1[v]; <span class="comment">// Gram-Schmidt orthogonalize</span></span><br><span class="line"></span><br><span class="line">                tmp.copy(t);</span><br><span class="line">                tmp.sub(n.multiplyScalar(n.dot(t))).normalize(); <span class="comment">// Calculate handedness</span></span><br><span class="line"></span><br><span class="line">                tmp2.crossVectors(n2, t);</span><br><span class="line">                <span class="keyword">const</span> test = tmp2.dot(tan2[v]);</span><br><span class="line">                <span class="keyword">const</span> w = test &lt; <span class="number">0.0</span> ? -<span class="number">1.0</span> : <span class="number">1.0</span>;</span><br><span class="line">                tangents[v * <span class="number">4</span>] = tmp.x;</span><br><span class="line">                tangents[v * <span class="number">4</span> + <span class="number">1</span>] = tmp.y;</span><br><span class="line">                tangents[v * <span class="number">4</span> + <span class="number">2</span>] = tmp.z;</span><br><span class="line">                tangents[v * <span class="number">4</span> + <span class="number">3</span>] = w;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = groups.length; i &lt; il; ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> group = groups[i];</span><br><span class="line">                <span class="keyword">const</span> start = group.start;</span><br><span class="line">                <span class="keyword">const</span> count = group.count;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> j = start, jl = start + count; j &lt; jl; j += <span class="number">3</span>) &#123;</span><br><span class="line">                    handleVertex(indices[j + <span class="number">0</span>]);</span><br><span class="line">                    handleVertex(indices[j + <span class="number">1</span>]);</span><br><span class="line">                    handleVertex(indices[j + <span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">computeVertexNormals</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> index = <span class="built_in">this</span>.index;</span><br><span class="line">            <span class="keyword">const</span> positionAttribute = <span class="built_in">this</span>.getAttribute(<span class="string">&#x27;position&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (positionAttribute !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> normalAttribute = <span class="built_in">this</span>.getAttribute(<span class="string">&#x27;normal&#x27;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (normalAttribute === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    normalAttribute = <span class="keyword">new</span> BufferAttribute(<span class="keyword">new</span> <span class="built_in">Float32Array</span>(positionAttribute.count * <span class="number">3</span>), <span class="number">3</span>);</span><br><span class="line">                    <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;normal&#x27;</span>, normalAttribute);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// reset existing normals to zero</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = normalAttribute.count; i &lt; il; i++) &#123;</span><br><span class="line">                        normalAttribute.setXYZ(i, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> pA = <span class="keyword">new</span> Vector3(),</span><br><span class="line">                    pB = <span class="keyword">new</span> Vector3(),</span><br><span class="line">                    pC = <span class="keyword">new</span> Vector3();</span><br><span class="line">                <span class="keyword">const</span> nA = <span class="keyword">new</span> Vector3(),</span><br><span class="line">                    nB = <span class="keyword">new</span> Vector3(),</span><br><span class="line">                    nC = <span class="keyword">new</span> Vector3();</span><br><span class="line">                <span class="keyword">const</span> cb = <span class="keyword">new</span> Vector3(),</span><br><span class="line">                    ab = <span class="keyword">new</span> Vector3(); <span class="comment">// indexed elements</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (index) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = index.count; i &lt; il; i += <span class="number">3</span>) &#123;</span><br><span class="line">                        <span class="keyword">const</span> vA = index.getX(i + <span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">const</span> vB = index.getX(i + <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">const</span> vC = index.getX(i + <span class="number">2</span>);</span><br><span class="line">                        pA.fromBufferAttribute(positionAttribute, vA);</span><br><span class="line">                        pB.fromBufferAttribute(positionAttribute, vB);</span><br><span class="line">                        pC.fromBufferAttribute(positionAttribute, vC);</span><br><span class="line">                        cb.subVectors(pC, pB);</span><br><span class="line">                        ab.subVectors(pA, pB);</span><br><span class="line">                        cb.cross(ab);</span><br><span class="line">                        nA.fromBufferAttribute(normalAttribute, vA);</span><br><span class="line">                        nB.fromBufferAttribute(normalAttribute, vB);</span><br><span class="line">                        nC.fromBufferAttribute(normalAttribute, vC);</span><br><span class="line">                        nA.add(cb);</span><br><span class="line">                        nB.add(cb);</span><br><span class="line">                        nC.add(cb);</span><br><span class="line">                        normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);</span><br><span class="line">                        normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);</span><br><span class="line">                        normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// non-indexed elements (unconnected triangle soup)</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = positionAttribute.count; i &lt; il; i += <span class="number">3</span>) &#123;</span><br><span class="line">                        pA.fromBufferAttribute(positionAttribute, i + <span class="number">0</span>);</span><br><span class="line">                        pB.fromBufferAttribute(positionAttribute, i + <span class="number">1</span>);</span><br><span class="line">                        pC.fromBufferAttribute(positionAttribute, i + <span class="number">2</span>);</span><br><span class="line">                        cb.subVectors(pC, pB);</span><br><span class="line">                        ab.subVectors(pA, pB);</span><br><span class="line">                        cb.cross(ab);</span><br><span class="line">                        normalAttribute.setXYZ(i + <span class="number">0</span>, cb.x, cb.y, cb.z);</span><br><span class="line">                        normalAttribute.setXYZ(i + <span class="number">1</span>, cb.x, cb.y, cb.z);</span><br><span class="line">                        normalAttribute.setXYZ(i + <span class="number">2</span>, cb.x, cb.y, cb.z);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.normalizeNormals();</span><br><span class="line">                normalAttribute.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">merge</span>(<span class="params">geometry, offset</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(geometry &amp;&amp; geometry.isBufferGeometry)) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.&#x27;</span>, geometry);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (offset === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                offset = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. &#x27;</span> + <span class="string">&#x27;Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> attributes = <span class="built_in">this</span>.attributes;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> attributes) &#123;</span><br><span class="line">                <span class="keyword">if</span> (geometry.attributes[key] === <span class="literal">undefined</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">const</span> attribute1 = attributes[key];</span><br><span class="line">                <span class="keyword">const</span> attributeArray1 = attribute1.array;</span><br><span class="line">                <span class="keyword">const</span> attribute2 = geometry.attributes[key];</span><br><span class="line">                <span class="keyword">const</span> attributeArray2 = attribute2.array;</span><br><span class="line">                <span class="keyword">const</span> attributeOffset = attribute2.itemSize * offset;</span><br><span class="line">                <span class="keyword">const</span> length = <span class="built_in">Math</span>.min(attributeArray2.length, attributeArray1.length - attributeOffset);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = attributeOffset; i &lt; length; i++, j++) &#123;</span><br><span class="line">                    attributeArray1[j] = attributeArray2[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">normalizeNormals</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> normals = <span class="built_in">this</span>.attributes.normal;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = normals.count; i &lt; il; i++) &#123;</span><br><span class="line">                _vector$<span class="number">8.</span>fromBufferAttribute(normals, i);</span><br><span class="line"></span><br><span class="line">                _vector$<span class="number">8.</span>normalize();</span><br><span class="line"></span><br><span class="line">                normals.setXYZ(i, _vector$<span class="number">8.</span>x, _vector$<span class="number">8.</span>y, _vector$<span class="number">8.</span>z);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toNonIndexed</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">convertBufferAttribute</span>(<span class="params">attribute, indices</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> array = attribute.array;</span><br><span class="line">                <span class="keyword">const</span> itemSize = attribute.itemSize;</span><br><span class="line">                <span class="keyword">const</span> normalized = attribute.normalized;</span><br><span class="line">                <span class="keyword">const</span> array2 = <span class="keyword">new</span> array.constructor(indices.length * itemSize);</span><br><span class="line">                <span class="keyword">let</span> index = <span class="number">0</span>,</span><br><span class="line">                    index2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = indices.length; i &lt; l; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (attribute.isInterleavedBufferAttribute) &#123;</span><br><span class="line">                        index = indices[i] * attribute.data.stride + attribute.offset;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        index = indices[i] * itemSize;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; itemSize; j++) &#123;</span><br><span class="line">                        array2[index2++] = array[index++];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> BufferAttribute(array2, itemSize, normalized);</span><br><span class="line">            &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.index === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> geometry2 = <span class="keyword">new</span> BufferGeometry();</span><br><span class="line">            <span class="keyword">const</span> indices = <span class="built_in">this</span>.index.array;</span><br><span class="line">            <span class="keyword">const</span> attributes = <span class="built_in">this</span>.attributes; <span class="comment">// attributes</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> attributes) &#123;</span><br><span class="line">                <span class="keyword">const</span> attribute = attributes[name];</span><br><span class="line">                <span class="keyword">const</span> newAttribute = convertBufferAttribute(attribute, indices);</span><br><span class="line">                geometry2.setAttribute(name, newAttribute);</span><br><span class="line">            &#125; <span class="comment">// morph attributes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> morphAttributes = <span class="built_in">this</span>.morphAttributes;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> morphAttributes) &#123;</span><br><span class="line">                <span class="keyword">const</span> morphArray = [];</span><br><span class="line">                <span class="keyword">const</span> morphAttribute = morphAttributes[name]; <span class="comment">// morphAttribute: array of Float32BufferAttributes</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = morphAttribute.length; i &lt; il; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> attribute = morphAttribute[i];</span><br><span class="line">                    <span class="keyword">const</span> newAttribute = convertBufferAttribute(attribute, indices);</span><br><span class="line">                    morphArray.push(newAttribute);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                geometry2.morphAttributes[name] = morphArray;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            geometry2.morphTargetsRelative = <span class="built_in">this</span>.morphTargetsRelative; <span class="comment">// groups</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> groups = <span class="built_in">this</span>.groups;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = groups.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> group = groups[i];</span><br><span class="line">                geometry2.addGroup(group.start, group.count, group.materialIndex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> geometry2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = &#123;</span><br><span class="line">                <span class="attr">metadata</span>: &#123;</span><br><span class="line">                    <span class="attr">version</span>: <span class="number">4.5</span>,</span><br><span class="line">                    <span class="attr">type</span>: <span class="string">&#x27;BufferGeometry&#x27;</span>,</span><br><span class="line">                    <span class="attr">generator</span>: <span class="string">&#x27;BufferGeometry.toJSON&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;; <span class="comment">// standard BufferGeometry serialization</span></span><br><span class="line"></span><br><span class="line">            data.uuid = <span class="built_in">this</span>.uuid;</span><br><span class="line">            data.type = <span class="built_in">this</span>.type;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.name !== <span class="string">&#x27;&#x27;</span>) data.name = <span class="built_in">this</span>.name;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(<span class="built_in">this</span>.userData).length &gt; <span class="number">0</span>) data.userData = <span class="built_in">this</span>.userData;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.parameters !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> parameters = <span class="built_in">this</span>.parameters;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> parameters) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parameters[key] !== <span class="literal">undefined</span>) data[key] = parameters[key];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> data;</span><br><span class="line">            &#125; <span class="comment">// for simplicity the code assumes attributes are not shared across geometries, see #15811</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            data.data = &#123;</span><br><span class="line">                <span class="attr">attributes</span>: &#123;&#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">const</span> index = <span class="built_in">this</span>.index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index !== <span class="literal">null</span>) &#123;</span><br><span class="line">                data.data.index = &#123;</span><br><span class="line">                    <span class="attr">type</span>: index.array.constructor.name,</span><br><span class="line">                    <span class="attr">array</span>: <span class="built_in">Array</span>.prototype.slice.call(index.array)</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> attributes = <span class="built_in">this</span>.attributes;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> attributes) &#123;</span><br><span class="line">                <span class="keyword">const</span> attribute = attributes[key];</span><br><span class="line">                data.data.attributes[key] = attribute.toJSON(data.data);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> morphAttributes = &#123;&#125;;</span><br><span class="line">            <span class="keyword">let</span> hasMorphAttributes = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="built_in">this</span>.morphAttributes) &#123;</span><br><span class="line">                <span class="keyword">const</span> attributeArray = <span class="built_in">this</span>.morphAttributes[key];</span><br><span class="line">                <span class="keyword">const</span> array = [];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = attributeArray.length; i &lt; il; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> attribute = attributeArray[i];</span><br><span class="line">                    array.push(attribute.toJSON(data.data));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (array.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    morphAttributes[key] = array;</span><br><span class="line">                    hasMorphAttributes = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hasMorphAttributes) &#123;</span><br><span class="line">                data.data.morphAttributes = morphAttributes;</span><br><span class="line">                data.data.morphTargetsRelative = <span class="built_in">this</span>.morphTargetsRelative;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> groups = <span class="built_in">this</span>.groups;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (groups.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                data.data.groups = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(groups));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> boundingSphere = <span class="built_in">this</span>.boundingSphere;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (boundingSphere !== <span class="literal">null</span>) &#123;</span><br><span class="line">                data.data.boundingSphere = &#123;</span><br><span class="line">                    <span class="attr">center</span>: boundingSphere.center.toArray(),</span><br><span class="line">                    <span class="attr">radius</span>: boundingSphere.radius</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor().copy(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// reset</span></span><br><span class="line">            <span class="built_in">this</span>.index = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.attributes = &#123;&#125;;</span><br><span class="line">            <span class="built_in">this</span>.morphAttributes = &#123;&#125;;</span><br><span class="line">            <span class="built_in">this</span>.groups = [];</span><br><span class="line">            <span class="built_in">this</span>.boundingBox = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.boundingSphere = <span class="literal">null</span>; <span class="comment">// used for storing cloned, shared data</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> data = &#123;&#125;; <span class="comment">// name</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.name = source.name; <span class="comment">// index</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> index = source.index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.setIndex(index.clone(data));</span><br><span class="line">            &#125; <span class="comment">// attributes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> attributes = source.attributes;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> attributes) &#123;</span><br><span class="line">                <span class="keyword">const</span> attribute = attributes[name];</span><br><span class="line">                <span class="built_in">this</span>.setAttribute(name, attribute.clone(data));</span><br><span class="line">            &#125; <span class="comment">// morph attributes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> morphAttributes = source.morphAttributes;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> morphAttributes) &#123;</span><br><span class="line">                <span class="keyword">const</span> array = [];</span><br><span class="line">                <span class="keyword">const</span> morphAttribute = morphAttributes[name]; <span class="comment">// morphAttribute: array of Float32BufferAttributes</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = morphAttribute.length; i &lt; l; i++) &#123;</span><br><span class="line">                    array.push(morphAttribute[i].clone(data));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.morphAttributes[name] = array;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.morphTargetsRelative = source.morphTargetsRelative; <span class="comment">// groups</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> groups = source.groups;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = groups.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> group = groups[i];</span><br><span class="line">                <span class="built_in">this</span>.addGroup(group.start, group.count, group.materialIndex);</span><br><span class="line">            &#125; <span class="comment">// bounding box</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> boundingBox = source.boundingBox;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (boundingBox !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.boundingBox = boundingBox.clone();</span><br><span class="line">            &#125; <span class="comment">// bounding sphere</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> boundingSphere = source.boundingSphere;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (boundingSphere !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.boundingSphere = boundingSphere.clone();</span><br><span class="line">            &#125; <span class="comment">// draw range</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.drawRange.start = source.drawRange.start;</span><br><span class="line">            <span class="built_in">this</span>.drawRange.count = source.drawRange.count; <span class="comment">// user data</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.userData = source.userData; <span class="comment">// geometry generator parameters</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (source.parameters !== <span class="literal">undefined</span>) <span class="built_in">this</span>.parameters = <span class="built_in">Object</span>.assign(&#123;&#125;, source.parameters);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dispose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.dispatchEvent(&#123;</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;dispose&#x27;</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BufferGeometry.prototype.isBufferGeometry = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _inverseMatrix$<span class="number">2</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Matrix4();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _ray$<span class="number">2</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Ray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _sphere$<span class="number">3</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Sphere();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vA$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vB$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vC$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _tempA = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _tempB = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _tempC = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _morphA = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _morphB = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _morphC = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _uvA$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector2();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _uvB$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector2();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _uvC$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector2();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _intersectionPoint = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _intersectionPointWorld = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Mesh</span> <span class="keyword">extends</span> <span class="title">Object3D</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">geometry = <span class="keyword">new</span> BufferGeometry(), material = <span class="keyword">new</span> MeshBasicMaterial()</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;Mesh&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.geometry = geometry;</span><br><span class="line">            <span class="built_in">this</span>.material = material;</span><br><span class="line">            <span class="built_in">this</span>.updateMorphTargets();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (source.morphTargetInfluences !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.morphTargetInfluences = source.morphTargetInfluences.slice();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (source.morphTargetDictionary !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.morphTargetDictionary = <span class="built_in">Object</span>.assign(&#123;&#125;, source.morphTargetDictionary);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.material = source.material;</span><br><span class="line">            <span class="built_in">this</span>.geometry = source.geometry;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">updateMorphTargets</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> geometry = <span class="built_in">this</span>.geometry;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (geometry.isBufferGeometry) &#123;</span><br><span class="line">                <span class="keyword">const</span> morphAttributes = geometry.morphAttributes;</span><br><span class="line">                <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(morphAttributes);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (keys.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> morphAttribute = morphAttributes[keys[<span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (morphAttribute !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.morphTargetInfluences = [];</span><br><span class="line">                        <span class="built_in">this</span>.morphTargetDictionary = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> m = <span class="number">0</span>, ml = morphAttribute.length; m &lt; ml; m++) &#123;</span><br><span class="line">                            <span class="keyword">const</span> name = morphAttribute[m].name || <span class="built_in">String</span>(m);</span><br><span class="line">                            <span class="built_in">this</span>.morphTargetInfluences.push(<span class="number">0</span>);</span><br><span class="line">                            <span class="built_in">this</span>.morphTargetDictionary[name] = m;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> morphTargets = geometry.morphTargets;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (morphTargets !== <span class="literal">undefined</span> &amp;&amp; morphTargets.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">raycast</span>(<span class="params">raycaster, intersects</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> geometry = <span class="built_in">this</span>.geometry;</span><br><span class="line">            <span class="keyword">const</span> material = <span class="built_in">this</span>.material;</span><br><span class="line">            <span class="keyword">const</span> matrixWorld = <span class="built_in">this</span>.matrixWorld;</span><br><span class="line">            <span class="keyword">if</span> (material === <span class="literal">undefined</span>) <span class="keyword">return</span>; <span class="comment">// Checking boundingSphere distance to ray</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (geometry.boundingSphere === <span class="literal">null</span>) geometry.computeBoundingSphere();</span><br><span class="line"></span><br><span class="line">            _sphere$<span class="number">3.</span>copy(geometry.boundingSphere);</span><br><span class="line"></span><br><span class="line">            _sphere$<span class="number">3.</span>applyMatrix4(matrixWorld);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (raycaster.ray.intersectsSphere(_sphere$<span class="number">3</span>) === <span class="literal">false</span>) <span class="keyword">return</span>; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            _inverseMatrix$<span class="number">2.</span>copy(matrixWorld).invert();</span><br><span class="line"></span><br><span class="line">            _ray$<span class="number">2.</span>copy(raycaster.ray).applyMatrix4(_inverseMatrix$<span class="number">2</span>); <span class="comment">// Check boundingBox before continuing</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (geometry.boundingBox !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_ray$<span class="number">2.</span>intersectsBox(geometry.boundingBox) === <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> intersection;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (geometry.isBufferGeometry) &#123;</span><br><span class="line">                <span class="keyword">const</span> index = geometry.index;</span><br><span class="line">                <span class="keyword">const</span> position = geometry.attributes.position;</span><br><span class="line">                <span class="keyword">const</span> morphPosition = geometry.morphAttributes.position;</span><br><span class="line">                <span class="keyword">const</span> morphTargetsRelative = geometry.morphTargetsRelative;</span><br><span class="line">                <span class="keyword">const</span> uv = geometry.attributes.uv;</span><br><span class="line">                <span class="keyword">const</span> uv2 = geometry.attributes.uv2;</span><br><span class="line">                <span class="keyword">const</span> groups = geometry.groups;</span><br><span class="line">                <span class="keyword">const</span> drawRange = geometry.drawRange;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (index !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// indexed buffer geometry</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(material)) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = groups.length; i &lt; il; i++) &#123;</span><br><span class="line">                            <span class="keyword">const</span> group = groups[i];</span><br><span class="line">                            <span class="keyword">const</span> groupMaterial = material[group.materialIndex];</span><br><span class="line">                            <span class="keyword">const</span> start = <span class="built_in">Math</span>.max(group.start, drawRange.start);</span><br><span class="line">                            <span class="keyword">const</span> end = <span class="built_in">Math</span>.min(index.count, <span class="built_in">Math</span>.min(group.start + group.count, drawRange.start + drawRange.count));</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">let</span> j = start, jl = end; j &lt; jl; j += <span class="number">3</span>) &#123;</span><br><span class="line">                                <span class="keyword">const</span> a = index.getX(j);</span><br><span class="line">                                <span class="keyword">const</span> b = index.getX(j + <span class="number">1</span>);</span><br><span class="line">                                <span class="keyword">const</span> c = index.getX(j + <span class="number">2</span>);</span><br><span class="line">                                intersection = checkBufferGeometryIntersection(<span class="built_in">this</span>, groupMaterial, raycaster, _ray$<span class="number">2</span>, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (intersection) &#123;</span><br><span class="line">                                    intersection.faceIndex = <span class="built_in">Math</span>.floor(j / <span class="number">3</span>); <span class="comment">// triangle number in indexed buffer semantics</span></span><br><span class="line"></span><br><span class="line">                                    intersection.face.materialIndex = group.materialIndex;</span><br><span class="line">                                    intersects.push(intersection);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">const</span> start = <span class="built_in">Math</span>.max(<span class="number">0</span>, drawRange.start);</span><br><span class="line">                        <span class="keyword">const</span> end = <span class="built_in">Math</span>.min(index.count, drawRange.start + drawRange.count);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> i = start, il = end; i &lt; il; i += <span class="number">3</span>) &#123;</span><br><span class="line">                            <span class="keyword">const</span> a = index.getX(i);</span><br><span class="line">                            <span class="keyword">const</span> b = index.getX(i + <span class="number">1</span>);</span><br><span class="line">                            <span class="keyword">const</span> c = index.getX(i + <span class="number">2</span>);</span><br><span class="line">                            intersection = checkBufferGeometryIntersection(<span class="built_in">this</span>, material, raycaster, _ray$<span class="number">2</span>, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (intersection) &#123;</span><br><span class="line">                                intersection.faceIndex = <span class="built_in">Math</span>.floor(i / <span class="number">3</span>); <span class="comment">// triangle number in indexed buffer semantics</span></span><br><span class="line"></span><br><span class="line">                                intersects.push(intersection);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="comment">// non-indexed buffer geometry</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(material)) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = groups.length; i &lt; il; i++) &#123;</span><br><span class="line">                            <span class="keyword">const</span> group = groups[i];</span><br><span class="line">                            <span class="keyword">const</span> groupMaterial = material[group.materialIndex];</span><br><span class="line">                            <span class="keyword">const</span> start = <span class="built_in">Math</span>.max(group.start, drawRange.start);</span><br><span class="line">                            <span class="keyword">const</span> end = <span class="built_in">Math</span>.min(position.count, <span class="built_in">Math</span>.min(group.start + group.count, drawRange.start + drawRange.count));</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">let</span> j = start, jl = end; j &lt; jl; j += <span class="number">3</span>) &#123;</span><br><span class="line">                                <span class="keyword">const</span> a = j;</span><br><span class="line">                                <span class="keyword">const</span> b = j + <span class="number">1</span>;</span><br><span class="line">                                <span class="keyword">const</span> c = j + <span class="number">2</span>;</span><br><span class="line">                                intersection = checkBufferGeometryIntersection(<span class="built_in">this</span>, groupMaterial, raycaster, _ray$<span class="number">2</span>, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (intersection) &#123;</span><br><span class="line">                                    intersection.faceIndex = <span class="built_in">Math</span>.floor(j / <span class="number">3</span>); <span class="comment">// triangle number in non-indexed buffer semantics</span></span><br><span class="line"></span><br><span class="line">                                    intersection.face.materialIndex = group.materialIndex;</span><br><span class="line">                                    intersects.push(intersection);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">const</span> start = <span class="built_in">Math</span>.max(<span class="number">0</span>, drawRange.start);</span><br><span class="line">                        <span class="keyword">const</span> end = <span class="built_in">Math</span>.min(position.count, drawRange.start + drawRange.count);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> i = start, il = end; i &lt; il; i += <span class="number">3</span>) &#123;</span><br><span class="line">                            <span class="keyword">const</span> a = i;</span><br><span class="line">                            <span class="keyword">const</span> b = i + <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">const</span> c = i + <span class="number">2</span>;</span><br><span class="line">                            intersection = checkBufferGeometryIntersection(<span class="built_in">this</span>, material, raycaster, _ray$<span class="number">2</span>, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (intersection) &#123;</span><br><span class="line">                                intersection.faceIndex = <span class="built_in">Math</span>.floor(i / <span class="number">3</span>); <span class="comment">// triangle number in non-indexed buffer semantics</span></span><br><span class="line"></span><br><span class="line">                                intersects.push(intersection);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (geometry.isGeometry) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mesh.prototype.isMesh = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkIntersection</span>(<span class="params">object, material, raycaster, ray, pA, pB, pC, point</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> intersect;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (material.side === BackSide) &#123;</span><br><span class="line">            intersect = ray.intersectTriangle(pC, pB, pA, <span class="literal">true</span>, point);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (intersect === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        _intersectionPointWorld.copy(point);</span><br><span class="line"></span><br><span class="line">        _intersectionPointWorld.applyMatrix4(object.matrixWorld);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);</span><br><span class="line">        <span class="keyword">if</span> (distance &lt; raycaster.near || distance &gt; raycaster.far) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">distance</span>: distance,</span><br><span class="line">            <span class="attr">point</span>: _intersectionPointWorld.clone(),</span><br><span class="line">            <span class="attr">object</span>: object</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkBufferGeometryIntersection</span>(<span class="params">object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c</span>) </span>&#123;</span><br><span class="line">        _vA$<span class="number">1.</span>fromBufferAttribute(position, a);</span><br><span class="line"></span><br><span class="line">        _vB$<span class="number">1.</span>fromBufferAttribute(position, b);</span><br><span class="line"></span><br><span class="line">        _vC$<span class="number">1.</span>fromBufferAttribute(position, c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> morphInfluences = object.morphTargetInfluences;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (morphPosition &amp;&amp; morphInfluences) &#123;</span><br><span class="line">            _morphA.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            _morphB.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            _morphC.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = morphPosition.length; i &lt; il; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> influence = morphInfluences[i];</span><br><span class="line">                <span class="keyword">const</span> morphAttribute = morphPosition[i];</span><br><span class="line">                <span class="keyword">if</span> (influence === <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                _tempA.fromBufferAttribute(morphAttribute, a);</span><br><span class="line"></span><br><span class="line">                _tempB.fromBufferAttribute(morphAttribute, b);</span><br><span class="line"></span><br><span class="line">                _tempC.fromBufferAttribute(morphAttribute, c);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (morphTargetsRelative) &#123;</span><br><span class="line">                    _morphA.addScaledVector(_tempA, influence);</span><br><span class="line"></span><br><span class="line">                    _morphB.addScaledVector(_tempB, influence);</span><br><span class="line"></span><br><span class="line">                    _morphC.addScaledVector(_tempC, influence);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    _morphA.addScaledVector(_tempA.sub(_vA$<span class="number">1</span>), influence);</span><br><span class="line"></span><br><span class="line">                    _morphB.addScaledVector(_tempB.sub(_vB$<span class="number">1</span>), influence);</span><br><span class="line"></span><br><span class="line">                    _morphC.addScaledVector(_tempC.sub(_vC$<span class="number">1</span>), influence);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _vA$<span class="number">1.</span>add(_morphA);</span><br><span class="line"></span><br><span class="line">            _vB$<span class="number">1.</span>add(_morphB);</span><br><span class="line"></span><br><span class="line">            _vC$<span class="number">1.</span>add(_morphC);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (object.isSkinnedMesh) &#123;</span><br><span class="line">            object.boneTransform(a, _vA$<span class="number">1</span>);</span><br><span class="line">            object.boneTransform(b, _vB$<span class="number">1</span>);</span><br><span class="line">            object.boneTransform(c, _vC$<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> intersection = checkIntersection(object, material, raycaster, ray, _vA$<span class="number">1</span>, _vB$<span class="number">1</span>, _vC$<span class="number">1</span>, _intersectionPoint);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (intersection) &#123;</span><br><span class="line">            <span class="keyword">if</span> (uv) &#123;</span><br><span class="line">                _uvA$<span class="number">1.</span>fromBufferAttribute(uv, a);</span><br><span class="line"></span><br><span class="line">                _uvB$<span class="number">1.</span>fromBufferAttribute(uv, b);</span><br><span class="line"></span><br><span class="line">                _uvC$<span class="number">1.</span>fromBufferAttribute(uv, c);</span><br><span class="line"></span><br><span class="line">                intersection.uv = Triangle.getUV(_intersectionPoint, _vA$<span class="number">1</span>, _vB$<span class="number">1</span>, _vC$<span class="number">1</span>, _uvA$<span class="number">1</span>, _uvB$<span class="number">1</span>, _uvC$<span class="number">1</span>, <span class="keyword">new</span> Vector2());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (uv2) &#123;</span><br><span class="line">                _uvA$<span class="number">1.</span>fromBufferAttribute(uv2, a);</span><br><span class="line"></span><br><span class="line">                _uvB$<span class="number">1.</span>fromBufferAttribute(uv2, b);</span><br><span class="line"></span><br><span class="line">                _uvC$<span class="number">1.</span>fromBufferAttribute(uv2, c);</span><br><span class="line"></span><br><span class="line">                intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$<span class="number">1</span>, _vB$<span class="number">1</span>, _vC$<span class="number">1</span>, _uvA$<span class="number">1</span>, _uvB$<span class="number">1</span>, _uvC$<span class="number">1</span>, <span class="keyword">new</span> Vector2());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> face = &#123;</span><br><span class="line">                <span class="attr">a</span>: a,</span><br><span class="line">                <span class="attr">b</span>: b,</span><br><span class="line">                <span class="attr">c</span>: c,</span><br><span class="line">                <span class="attr">normal</span>: <span class="keyword">new</span> Vector3(),</span><br><span class="line">                <span class="attr">materialIndex</span>: <span class="number">0</span></span><br><span class="line">            &#125;;</span><br><span class="line">            Triangle.getNormal(_vA$<span class="number">1</span>, _vB$<span class="number">1</span>, _vC$<span class="number">1</span>, face.normal);</span><br><span class="line">            intersection.face = face;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> intersection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BoxGeometry</span> <span class="keyword">extends</span> <span class="title">BufferGeometry</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">width = <span class="number">1</span>, height = <span class="number">1</span>, depth = <span class="number">1</span>, widthSegments = <span class="number">1</span>, heightSegments = <span class="number">1</span>, depthSegments = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;BoxGeometry&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.parameters = &#123;</span><br><span class="line">                <span class="attr">width</span>: width,</span><br><span class="line">                <span class="attr">height</span>: height,</span><br><span class="line">                <span class="attr">depth</span>: depth,</span><br><span class="line">                <span class="attr">widthSegments</span>: widthSegments,</span><br><span class="line">                <span class="attr">heightSegments</span>: heightSegments,</span><br><span class="line">                <span class="attr">depthSegments</span>: depthSegments</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">const</span> scope = <span class="built_in">this</span>; <span class="comment">// segments</span></span><br><span class="line"></span><br><span class="line">            widthSegments = <span class="built_in">Math</span>.floor(widthSegments);</span><br><span class="line">            heightSegments = <span class="built_in">Math</span>.floor(heightSegments);</span><br><span class="line">            depthSegments = <span class="built_in">Math</span>.floor(depthSegments); <span class="comment">// buffers</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> indices = [];</span><br><span class="line">            <span class="keyword">const</span> vertices = [];</span><br><span class="line">            <span class="keyword">const</span> normals = [];</span><br><span class="line">            <span class="keyword">const</span> uvs = []; <span class="comment">// helper variables</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> numberOfVertices = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> groupStart = <span class="number">0</span>; <span class="comment">// build each side of the box geometry</span></span><br><span class="line"></span><br><span class="line">            buildPlane(<span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, -<span class="number">1</span>, -<span class="number">1</span>, depth, height, width, depthSegments, heightSegments, <span class="number">0</span>); <span class="comment">// px</span></span><br><span class="line"></span><br><span class="line">            buildPlane(<span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="number">1</span>, -<span class="number">1</span>, depth, height, -width, depthSegments, heightSegments, <span class="number">1</span>); <span class="comment">// nx</span></span><br><span class="line"></span><br><span class="line">            buildPlane(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>, width, depth, height, widthSegments, depthSegments, <span class="number">2</span>); <span class="comment">// py</span></span><br><span class="line"></span><br><span class="line">            buildPlane(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="number">1</span>, -<span class="number">1</span>, width, depth, -height, widthSegments, depthSegments, <span class="number">3</span>); <span class="comment">// ny</span></span><br><span class="line"></span><br><span class="line">            buildPlane(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="number">1</span>, -<span class="number">1</span>, width, height, depth, widthSegments, heightSegments, <span class="number">4</span>); <span class="comment">// pz</span></span><br><span class="line"></span><br><span class="line">            buildPlane(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, -<span class="number">1</span>, -<span class="number">1</span>, width, height, -depth, widthSegments, heightSegments, <span class="number">5</span>); <span class="comment">// nz</span></span><br><span class="line">            <span class="comment">// build geometry</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setIndex(indices);</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(vertices, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;normal&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(normals, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;uv&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(uvs, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">buildPlane</span>(<span class="params">u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> segmentWidth = width / gridX;</span><br><span class="line">                <span class="keyword">const</span> segmentHeight = height / gridY;</span><br><span class="line">                <span class="keyword">const</span> widthHalf = width / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">const</span> heightHalf = height / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">const</span> depthHalf = depth / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">const</span> gridX1 = gridX + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">const</span> gridY1 = gridY + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">let</span> vertexCounter = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">let</span> groupCount = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">const</span> vector = <span class="keyword">new</span> Vector3(); <span class="comment">// generate vertices, normals and uvs</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> iy = <span class="number">0</span>; iy &lt; gridY1; iy++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> y = iy * segmentHeight - heightHalf;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> ix = <span class="number">0</span>; ix &lt; gridX1; ix++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> x = ix * segmentWidth - widthHalf; <span class="comment">// set values to correct vector component</span></span><br><span class="line"></span><br><span class="line">                        vector[u] = x * udir;</span><br><span class="line">                        vector[v] = y * vdir;</span><br><span class="line">                        vector[w] = depthHalf; <span class="comment">// now apply vector to vertex buffer</span></span><br><span class="line"></span><br><span class="line">                        vertices.push(vector.x, vector.y, vector.z); <span class="comment">// set values to correct vector component</span></span><br><span class="line"></span><br><span class="line">                        vector[u] = <span class="number">0</span>;</span><br><span class="line">                        vector[v] = <span class="number">0</span>;</span><br><span class="line">                        vector[w] = depth &gt; <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>; <span class="comment">// now apply vector to normal buffer</span></span><br><span class="line"></span><br><span class="line">                        normals.push(vector.x, vector.y, vector.z); <span class="comment">// uvs</span></span><br><span class="line"></span><br><span class="line">                        uvs.push(ix / gridX);</span><br><span class="line">                        uvs.push(<span class="number">1</span> - iy / gridY); <span class="comment">// counters</span></span><br><span class="line"></span><br><span class="line">                        vertexCounter += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="comment">// indices</span></span><br><span class="line">                <span class="comment">// 1. you need three indices to draw a single face</span></span><br><span class="line">                <span class="comment">// 2. a single segment consists of two faces</span></span><br><span class="line">                <span class="comment">// 3. so we need to generate six (2*3) indices per segment</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> iy = <span class="number">0</span>; iy &lt; gridY; iy++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> ix = <span class="number">0</span>; ix &lt; gridX; ix++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> a = numberOfVertices + ix + gridX1 * iy;</span><br><span class="line">                        <span class="keyword">const</span> b = numberOfVertices + ix + gridX1 * (iy + <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">const</span> c = numberOfVertices + (ix + <span class="number">1</span>) + gridX1 * (iy + <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">const</span> d = numberOfVertices + (ix + <span class="number">1</span>) + gridX1 * iy; <span class="comment">// faces</span></span><br><span class="line"></span><br><span class="line">                        indices.push(a, b, d);</span><br><span class="line">                        indices.push(b, c, d); <span class="comment">// increase counter</span></span><br><span class="line"></span><br><span class="line">                        groupCount += <span class="number">6</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="comment">// add a group to the geometry. this will ensure multi material support</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                scope.addGroup(groupStart, groupCount, materialIndex); <span class="comment">// calculate new start value for groups</span></span><br><span class="line"></span><br><span class="line">                groupStart += groupCount; <span class="comment">// update total number of vertices</span></span><br><span class="line"></span><br><span class="line">                numberOfVertices += vertexCounter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">fromJSON</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Uniform Utilities</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cloneUniforms</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> dst = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> u <span class="keyword">in</span> src) &#123;</span><br><span class="line">            dst[u] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">in</span> src[u]) &#123;</span><br><span class="line">                <span class="keyword">const</span> property = src[u][p];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (property &amp;&amp; (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) &#123;</span><br><span class="line">                    dst[u][p] = property.clone();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(property)) &#123;</span><br><span class="line">                    dst[u][p] = property.slice();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dst[u][p] = property;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mergeUniforms</span>(<span class="params">uniforms</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> merged = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> u = <span class="number">0</span>; u &lt; uniforms.length; u++) &#123;</span><br><span class="line">            <span class="keyword">const</span> tmp = cloneUniforms(uniforms[u]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">in</span> tmp) &#123;</span><br><span class="line">                merged[p] = tmp[p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125; <span class="comment">// Legacy</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> UniformsUtils = &#123;</span><br><span class="line">        <span class="attr">clone</span>: cloneUniforms,</span><br><span class="line">        <span class="attr">merge</span>: mergeUniforms</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> default_vertex = <span class="string">&quot;void main() &#123;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> default_fragment = <span class="string">&quot;void main() &#123;\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ShaderMaterial</span> <span class="keyword">extends</span> <span class="title">Material</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameters</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;ShaderMaterial&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.defines = &#123;&#125;;</span><br><span class="line">            <span class="built_in">this</span>.uniforms = &#123;&#125;;</span><br><span class="line">            <span class="built_in">this</span>.vertexShader = default_vertex;</span><br><span class="line">            <span class="built_in">this</span>.fragmentShader = default_fragment;</span><br><span class="line">            <span class="built_in">this</span>.linewidth = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframe = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinewidth = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.fog = <span class="literal">false</span>; <span class="comment">// set to use scene fog</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.lights = <span class="literal">false</span>; <span class="comment">// set to use scene lights</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.clipping = <span class="literal">false</span>; <span class="comment">// set to use user-defined clipping planes</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.extensions = &#123;</span><br><span class="line">                <span class="attr">derivatives</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="comment">// set to use derivatives</span></span><br><span class="line">                <span class="attr">fragDepth</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="comment">// set to use fragment depth values</span></span><br><span class="line">                <span class="attr">drawBuffers</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="comment">// set to use draw buffers</span></span><br><span class="line">                <span class="attr">shaderTextureLOD</span>: <span class="literal">false</span> <span class="comment">// set to use shader texture LOD</span></span><br><span class="line"></span><br><span class="line">            &#125;; <span class="comment">// When rendered geometry doesn&#x27;t include these attributes but the material does,</span></span><br><span class="line">            <span class="comment">// use these default values in WebGL. This avoids errors when buffer data is missing.</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.defaultAttributeValues = &#123;</span><br><span class="line">                <span class="string">&#x27;color&#x27;</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                <span class="string">&#x27;uv&#x27;</span>: [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                <span class="string">&#x27;uv2&#x27;</span>: [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">this</span>.index0AttributeName = <span class="literal">undefined</span>;</span><br><span class="line">            <span class="built_in">this</span>.uniformsNeedUpdate = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.glslVersion = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (parameters !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (parameters.attributes !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.setValues(parameters);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.fragmentShader = source.fragmentShader;</span><br><span class="line">            <span class="built_in">this</span>.vertexShader = source.vertexShader;</span><br><span class="line">            <span class="built_in">this</span>.uniforms = cloneUniforms(source.uniforms);</span><br><span class="line">            <span class="built_in">this</span>.defines = <span class="built_in">Object</span>.assign(&#123;&#125;, source.defines);</span><br><span class="line">            <span class="built_in">this</span>.wireframe = source.wireframe;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinewidth = source.wireframeLinewidth;</span><br><span class="line">            <span class="built_in">this</span>.lights = source.lights;</span><br><span class="line">            <span class="built_in">this</span>.clipping = source.clipping;</span><br><span class="line">            <span class="built_in">this</span>.extensions = <span class="built_in">Object</span>.assign(&#123;&#125;, source.extensions);</span><br><span class="line">            <span class="built_in">this</span>.glslVersion = source.glslVersion;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params">meta</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON(meta);</span><br><span class="line">            data.glslVersion = <span class="built_in">this</span>.glslVersion;</span><br><span class="line">            data.uniforms = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> <span class="built_in">this</span>.uniforms) &#123;</span><br><span class="line">                <span class="keyword">const</span> uniform = <span class="built_in">this</span>.uniforms[name];</span><br><span class="line">                <span class="keyword">const</span> value = uniform.value;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (value &amp;&amp; value.isTexture) &#123;</span><br><span class="line">                    data.uniforms[name] = &#123;</span><br><span class="line">                        <span class="attr">type</span>: <span class="string">&#x27;t&#x27;</span>,</span><br><span class="line">                        <span class="attr">value</span>: value.toJSON(meta).uuid</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &amp;&amp; value.isColor) &#123;</span><br><span class="line">                    data.uniforms[name] = &#123;</span><br><span class="line">                        <span class="attr">type</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">                        <span class="attr">value</span>: value.getHex()</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &amp;&amp; value.isVector2) &#123;</span><br><span class="line">                    data.uniforms[name] = &#123;</span><br><span class="line">                        <span class="attr">type</span>: <span class="string">&#x27;v2&#x27;</span>,</span><br><span class="line">                        <span class="attr">value</span>: value.toArray()</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &amp;&amp; value.isVector3) &#123;</span><br><span class="line">                    data.uniforms[name] = &#123;</span><br><span class="line">                        <span class="attr">type</span>: <span class="string">&#x27;v3&#x27;</span>,</span><br><span class="line">                        <span class="attr">value</span>: value.toArray()</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &amp;&amp; value.isVector4) &#123;</span><br><span class="line">                    data.uniforms[name] = &#123;</span><br><span class="line">                        <span class="attr">type</span>: <span class="string">&#x27;v4&#x27;</span>,</span><br><span class="line">                        <span class="attr">value</span>: value.toArray()</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &amp;&amp; value.isMatrix3) &#123;</span><br><span class="line">                    data.uniforms[name] = &#123;</span><br><span class="line">                        <span class="attr">type</span>: <span class="string">&#x27;m3&#x27;</span>,</span><br><span class="line">                        <span class="attr">value</span>: value.toArray()</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &amp;&amp; value.isMatrix4) &#123;</span><br><span class="line">                    data.uniforms[name] = &#123;</span><br><span class="line">                        <span class="attr">type</span>: <span class="string">&#x27;m4&#x27;</span>,</span><br><span class="line">                        <span class="attr">value</span>: value.toArray()</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    data.uniforms[name] = &#123;</span><br><span class="line">                        <span class="attr">value</span>: value</span><br><span class="line">                    &#125;; <span class="comment">// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(<span class="built_in">this</span>.defines).length &gt; <span class="number">0</span>) data.defines = <span class="built_in">this</span>.defines;</span><br><span class="line">            data.vertexShader = <span class="built_in">this</span>.vertexShader;</span><br><span class="line">            data.fragmentShader = <span class="built_in">this</span>.fragmentShader;</span><br><span class="line">            <span class="keyword">const</span> extensions = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="built_in">this</span>.extensions) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.extensions[key] === <span class="literal">true</span>) extensions[key] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(extensions).length &gt; <span class="number">0</span>) data.extensions = extensions;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ShaderMaterial.prototype.isShaderMaterial = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Camera</span> <span class="keyword">extends</span> <span class="title">Object3D</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;Camera&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.matrixWorldInverse = <span class="keyword">new</span> Matrix4();</span><br><span class="line">            <span class="built_in">this</span>.projectionMatrix = <span class="keyword">new</span> Matrix4();</span><br><span class="line">            <span class="built_in">this</span>.projectionMatrixInverse = <span class="keyword">new</span> Matrix4();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source, recursive</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source, recursive);</span><br><span class="line">            <span class="built_in">this</span>.matrixWorldInverse.copy(source.matrixWorldInverse);</span><br><span class="line">            <span class="built_in">this</span>.projectionMatrix.copy(source.projectionMatrix);</span><br><span class="line">            <span class="built_in">this</span>.projectionMatrixInverse.copy(source.projectionMatrixInverse);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getWorldDirection</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.updateWorldMatrix(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">const</span> e = <span class="built_in">this</span>.matrixWorld.elements;</span><br><span class="line">            <span class="keyword">return</span> target.set(-e[<span class="number">8</span>], -e[<span class="number">9</span>], -e[<span class="number">10</span>]).normalize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">updateMatrixWorld</span>(<span class="params">force</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.updateMatrixWorld(force);</span><br><span class="line">            <span class="built_in">this</span>.matrixWorldInverse.copy(<span class="built_in">this</span>.matrixWorld).invert();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">updateWorldMatrix</span>(<span class="params">updateParents, updateChildren</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.updateWorldMatrix(updateParents, updateChildren);</span><br><span class="line">            <span class="built_in">this</span>.matrixWorldInverse.copy(<span class="built_in">this</span>.matrixWorld).invert();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor().copy(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Camera.prototype.isCamera = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PerspectiveCamera</span> <span class="keyword">extends</span> <span class="title">Camera</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">fov = <span class="number">50</span>, aspect = <span class="number">1</span>, near = <span class="number">0.1</span>, far = <span class="number">2000</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;PerspectiveCamera&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.fov = fov;</span><br><span class="line">            <span class="built_in">this</span>.zoom = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.near = near;</span><br><span class="line">            <span class="built_in">this</span>.far = far;</span><br><span class="line">            <span class="built_in">this</span>.focus = <span class="number">10</span>;</span><br><span class="line">            <span class="built_in">this</span>.aspect = aspect;</span><br><span class="line">            <span class="built_in">this</span>.view = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.filmGauge = <span class="number">35</span>; <span class="comment">// width of the film (default in millimeters)</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.filmOffset = <span class="number">0</span>; <span class="comment">// horizontal film offset (same unit as gauge)</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.updateProjectionMatrix();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source, recursive</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source, recursive);</span><br><span class="line">            <span class="built_in">this</span>.fov = source.fov;</span><br><span class="line">            <span class="built_in">this</span>.zoom = source.zoom;</span><br><span class="line">            <span class="built_in">this</span>.near = source.near;</span><br><span class="line">            <span class="built_in">this</span>.far = source.far;</span><br><span class="line">            <span class="built_in">this</span>.focus = source.focus;</span><br><span class="line">            <span class="built_in">this</span>.aspect = source.aspect;</span><br><span class="line">            <span class="built_in">this</span>.view = source.view === <span class="literal">null</span> ? <span class="literal">null</span> : <span class="built_in">Object</span>.assign(&#123;&#125;, source.view);</span><br><span class="line">            <span class="built_in">this</span>.filmGauge = source.filmGauge;</span><br><span class="line">            <span class="built_in">this</span>.filmOffset = source.filmOffset;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Sets the FOV by focal length in respect to the current .filmGauge.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The default film gauge is 35, so that the focal length can be specified for</span></span><br><span class="line"><span class="comment">         * a 35mm (full frame) camera.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Values for focal length and film gauge must have the same unit.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFocalLength</span>(<span class="params">focalLength</span>)</span> &#123;</span><br><span class="line">            <span class="comment">/** see &#123;<span class="doctag">@link </span>http://www.bobatkins.com/photography/technical/field_of_view.html&#125; */</span></span><br><span class="line">            <span class="keyword">const</span> vExtentSlope = <span class="number">0.5</span> * <span class="built_in">this</span>.getFilmHeight() / focalLength;</span><br><span class="line">            <span class="built_in">this</span>.fov = RAD2DEG * <span class="number">2</span> * <span class="built_in">Math</span>.atan(vExtentSlope);</span><br><span class="line">            <span class="built_in">this</span>.updateProjectionMatrix();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Calculates the focal length from the current .fov and .filmGauge.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getFocalLength</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> vExtentSlope = <span class="built_in">Math</span>.tan(DEG2RAD * <span class="number">0.5</span> * <span class="built_in">this</span>.fov);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">this</span>.getFilmHeight() / vExtentSlope;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getEffectiveFOV</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> RAD2DEG * <span class="number">2</span> * <span class="built_in">Math</span>.atan(<span class="built_in">Math</span>.tan(DEG2RAD * <span class="number">0.5</span> * <span class="built_in">this</span>.fov) / <span class="built_in">this</span>.zoom);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getFilmWidth</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// film not completely covered in portrait format (aspect &lt; 1)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.filmGauge * <span class="built_in">Math</span>.min(<span class="built_in">this</span>.aspect, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getFilmHeight</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// film not completely covered in landscape format (aspect &gt; 1)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.filmGauge / <span class="built_in">Math</span>.max(<span class="built_in">this</span>.aspect, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Sets an offset in a larger frustum. This is useful for multi-window or</span></span><br><span class="line"><span class="comment">         * multi-monitor/multi-machine setups.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * For example, if you have 3x2 monitors and each monitor is 1920x1080 and</span></span><br><span class="line"><span class="comment">         * the monitors are in grid like this</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *	 +---+---+---+</span></span><br><span class="line"><span class="comment">         *	 | A | B | C |</span></span><br><span class="line"><span class="comment">         *	 +---+---+---+</span></span><br><span class="line"><span class="comment">         *	 | D | E | F |</span></span><br><span class="line"><span class="comment">         *	 +---+---+---+</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * then for each monitor you would call it like this</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *	 const w = 1920;</span></span><br><span class="line"><span class="comment">         *	 const h = 1080;</span></span><br><span class="line"><span class="comment">         *	 const fullWidth = w * 3;</span></span><br><span class="line"><span class="comment">         *	 const fullHeight = h * 2;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *	 --A--</span></span><br><span class="line"><span class="comment">         *	 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );</span></span><br><span class="line"><span class="comment">         *	 --B--</span></span><br><span class="line"><span class="comment">         *	 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );</span></span><br><span class="line"><span class="comment">         *	 --C--</span></span><br><span class="line"><span class="comment">         *	 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );</span></span><br><span class="line"><span class="comment">         *	 --D--</span></span><br><span class="line"><span class="comment">         *	 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );</span></span><br><span class="line"><span class="comment">         *	 --E--</span></span><br><span class="line"><span class="comment">         *	 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );</span></span><br><span class="line"><span class="comment">         *	 --F--</span></span><br><span class="line"><span class="comment">         *	 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *	 Note there is no reason monitors have to be the same size or in a grid.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setViewOffset</span>(<span class="params">fullWidth, fullHeight, x, y, width, height</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.aspect = fullWidth / fullHeight;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.view === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.view = &#123;</span><br><span class="line">                    <span class="attr">enabled</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">fullWidth</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="attr">fullHeight</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="attr">offsetX</span>: <span class="number">0</span>,</span><br><span class="line">                    <span class="attr">offsetY</span>: <span class="number">0</span>,</span><br><span class="line">                    <span class="attr">width</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="attr">height</span>: <span class="number">1</span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.view.enabled = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.view.fullWidth = fullWidth;</span><br><span class="line">            <span class="built_in">this</span>.view.fullHeight = fullHeight;</span><br><span class="line">            <span class="built_in">this</span>.view.offsetX = x;</span><br><span class="line">            <span class="built_in">this</span>.view.offsetY = y;</span><br><span class="line">            <span class="built_in">this</span>.view.width = width;</span><br><span class="line">            <span class="built_in">this</span>.view.height = height;</span><br><span class="line">            <span class="built_in">this</span>.updateProjectionMatrix();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clearViewOffset</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.view !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.view.enabled = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.updateProjectionMatrix();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">updateProjectionMatrix</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> near = <span class="built_in">this</span>.near;</span><br><span class="line">            <span class="keyword">let</span> top = near * <span class="built_in">Math</span>.tan(DEG2RAD * <span class="number">0.5</span> * <span class="built_in">this</span>.fov) / <span class="built_in">this</span>.zoom;</span><br><span class="line">            <span class="keyword">let</span> height = <span class="number">2</span> * top;</span><br><span class="line">            <span class="keyword">let</span> width = <span class="built_in">this</span>.aspect * height;</span><br><span class="line">            <span class="keyword">let</span> left = -<span class="number">0.5</span> * width;</span><br><span class="line">            <span class="keyword">const</span> view = <span class="built_in">this</span>.view;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.view !== <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.view.enabled) &#123;</span><br><span class="line">                <span class="keyword">const</span> fullWidth = view.fullWidth,</span><br><span class="line">                    fullHeight = view.fullHeight;</span><br><span class="line">                left += view.offsetX * width / fullWidth;</span><br><span class="line">                top -= view.offsetY * height / fullHeight;</span><br><span class="line">                width *= view.width / fullWidth;</span><br><span class="line">                height *= view.height / fullHeight;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> skew = <span class="built_in">this</span>.filmOffset;</span><br><span class="line">            <span class="keyword">if</span> (skew !== <span class="number">0</span>) left += near * skew / <span class="built_in">this</span>.getFilmWidth();</span><br><span class="line">            <span class="built_in">this</span>.projectionMatrix.makePerspective(left, left + width, top, top - height, near, <span class="built_in">this</span>.far);</span><br><span class="line">            <span class="built_in">this</span>.projectionMatrixInverse.copy(<span class="built_in">this</span>.projectionMatrix).invert();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params">meta</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON(meta);</span><br><span class="line">            data.object.fov = <span class="built_in">this</span>.fov;</span><br><span class="line">            data.object.zoom = <span class="built_in">this</span>.zoom;</span><br><span class="line">            data.object.near = <span class="built_in">this</span>.near;</span><br><span class="line">            data.object.far = <span class="built_in">this</span>.far;</span><br><span class="line">            data.object.focus = <span class="built_in">this</span>.focus;</span><br><span class="line">            data.object.aspect = <span class="built_in">this</span>.aspect;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.view !== <span class="literal">null</span>) data.object.view = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="built_in">this</span>.view);</span><br><span class="line">            data.object.filmGauge = <span class="built_in">this</span>.filmGauge;</span><br><span class="line">            data.object.filmOffset = <span class="built_in">this</span>.filmOffset;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PerspectiveCamera.prototype.isPerspectiveCamera = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fov = <span class="number">90</span>,</span><br><span class="line">        aspect = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CubeCamera</span> <span class="keyword">extends</span> <span class="title">Object3D</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">near, far, renderTarget</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;CubeCamera&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (renderTarget.isWebGLCubeRenderTarget !== <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.renderTarget = renderTarget;</span><br><span class="line">            <span class="keyword">const</span> cameraPX = <span class="keyword">new</span> PerspectiveCamera(fov, aspect, near, far);</span><br><span class="line">            cameraPX.layers = <span class="built_in">this</span>.layers;</span><br><span class="line">            cameraPX.up.set(<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            cameraPX.lookAt(<span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">            <span class="built_in">this</span>.add(cameraPX);</span><br><span class="line">            <span class="keyword">const</span> cameraNX = <span class="keyword">new</span> PerspectiveCamera(fov, aspect, near, far);</span><br><span class="line">            cameraNX.layers = <span class="built_in">this</span>.layers;</span><br><span class="line">            cameraNX.up.set(<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            cameraNX.lookAt(<span class="keyword">new</span> Vector3(-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">            <span class="built_in">this</span>.add(cameraNX);</span><br><span class="line">            <span class="keyword">const</span> cameraPY = <span class="keyword">new</span> PerspectiveCamera(fov, aspect, near, far);</span><br><span class="line">            cameraPY.layers = <span class="built_in">this</span>.layers;</span><br><span class="line">            cameraPY.up.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            cameraPY.lookAt(<span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">            <span class="built_in">this</span>.add(cameraPY);</span><br><span class="line">            <span class="keyword">const</span> cameraNY = <span class="keyword">new</span> PerspectiveCamera(fov, aspect, near, far);</span><br><span class="line">            cameraNY.layers = <span class="built_in">this</span>.layers;</span><br><span class="line">            cameraNY.up.set(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">            cameraNY.lookAt(<span class="keyword">new</span> Vector3(<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">            <span class="built_in">this</span>.add(cameraNY);</span><br><span class="line">            <span class="keyword">const</span> cameraPZ = <span class="keyword">new</span> PerspectiveCamera(fov, aspect, near, far);</span><br><span class="line">            cameraPZ.layers = <span class="built_in">this</span>.layers;</span><br><span class="line">            cameraPZ.up.set(<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            cameraPZ.lookAt(<span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">            <span class="built_in">this</span>.add(cameraPZ);</span><br><span class="line">            <span class="keyword">const</span> cameraNZ = <span class="keyword">new</span> PerspectiveCamera(fov, aspect, near, far);</span><br><span class="line">            cameraNZ.layers = <span class="built_in">this</span>.layers;</span><br><span class="line">            cameraNZ.up.set(<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            cameraNZ.lookAt(<span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">            <span class="built_in">this</span>.add(cameraNZ);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">update</span>(<span class="params">renderer, scene</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.parent === <span class="literal">null</span>) <span class="built_in">this</span>.updateMatrixWorld();</span><br><span class="line">            <span class="keyword">const</span> renderTarget = <span class="built_in">this</span>.renderTarget;</span><br><span class="line">            <span class="keyword">const</span> [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = <span class="built_in">this</span>.children;</span><br><span class="line">            <span class="keyword">const</span> currentRenderTarget = renderer.getRenderTarget();</span><br><span class="line">            <span class="keyword">const</span> currentOutputEncoding = renderer.outputEncoding;</span><br><span class="line">            <span class="keyword">const</span> currentToneMapping = renderer.toneMapping;</span><br><span class="line">            <span class="keyword">const</span> currentXrEnabled = renderer.xr.enabled;</span><br><span class="line">            renderer.outputEncoding = LinearEncoding;</span><br><span class="line">            renderer.toneMapping = NoToneMapping;</span><br><span class="line">            renderer.xr.enabled = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">const</span> generateMipmaps = renderTarget.texture.generateMipmaps;</span><br><span class="line">            renderTarget.texture.generateMipmaps = <span class="literal">false</span>;</span><br><span class="line">            renderer.setRenderTarget(renderTarget, <span class="number">0</span>);</span><br><span class="line">            renderer.render(scene, cameraPX);</span><br><span class="line">            renderer.setRenderTarget(renderTarget, <span class="number">1</span>);</span><br><span class="line">            renderer.render(scene, cameraNX);</span><br><span class="line">            renderer.setRenderTarget(renderTarget, <span class="number">2</span>);</span><br><span class="line">            renderer.render(scene, cameraPY);</span><br><span class="line">            renderer.setRenderTarget(renderTarget, <span class="number">3</span>);</span><br><span class="line">            renderer.render(scene, cameraNY);</span><br><span class="line">            renderer.setRenderTarget(renderTarget, <span class="number">4</span>);</span><br><span class="line">            renderer.render(scene, cameraPZ);</span><br><span class="line">            renderTarget.texture.generateMipmaps = generateMipmaps;</span><br><span class="line">            renderer.setRenderTarget(renderTarget, <span class="number">5</span>);</span><br><span class="line">            renderer.render(scene, cameraNZ);</span><br><span class="line">            renderer.setRenderTarget(currentRenderTarget);</span><br><span class="line">            renderer.outputEncoding = currentOutputEncoding;</span><br><span class="line">            renderer.toneMapping = currentToneMapping;</span><br><span class="line">            renderer.xr.enabled = currentXrEnabled;</span><br><span class="line">            renderTarget.texture.needsPMREMUpdate = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CubeTexture</span> <span class="keyword">extends</span> <span class="title">Texture</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding</span>)</span> &#123;</span><br><span class="line">            images = images !== <span class="literal">undefined</span> ? images : [];</span><br><span class="line">            mapping = mapping !== <span class="literal">undefined</span> ? mapping : CubeReflectionMapping;</span><br><span class="line">            <span class="built_in">super</span>(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);</span><br><span class="line">            <span class="built_in">this</span>.flipY = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">images</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.image;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">images</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.image = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CubeTexture.prototype.isCubeTexture = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WebGLCubeRenderTarget</span> <span class="keyword">extends</span> <span class="title">WebGLRenderTarget</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">size, options = &#123;&#125;</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(size, size, options);</span><br><span class="line">            <span class="keyword">const</span> image = &#123;</span><br><span class="line">                <span class="attr">width</span>: size,</span><br><span class="line">                <span class="attr">height</span>: size,</span><br><span class="line">                <span class="attr">depth</span>: <span class="number">1</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">const</span> images = [image, image, image, image, image, image];</span><br><span class="line">            <span class="built_in">this</span>.texture = <span class="keyword">new</span> CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding); <span class="comment">// By convention -- likely based on the RenderMan spec from the 1990&#x27;s -- cube maps are specified by WebGL (and three.js)</span></span><br><span class="line">            <span class="comment">// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,</span></span><br><span class="line">            <span class="comment">// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.</span></span><br><span class="line">            <span class="comment">// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped</span></span><br><span class="line">            <span class="comment">// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture</span></span><br><span class="line">            <span class="comment">// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.texture.isRenderTargetTexture = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.texture.generateMipmaps = options.generateMipmaps !== <span class="literal">undefined</span> ? options.generateMipmaps : <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.texture.minFilter = options.minFilter !== <span class="literal">undefined</span> ? options.minFilter : LinearFilter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromEquirectangularTexture</span>(<span class="params">renderer, texture</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.texture.type = texture.type;</span><br><span class="line">            <span class="built_in">this</span>.texture.encoding = texture.encoding;</span><br><span class="line">            <span class="built_in">this</span>.texture.generateMipmaps = texture.generateMipmaps;</span><br><span class="line">            <span class="built_in">this</span>.texture.minFilter = texture.minFilter;</span><br><span class="line">            <span class="built_in">this</span>.texture.magFilter = texture.magFilter;</span><br><span class="line">            <span class="keyword">const</span> shader = &#123;</span><br><span class="line">                <span class="attr">uniforms</span>: &#123;</span><br><span class="line">                    <span class="attr">tEquirect</span>: &#123;</span><br><span class="line">                        <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">vertexShader</span>:</span><br><span class="line">                <span class="comment">/* glsl */</span></span><br><span class="line">                    <span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				varying vec3 vWorldDirection;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				vec3 transformDirection( in vec3 dir, in mat4 matrix ) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				void main() &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">					vWorldDirection = transformDirection( position, modelMatrix );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">					#include &lt;begin_vertex&gt;</span></span><br><span class="line"><span class="string">					#include &lt;project_vertex&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				&#125;</span></span><br><span class="line"><span class="string">			`</span>,</span><br><span class="line">                <span class="attr">fragmentShader</span>:</span><br><span class="line">                <span class="comment">/* glsl */</span></span><br><span class="line">                    <span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				uniform sampler2D tEquirect;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				varying vec3 vWorldDirection;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				#include &lt;common&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				void main() &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">					vec3 direction = normalize( vWorldDirection );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">					vec2 sampleUV = equirectUv( direction );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">					gl_FragColor = texture2D( tEquirect, sampleUV );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				&#125;</span></span><br><span class="line"><span class="string">			`</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">const</span> geometry = <span class="keyword">new</span> BoxGeometry(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">            <span class="keyword">const</span> material = <span class="keyword">new</span> ShaderMaterial(&#123;</span><br><span class="line">                <span class="attr">name</span>: <span class="string">&#x27;CubemapFromEquirect&#x27;</span>,</span><br><span class="line">                <span class="attr">uniforms</span>: cloneUniforms(shader.uniforms),</span><br><span class="line">                <span class="attr">vertexShader</span>: shader.vertexShader,</span><br><span class="line">                <span class="attr">fragmentShader</span>: shader.fragmentShader,</span><br><span class="line">                <span class="attr">side</span>: BackSide,</span><br><span class="line">                <span class="attr">blending</span>: NoBlending</span><br><span class="line">            &#125;);</span><br><span class="line">            material.uniforms.tEquirect.value = texture;</span><br><span class="line">            <span class="keyword">const</span> mesh = <span class="keyword">new</span> Mesh(geometry, material);</span><br><span class="line">            <span class="keyword">const</span> currentMinFilter = texture.minFilter; <span class="comment">// Avoid blurred poles</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;</span><br><span class="line">            <span class="keyword">const</span> camera = <span class="keyword">new</span> CubeCamera(<span class="number">1</span>, <span class="number">10</span>, <span class="built_in">this</span>);</span><br><span class="line">            camera.update(renderer, mesh);</span><br><span class="line">            texture.minFilter = currentMinFilter;</span><br><span class="line">            mesh.geometry.dispose();</span><br><span class="line">            mesh.material.dispose();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clear</span>(<span class="params">renderer, color, depth, stencil</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> currentRenderTarget = renderer.getRenderTarget();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                renderer.setRenderTarget(<span class="built_in">this</span>, i);</span><br><span class="line">                renderer.clear(color, depth, stencil);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            renderer.setRenderTarget(currentRenderTarget);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vector1 = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vector2 = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _normalMatrix = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Matrix3();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Plane</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">normal = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), constant = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// normal is assumed to be normalized</span></span><br><span class="line">            <span class="built_in">this</span>.normal = normal;</span><br><span class="line">            <span class="built_in">this</span>.constant = constant;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">normal, constant</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.normal.copy(normal);</span><br><span class="line">            <span class="built_in">this</span>.constant = constant;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setComponents</span>(<span class="params">x, y, z, w</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.normal.set(x, y, z);</span><br><span class="line">            <span class="built_in">this</span>.constant = w;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromNormalAndCoplanarPoint</span>(<span class="params">normal, point</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.normal.copy(normal);</span><br><span class="line">            <span class="built_in">this</span>.constant = -point.dot(<span class="built_in">this</span>.normal);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromCoplanarPoints</span>(<span class="params">a, b, c</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize(); <span class="comment">// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setFromNormalAndCoplanarPoint(normal, a);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">plane</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.normal.copy(plane.normal);</span><br><span class="line">            <span class="built_in">this</span>.constant = plane.constant;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">normalize</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// Note: will lead to a divide by zero if the plane is invalid.</span></span><br><span class="line">            <span class="keyword">const</span> inverseNormalLength = <span class="number">1.0</span> / <span class="built_in">this</span>.normal.length();</span><br><span class="line">            <span class="built_in">this</span>.normal.multiplyScalar(inverseNormalLength);</span><br><span class="line">            <span class="built_in">this</span>.constant *= inverseNormalLength;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">negate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.constant *= -<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.normal.negate();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">distanceToPoint</span>(<span class="params">point</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.normal.dot(point) + <span class="built_in">this</span>.constant;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">distanceToSphere</span>(<span class="params">sphere</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.distanceToPoint(sphere.center) - sphere.radius;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">projectPoint</span>(<span class="params">point, target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> target.copy(<span class="built_in">this</span>.normal).multiplyScalar(-<span class="built_in">this</span>.distanceToPoint(point)).add(point);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectLine</span>(<span class="params">line, target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> direction = line.delta(_vector1);</span><br><span class="line">            <span class="keyword">const</span> denominator = <span class="built_in">this</span>.normal.dot(direction);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (denominator === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// line is coplanar, return origin</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.distanceToPoint(line.start) === <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> target.copy(line.start);</span><br><span class="line">                &#125; <span class="comment">// Unsure if this is the correct method to handle this case.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> t = -(line.start.dot(<span class="built_in">this</span>.normal) + <span class="built_in">this</span>.constant) / denominator;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t &lt; <span class="number">0</span> || t &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> target.copy(direction).multiplyScalar(t).add(line.start);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectsLine</span>(<span class="params">line</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.</span></span><br><span class="line">            <span class="keyword">const</span> startSign = <span class="built_in">this</span>.distanceToPoint(line.start);</span><br><span class="line">            <span class="keyword">const</span> endSign = <span class="built_in">this</span>.distanceToPoint(line.end);</span><br><span class="line">            <span class="keyword">return</span> startSign &lt; <span class="number">0</span> &amp;&amp; endSign &gt; <span class="number">0</span> || endSign &lt; <span class="number">0</span> &amp;&amp; startSign &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectsBox</span>(<span class="params">box</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> box.intersectsPlane(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectsSphere</span>(<span class="params">sphere</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sphere.intersectsPlane(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">coplanarPoint</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> target.copy(<span class="built_in">this</span>.normal).multiplyScalar(-<span class="built_in">this</span>.constant);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">applyMatrix4</span>(<span class="params">matrix, optionalNormalMatrix</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> referencePoint = <span class="built_in">this</span>.coplanarPoint(_vector1).applyMatrix4(matrix);</span><br><span class="line">            <span class="keyword">const</span> normal = <span class="built_in">this</span>.normal.applyMatrix3(normalMatrix).normalize();</span><br><span class="line">            <span class="built_in">this</span>.constant = -referencePoint.dot(normal);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">translate</span>(<span class="params">offset</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.constant -= offset.dot(<span class="built_in">this</span>.normal);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">equals</span>(<span class="params">plane</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> plane.normal.equals(<span class="built_in">this</span>.normal) &amp;&amp; plane.constant === <span class="built_in">this</span>.constant;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor().copy(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Plane.prototype.isPlane = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _sphere$<span class="number">2</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Sphere();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vector$<span class="number">7</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Frustum</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">p0 = <span class="keyword">new</span> Plane(), p1 = <span class="keyword">new</span> Plane(), p2 = <span class="keyword">new</span> Plane(), p3 = <span class="keyword">new</span> Plane(), p4 = <span class="keyword">new</span> Plane(), p5 = <span class="keyword">new</span> Plane()</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.planes = [p0, p1, p2, p3, p4, p5];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">p0, p1, p2, p3, p4, p5</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> planes = <span class="built_in">this</span>.planes;</span><br><span class="line">            planes[<span class="number">0</span>].copy(p0);</span><br><span class="line">            planes[<span class="number">1</span>].copy(p1);</span><br><span class="line">            planes[<span class="number">2</span>].copy(p2);</span><br><span class="line">            planes[<span class="number">3</span>].copy(p3);</span><br><span class="line">            planes[<span class="number">4</span>].copy(p4);</span><br><span class="line">            planes[<span class="number">5</span>].copy(p5);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">frustum</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> planes = <span class="built_in">this</span>.planes;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                planes[i].copy(frustum.planes[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromProjectionMatrix</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> planes = <span class="built_in">this</span>.planes;</span><br><span class="line">            <span class="keyword">const</span> me = m.elements;</span><br><span class="line">            <span class="keyword">const</span> me0 = me[<span class="number">0</span>],</span><br><span class="line">                me1 = me[<span class="number">1</span>],</span><br><span class="line">                me2 = me[<span class="number">2</span>],</span><br><span class="line">                me3 = me[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">const</span> me4 = me[<span class="number">4</span>],</span><br><span class="line">                me5 = me[<span class="number">5</span>],</span><br><span class="line">                me6 = me[<span class="number">6</span>],</span><br><span class="line">                me7 = me[<span class="number">7</span>];</span><br><span class="line">            <span class="keyword">const</span> me8 = me[<span class="number">8</span>],</span><br><span class="line">                me9 = me[<span class="number">9</span>],</span><br><span class="line">                me10 = me[<span class="number">10</span>],</span><br><span class="line">                me11 = me[<span class="number">11</span>];</span><br><span class="line">            <span class="keyword">const</span> me12 = me[<span class="number">12</span>],</span><br><span class="line">                me13 = me[<span class="number">13</span>],</span><br><span class="line">                me14 = me[<span class="number">14</span>],</span><br><span class="line">                me15 = me[<span class="number">15</span>];</span><br><span class="line">            planes[<span class="number">0</span>].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();</span><br><span class="line">            planes[<span class="number">1</span>].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();</span><br><span class="line">            planes[<span class="number">2</span>].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();</span><br><span class="line">            planes[<span class="number">3</span>].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();</span><br><span class="line">            planes[<span class="number">4</span>].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();</span><br><span class="line">            planes[<span class="number">5</span>].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectsObject</span>(<span class="params">object</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> geometry = object.geometry;</span><br><span class="line">            <span class="keyword">if</span> (geometry.boundingSphere === <span class="literal">null</span>) geometry.computeBoundingSphere();</span><br><span class="line"></span><br><span class="line">            _sphere$<span class="number">2.</span>copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.intersectsSphere(_sphere$<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectsSprite</span>(<span class="params">sprite</span>)</span> &#123;</span><br><span class="line">            _sphere$<span class="number">2.</span>center.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            _sphere$<span class="number">2.</span>radius = <span class="number">0.7071067811865476</span>;</span><br><span class="line"></span><br><span class="line">            _sphere$<span class="number">2.</span>applyMatrix4(sprite.matrixWorld);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.intersectsSphere(_sphere$<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectsSphere</span>(<span class="params">sphere</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> planes = <span class="built_in">this</span>.planes;</span><br><span class="line">            <span class="keyword">const</span> center = sphere.center;</span><br><span class="line">            <span class="keyword">const</span> negRadius = -sphere.radius;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> distance = planes[i].distanceToPoint(center);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (distance &lt; negRadius) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectsBox</span>(<span class="params">box</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> planes = <span class="built_in">this</span>.planes;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> plane = planes[i]; <span class="comment">// corner at max distance</span></span><br><span class="line"></span><br><span class="line">                _vector$<span class="number">7.</span>x = plane.normal.x &gt; <span class="number">0</span> ? box.max.x : box.min.x;</span><br><span class="line">                _vector$<span class="number">7.</span>y = plane.normal.y &gt; <span class="number">0</span> ? box.max.y : box.min.y;</span><br><span class="line">                _vector$<span class="number">7.</span>z = plane.normal.z &gt; <span class="number">0</span> ? box.max.z : box.min.z;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (plane.distanceToPoint(_vector$<span class="number">7</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">containsPoint</span>(<span class="params">point</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> planes = <span class="built_in">this</span>.planes;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (planes[i].distanceToPoint(point) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor().copy(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLAnimation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> isAnimating = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">let</span> animationLoop = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> requestId = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">onAnimationFrame</span>(<span class="params">time, frame</span>) </span>&#123;</span><br><span class="line">            animationLoop(time, frame);</span><br><span class="line">            requestId = context.requestAnimationFrame(onAnimationFrame);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">start</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (isAnimating === <span class="literal">true</span>) <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">if</span> (animationLoop === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">                requestId = context.requestAnimationFrame(onAnimationFrame);</span><br><span class="line">                isAnimating = <span class="literal">true</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">stop</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                context.cancelAnimationFrame(requestId);</span><br><span class="line">                isAnimating = <span class="literal">false</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">setAnimationLoop</span>: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">                animationLoop = callback;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">setContext</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                context = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLAttributes</span>(<span class="params">gl, capabilities</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> isWebGL2 = capabilities.isWebGL2;</span><br><span class="line">        <span class="keyword">const</span> buffers = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">createBuffer</span>(<span class="params">attribute, bufferType</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> array = attribute.array;</span><br><span class="line">            <span class="keyword">const</span> usage = attribute.usage;</span><br><span class="line">            <span class="keyword">const</span> buffer = gl.createBuffer();</span><br><span class="line">            gl.bindBuffer(bufferType, buffer);</span><br><span class="line">            gl.bufferData(bufferType, array, usage);</span><br><span class="line">            attribute.onUploadCallback();</span><br><span class="line">            <span class="keyword">let</span> type;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (array <span class="keyword">instanceof</span> <span class="built_in">Float32Array</span>) &#123;</span><br><span class="line">                type = gl.FLOAT;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array <span class="keyword">instanceof</span> <span class="built_in">Uint16Array</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (attribute.isFloat16BufferAttribute) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isWebGL2) &#123;</span><br><span class="line">                        type = gl.HALF_FLOAT;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.&#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    type = gl.UNSIGNED_SHORT;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array <span class="keyword">instanceof</span> <span class="built_in">Int16Array</span>) &#123;</span><br><span class="line">                type = gl.SHORT;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array <span class="keyword">instanceof</span> <span class="built_in">Uint32Array</span>) &#123;</span><br><span class="line">                type = gl.UNSIGNED_INT;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array <span class="keyword">instanceof</span> <span class="built_in">Int32Array</span>) &#123;</span><br><span class="line">                type = gl.INT;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array <span class="keyword">instanceof</span> <span class="built_in">Int8Array</span>) &#123;</span><br><span class="line">                type = gl.BYTE;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array <span class="keyword">instanceof</span> <span class="built_in">Uint8Array</span>) &#123;</span><br><span class="line">                type = gl.UNSIGNED_BYTE;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array <span class="keyword">instanceof</span> <span class="built_in">Uint8ClampedArray</span>) &#123;</span><br><span class="line">                type = gl.UNSIGNED_BYTE;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;THREE.WebGLAttributes: Unsupported buffer data format: &#x27;</span> + array);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">buffer</span>: buffer,</span><br><span class="line">                <span class="attr">type</span>: type,</span><br><span class="line">                <span class="attr">bytesPerElement</span>: array.BYTES_PER_ELEMENT,</span><br><span class="line">                <span class="attr">version</span>: attribute.version</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">updateBuffer</span>(<span class="params">buffer, attribute, bufferType</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> array = attribute.array;</span><br><span class="line">            <span class="keyword">const</span> updateRange = attribute.updateRange;</span><br><span class="line">            gl.bindBuffer(bufferType, buffer);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (updateRange.count === -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// Not using update ranges</span></span><br><span class="line">                gl.bufferSubData(bufferType, <span class="number">0</span>, array);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isWebGL2) &#123;</span><br><span class="line">                    gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                updateRange.count = -<span class="number">1</span>; <span class="comment">// reset range</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">attribute</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (attribute.isInterleavedBufferAttribute) attribute = attribute.data;</span><br><span class="line">            <span class="keyword">return</span> buffers.get(attribute);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">attribute</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (attribute.isInterleavedBufferAttribute) attribute = attribute.data;</span><br><span class="line">            <span class="keyword">const</span> data = buffers.get(attribute);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (data) &#123;</span><br><span class="line">                gl.deleteBuffer(data.buffer);</span><br><span class="line">                buffers.delete(attribute);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">attribute, bufferType</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (attribute.isGLBufferAttribute) &#123;</span><br><span class="line">                <span class="keyword">const</span> cached = buffers.get(attribute);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!cached || cached.version &lt; attribute.version) &#123;</span><br><span class="line">                    buffers.set(attribute, &#123;</span><br><span class="line">                        <span class="attr">buffer</span>: attribute.buffer,</span><br><span class="line">                        <span class="attr">type</span>: attribute.type,</span><br><span class="line">                        <span class="attr">bytesPerElement</span>: attribute.elementSize,</span><br><span class="line">                        <span class="attr">version</span>: attribute.version</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (attribute.isInterleavedBufferAttribute) attribute = attribute.data;</span><br><span class="line">            <span class="keyword">const</span> data = buffers.get(attribute);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (data === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                buffers.set(attribute, createBuffer(attribute, bufferType));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.version &lt; attribute.version) &#123;</span><br><span class="line">                updateBuffer(data.buffer, attribute, bufferType);</span><br><span class="line">                data.version = attribute.version;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">get</span>: get,</span><br><span class="line">            <span class="attr">remove</span>: remove,</span><br><span class="line">            <span class="attr">update</span>: update</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PlaneGeometry</span> <span class="keyword">extends</span> <span class="title">BufferGeometry</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">width = <span class="number">1</span>, height = <span class="number">1</span>, widthSegments = <span class="number">1</span>, heightSegments = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;PlaneGeometry&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.parameters = &#123;</span><br><span class="line">                <span class="attr">width</span>: width,</span><br><span class="line">                <span class="attr">height</span>: height,</span><br><span class="line">                <span class="attr">widthSegments</span>: widthSegments,</span><br><span class="line">                <span class="attr">heightSegments</span>: heightSegments</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">const</span> width_half = width / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">const</span> height_half = height / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">const</span> gridX = <span class="built_in">Math</span>.floor(widthSegments);</span><br><span class="line">            <span class="keyword">const</span> gridY = <span class="built_in">Math</span>.floor(heightSegments);</span><br><span class="line">            <span class="keyword">const</span> gridX1 = gridX + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">const</span> gridY1 = gridY + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">const</span> segment_width = width / gridX;</span><br><span class="line">            <span class="keyword">const</span> segment_height = height / gridY; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> indices = [];</span><br><span class="line">            <span class="keyword">const</span> vertices = [];</span><br><span class="line">            <span class="keyword">const</span> normals = [];</span><br><span class="line">            <span class="keyword">const</span> uvs = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> iy = <span class="number">0</span>; iy &lt; gridY1; iy++) &#123;</span><br><span class="line">                <span class="keyword">const</span> y = iy * segment_height - height_half;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> ix = <span class="number">0</span>; ix &lt; gridX1; ix++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> x = ix * segment_width - width_half;</span><br><span class="line">                    vertices.push(x, -y, <span class="number">0</span>);</span><br><span class="line">                    normals.push(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                    uvs.push(ix / gridX);</span><br><span class="line">                    uvs.push(<span class="number">1</span> - iy / gridY);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> iy = <span class="number">0</span>; iy &lt; gridY; iy++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> ix = <span class="number">0</span>; ix &lt; gridX; ix++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> a = ix + gridX1 * iy;</span><br><span class="line">                    <span class="keyword">const</span> b = ix + gridX1 * (iy + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">const</span> c = ix + <span class="number">1</span> + gridX1 * (iy + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">const</span> d = ix + <span class="number">1</span> + gridX1 * iy;</span><br><span class="line">                    indices.push(a, b, d);</span><br><span class="line">                    indices.push(b, c, d);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setIndex(indices);</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(vertices, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;normal&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(normals, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;uv&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(uvs, <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">fromJSON</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> alphamap_fragment = <span class="string">&quot;#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> alphamap_pars_fragment = <span class="string">&quot;#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> alphatest_fragment = <span class="string">&quot;#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a &lt; alphaTest ) discard;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> alphatest_pars_fragment = <span class="string">&quot;#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> aomap_fragment = <span class="string">&quot;#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) &amp;&amp; defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> aomap_pars_fragment = <span class="string">&quot;#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> begin_vertex = <span class="string">&quot;vec3 transformed = vec3( position );&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> beginnormal_vertex = <span class="string">&quot;vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> bsdfs = <span class="string">&quot;vec3 BRDF_Lambert( const in vec3 diffuseColor ) &#123;\n\treturn RECIPROCAL_PI * diffuseColor;\n&#125;\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) &#123;\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n&#125;\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) &#123;\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n&#125;\nfloat D_GGX( const in float alpha, const in float dotNH ) &#123;\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n&#125;\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) &#123;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n&#125;\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) &#123;\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n&#125;\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) &#123;\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n&#125;\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) &#123;\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x &gt; 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n&#125;\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) &#123;\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) &lt; 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n&#125;\nfloat G_BlinnPhong_Implicit( ) &#123;\n\treturn 0.25;\n&#125;\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) &#123;\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n&#125;\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) &#123;\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n&#125;\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) &#123;\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n&#125;\nfloat V_Neubelt( float dotNV, float dotNL ) &#123;\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n&#125;\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) &#123;\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n&#125;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> bumpmap_pars_fragment = <span class="string">&quot;#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() &#123;\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t&#125;\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) &#123;\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t&#125;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> clipping_planes_fragment = <span class="string">&quot;#if NUM_CLIPPING_PLANES &gt; 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i &lt; UNION_CLIPPING_PLANES; i ++ ) &#123;\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) &gt; plane.w ) discard;\n\t&#125;\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES &lt; NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i &lt; NUM_CLIPPING_PLANES; i ++ ) &#123;\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) &gt; plane.w ) &amp;&amp; clipped;\n\t\t&#125;\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> clipping_planes_pars_fragment = <span class="string">&quot;#if NUM_CLIPPING_PLANES &gt; 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> clipping_planes_pars_vertex = <span class="string">&quot;#if NUM_CLIPPING_PLANES &gt; 0\n\tvarying vec3 vClipPosition;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> clipping_planes_vertex = <span class="string">&quot;#if NUM_CLIPPING_PLANES &gt; 0\n\tvClipPosition = - mvPosition.xyz;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> color_fragment = <span class="string">&quot;#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> color_pars_fragment = <span class="string">&quot;#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> color_pars_vertex = <span class="string">&quot;#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> color_vertex = <span class="string">&quot;#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> common = <span class="string">&quot;#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) &#123; return x*x; &#125;\nfloat pow3( const in float x ) &#123; return x*x*x; &#125;\nfloat pow4( const in float x ) &#123; float x2 = x*x; return x2*x2; &#125;\nfloat max3( const in vec3 v ) &#123; return max( max( v.x, v.y ), v.z ); &#125;\nfloat average( const in vec3 color ) &#123; return dot( color, vec3( 0.3333 ) ); &#125;\nhighp float rand( const in vec2 uv ) &#123;\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n&#125;\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) &#123; return length( v ); &#125;\n#else\n\tfloat precisionSafeLength( vec3 v ) &#123;\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t&#125;\n#endif\nstruct IncidentLight &#123;\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n&#125;;\nstruct ReflectedLight &#123;\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n&#125;;\nstruct GeometricContext &#123;\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n&#125;;\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) &#123;\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n&#125;\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) &#123;\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n&#125;\nmat3 transposeMat3( const in mat3 m ) &#123;\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n&#125;\nfloat linearToRelativeLuminance( const in vec3 color ) &#123;\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n&#125;\nbool isPerspectiveMatrix( mat4 m ) &#123;\n\treturn m[ 2 ][ 3 ] == - 1.0;\n&#125;\nvec2 equirectUv( in vec3 dir ) &#123;\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cube_uv_reflection_fragment = <span class="string">&quot;#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) &#123;\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x &gt; absDirection.z ) &#123;\n\t\t\tif ( absDirection.x &gt; absDirection.y )\n\t\t\t\tface = direction.x &gt; 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y &gt; 0.0 ? 1.0 : 4.0;\n\t\t&#125; else &#123;\n\t\t\tif ( absDirection.z &gt; absDirection.y )\n\t\t\t\tface = direction.z &gt; 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y &gt; 0.0 ? 1.0 : 4.0;\n\t\t&#125;\n\t\treturn face;\n\t&#125;\n\tvec2 getUV( vec3 direction, float face ) &#123;\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) &#123;\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t&#125; else if ( face == 1.0 ) &#123;\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t&#125; else if ( face == 2.0 ) &#123;\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t&#125; else if ( face == 3.0 ) &#123;\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t&#125; else if ( face == 4.0 ) &#123;\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t&#125; else &#123;\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t&#125;\n\t\treturn 0.5 * ( uv + 1.0 );\n\t&#125;\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) &#123;\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n\t\tif ( face &gt; 2.0 ) &#123;\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t&#125;\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t&#125;\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) &#123;\n\t\tfloat mip = 0.0;\n\t\tif ( roughness &gt;= r1 ) &#123;\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t&#125; else if ( roughness &gt;= r4 ) &#123;\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t&#125; else if ( roughness &gt;= r5 ) &#123;\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t&#125; else if ( roughness &gt;= r6 ) &#123;\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t&#125; else &#123;\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t&#125;\n\t\treturn mip;\n\t&#125;\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) &#123;\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) &#123;\n\t\t\treturn vec4( color0, 1.0 );\n\t\t&#125; else &#123;\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t&#125;\n\t&#125;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> defaultnormal_vertex = <span class="string">&quot;vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> displacementmap_pars_vertex = <span class="string">&quot;#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> displacementmap_vertex = <span class="string">&quot;#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> emissivemap_fragment = <span class="string">&quot;#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> emissivemap_pars_fragment = <span class="string">&quot;#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> encodings_fragment = <span class="string">&quot;gl_FragColor = linearToOutputTexel( gl_FragColor );&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> encodings_pars_fragment = <span class="string">&quot;vec4 LinearToLinear( in vec4 value ) &#123;\n\treturn value;\n&#125;\nvec4 LinearTosRGB( in vec4 value ) &#123;\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> envmap_fragment = <span class="string">&quot;#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) &#123;\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t&#125; else &#123;\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t&#125;\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> envmap_common_pars_fragment = <span class="string">&quot;#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> envmap_pars_fragment = <span class="string">&quot;#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> envmap_pars_vertex = <span class="string">&quot;#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> envmap_vertex = <span class="string">&quot;#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) &#123;\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t&#125; else &#123;\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t&#125;\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fog_vertex = <span class="string">&quot;#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fog_pars_vertex = <span class="string">&quot;#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fog_fragment = <span class="string">&quot;#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fog_pars_fragment = <span class="string">&quot;#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> gradientmap_pars_fragment = <span class="string">&quot;#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) &#123;\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x &lt; 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> lightmap_fragment = <span class="string">&quot;#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> lightmap_pars_fragment = <span class="string">&quot;#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> lights_lambert_vertex = <span class="string">&quot;vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS &gt; 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i &lt; NUM_POINT_LIGHTS; i ++ ) &#123;\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t&#125;\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS &gt; 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i &lt; NUM_SPOT_LIGHTS; i ++ ) &#123;\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t&#125;\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS &gt; 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i &lt; NUM_DIR_LIGHTS; i ++ ) &#123;\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t&#125;\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS &gt; 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i &lt; NUM_HEMI_LIGHTS; i ++ ) &#123;\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t&#125;\n\t#pragma unroll_loop_end\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> lights_pars_begin = <span class="string">&quot;uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) &#123;\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n&#125;\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) &#123;\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n&#125;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) &#123;\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n&#125;\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) &#123;\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance &gt; 0.0 ) &#123;\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t&#125;\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance &gt; 0.0 &amp;&amp; decayExponent &gt; 0.0 ) &#123;\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t&#125;\n\t\treturn 1.0;\n\t#endif\n&#125;\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) &#123;\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n&#125;\n#if NUM_DIR_LIGHTS &gt; 0\n\tstruct DirectionalLight &#123;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t&#125;;\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) &#123;\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t&#125;\n#endif\n#if NUM_POINT_LIGHTS &gt; 0\n\tstruct PointLight &#123;\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t&#125;;\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) &#123;\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t&#125;\n#endif\n#if NUM_SPOT_LIGHTS &gt; 0\n\tstruct SpotLight &#123;\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t&#125;;\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) &#123;\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation &gt; 0.0 ) &#123;\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t&#125; else &#123;\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t&#125;\n\t&#125;\n#endif\n#if NUM_RECT_AREA_LIGHTS &gt; 0\n\tstruct RectAreaLight &#123;\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t&#125;;\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS &gt; 0\n\tstruct HemisphereLight &#123;\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t&#125;;\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) &#123;\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t&#125;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> envmap_physical_pars_fragment = <span class="string">&quot;#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) &#123;\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t&#125;\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) &#123;\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t&#125;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> lights_toon_fragment = <span class="string">&quot;ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> lights_toon_pars_fragment = <span class="string">&quot;varying vec3 vViewPosition;\nstruct ToonMaterial &#123;\n\tvec3 diffuseColor;\n&#125;;\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) &#123;\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n&#125;\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) &#123;\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n&#125;\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> lights_phong_fragment = <span class="string">&quot;BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> lights_phong_pars_fragment = <span class="string">&quot;varying vec3 vViewPosition;\nstruct BlinnPhongMaterial &#123;\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n&#125;;\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) &#123;\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n&#125;\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) &#123;\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n&#125;\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> lights_physical_fragment = <span class="string">&quot;PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> lights_physical_pars_fragment = <span class="string">&quot;struct PhysicalMaterial &#123;\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n&#125;;\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) &#123;\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness &lt; 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness &lt; 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness &lt; 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n&#125;\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) &#123;\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n&#125;\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) &#123;\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n&#125;\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) &#123;\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n&#125;\n#if NUM_RECT_AREA_LIGHTS &gt; 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) &#123;\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(		0, 1,		0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t&#125;\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) &#123;\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n&#125;\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) &#123;\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n&#125;\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) &#123;\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n&#125;\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) &#123;\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> lights_fragment_begin = <span class="string">&quot;\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS &gt; 0 ) &amp;&amp; defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) &amp;&amp; NUM_POINT_LIGHT_SHADOWS &gt; 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i &lt; NUM_POINT_LIGHTS; i ++ ) &#123;\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) &amp;&amp; ( UNROLLED_LOOP_INDEX &lt; NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t&#125;\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS &gt; 0 ) &amp;&amp; defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) &amp;&amp; NUM_SPOT_LIGHT_SHADOWS &gt; 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i &lt; NUM_SPOT_LIGHTS; i ++ ) &#123;\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) &amp;&amp; ( UNROLLED_LOOP_INDEX &lt; NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t&#125;\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS &gt; 0 ) &amp;&amp; defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) &amp;&amp; NUM_DIR_LIGHT_SHADOWS &gt; 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i &lt; NUM_DIR_LIGHTS; i ++ ) &#123;\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) &amp;&amp; ( UNROLLED_LOOP_INDEX &lt; NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t&#125;\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS &gt; 0 ) &amp;&amp; defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i &lt; NUM_RECT_AREA_LIGHTS; i ++ ) &#123;\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t&#125;\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS &gt; 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i &lt; NUM_HEMI_LIGHTS; i ++ ) &#123;\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t&#125;\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> lights_fragment_maps = <span class="string">&quot;#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) &amp;&amp; defined( STANDARD ) &amp;&amp; defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) &amp;&amp; defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> lights_fragment_end = <span class="string">&quot;#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> logdepthbuf_fragment = <span class="string">&quot;#if defined( USE_LOGDEPTHBUF ) &amp;&amp; defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> logdepthbuf_pars_fragment = <span class="string">&quot;#if defined( USE_LOGDEPTHBUF ) &amp;&amp; defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> logdepthbuf_pars_vertex = <span class="string">&quot;#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> logdepthbuf_vertex = <span class="string">&quot;#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) &#123;\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t&#125;\n\t#endif\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> map_fragment = <span class="string">&quot;#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> map_pars_fragment = <span class="string">&quot;#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> map_particle_fragment = <span class="string">&quot;#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> map_particle_pars_fragment = <span class="string">&quot;#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> metalnessmap_fragment = <span class="string">&quot;float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> metalnessmap_pars_fragment = <span class="string">&quot;#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> morphcolor_vertex = <span class="string">&quot;#if defined( USE_MORPHCOLORS ) &amp;&amp; defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i &lt; MORPHTARGETS_COUNT; i ++ ) &#123;\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t&#125;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> morphnormal_vertex = <span class="string">&quot;#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i &lt; MORPHTARGETS_COUNT; i ++ ) &#123;\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t&#125;\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> morphtarget_pars_vertex = <span class="string">&quot;#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) &#123;\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t&#125;\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> morphtarget_vertex = <span class="string">&quot;#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i &lt; MORPHTARGETS_COUNT; i ++ ) &#123;\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t&#125;\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> normal_fragment_begin = <span class="string">&quot;float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> normal_fragment_maps = <span class="string">&quot;#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> normal_pars_fragment = <span class="string">&quot;#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> normal_pars_vertex = <span class="string">&quot;#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> normal_vertex = <span class="string">&quot;#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> normalmap_pars_fragment = <span class="string">&quot;#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) &amp;&amp; ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) &#123;\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t&#125;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> clearcoat_normal_fragment_begin = <span class="string">&quot;#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> clearcoat_normal_fragment_maps = <span class="string">&quot;#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> clearcoat_pars_fragment = <span class="string">&quot;#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> output_fragment = <span class="string">&quot;#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> packing = <span class="string">&quot;vec3 packNormalToRGB( const in vec3 normal ) &#123;\n\treturn normalize( normal ) * 0.5 + 0.5;\n&#125;\nvec3 unpackRGBToNormal( const in vec3 rgb ) &#123;\n\treturn 2.0 * rgb.xyz - 1.0;\n&#125;\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) &#123;\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n&#125;\nfloat unpackRGBAToDepth( const in vec4 v ) &#123;\n\treturn dot( v, UnpackFactors );\n&#125;\nvec4 pack2HalfToRGBA( vec2 v ) &#123;\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n&#125;\nvec2 unpackRGBATo2Half( vec4 v ) &#123;\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n&#125;\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) &#123;\n\treturn ( viewZ + near ) / ( near - far );\n&#125;\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) &#123;\n\treturn linearClipZ * ( near - far ) - near;\n&#125;\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) &#123;\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n&#125;\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) &#123;\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> premultiplied_alpha_fragment = <span class="string">&quot;#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> project_vertex = <span class="string">&quot;vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dithering_fragment = <span class="string">&quot;#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dithering_pars_fragment = <span class="string">&quot;#ifdef DITHERING\n\tvec3 dithering( vec3 color ) &#123;\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t&#125;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> roughnessmap_fragment = <span class="string">&quot;float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> roughnessmap_pars_fragment = <span class="string">&quot;#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> shadowmap_pars_fragment = <span class="string">&quot;#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS &gt; 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow &#123;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t&#125;;\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS &gt; 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow &#123;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t&#125;;\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS &gt; 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow &#123;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t&#125;;\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) &#123;\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t&#125;\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) &#123;\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t&#125;\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare )&#123;\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) &#123;\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t&#125;\n\t\treturn occlusion;\n\t&#125;\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) &#123;\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x &gt;= 0.0, shadowCoord.x &lt;= 1.0, shadowCoord.y &gt;= 0.0, shadowCoord.y &lt;= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z &lt;= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) &#123;\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t	texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t	f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t	texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t	f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t&#125;\n\t\treturn shadow;\n\t&#125;\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) &#123;\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z &gt;= almostOne ) &#123;\n\t\t\tif ( v.z &gt; 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t&#125; else if ( absV.x &gt;= almostOne ) &#123;\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t&#125; else if ( absV.y &gt;= almostOne ) &#123;\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t&#125;\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t&#125;\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) &#123;\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t&#125;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> shadowmap_pars_vertex = <span class="string">&quot;#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS &gt; 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow &#123;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t&#125;;\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS &gt; 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow &#123;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t&#125;;\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS &gt; 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow &#123;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t&#125;;\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> shadowmap_vertex = <span class="string">&quot;#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS &gt; 0 || NUM_SPOT_LIGHT_SHADOWS &gt; 0 || NUM_POINT_LIGHT_SHADOWS &gt; 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS &gt; 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i &lt; NUM_DIR_LIGHT_SHADOWS; i ++ ) &#123;\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t&#125;\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS &gt; 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i &lt; NUM_SPOT_LIGHT_SHADOWS; i ++ ) &#123;\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t&#125;\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS &gt; 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i &lt; NUM_POINT_LIGHT_SHADOWS; i ++ ) &#123;\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t&#125;\n\t#pragma unroll_loop_end\n\t#endif\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> shadowmask_pars_fragment = <span class="string">&quot;float getShadowMask() &#123;\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS &gt; 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i &lt; NUM_DIR_LIGHT_SHADOWS; i ++ ) &#123;\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t&#125;\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS &gt; 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i &lt; NUM_SPOT_LIGHT_SHADOWS; i ++ ) &#123;\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t&#125;\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS &gt; 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i &lt; NUM_POINT_LIGHT_SHADOWS; i ++ ) &#123;\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t&#125;\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> skinbase_vertex = <span class="string">&quot;#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> skinning_pars_vertex = <span class="string">&quot;#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) &#123;\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t&#125;\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) &#123;\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t&#125;\n\t#endif\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> skinning_vertex = <span class="string">&quot;#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> skinnormal_vertex = <span class="string">&quot;#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> specularmap_fragment = <span class="string">&quot;float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> specularmap_pars_fragment = <span class="string">&quot;#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tonemapping_fragment = <span class="string">&quot;#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tonemapping_pars_fragment = <span class="string">&quot;#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) &#123;\n\treturn toneMappingExposure * color;\n&#125;\nvec3 ReinhardToneMapping( vec3 color ) &#123;\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n&#125;\nvec3 OptimizedCineonToneMapping( vec3 color ) &#123;\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n&#125;\nvec3 RRTAndODTFit( vec3 v ) &#123;\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n&#125;\nvec3 ACESFilmicToneMapping( vec3 color ) &#123;\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(	1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,	1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,	1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n&#125;\nvec3 CustomToneMapping( vec3 color ) &#123; return color; &#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> transmission_fragment = <span class="string">&quot;#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> transmission_pars_fragment = <span class="string">&quot;#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) &#123;\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t&#125;\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) &#123;\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t&#125;\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) &#123;\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t&#125;\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) &#123;\n\t\tif ( attenuationDistance == 0.0 ) &#123;\n\t\t\treturn radiance;\n\t\t&#125; else &#123;\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t&#125;\n\t&#125;\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) &#123;\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t&#125;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> uv_pars_fragment = <span class="string">&quot;#if ( defined( USE_UV ) &amp;&amp; ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> uv_pars_vertex = <span class="string">&quot;#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> uv_vertex = <span class="string">&quot;#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> uv2_pars_fragment = <span class="string">&quot;#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> uv2_pars_vertex = <span class="string">&quot;#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> uv2_vertex = <span class="string">&quot;#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> worldpos_vertex = <span class="string">&quot;#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> vertex$g = <span class="string">&quot;varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() &#123;\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> fragment$g = <span class="string">&quot;uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() &#123;\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include &lt;tonemapping_fragment&gt;\n\t#include &lt;encodings_fragment&gt;\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> vertex$f = <span class="string">&quot;varying vec3 vWorldDirection;\n#include &lt;common&gt;\nvoid main() &#123;\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;project_vertex&gt;\n\tgl_Position.z = gl_Position.w;\n&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> fragment$f = <span class="string">&quot;#include &lt;envmap_common_pars_fragment&gt;\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include &lt;cube_uv_reflection_fragment&gt;\nvoid main() &#123;\n\tvec3 vReflect = vWorldDirection;\n\t#include &lt;envmap_fragment&gt;\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include &lt;tonemapping_fragment&gt;\n\t#include &lt;encodings_fragment&gt;\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> vertex$e = <span class="string">&quot;#include &lt;common&gt;\n#include &lt;uv_pars_vertex&gt;\n#include &lt;displacementmap_pars_vertex&gt;\n#include &lt;morphtarget_pars_vertex&gt;\n#include &lt;skinning_pars_vertex&gt;\n#include &lt;logdepthbuf_pars_vertex&gt;\n#include &lt;clipping_planes_pars_vertex&gt;\nvarying vec2 vHighPrecisionZW;\nvoid main() &#123;\n\t#include &lt;uv_vertex&gt;\n\t#include &lt;skinbase_vertex&gt;\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include &lt;beginnormal_vertex&gt;\n\t\t#include &lt;morphnormal_vertex&gt;\n\t\t#include &lt;skinnormal_vertex&gt;\n\t#endif\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;morphtarget_vertex&gt;\n\t#include &lt;skinning_vertex&gt;\n\t#include &lt;displacementmap_vertex&gt;\n\t#include &lt;project_vertex&gt;\n\t#include &lt;logdepthbuf_vertex&gt;\n\t#include &lt;clipping_planes_vertex&gt;\n\tvHighPrecisionZW = gl_Position.zw;\n&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> fragment$e = <span class="string">&quot;#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include &lt;common&gt;\n#include &lt;packing&gt;\n#include &lt;uv_pars_fragment&gt;\n#include &lt;map_pars_fragment&gt;\n#include &lt;alphamap_pars_fragment&gt;\n#include &lt;alphatest_pars_fragment&gt;\n#include &lt;logdepthbuf_pars_fragment&gt;\n#include &lt;clipping_planes_pars_fragment&gt;\nvarying vec2 vHighPrecisionZW;\nvoid main() &#123;\n\t#include &lt;clipping_planes_fragment&gt;\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include &lt;map_fragment&gt;\n\t#include &lt;alphamap_fragment&gt;\n\t#include &lt;alphatest_fragment&gt;\n\t#include &lt;logdepthbuf_fragment&gt;\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> vertex$d = <span class="string">&quot;#define DISTANCE\nvarying vec3 vWorldPosition;\n#include &lt;common&gt;\n#include &lt;uv_pars_vertex&gt;\n#include &lt;displacementmap_pars_vertex&gt;\n#include &lt;morphtarget_pars_vertex&gt;\n#include &lt;skinning_pars_vertex&gt;\n#include &lt;clipping_planes_pars_vertex&gt;\nvoid main() &#123;\n\t#include &lt;uv_vertex&gt;\n\t#include &lt;skinbase_vertex&gt;\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include &lt;beginnormal_vertex&gt;\n\t\t#include &lt;morphnormal_vertex&gt;\n\t\t#include &lt;skinnormal_vertex&gt;\n\t#endif\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;morphtarget_vertex&gt;\n\t#include &lt;skinning_vertex&gt;\n\t#include &lt;displacementmap_vertex&gt;\n\t#include &lt;project_vertex&gt;\n\t#include &lt;worldpos_vertex&gt;\n\t#include &lt;clipping_planes_vertex&gt;\n\tvWorldPosition = worldPosition.xyz;\n&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> fragment$d = <span class="string">&quot;#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include &lt;common&gt;\n#include &lt;packing&gt;\n#include &lt;uv_pars_fragment&gt;\n#include &lt;map_pars_fragment&gt;\n#include &lt;alphamap_pars_fragment&gt;\n#include &lt;alphatest_pars_fragment&gt;\n#include &lt;clipping_planes_pars_fragment&gt;\nvoid main () &#123;\n\t#include &lt;clipping_planes_fragment&gt;\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include &lt;map_fragment&gt;\n\t#include &lt;alphamap_fragment&gt;\n\t#include &lt;alphatest_fragment&gt;\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> vertex$c = <span class="string">&quot;varying vec3 vWorldDirection;\n#include &lt;common&gt;\nvoid main() &#123;\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;project_vertex&gt;\n&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> fragment$c = <span class="string">&quot;uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include &lt;common&gt;\nvoid main() &#123;\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include &lt;tonemapping_fragment&gt;\n\t#include &lt;encodings_fragment&gt;\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> vertex$b = <span class="string">&quot;uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include &lt;common&gt;\n#include &lt;color_pars_vertex&gt;\n#include &lt;fog_pars_vertex&gt;\n#include &lt;morphtarget_pars_vertex&gt;\n#include &lt;logdepthbuf_pars_vertex&gt;\n#include &lt;clipping_planes_pars_vertex&gt;\nvoid main() &#123;\n\tvLineDistance = scale * lineDistance;\n\t#include &lt;color_vertex&gt;\n\t#include &lt;morphcolor_vertex&gt;\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;morphtarget_vertex&gt;\n\t#include &lt;project_vertex&gt;\n\t#include &lt;logdepthbuf_vertex&gt;\n\t#include &lt;clipping_planes_vertex&gt;\n\t#include &lt;fog_vertex&gt;\n&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> fragment$b = <span class="string">&quot;uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include &lt;common&gt;\n#include &lt;color_pars_fragment&gt;\n#include &lt;fog_pars_fragment&gt;\n#include &lt;logdepthbuf_pars_fragment&gt;\n#include &lt;clipping_planes_pars_fragment&gt;\nvoid main() &#123;\n\t#include &lt;clipping_planes_fragment&gt;\n\tif ( mod( vLineDistance, totalSize ) &gt; dashSize ) &#123;\n\t\tdiscard;\n\t&#125;\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include &lt;logdepthbuf_fragment&gt;\n\t#include &lt;color_fragment&gt;\n\toutgoingLight = diffuseColor.rgb;\n\t#include &lt;output_fragment&gt;\n\t#include &lt;tonemapping_fragment&gt;\n\t#include &lt;encodings_fragment&gt;\n\t#include &lt;fog_fragment&gt;\n\t#include &lt;premultiplied_alpha_fragment&gt;\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> vertex$a = <span class="string">&quot;#include &lt;common&gt;\n#include &lt;uv_pars_vertex&gt;\n#include &lt;uv2_pars_vertex&gt;\n#include &lt;envmap_pars_vertex&gt;\n#include &lt;color_pars_vertex&gt;\n#include &lt;fog_pars_vertex&gt;\n#include &lt;morphtarget_pars_vertex&gt;\n#include &lt;skinning_pars_vertex&gt;\n#include &lt;logdepthbuf_pars_vertex&gt;\n#include &lt;clipping_planes_pars_vertex&gt;\nvoid main() &#123;\n\t#include &lt;uv_vertex&gt;\n\t#include &lt;uv2_vertex&gt;\n\t#include &lt;color_vertex&gt;\n\t#include &lt;morphcolor_vertex&gt;\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include &lt;beginnormal_vertex&gt;\n\t\t#include &lt;morphnormal_vertex&gt;\n\t\t#include &lt;skinbase_vertex&gt;\n\t\t#include &lt;skinnormal_vertex&gt;\n\t\t#include &lt;defaultnormal_vertex&gt;\n\t#endif\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;morphtarget_vertex&gt;\n\t#include &lt;skinning_vertex&gt;\n\t#include &lt;project_vertex&gt;\n\t#include &lt;logdepthbuf_vertex&gt;\n\t#include &lt;clipping_planes_vertex&gt;\n\t#include &lt;worldpos_vertex&gt;\n\t#include &lt;envmap_vertex&gt;\n\t#include &lt;fog_vertex&gt;\n&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> fragment$a = <span class="string">&quot;uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include &lt;common&gt;\n#include &lt;dithering_pars_fragment&gt;\n#include &lt;color_pars_fragment&gt;\n#include &lt;uv_pars_fragment&gt;\n#include &lt;uv2_pars_fragment&gt;\n#include &lt;map_pars_fragment&gt;\n#include &lt;alphamap_pars_fragment&gt;\n#include &lt;alphatest_pars_fragment&gt;\n#include &lt;aomap_pars_fragment&gt;\n#include &lt;lightmap_pars_fragment&gt;\n#include &lt;envmap_common_pars_fragment&gt;\n#include &lt;envmap_pars_fragment&gt;\n#include &lt;cube_uv_reflection_fragment&gt;\n#include &lt;fog_pars_fragment&gt;\n#include &lt;specularmap_pars_fragment&gt;\n#include &lt;logdepthbuf_pars_fragment&gt;\n#include &lt;clipping_planes_pars_fragment&gt;\nvoid main() &#123;\n\t#include &lt;clipping_planes_fragment&gt;\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include &lt;logdepthbuf_fragment&gt;\n\t#include &lt;map_fragment&gt;\n\t#include &lt;color_fragment&gt;\n\t#include &lt;alphamap_fragment&gt;\n\t#include &lt;alphatest_fragment&gt;\n\t#include &lt;specularmap_fragment&gt;\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include &lt;aomap_fragment&gt;\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include &lt;envmap_fragment&gt;\n\t#include &lt;output_fragment&gt;\n\t#include &lt;tonemapping_fragment&gt;\n\t#include &lt;encodings_fragment&gt;\n\t#include &lt;fog_fragment&gt;\n\t#include &lt;premultiplied_alpha_fragment&gt;\n\t#include &lt;dithering_fragment&gt;\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> vertex$<span class="number">9</span> = <span class="string">&quot;#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include &lt;common&gt;\n#include &lt;uv_pars_vertex&gt;\n#include &lt;uv2_pars_vertex&gt;\n#include &lt;envmap_pars_vertex&gt;\n#include &lt;bsdfs&gt;\n#include &lt;lights_pars_begin&gt;\n#include &lt;color_pars_vertex&gt;\n#include &lt;fog_pars_vertex&gt;\n#include &lt;morphtarget_pars_vertex&gt;\n#include &lt;skinning_pars_vertex&gt;\n#include &lt;shadowmap_pars_vertex&gt;\n#include &lt;logdepthbuf_pars_vertex&gt;\n#include &lt;clipping_planes_pars_vertex&gt;\nvoid main() &#123;\n\t#include &lt;uv_vertex&gt;\n\t#include &lt;uv2_vertex&gt;\n\t#include &lt;color_vertex&gt;\n\t#include &lt;morphcolor_vertex&gt;\n\t#include &lt;beginnormal_vertex&gt;\n\t#include &lt;morphnormal_vertex&gt;\n\t#include &lt;skinbase_vertex&gt;\n\t#include &lt;skinnormal_vertex&gt;\n\t#include &lt;defaultnormal_vertex&gt;\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;morphtarget_vertex&gt;\n\t#include &lt;skinning_vertex&gt;\n\t#include &lt;project_vertex&gt;\n\t#include &lt;logdepthbuf_vertex&gt;\n\t#include &lt;clipping_planes_vertex&gt;\n\t#include &lt;worldpos_vertex&gt;\n\t#include &lt;envmap_vertex&gt;\n\t#include &lt;lights_lambert_vertex&gt;\n\t#include &lt;shadowmap_vertex&gt;\n\t#include &lt;fog_vertex&gt;\n&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> fragment$<span class="number">9</span> = <span class="string">&quot;uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include &lt;common&gt;\n#include &lt;packing&gt;\n#include &lt;dithering_pars_fragment&gt;\n#include &lt;color_pars_fragment&gt;\n#include &lt;uv_pars_fragment&gt;\n#include &lt;uv2_pars_fragment&gt;\n#include &lt;map_pars_fragment&gt;\n#include &lt;alphamap_pars_fragment&gt;\n#include &lt;alphatest_pars_fragment&gt;\n#include &lt;aomap_pars_fragment&gt;\n#include &lt;lightmap_pars_fragment&gt;\n#include &lt;emissivemap_pars_fragment&gt;\n#include &lt;envmap_common_pars_fragment&gt;\n#include &lt;envmap_pars_fragment&gt;\n#include &lt;cube_uv_reflection_fragment&gt;\n#include &lt;bsdfs&gt;\n#include &lt;lights_pars_begin&gt;\n#include &lt;fog_pars_fragment&gt;\n#include &lt;shadowmap_pars_fragment&gt;\n#include &lt;shadowmask_pars_fragment&gt;\n#include &lt;specularmap_pars_fragment&gt;\n#include &lt;logdepthbuf_pars_fragment&gt;\n#include &lt;clipping_planes_pars_fragment&gt;\nvoid main() &#123;\n\t#include &lt;clipping_planes_fragment&gt;\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include &lt;logdepthbuf_fragment&gt;\n\t#include &lt;map_fragment&gt;\n\t#include &lt;color_fragment&gt;\n\t#include &lt;alphamap_fragment&gt;\n\t#include &lt;alphatest_fragment&gt;\n\t#include &lt;specularmap_fragment&gt;\n\t#include &lt;emissivemap_fragment&gt;\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include &lt;lightmap_fragment&gt;\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include &lt;aomap_fragment&gt;\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include &lt;envmap_fragment&gt;\n\t#include &lt;output_fragment&gt;\n\t#include &lt;tonemapping_fragment&gt;\n\t#include &lt;encodings_fragment&gt;\n\t#include &lt;fog_fragment&gt;\n\t#include &lt;premultiplied_alpha_fragment&gt;\n\t#include &lt;dithering_fragment&gt;\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> vertex$<span class="number">8</span> = <span class="string">&quot;#define MATCAP\nvarying vec3 vViewPosition;\n#include &lt;common&gt;\n#include &lt;uv_pars_vertex&gt;\n#include &lt;color_pars_vertex&gt;\n#include &lt;displacementmap_pars_vertex&gt;\n#include &lt;fog_pars_vertex&gt;\n#include &lt;normal_pars_vertex&gt;\n#include &lt;morphtarget_pars_vertex&gt;\n#include &lt;skinning_pars_vertex&gt;\n#include &lt;logdepthbuf_pars_vertex&gt;\n#include &lt;clipping_planes_pars_vertex&gt;\nvoid main() &#123;\n\t#include &lt;uv_vertex&gt;\n\t#include &lt;color_vertex&gt;\n\t#include &lt;morphcolor_vertex&gt;\n\t#include &lt;beginnormal_vertex&gt;\n\t#include &lt;morphnormal_vertex&gt;\n\t#include &lt;skinbase_vertex&gt;\n\t#include &lt;skinnormal_vertex&gt;\n\t#include &lt;defaultnormal_vertex&gt;\n\t#include &lt;normal_vertex&gt;\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;morphtarget_vertex&gt;\n\t#include &lt;skinning_vertex&gt;\n\t#include &lt;displacementmap_vertex&gt;\n\t#include &lt;project_vertex&gt;\n\t#include &lt;logdepthbuf_vertex&gt;\n\t#include &lt;clipping_planes_vertex&gt;\n\t#include &lt;fog_vertex&gt;\n\tvViewPosition = - mvPosition.xyz;\n&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> fragment$<span class="number">8</span> = <span class="string">&quot;#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include &lt;common&gt;\n#include &lt;dithering_pars_fragment&gt;\n#include &lt;color_pars_fragment&gt;\n#include &lt;uv_pars_fragment&gt;\n#include &lt;map_pars_fragment&gt;\n#include &lt;alphamap_pars_fragment&gt;\n#include &lt;alphatest_pars_fragment&gt;\n#include &lt;fog_pars_fragment&gt;\n#include &lt;normal_pars_fragment&gt;\n#include &lt;bumpmap_pars_fragment&gt;\n#include &lt;normalmap_pars_fragment&gt;\n#include &lt;logdepthbuf_pars_fragment&gt;\n#include &lt;clipping_planes_pars_fragment&gt;\nvoid main() &#123;\n\t#include &lt;clipping_planes_fragment&gt;\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include &lt;logdepthbuf_fragment&gt;\n\t#include &lt;map_fragment&gt;\n\t#include &lt;color_fragment&gt;\n\t#include &lt;alphamap_fragment&gt;\n\t#include &lt;alphatest_fragment&gt;\n\t#include &lt;normal_fragment_begin&gt;\n\t#include &lt;normal_fragment_maps&gt;\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include &lt;output_fragment&gt;\n\t#include &lt;tonemapping_fragment&gt;\n\t#include &lt;encodings_fragment&gt;\n\t#include &lt;fog_fragment&gt;\n\t#include &lt;premultiplied_alpha_fragment&gt;\n\t#include &lt;dithering_fragment&gt;\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> vertex$<span class="number">7</span> = <span class="string">&quot;#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include &lt;common&gt;\n#include &lt;uv_pars_vertex&gt;\n#include &lt;displacementmap_pars_vertex&gt;\n#include &lt;normal_pars_vertex&gt;\n#include &lt;morphtarget_pars_vertex&gt;\n#include &lt;skinning_pars_vertex&gt;\n#include &lt;logdepthbuf_pars_vertex&gt;\n#include &lt;clipping_planes_pars_vertex&gt;\nvoid main() &#123;\n\t#include &lt;uv_vertex&gt;\n\t#include &lt;beginnormal_vertex&gt;\n\t#include &lt;morphnormal_vertex&gt;\n\t#include &lt;skinbase_vertex&gt;\n\t#include &lt;skinnormal_vertex&gt;\n\t#include &lt;defaultnormal_vertex&gt;\n\t#include &lt;normal_vertex&gt;\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;morphtarget_vertex&gt;\n\t#include &lt;skinning_vertex&gt;\n\t#include &lt;displacementmap_vertex&gt;\n\t#include &lt;project_vertex&gt;\n\t#include &lt;logdepthbuf_vertex&gt;\n\t#include &lt;clipping_planes_vertex&gt;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> fragment$<span class="number">7</span> = <span class="string">&quot;#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include &lt;packing&gt;\n#include &lt;uv_pars_fragment&gt;\n#include &lt;normal_pars_fragment&gt;\n#include &lt;bumpmap_pars_fragment&gt;\n#include &lt;normalmap_pars_fragment&gt;\n#include &lt;logdepthbuf_pars_fragment&gt;\n#include &lt;clipping_planes_pars_fragment&gt;\nvoid main() &#123;\n\t#include &lt;clipping_planes_fragment&gt;\n\t#include &lt;logdepthbuf_fragment&gt;\n\t#include &lt;normal_fragment_begin&gt;\n\t#include &lt;normal_fragment_maps&gt;\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> vertex$<span class="number">6</span> = <span class="string">&quot;#define PHONG\nvarying vec3 vViewPosition;\n#include &lt;common&gt;\n#include &lt;uv_pars_vertex&gt;\n#include &lt;uv2_pars_vertex&gt;\n#include &lt;displacementmap_pars_vertex&gt;\n#include &lt;envmap_pars_vertex&gt;\n#include &lt;color_pars_vertex&gt;\n#include &lt;fog_pars_vertex&gt;\n#include &lt;normal_pars_vertex&gt;\n#include &lt;morphtarget_pars_vertex&gt;\n#include &lt;skinning_pars_vertex&gt;\n#include &lt;shadowmap_pars_vertex&gt;\n#include &lt;logdepthbuf_pars_vertex&gt;\n#include &lt;clipping_planes_pars_vertex&gt;\nvoid main() &#123;\n\t#include &lt;uv_vertex&gt;\n\t#include &lt;uv2_vertex&gt;\n\t#include &lt;color_vertex&gt;\n\t#include &lt;morphcolor_vertex&gt;\n\t#include &lt;beginnormal_vertex&gt;\n\t#include &lt;morphnormal_vertex&gt;\n\t#include &lt;skinbase_vertex&gt;\n\t#include &lt;skinnormal_vertex&gt;\n\t#include &lt;defaultnormal_vertex&gt;\n\t#include &lt;normal_vertex&gt;\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;morphtarget_vertex&gt;\n\t#include &lt;skinning_vertex&gt;\n\t#include &lt;displacementmap_vertex&gt;\n\t#include &lt;project_vertex&gt;\n\t#include &lt;logdepthbuf_vertex&gt;\n\t#include &lt;clipping_planes_vertex&gt;\n\tvViewPosition = - mvPosition.xyz;\n\t#include &lt;worldpos_vertex&gt;\n\t#include &lt;envmap_vertex&gt;\n\t#include &lt;shadowmap_vertex&gt;\n\t#include &lt;fog_vertex&gt;\n&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> fragment$<span class="number">6</span> = <span class="string">&quot;#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include &lt;common&gt;\n#include &lt;packing&gt;\n#include &lt;dithering_pars_fragment&gt;\n#include &lt;color_pars_fragment&gt;\n#include &lt;uv_pars_fragment&gt;\n#include &lt;uv2_pars_fragment&gt;\n#include &lt;map_pars_fragment&gt;\n#include &lt;alphamap_pars_fragment&gt;\n#include &lt;alphatest_pars_fragment&gt;\n#include &lt;aomap_pars_fragment&gt;\n#include &lt;lightmap_pars_fragment&gt;\n#include &lt;emissivemap_pars_fragment&gt;\n#include &lt;envmap_common_pars_fragment&gt;\n#include &lt;envmap_pars_fragment&gt;\n#include &lt;cube_uv_reflection_fragment&gt;\n#include &lt;fog_pars_fragment&gt;\n#include &lt;bsdfs&gt;\n#include &lt;lights_pars_begin&gt;\n#include &lt;normal_pars_fragment&gt;\n#include &lt;lights_phong_pars_fragment&gt;\n#include &lt;shadowmap_pars_fragment&gt;\n#include &lt;bumpmap_pars_fragment&gt;\n#include &lt;normalmap_pars_fragment&gt;\n#include &lt;specularmap_pars_fragment&gt;\n#include &lt;logdepthbuf_pars_fragment&gt;\n#include &lt;clipping_planes_pars_fragment&gt;\nvoid main() &#123;\n\t#include &lt;clipping_planes_fragment&gt;\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include &lt;logdepthbuf_fragment&gt;\n\t#include &lt;map_fragment&gt;\n\t#include &lt;color_fragment&gt;\n\t#include &lt;alphamap_fragment&gt;\n\t#include &lt;alphatest_fragment&gt;\n\t#include &lt;specularmap_fragment&gt;\n\t#include &lt;normal_fragment_begin&gt;\n\t#include &lt;normal_fragment_maps&gt;\n\t#include &lt;emissivemap_fragment&gt;\n\t#include &lt;lights_phong_fragment&gt;\n\t#include &lt;lights_fragment_begin&gt;\n\t#include &lt;lights_fragment_maps&gt;\n\t#include &lt;lights_fragment_end&gt;\n\t#include &lt;aomap_fragment&gt;\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include &lt;envmap_fragment&gt;\n\t#include &lt;output_fragment&gt;\n\t#include &lt;tonemapping_fragment&gt;\n\t#include &lt;encodings_fragment&gt;\n\t#include &lt;fog_fragment&gt;\n\t#include &lt;premultiplied_alpha_fragment&gt;\n\t#include &lt;dithering_fragment&gt;\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> vertex$<span class="number">5</span> = <span class="string">&quot;#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include &lt;common&gt;\n#include &lt;uv_pars_vertex&gt;\n#include &lt;uv2_pars_vertex&gt;\n#include &lt;displacementmap_pars_vertex&gt;\n#include &lt;color_pars_vertex&gt;\n#include &lt;fog_pars_vertex&gt;\n#include &lt;normal_pars_vertex&gt;\n#include &lt;morphtarget_pars_vertex&gt;\n#include &lt;skinning_pars_vertex&gt;\n#include &lt;shadowmap_pars_vertex&gt;\n#include &lt;logdepthbuf_pars_vertex&gt;\n#include &lt;clipping_planes_pars_vertex&gt;\nvoid main() &#123;\n\t#include &lt;uv_vertex&gt;\n\t#include &lt;uv2_vertex&gt;\n\t#include &lt;color_vertex&gt;\n\t#include &lt;morphcolor_vertex&gt;\n\t#include &lt;beginnormal_vertex&gt;\n\t#include &lt;morphnormal_vertex&gt;\n\t#include &lt;skinbase_vertex&gt;\n\t#include &lt;skinnormal_vertex&gt;\n\t#include &lt;defaultnormal_vertex&gt;\n\t#include &lt;normal_vertex&gt;\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;morphtarget_vertex&gt;\n\t#include &lt;skinning_vertex&gt;\n\t#include &lt;displacementmap_vertex&gt;\n\t#include &lt;project_vertex&gt;\n\t#include &lt;logdepthbuf_vertex&gt;\n\t#include &lt;clipping_planes_vertex&gt;\n\tvViewPosition = - mvPosition.xyz;\n\t#include &lt;worldpos_vertex&gt;\n\t#include &lt;shadowmap_vertex&gt;\n\t#include &lt;fog_vertex&gt;\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> fragment$<span class="number">5</span> = <span class="string">&quot;#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include &lt;common&gt;\n#include &lt;packing&gt;\n#include &lt;dithering_pars_fragment&gt;\n#include &lt;color_pars_fragment&gt;\n#include &lt;uv_pars_fragment&gt;\n#include &lt;uv2_pars_fragment&gt;\n#include &lt;map_pars_fragment&gt;\n#include &lt;alphamap_pars_fragment&gt;\n#include &lt;alphatest_pars_fragment&gt;\n#include &lt;aomap_pars_fragment&gt;\n#include &lt;lightmap_pars_fragment&gt;\n#include &lt;emissivemap_pars_fragment&gt;\n#include &lt;bsdfs&gt;\n#include &lt;cube_uv_reflection_fragment&gt;\n#include &lt;envmap_common_pars_fragment&gt;\n#include &lt;envmap_physical_pars_fragment&gt;\n#include &lt;fog_pars_fragment&gt;\n#include &lt;lights_pars_begin&gt;\n#include &lt;normal_pars_fragment&gt;\n#include &lt;lights_physical_pars_fragment&gt;\n#include &lt;transmission_pars_fragment&gt;\n#include &lt;shadowmap_pars_fragment&gt;\n#include &lt;bumpmap_pars_fragment&gt;\n#include &lt;normalmap_pars_fragment&gt;\n#include &lt;clearcoat_pars_fragment&gt;\n#include &lt;roughnessmap_pars_fragment&gt;\n#include &lt;metalnessmap_pars_fragment&gt;\n#include &lt;logdepthbuf_pars_fragment&gt;\n#include &lt;clipping_planes_pars_fragment&gt;\nvoid main() &#123;\n\t#include &lt;clipping_planes_fragment&gt;\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include &lt;logdepthbuf_fragment&gt;\n\t#include &lt;map_fragment&gt;\n\t#include &lt;color_fragment&gt;\n\t#include &lt;alphamap_fragment&gt;\n\t#include &lt;alphatest_fragment&gt;\n\t#include &lt;roughnessmap_fragment&gt;\n\t#include &lt;metalnessmap_fragment&gt;\n\t#include &lt;normal_fragment_begin&gt;\n\t#include &lt;normal_fragment_maps&gt;\n\t#include &lt;clearcoat_normal_fragment_begin&gt;\n\t#include &lt;clearcoat_normal_fragment_maps&gt;\n\t#include &lt;emissivemap_fragment&gt;\n\t#include &lt;lights_physical_fragment&gt;\n\t#include &lt;lights_fragment_begin&gt;\n\t#include &lt;lights_fragment_maps&gt;\n\t#include &lt;lights_fragment_end&gt;\n\t#include &lt;aomap_fragment&gt;\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include &lt;transmission_fragment&gt;\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include &lt;output_fragment&gt;\n\t#include &lt;tonemapping_fragment&gt;\n\t#include &lt;encodings_fragment&gt;\n\t#include &lt;fog_fragment&gt;\n\t#include &lt;premultiplied_alpha_fragment&gt;\n\t#include &lt;dithering_fragment&gt;\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> vertex$<span class="number">4</span> = <span class="string">&quot;#define TOON\nvarying vec3 vViewPosition;\n#include &lt;common&gt;\n#include &lt;uv_pars_vertex&gt;\n#include &lt;uv2_pars_vertex&gt;\n#include &lt;displacementmap_pars_vertex&gt;\n#include &lt;color_pars_vertex&gt;\n#include &lt;fog_pars_vertex&gt;\n#include &lt;normal_pars_vertex&gt;\n#include &lt;morphtarget_pars_vertex&gt;\n#include &lt;skinning_pars_vertex&gt;\n#include &lt;shadowmap_pars_vertex&gt;\n#include &lt;logdepthbuf_pars_vertex&gt;\n#include &lt;clipping_planes_pars_vertex&gt;\nvoid main() &#123;\n\t#include &lt;uv_vertex&gt;\n\t#include &lt;uv2_vertex&gt;\n\t#include &lt;color_vertex&gt;\n\t#include &lt;morphcolor_vertex&gt;\n\t#include &lt;beginnormal_vertex&gt;\n\t#include &lt;morphnormal_vertex&gt;\n\t#include &lt;skinbase_vertex&gt;\n\t#include &lt;skinnormal_vertex&gt;\n\t#include &lt;defaultnormal_vertex&gt;\n\t#include &lt;normal_vertex&gt;\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;morphtarget_vertex&gt;\n\t#include &lt;skinning_vertex&gt;\n\t#include &lt;displacementmap_vertex&gt;\n\t#include &lt;project_vertex&gt;\n\t#include &lt;logdepthbuf_vertex&gt;\n\t#include &lt;clipping_planes_vertex&gt;\n\tvViewPosition = - mvPosition.xyz;\n\t#include &lt;worldpos_vertex&gt;\n\t#include &lt;shadowmap_vertex&gt;\n\t#include &lt;fog_vertex&gt;\n&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> fragment$<span class="number">4</span> = <span class="string">&quot;#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include &lt;common&gt;\n#include &lt;packing&gt;\n#include &lt;dithering_pars_fragment&gt;\n#include &lt;color_pars_fragment&gt;\n#include &lt;uv_pars_fragment&gt;\n#include &lt;uv2_pars_fragment&gt;\n#include &lt;map_pars_fragment&gt;\n#include &lt;alphamap_pars_fragment&gt;\n#include &lt;alphatest_pars_fragment&gt;\n#include &lt;aomap_pars_fragment&gt;\n#include &lt;lightmap_pars_fragment&gt;\n#include &lt;emissivemap_pars_fragment&gt;\n#include &lt;gradientmap_pars_fragment&gt;\n#include &lt;fog_pars_fragment&gt;\n#include &lt;bsdfs&gt;\n#include &lt;lights_pars_begin&gt;\n#include &lt;normal_pars_fragment&gt;\n#include &lt;lights_toon_pars_fragment&gt;\n#include &lt;shadowmap_pars_fragment&gt;\n#include &lt;bumpmap_pars_fragment&gt;\n#include &lt;normalmap_pars_fragment&gt;\n#include &lt;logdepthbuf_pars_fragment&gt;\n#include &lt;clipping_planes_pars_fragment&gt;\nvoid main() &#123;\n\t#include &lt;clipping_planes_fragment&gt;\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include &lt;logdepthbuf_fragment&gt;\n\t#include &lt;map_fragment&gt;\n\t#include &lt;color_fragment&gt;\n\t#include &lt;alphamap_fragment&gt;\n\t#include &lt;alphatest_fragment&gt;\n\t#include &lt;normal_fragment_begin&gt;\n\t#include &lt;normal_fragment_maps&gt;\n\t#include &lt;emissivemap_fragment&gt;\n\t#include &lt;lights_toon_fragment&gt;\n\t#include &lt;lights_fragment_begin&gt;\n\t#include &lt;lights_fragment_maps&gt;\n\t#include &lt;lights_fragment_end&gt;\n\t#include &lt;aomap_fragment&gt;\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include &lt;output_fragment&gt;\n\t#include &lt;tonemapping_fragment&gt;\n\t#include &lt;encodings_fragment&gt;\n\t#include &lt;fog_fragment&gt;\n\t#include &lt;premultiplied_alpha_fragment&gt;\n\t#include &lt;dithering_fragment&gt;\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> vertex$<span class="number">3</span> = <span class="string">&quot;uniform float size;\nuniform float scale;\n#include &lt;common&gt;\n#include &lt;color_pars_vertex&gt;\n#include &lt;fog_pars_vertex&gt;\n#include &lt;morphtarget_pars_vertex&gt;\n#include &lt;logdepthbuf_pars_vertex&gt;\n#include &lt;clipping_planes_pars_vertex&gt;\nvoid main() &#123;\n\t#include &lt;color_vertex&gt;\n\t#include &lt;morphcolor_vertex&gt;\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;morphtarget_vertex&gt;\n\t#include &lt;project_vertex&gt;\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include &lt;logdepthbuf_vertex&gt;\n\t#include &lt;clipping_planes_vertex&gt;\n\t#include &lt;worldpos_vertex&gt;\n\t#include &lt;fog_vertex&gt;\n&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> fragment$<span class="number">3</span> = <span class="string">&quot;uniform vec3 diffuse;\nuniform float opacity;\n#include &lt;common&gt;\n#include &lt;color_pars_fragment&gt;\n#include &lt;map_particle_pars_fragment&gt;\n#include &lt;alphatest_pars_fragment&gt;\n#include &lt;fog_pars_fragment&gt;\n#include &lt;logdepthbuf_pars_fragment&gt;\n#include &lt;clipping_planes_pars_fragment&gt;\nvoid main() &#123;\n\t#include &lt;clipping_planes_fragment&gt;\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include &lt;logdepthbuf_fragment&gt;\n\t#include &lt;map_particle_fragment&gt;\n\t#include &lt;color_fragment&gt;\n\t#include &lt;alphatest_fragment&gt;\n\toutgoingLight = diffuseColor.rgb;\n\t#include &lt;output_fragment&gt;\n\t#include &lt;tonemapping_fragment&gt;\n\t#include &lt;encodings_fragment&gt;\n\t#include &lt;fog_fragment&gt;\n\t#include &lt;premultiplied_alpha_fragment&gt;\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> vertex$<span class="number">2</span> = <span class="string">&quot;#include &lt;common&gt;\n#include &lt;fog_pars_vertex&gt;\n#include &lt;morphtarget_pars_vertex&gt;\n#include &lt;skinning_pars_vertex&gt;\n#include &lt;shadowmap_pars_vertex&gt;\nvoid main() &#123;\n\t#include &lt;beginnormal_vertex&gt;\n\t#include &lt;morphnormal_vertex&gt;\n\t#include &lt;skinbase_vertex&gt;\n\t#include &lt;skinnormal_vertex&gt;\n\t#include &lt;defaultnormal_vertex&gt;\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;morphtarget_vertex&gt;\n\t#include &lt;skinning_vertex&gt;\n\t#include &lt;project_vertex&gt;\n\t#include &lt;worldpos_vertex&gt;\n\t#include &lt;shadowmap_vertex&gt;\n\t#include &lt;fog_vertex&gt;\n&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> fragment$<span class="number">2</span> = <span class="string">&quot;uniform vec3 color;\nuniform float opacity;\n#include &lt;common&gt;\n#include &lt;packing&gt;\n#include &lt;fog_pars_fragment&gt;\n#include &lt;bsdfs&gt;\n#include &lt;lights_pars_begin&gt;\n#include &lt;shadowmap_pars_fragment&gt;\n#include &lt;shadowmask_pars_fragment&gt;\nvoid main() &#123;\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include &lt;tonemapping_fragment&gt;\n\t#include &lt;encodings_fragment&gt;\n\t#include &lt;fog_fragment&gt;\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> vertex$<span class="number">1</span> = <span class="string">&quot;uniform float rotation;\nuniform vec2 center;\n#include &lt;common&gt;\n#include &lt;uv_pars_vertex&gt;\n#include &lt;fog_pars_vertex&gt;\n#include &lt;logdepthbuf_pars_vertex&gt;\n#include &lt;clipping_planes_pars_vertex&gt;\nvoid main() &#123;\n\t#include &lt;uv_vertex&gt;\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include &lt;logdepthbuf_vertex&gt;\n\t#include &lt;clipping_planes_vertex&gt;\n\t#include &lt;fog_vertex&gt;\n&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> fragment$<span class="number">1</span> = <span class="string">&quot;uniform vec3 diffuse;\nuniform float opacity;\n#include &lt;common&gt;\n#include &lt;uv_pars_fragment&gt;\n#include &lt;map_pars_fragment&gt;\n#include &lt;alphamap_pars_fragment&gt;\n#include &lt;alphatest_pars_fragment&gt;\n#include &lt;fog_pars_fragment&gt;\n#include &lt;logdepthbuf_pars_fragment&gt;\n#include &lt;clipping_planes_pars_fragment&gt;\nvoid main() &#123;\n\t#include &lt;clipping_planes_fragment&gt;\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include &lt;logdepthbuf_fragment&gt;\n\t#include &lt;map_fragment&gt;\n\t#include &lt;alphamap_fragment&gt;\n\t#include &lt;alphatest_fragment&gt;\n\toutgoingLight = diffuseColor.rgb;\n\t#include &lt;output_fragment&gt;\n\t#include &lt;tonemapping_fragment&gt;\n\t#include &lt;encodings_fragment&gt;\n\t#include &lt;fog_fragment&gt;\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ShaderChunk = &#123;</span><br><span class="line">        <span class="attr">alphamap_fragment</span>: alphamap_fragment,</span><br><span class="line">        <span class="attr">alphamap_pars_fragment</span>: alphamap_pars_fragment,</span><br><span class="line">        <span class="attr">alphatest_fragment</span>: alphatest_fragment,</span><br><span class="line">        <span class="attr">alphatest_pars_fragment</span>: alphatest_pars_fragment,</span><br><span class="line">        <span class="attr">aomap_fragment</span>: aomap_fragment,</span><br><span class="line">        <span class="attr">aomap_pars_fragment</span>: aomap_pars_fragment,</span><br><span class="line">        <span class="attr">begin_vertex</span>: begin_vertex,</span><br><span class="line">        <span class="attr">beginnormal_vertex</span>: beginnormal_vertex,</span><br><span class="line">        <span class="attr">bsdfs</span>: bsdfs,</span><br><span class="line">        <span class="attr">bumpmap_pars_fragment</span>: bumpmap_pars_fragment,</span><br><span class="line">        <span class="attr">clipping_planes_fragment</span>: clipping_planes_fragment,</span><br><span class="line">        <span class="attr">clipping_planes_pars_fragment</span>: clipping_planes_pars_fragment,</span><br><span class="line">        <span class="attr">clipping_planes_pars_vertex</span>: clipping_planes_pars_vertex,</span><br><span class="line">        <span class="attr">clipping_planes_vertex</span>: clipping_planes_vertex,</span><br><span class="line">        <span class="attr">color_fragment</span>: color_fragment,</span><br><span class="line">        <span class="attr">color_pars_fragment</span>: color_pars_fragment,</span><br><span class="line">        <span class="attr">color_pars_vertex</span>: color_pars_vertex,</span><br><span class="line">        <span class="attr">color_vertex</span>: color_vertex,</span><br><span class="line">        <span class="attr">common</span>: common,</span><br><span class="line">        <span class="attr">cube_uv_reflection_fragment</span>: cube_uv_reflection_fragment,</span><br><span class="line">        <span class="attr">defaultnormal_vertex</span>: defaultnormal_vertex,</span><br><span class="line">        <span class="attr">displacementmap_pars_vertex</span>: displacementmap_pars_vertex,</span><br><span class="line">        <span class="attr">displacementmap_vertex</span>: displacementmap_vertex,</span><br><span class="line">        <span class="attr">emissivemap_fragment</span>: emissivemap_fragment,</span><br><span class="line">        <span class="attr">emissivemap_pars_fragment</span>: emissivemap_pars_fragment,</span><br><span class="line">        <span class="attr">encodings_fragment</span>: encodings_fragment,</span><br><span class="line">        <span class="attr">encodings_pars_fragment</span>: encodings_pars_fragment,</span><br><span class="line">        <span class="attr">envmap_fragment</span>: envmap_fragment,</span><br><span class="line">        <span class="attr">envmap_common_pars_fragment</span>: envmap_common_pars_fragment,</span><br><span class="line">        <span class="attr">envmap_pars_fragment</span>: envmap_pars_fragment,</span><br><span class="line">        <span class="attr">envmap_pars_vertex</span>: envmap_pars_vertex,</span><br><span class="line">        <span class="attr">envmap_physical_pars_fragment</span>: envmap_physical_pars_fragment,</span><br><span class="line">        <span class="attr">envmap_vertex</span>: envmap_vertex,</span><br><span class="line">        <span class="attr">fog_vertex</span>: fog_vertex,</span><br><span class="line">        <span class="attr">fog_pars_vertex</span>: fog_pars_vertex,</span><br><span class="line">        <span class="attr">fog_fragment</span>: fog_fragment,</span><br><span class="line">        <span class="attr">fog_pars_fragment</span>: fog_pars_fragment,</span><br><span class="line">        <span class="attr">gradientmap_pars_fragment</span>: gradientmap_pars_fragment,</span><br><span class="line">        <span class="attr">lightmap_fragment</span>: lightmap_fragment,</span><br><span class="line">        <span class="attr">lightmap_pars_fragment</span>: lightmap_pars_fragment,</span><br><span class="line">        <span class="attr">lights_lambert_vertex</span>: lights_lambert_vertex,</span><br><span class="line">        <span class="attr">lights_pars_begin</span>: lights_pars_begin,</span><br><span class="line">        <span class="attr">lights_toon_fragment</span>: lights_toon_fragment,</span><br><span class="line">        <span class="attr">lights_toon_pars_fragment</span>: lights_toon_pars_fragment,</span><br><span class="line">        <span class="attr">lights_phong_fragment</span>: lights_phong_fragment,</span><br><span class="line">        <span class="attr">lights_phong_pars_fragment</span>: lights_phong_pars_fragment,</span><br><span class="line">        <span class="attr">lights_physical_fragment</span>: lights_physical_fragment,</span><br><span class="line">        <span class="attr">lights_physical_pars_fragment</span>: lights_physical_pars_fragment,</span><br><span class="line">        <span class="attr">lights_fragment_begin</span>: lights_fragment_begin,</span><br><span class="line">        <span class="attr">lights_fragment_maps</span>: lights_fragment_maps,</span><br><span class="line">        <span class="attr">lights_fragment_end</span>: lights_fragment_end,</span><br><span class="line">        <span class="attr">logdepthbuf_fragment</span>: logdepthbuf_fragment,</span><br><span class="line">        <span class="attr">logdepthbuf_pars_fragment</span>: logdepthbuf_pars_fragment,</span><br><span class="line">        <span class="attr">logdepthbuf_pars_vertex</span>: logdepthbuf_pars_vertex,</span><br><span class="line">        <span class="attr">logdepthbuf_vertex</span>: logdepthbuf_vertex,</span><br><span class="line">        <span class="attr">map_fragment</span>: map_fragment,</span><br><span class="line">        <span class="attr">map_pars_fragment</span>: map_pars_fragment,</span><br><span class="line">        <span class="attr">map_particle_fragment</span>: map_particle_fragment,</span><br><span class="line">        <span class="attr">map_particle_pars_fragment</span>: map_particle_pars_fragment,</span><br><span class="line">        <span class="attr">metalnessmap_fragment</span>: metalnessmap_fragment,</span><br><span class="line">        <span class="attr">metalnessmap_pars_fragment</span>: metalnessmap_pars_fragment,</span><br><span class="line">        <span class="attr">morphcolor_vertex</span>: morphcolor_vertex,</span><br><span class="line">        <span class="attr">morphnormal_vertex</span>: morphnormal_vertex,</span><br><span class="line">        <span class="attr">morphtarget_pars_vertex</span>: morphtarget_pars_vertex,</span><br><span class="line">        <span class="attr">morphtarget_vertex</span>: morphtarget_vertex,</span><br><span class="line">        <span class="attr">normal_fragment_begin</span>: normal_fragment_begin,</span><br><span class="line">        <span class="attr">normal_fragment_maps</span>: normal_fragment_maps,</span><br><span class="line">        <span class="attr">normal_pars_fragment</span>: normal_pars_fragment,</span><br><span class="line">        <span class="attr">normal_pars_vertex</span>: normal_pars_vertex,</span><br><span class="line">        <span class="attr">normal_vertex</span>: normal_vertex,</span><br><span class="line">        <span class="attr">normalmap_pars_fragment</span>: normalmap_pars_fragment,</span><br><span class="line">        <span class="attr">clearcoat_normal_fragment_begin</span>: clearcoat_normal_fragment_begin,</span><br><span class="line">        <span class="attr">clearcoat_normal_fragment_maps</span>: clearcoat_normal_fragment_maps,</span><br><span class="line">        <span class="attr">clearcoat_pars_fragment</span>: clearcoat_pars_fragment,</span><br><span class="line">        <span class="attr">output_fragment</span>: output_fragment,</span><br><span class="line">        <span class="attr">packing</span>: packing,</span><br><span class="line">        <span class="attr">premultiplied_alpha_fragment</span>: premultiplied_alpha_fragment,</span><br><span class="line">        <span class="attr">project_vertex</span>: project_vertex,</span><br><span class="line">        <span class="attr">dithering_fragment</span>: dithering_fragment,</span><br><span class="line">        <span class="attr">dithering_pars_fragment</span>: dithering_pars_fragment,</span><br><span class="line">        <span class="attr">roughnessmap_fragment</span>: roughnessmap_fragment,</span><br><span class="line">        <span class="attr">roughnessmap_pars_fragment</span>: roughnessmap_pars_fragment,</span><br><span class="line">        <span class="attr">shadowmap_pars_fragment</span>: shadowmap_pars_fragment,</span><br><span class="line">        <span class="attr">shadowmap_pars_vertex</span>: shadowmap_pars_vertex,</span><br><span class="line">        <span class="attr">shadowmap_vertex</span>: shadowmap_vertex,</span><br><span class="line">        <span class="attr">shadowmask_pars_fragment</span>: shadowmask_pars_fragment,</span><br><span class="line">        <span class="attr">skinbase_vertex</span>: skinbase_vertex,</span><br><span class="line">        <span class="attr">skinning_pars_vertex</span>: skinning_pars_vertex,</span><br><span class="line">        <span class="attr">skinning_vertex</span>: skinning_vertex,</span><br><span class="line">        <span class="attr">skinnormal_vertex</span>: skinnormal_vertex,</span><br><span class="line">        <span class="attr">specularmap_fragment</span>: specularmap_fragment,</span><br><span class="line">        <span class="attr">specularmap_pars_fragment</span>: specularmap_pars_fragment,</span><br><span class="line">        <span class="attr">tonemapping_fragment</span>: tonemapping_fragment,</span><br><span class="line">        <span class="attr">tonemapping_pars_fragment</span>: tonemapping_pars_fragment,</span><br><span class="line">        <span class="attr">transmission_fragment</span>: transmission_fragment,</span><br><span class="line">        <span class="attr">transmission_pars_fragment</span>: transmission_pars_fragment,</span><br><span class="line">        <span class="attr">uv_pars_fragment</span>: uv_pars_fragment,</span><br><span class="line">        <span class="attr">uv_pars_vertex</span>: uv_pars_vertex,</span><br><span class="line">        <span class="attr">uv_vertex</span>: uv_vertex,</span><br><span class="line">        <span class="attr">uv2_pars_fragment</span>: uv2_pars_fragment,</span><br><span class="line">        <span class="attr">uv2_pars_vertex</span>: uv2_pars_vertex,</span><br><span class="line">        <span class="attr">uv2_vertex</span>: uv2_vertex,</span><br><span class="line">        <span class="attr">worldpos_vertex</span>: worldpos_vertex,</span><br><span class="line">        <span class="attr">background_vert</span>: vertex$g,</span><br><span class="line">        <span class="attr">background_frag</span>: fragment$g,</span><br><span class="line">        <span class="attr">cube_vert</span>: vertex$f,</span><br><span class="line">        <span class="attr">cube_frag</span>: fragment$f,</span><br><span class="line">        <span class="attr">depth_vert</span>: vertex$e,</span><br><span class="line">        <span class="attr">depth_frag</span>: fragment$e,</span><br><span class="line">        <span class="attr">distanceRGBA_vert</span>: vertex$d,</span><br><span class="line">        <span class="attr">distanceRGBA_frag</span>: fragment$d,</span><br><span class="line">        <span class="attr">equirect_vert</span>: vertex$c,</span><br><span class="line">        <span class="attr">equirect_frag</span>: fragment$c,</span><br><span class="line">        <span class="attr">linedashed_vert</span>: vertex$b,</span><br><span class="line">        <span class="attr">linedashed_frag</span>: fragment$b,</span><br><span class="line">        <span class="attr">meshbasic_vert</span>: vertex$a,</span><br><span class="line">        <span class="attr">meshbasic_frag</span>: fragment$a,</span><br><span class="line">        <span class="attr">meshlambert_vert</span>: vertex$<span class="number">9</span>,</span><br><span class="line">        <span class="attr">meshlambert_frag</span>: fragment$<span class="number">9</span>,</span><br><span class="line">        <span class="attr">meshmatcap_vert</span>: vertex$<span class="number">8</span>,</span><br><span class="line">        <span class="attr">meshmatcap_frag</span>: fragment$<span class="number">8</span>,</span><br><span class="line">        <span class="attr">meshnormal_vert</span>: vertex$<span class="number">7</span>,</span><br><span class="line">        <span class="attr">meshnormal_frag</span>: fragment$<span class="number">7</span>,</span><br><span class="line">        <span class="attr">meshphong_vert</span>: vertex$<span class="number">6</span>,</span><br><span class="line">        <span class="attr">meshphong_frag</span>: fragment$<span class="number">6</span>,</span><br><span class="line">        <span class="attr">meshphysical_vert</span>: vertex$<span class="number">5</span>,</span><br><span class="line">        <span class="attr">meshphysical_frag</span>: fragment$<span class="number">5</span>,</span><br><span class="line">        <span class="attr">meshtoon_vert</span>: vertex$<span class="number">4</span>,</span><br><span class="line">        <span class="attr">meshtoon_frag</span>: fragment$<span class="number">4</span>,</span><br><span class="line">        <span class="attr">points_vert</span>: vertex$<span class="number">3</span>,</span><br><span class="line">        <span class="attr">points_frag</span>: fragment$<span class="number">3</span>,</span><br><span class="line">        <span class="attr">shadow_vert</span>: vertex$<span class="number">2</span>,</span><br><span class="line">        <span class="attr">shadow_frag</span>: fragment$<span class="number">2</span>,</span><br><span class="line">        <span class="attr">sprite_vert</span>: vertex$<span class="number">1</span>,</span><br><span class="line">        <span class="attr">sprite_frag</span>: fragment$<span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Uniforms library for shared webgl shaders</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> UniformsLib = &#123;</span><br><span class="line">        <span class="attr">common</span>: &#123;</span><br><span class="line">            <span class="attr">diffuse</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="keyword">new</span> Color(<span class="number">0xffffff</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">opacity</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">1.0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">map</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">uvTransform</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="keyword">new</span> Matrix3()</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">uv2Transform</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="keyword">new</span> Matrix3()</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">alphaMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">alphaTest</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">specularmap</span>: &#123;</span><br><span class="line">            <span class="attr">specularMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">envmap</span>: &#123;</span><br><span class="line">            <span class="attr">envMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">flipEnvMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: -<span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">reflectivity</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">1.0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// basic, lambert, phong</span></span><br><span class="line">            <span class="attr">ior</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">1.5</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// physical</span></span><br><span class="line">            <span class="attr">refractionRatio</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">0.98</span></span><br><span class="line">            &#125; <span class="comment">// basic, lambert, phong</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">aomap</span>: &#123;</span><br><span class="line">            <span class="attr">aoMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">aoMapIntensity</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">lightmap</span>: &#123;</span><br><span class="line">            <span class="attr">lightMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">lightMapIntensity</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">emissivemap</span>: &#123;</span><br><span class="line">            <span class="attr">emissiveMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">bumpmap</span>: &#123;</span><br><span class="line">            <span class="attr">bumpMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">bumpScale</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">normalmap</span>: &#123;</span><br><span class="line">            <span class="attr">normalMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">normalScale</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="keyword">new</span> Vector2(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">displacementmap</span>: &#123;</span><br><span class="line">            <span class="attr">displacementMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">displacementScale</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">displacementBias</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">roughnessmap</span>: &#123;</span><br><span class="line">            <span class="attr">roughnessMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">metalnessmap</span>: &#123;</span><br><span class="line">            <span class="attr">metalnessMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">gradientmap</span>: &#123;</span><br><span class="line">            <span class="attr">gradientMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">fog</span>: &#123;</span><br><span class="line">            <span class="attr">fogDensity</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">0.00025</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">fogNear</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">fogFar</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">2000</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">fogColor</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="keyword">new</span> Color(<span class="number">0xffffff</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">lights</span>: &#123;</span><br><span class="line">            <span class="attr">ambientLightColor</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: []</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">lightProbe</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: []</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">directionalLights</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: [],</span><br><span class="line">                <span class="attr">properties</span>: &#123;</span><br><span class="line">                    <span class="attr">direction</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">color</span>: &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">directionalLightShadows</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: [],</span><br><span class="line">                <span class="attr">properties</span>: &#123;</span><br><span class="line">                    <span class="attr">shadowBias</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">shadowNormalBias</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">shadowRadius</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">shadowMapSize</span>: &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">directionalShadowMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: []</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">directionalShadowMatrix</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: []</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">spotLights</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: [],</span><br><span class="line">                <span class="attr">properties</span>: &#123;</span><br><span class="line">                    <span class="attr">color</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">position</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">direction</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">distance</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">coneCos</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">penumbraCos</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">decay</span>: &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">spotLightShadows</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: [],</span><br><span class="line">                <span class="attr">properties</span>: &#123;</span><br><span class="line">                    <span class="attr">shadowBias</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">shadowNormalBias</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">shadowRadius</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">shadowMapSize</span>: &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">spotShadowMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: []</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">spotShadowMatrix</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: []</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">pointLights</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: [],</span><br><span class="line">                <span class="attr">properties</span>: &#123;</span><br><span class="line">                    <span class="attr">color</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">position</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">decay</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">distance</span>: &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">pointLightShadows</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: [],</span><br><span class="line">                <span class="attr">properties</span>: &#123;</span><br><span class="line">                    <span class="attr">shadowBias</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">shadowNormalBias</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">shadowRadius</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">shadowMapSize</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">shadowCameraNear</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">shadowCameraFar</span>: &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">pointShadowMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: []</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">pointShadowMatrix</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: []</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">hemisphereLights</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: [],</span><br><span class="line">                <span class="attr">properties</span>: &#123;</span><br><span class="line">                    <span class="attr">direction</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">skyColor</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">groundColor</span>: &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src</span></span><br><span class="line">            <span class="attr">rectAreaLights</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: [],</span><br><span class="line">                <span class="attr">properties</span>: &#123;</span><br><span class="line">                    <span class="attr">color</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">position</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">width</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">height</span>: &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">ltc_1</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">ltc_2</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">points</span>: &#123;</span><br><span class="line">            <span class="attr">diffuse</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="keyword">new</span> Color(<span class="number">0xffffff</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">opacity</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">1.0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">size</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">1.0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">scale</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">1.0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">map</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">alphaMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">alphaTest</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">uvTransform</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="keyword">new</span> Matrix3()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">sprite</span>: &#123;</span><br><span class="line">            <span class="attr">diffuse</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="keyword">new</span> Color(<span class="number">0xffffff</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">opacity</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">1.0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">center</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="keyword">new</span> Vector2(<span class="number">0.5</span>, <span class="number">0.5</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">rotation</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">0.0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">map</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">alphaMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">alphaTest</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">uvTransform</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="keyword">new</span> Matrix3()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ShaderLib = &#123;</span><br><span class="line">        <span class="attr">basic</span>: &#123;</span><br><span class="line">            <span class="attr">uniforms</span>: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),</span><br><span class="line">            <span class="attr">vertexShader</span>: ShaderChunk.meshbasic_vert,</span><br><span class="line">            <span class="attr">fragmentShader</span>: ShaderChunk.meshbasic_frag</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">lambert</span>: &#123;</span><br><span class="line">            <span class="attr">uniforms</span>: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, &#123;</span><br><span class="line">                <span class="attr">emissive</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="keyword">new</span> Color(<span class="number">0x000000</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;]),</span><br><span class="line">            <span class="attr">vertexShader</span>: ShaderChunk.meshlambert_vert,</span><br><span class="line">            <span class="attr">fragmentShader</span>: ShaderChunk.meshlambert_frag</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">phong</span>: &#123;</span><br><span class="line">            <span class="attr">uniforms</span>: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, &#123;</span><br><span class="line">                <span class="attr">emissive</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="keyword">new</span> Color(<span class="number">0x000000</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">specular</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="keyword">new</span> Color(<span class="number">0x111111</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">shininess</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="number">30</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;]),</span><br><span class="line">            <span class="attr">vertexShader</span>: ShaderChunk.meshphong_vert,</span><br><span class="line">            <span class="attr">fragmentShader</span>: ShaderChunk.meshphong_frag</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">standard</span>: &#123;</span><br><span class="line">            <span class="attr">uniforms</span>: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, &#123;</span><br><span class="line">                <span class="attr">emissive</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="keyword">new</span> Color(<span class="number">0x000000</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">roughness</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="number">1.0</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">metalness</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="number">0.0</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">envMapIntensity</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">                &#125; <span class="comment">// temporary</span></span><br><span class="line"></span><br><span class="line">            &#125;]),</span><br><span class="line">            <span class="attr">vertexShader</span>: ShaderChunk.meshphysical_vert,</span><br><span class="line">            <span class="attr">fragmentShader</span>: ShaderChunk.meshphysical_frag</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">toon</span>: &#123;</span><br><span class="line">            <span class="attr">uniforms</span>: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, &#123;</span><br><span class="line">                <span class="attr">emissive</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="keyword">new</span> Color(<span class="number">0x000000</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;]),</span><br><span class="line">            <span class="attr">vertexShader</span>: ShaderChunk.meshtoon_vert,</span><br><span class="line">            <span class="attr">fragmentShader</span>: ShaderChunk.meshtoon_frag</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">matcap</span>: &#123;</span><br><span class="line">            <span class="attr">uniforms</span>: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, &#123;</span><br><span class="line">                <span class="attr">matcap</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;]),</span><br><span class="line">            <span class="attr">vertexShader</span>: ShaderChunk.meshmatcap_vert,</span><br><span class="line">            <span class="attr">fragmentShader</span>: ShaderChunk.meshmatcap_frag</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">points</span>: &#123;</span><br><span class="line">            <span class="attr">uniforms</span>: mergeUniforms([UniformsLib.points, UniformsLib.fog]),</span><br><span class="line">            <span class="attr">vertexShader</span>: ShaderChunk.points_vert,</span><br><span class="line">            <span class="attr">fragmentShader</span>: ShaderChunk.points_frag</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">dashed</span>: &#123;</span><br><span class="line">            <span class="attr">uniforms</span>: mergeUniforms([UniformsLib.common, UniformsLib.fog, &#123;</span><br><span class="line">                <span class="attr">scale</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">dashSize</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">totalSize</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;]),</span><br><span class="line">            <span class="attr">vertexShader</span>: ShaderChunk.linedashed_vert,</span><br><span class="line">            <span class="attr">fragmentShader</span>: ShaderChunk.linedashed_frag</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">depth</span>: &#123;</span><br><span class="line">            <span class="attr">uniforms</span>: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),</span><br><span class="line">            <span class="attr">vertexShader</span>: ShaderChunk.depth_vert,</span><br><span class="line">            <span class="attr">fragmentShader</span>: ShaderChunk.depth_frag</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">normal</span>: &#123;</span><br><span class="line">            <span class="attr">uniforms</span>: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, &#123;</span><br><span class="line">                <span class="attr">opacity</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="number">1.0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;]),</span><br><span class="line">            <span class="attr">vertexShader</span>: ShaderChunk.meshnormal_vert,</span><br><span class="line">            <span class="attr">fragmentShader</span>: ShaderChunk.meshnormal_frag</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">sprite</span>: &#123;</span><br><span class="line">            <span class="attr">uniforms</span>: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),</span><br><span class="line">            <span class="attr">vertexShader</span>: ShaderChunk.sprite_vert,</span><br><span class="line">            <span class="attr">fragmentShader</span>: ShaderChunk.sprite_frag</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">background</span>: &#123;</span><br><span class="line">            <span class="attr">uniforms</span>: &#123;</span><br><span class="line">                <span class="attr">uvTransform</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="keyword">new</span> Matrix3()</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">t2D</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">vertexShader</span>: ShaderChunk.background_vert,</span><br><span class="line">            <span class="attr">fragmentShader</span>: ShaderChunk.background_frag</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* -------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">		//	Cube map shader</span></span><br><span class="line"><span class="comment">		 ------------------------------------------------------------------------- */</span></span><br><span class="line">        <span class="attr">cube</span>: &#123;</span><br><span class="line">            <span class="attr">uniforms</span>: mergeUniforms([UniformsLib.envmap, &#123;</span><br><span class="line">                <span class="attr">opacity</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="number">1.0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;]),</span><br><span class="line">            <span class="attr">vertexShader</span>: ShaderChunk.cube_vert,</span><br><span class="line">            <span class="attr">fragmentShader</span>: ShaderChunk.cube_frag</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">equirect</span>: &#123;</span><br><span class="line">            <span class="attr">uniforms</span>: &#123;</span><br><span class="line">                <span class="attr">tEquirect</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">vertexShader</span>: ShaderChunk.equirect_vert,</span><br><span class="line">            <span class="attr">fragmentShader</span>: ShaderChunk.equirect_frag</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">distanceRGBA</span>: &#123;</span><br><span class="line">            <span class="attr">uniforms</span>: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, &#123;</span><br><span class="line">                <span class="attr">referencePosition</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="keyword">new</span> Vector3()</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">nearDistance</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">farDistance</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="number">1000</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;]),</span><br><span class="line">            <span class="attr">vertexShader</span>: ShaderChunk.distanceRGBA_vert,</span><br><span class="line">            <span class="attr">fragmentShader</span>: ShaderChunk.distanceRGBA_frag</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">shadow</span>: &#123;</span><br><span class="line">            <span class="attr">uniforms</span>: mergeUniforms([UniformsLib.lights, UniformsLib.fog, &#123;</span><br><span class="line">                <span class="attr">color</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="keyword">new</span> Color(<span class="number">0x00000</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">opacity</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="number">1.0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;]),</span><br><span class="line">            <span class="attr">vertexShader</span>: ShaderChunk.shadow_vert,</span><br><span class="line">            <span class="attr">fragmentShader</span>: ShaderChunk.shadow_frag</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ShaderLib.physical = &#123;</span><br><span class="line">        <span class="attr">uniforms</span>: mergeUniforms([ShaderLib.standard.uniforms, &#123;</span><br><span class="line">            <span class="attr">clearcoat</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">clearcoatMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">clearcoatRoughness</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">clearcoatRoughnessMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">clearcoatNormalScale</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="keyword">new</span> Vector2(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">clearcoatNormalMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">sheen</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">sheenColor</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="keyword">new</span> Color(<span class="number">0x000000</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">sheenColorMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">sheenRoughness</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">sheenRoughnessMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">transmission</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">transmissionMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">transmissionSamplerSize</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="keyword">new</span> Vector2()</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">transmissionSamplerMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">thickness</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">thicknessMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">attenuationDistance</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">attenuationColor</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="keyword">new</span> Color(<span class="number">0x000000</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">specularIntensity</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">specularIntensityMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">specularColor</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="keyword">new</span> Color(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">specularColorMap</span>: &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]),</span><br><span class="line">        <span class="attr">vertexShader</span>: ShaderChunk.meshphysical_vert,</span><br><span class="line">        <span class="attr">fragmentShader</span>: ShaderChunk.meshphysical_frag</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLBackground</span>(<span class="params">renderer, cubemaps, state, objects, alpha, premultipliedAlpha</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> clearColor = <span class="keyword">new</span> Color(<span class="number">0x000000</span>);</span><br><span class="line">        <span class="keyword">let</span> clearAlpha = alpha === <span class="literal">true</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> planeMesh;</span><br><span class="line">        <span class="keyword">let</span> boxMesh;</span><br><span class="line">        <span class="keyword">let</span> currentBackground = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> currentBackgroundVersion = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> currentTonemapping = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">renderList, scene</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> forceClear = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">let</span> background = scene.isScene === <span class="literal">true</span> ? scene.background : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (background &amp;&amp; background.isTexture) &#123;</span><br><span class="line">                background = cubemaps.get(background);</span><br><span class="line">            &#125; <span class="comment">// Ignore background in AR</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Reconsider this.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> xr = renderer.xr;</span><br><span class="line">            <span class="keyword">const</span> session = xr.getSession &amp;&amp; xr.getSession();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (session &amp;&amp; session.environmentBlendMode === <span class="string">&#x27;additive&#x27;</span>) &#123;</span><br><span class="line">                background = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (background === <span class="literal">null</span>) &#123;</span><br><span class="line">                setClear(clearColor, clearAlpha);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (background &amp;&amp; background.isColor) &#123;</span><br><span class="line">                setClear(background, <span class="number">1</span>);</span><br><span class="line">                forceClear = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (renderer.autoClear || forceClear) &#123;</span><br><span class="line">                renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (background &amp;&amp; (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (boxMesh === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    boxMesh = <span class="keyword">new</span> Mesh(<span class="keyword">new</span> BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="keyword">new</span> ShaderMaterial(&#123;</span><br><span class="line">                        <span class="attr">name</span>: <span class="string">&#x27;BackgroundCubeMaterial&#x27;</span>,</span><br><span class="line">                        <span class="attr">uniforms</span>: cloneUniforms(ShaderLib.cube.uniforms),</span><br><span class="line">                        <span class="attr">vertexShader</span>: ShaderLib.cube.vertexShader,</span><br><span class="line">                        <span class="attr">fragmentShader</span>: ShaderLib.cube.fragmentShader,</span><br><span class="line">                        <span class="attr">side</span>: BackSide,</span><br><span class="line">                        <span class="attr">depthTest</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="attr">depthWrite</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="attr">fog</span>: <span class="literal">false</span></span><br><span class="line">                    &#125;));</span><br><span class="line">                    boxMesh.geometry.deleteAttribute(<span class="string">&#x27;normal&#x27;</span>);</span><br><span class="line">                    boxMesh.geometry.deleteAttribute(<span class="string">&#x27;uv&#x27;</span>);</span><br><span class="line"></span><br><span class="line">                    boxMesh.onBeforeRender = <span class="function"><span class="keyword">function</span> (<span class="params">renderer, scene, camera</span>) </span>&#123;</span><br><span class="line">                        <span class="built_in">this</span>.matrixWorld.copyPosition(camera.matrixWorld);</span><br><span class="line">                    &#125;; <span class="comment">// enable code injection for non-built-in material</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="built_in">Object</span>.defineProperty(boxMesh.material, <span class="string">&#x27;envMap&#x27;</span>, &#123;</span><br><span class="line">                        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="built_in">this</span>.uniforms.envMap.value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    objects.update(boxMesh);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                boxMesh.material.uniforms.envMap.value = background;</span><br><span class="line">                boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture &amp;&amp; background.isRenderTargetTexture === <span class="literal">false</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) &#123;</span><br><span class="line">                    boxMesh.material.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">                    currentBackground = background;</span><br><span class="line">                    currentBackgroundVersion = background.version;</span><br><span class="line">                    currentTonemapping = renderer.toneMapping;</span><br><span class="line">                &#125; <span class="comment">// push to the pre-sorted opaque render list</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (background &amp;&amp; background.isTexture) &#123;</span><br><span class="line">                <span class="keyword">if</span> (planeMesh === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    planeMesh = <span class="keyword">new</span> Mesh(<span class="keyword">new</span> PlaneGeometry(<span class="number">2</span>, <span class="number">2</span>), <span class="keyword">new</span> ShaderMaterial(&#123;</span><br><span class="line">                        <span class="attr">name</span>: <span class="string">&#x27;BackgroundMaterial&#x27;</span>,</span><br><span class="line">                        <span class="attr">uniforms</span>: cloneUniforms(ShaderLib.background.uniforms),</span><br><span class="line">                        <span class="attr">vertexShader</span>: ShaderLib.background.vertexShader,</span><br><span class="line">                        <span class="attr">fragmentShader</span>: ShaderLib.background.fragmentShader,</span><br><span class="line">                        <span class="attr">side</span>: FrontSide,</span><br><span class="line">                        <span class="attr">depthTest</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="attr">depthWrite</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="attr">fog</span>: <span class="literal">false</span></span><br><span class="line">                    &#125;));</span><br><span class="line">                    planeMesh.geometry.deleteAttribute(<span class="string">&#x27;normal&#x27;</span>); <span class="comment">// enable code injection for non-built-in material</span></span><br><span class="line"></span><br><span class="line">                    <span class="built_in">Object</span>.defineProperty(planeMesh.material, <span class="string">&#x27;map&#x27;</span>, &#123;</span><br><span class="line">                        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="built_in">this</span>.uniforms.t2D.value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    objects.update(planeMesh);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                planeMesh.material.uniforms.t2D.value = background;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (background.matrixAutoUpdate === <span class="literal">true</span>) &#123;</span><br><span class="line">                    background.updateMatrix();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) &#123;</span><br><span class="line">                    planeMesh.material.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">                    currentBackground = background;</span><br><span class="line">                    currentBackgroundVersion = background.version;</span><br><span class="line">                    currentTonemapping = renderer.toneMapping;</span><br><span class="line">                &#125; <span class="comment">// push to the pre-sorted opaque render list</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setClear</span>(<span class="params">color, alpha</span>) </span>&#123;</span><br><span class="line">            state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">getClearColor</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> clearColor;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">setClearColor</span>: <span class="function"><span class="keyword">function</span> (<span class="params">color, alpha = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">                clearColor.set(color);</span><br><span class="line">                clearAlpha = alpha;</span><br><span class="line">                setClear(clearColor, clearAlpha);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">getClearAlpha</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> clearAlpha;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">setClearAlpha</span>: <span class="function"><span class="keyword">function</span> (<span class="params">alpha</span>) </span>&#123;</span><br><span class="line">                clearAlpha = alpha;</span><br><span class="line">                setClear(clearColor, clearAlpha);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">render</span>: render</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLBindingStates</span>(<span class="params">gl, extensions, attributes, capabilities</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);</span><br><span class="line">        <span class="keyword">const</span> extension = capabilities.isWebGL2 ? <span class="literal">null</span> : extensions.get(<span class="string">&#x27;OES_vertex_array_object&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> vaoAvailable = capabilities.isWebGL2 || extension !== <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">const</span> bindingStates = &#123;&#125;;</span><br><span class="line">        <span class="keyword">const</span> defaultState = createBindingState(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">let</span> currentState = defaultState;</span><br><span class="line">        <span class="keyword">let</span> forceUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setup</span>(<span class="params">object, material, program, geometry, index</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> updateBuffers = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (vaoAvailable) &#123;</span><br><span class="line">                <span class="keyword">const</span> state = getBindingState(geometry, program, material);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (currentState !== state) &#123;</span><br><span class="line">                    currentState = state;</span><br><span class="line">                    bindVertexArrayObject(currentState.object);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                updateBuffers = needsUpdate(geometry, index);</span><br><span class="line">                <span class="keyword">if</span> (updateBuffers) saveCache(geometry, index);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> wireframe = material.wireframe === <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) &#123;</span><br><span class="line">                    currentState.geometry = geometry.id;</span><br><span class="line">                    currentState.program = program.id;</span><br><span class="line">                    currentState.wireframe = wireframe;</span><br><span class="line">                    updateBuffers = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (object.isInstancedMesh === <span class="literal">true</span>) &#123;</span><br><span class="line">                updateBuffers = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index !== <span class="literal">null</span>) &#123;</span><br><span class="line">                attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (updateBuffers || forceUpdate) &#123;</span><br><span class="line">                forceUpdate = <span class="literal">false</span>;</span><br><span class="line">                setupVertexAttributes(object, material, program, geometry);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (index !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">createVertexArrayObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (capabilities.isWebGL2) <span class="keyword">return</span> gl.createVertexArray();</span><br><span class="line">            <span class="keyword">return</span> extension.createVertexArrayOES();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">bindVertexArrayObject</span>(<span class="params">vao</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (capabilities.isWebGL2) <span class="keyword">return</span> gl.bindVertexArray(vao);</span><br><span class="line">            <span class="keyword">return</span> extension.bindVertexArrayOES(vao);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">deleteVertexArrayObject</span>(<span class="params">vao</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (capabilities.isWebGL2) <span class="keyword">return</span> gl.deleteVertexArray(vao);</span><br><span class="line">            <span class="keyword">return</span> extension.deleteVertexArrayOES(vao);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getBindingState</span>(<span class="params">geometry, program, material</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> wireframe = material.wireframe === <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">let</span> programMap = bindingStates[geometry.id];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (programMap === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                programMap = &#123;&#125;;</span><br><span class="line">                bindingStates[geometry.id] = programMap;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> stateMap = programMap[program.id];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stateMap === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                stateMap = &#123;&#125;;</span><br><span class="line">                programMap[program.id] = stateMap;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> state = stateMap[wireframe];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (state === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                state = createBindingState(createVertexArrayObject());</span><br><span class="line">                stateMap[wireframe] = state;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">createBindingState</span>(<span class="params">vao</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> newAttributes = [];</span><br><span class="line">            <span class="keyword">const</span> enabledAttributes = [];</span><br><span class="line">            <span class="keyword">const</span> attributeDivisors = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxVertexAttributes; i++) &#123;</span><br><span class="line">                newAttributes[i] = <span class="number">0</span>;</span><br><span class="line">                enabledAttributes[i] = <span class="number">0</span>;</span><br><span class="line">                attributeDivisors[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="comment">// for backward compatibility on non-VAO support browser</span></span><br><span class="line">                <span class="attr">geometry</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">program</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">wireframe</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">newAttributes</span>: newAttributes,</span><br><span class="line">                <span class="attr">enabledAttributes</span>: enabledAttributes,</span><br><span class="line">                <span class="attr">attributeDivisors</span>: attributeDivisors,</span><br><span class="line">                <span class="attr">object</span>: vao,</span><br><span class="line">                <span class="attr">attributes</span>: &#123;&#125;,</span><br><span class="line">                <span class="attr">index</span>: <span class="literal">null</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">needsUpdate</span>(<span class="params">geometry, index</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> cachedAttributes = currentState.attributes;</span><br><span class="line">            <span class="keyword">const</span> geometryAttributes = geometry.attributes;</span><br><span class="line">            <span class="keyword">let</span> attributesNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> geometryAttributes) &#123;</span><br><span class="line">                <span class="keyword">const</span> cachedAttribute = cachedAttributes[key];</span><br><span class="line">                <span class="keyword">const</span> geometryAttribute = geometryAttributes[key];</span><br><span class="line">                <span class="keyword">if</span> (cachedAttribute === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (cachedAttribute.attribute !== geometryAttribute) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (cachedAttribute.data !== geometryAttribute.data) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                attributesNum++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currentState.attributesNum !== attributesNum) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (currentState.index !== index) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">saveCache</span>(<span class="params">geometry, index</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line">            <span class="keyword">const</span> attributes = geometry.attributes;</span><br><span class="line">            <span class="keyword">let</span> attributesNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> attributes) &#123;</span><br><span class="line">                <span class="keyword">const</span> attribute = attributes[key];</span><br><span class="line">                <span class="keyword">const</span> data = &#123;&#125;;</span><br><span class="line">                data.attribute = attribute;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (attribute.data) &#123;</span><br><span class="line">                    data.data = attribute.data;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                cache[key] = data;</span><br><span class="line">                attributesNum++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currentState.attributes = cache;</span><br><span class="line">            currentState.attributesNum = attributesNum;</span><br><span class="line">            currentState.index = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">initAttributes</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> newAttributes = currentState.newAttributes;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = newAttributes.length; i &lt; il; i++) &#123;</span><br><span class="line">                newAttributes[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">enableAttribute</span>(<span class="params">attribute</span>) </span>&#123;</span><br><span class="line">            enableAttributeAndDivisor(attribute, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">enableAttributeAndDivisor</span>(<span class="params">attribute, meshPerAttribute</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> newAttributes = currentState.newAttributes;</span><br><span class="line">            <span class="keyword">const</span> enabledAttributes = currentState.enabledAttributes;</span><br><span class="line">            <span class="keyword">const</span> attributeDivisors = currentState.attributeDivisors;</span><br><span class="line">            newAttributes[attribute] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (enabledAttributes[attribute] === <span class="number">0</span>) &#123;</span><br><span class="line">                gl.enableVertexAttribArray(attribute);</span><br><span class="line">                enabledAttributes[attribute] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (attributeDivisors[attribute] !== meshPerAttribute) &#123;</span><br><span class="line">                <span class="keyword">const</span> extension = capabilities.isWebGL2 ? gl : extensions.get(<span class="string">&#x27;ANGLE_instanced_arrays&#x27;</span>);</span><br><span class="line">                extension[capabilities.isWebGL2 ? <span class="string">&#x27;vertexAttribDivisor&#x27;</span> : <span class="string">&#x27;vertexAttribDivisorANGLE&#x27;</span>](attribute, meshPerAttribute);</span><br><span class="line">                attributeDivisors[attribute] = meshPerAttribute;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">disableUnusedAttributes</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> newAttributes = currentState.newAttributes;</span><br><span class="line">            <span class="keyword">const</span> enabledAttributes = currentState.enabledAttributes;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = enabledAttributes.length; i &lt; il; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (enabledAttributes[i] !== newAttributes[i]) &#123;</span><br><span class="line">                    gl.disableVertexAttribArray(i);</span><br><span class="line">                    enabledAttributes[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">vertexAttribPointer</span>(<span class="params">index, size, type, normalized, stride, offset</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (capabilities.isWebGL2 === <span class="literal">true</span> &amp;&amp; (type === gl.INT || type === gl.UNSIGNED_INT)) &#123;</span><br><span class="line">                gl.vertexAttribIPointer(index, size, type, stride, offset);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                gl.vertexAttribPointer(index, size, type, normalized, stride, offset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setupVertexAttributes</span>(<span class="params">object, material, program, geometry</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (capabilities.isWebGL2 === <span class="literal">false</span> &amp;&amp; (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (extensions.get(<span class="string">&#x27;ANGLE_instanced_arrays&#x27;</span>) === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            initAttributes();</span><br><span class="line">            <span class="keyword">const</span> geometryAttributes = geometry.attributes;</span><br><span class="line">            <span class="keyword">const</span> programAttributes = program.getAttributes();</span><br><span class="line">            <span class="keyword">const</span> materialDefaultAttributeValues = material.defaultAttributeValues;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> programAttributes) &#123;</span><br><span class="line">                <span class="keyword">const</span> programAttribute = programAttributes[name];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (programAttribute.location &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">let</span> geometryAttribute = geometryAttributes[name];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (geometryAttribute === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (name === <span class="string">&#x27;instanceMatrix&#x27;</span> &amp;&amp; object.instanceMatrix) geometryAttribute = object.instanceMatrix;</span><br><span class="line">                        <span class="keyword">if</span> (name === <span class="string">&#x27;instanceColor&#x27;</span> &amp;&amp; object.instanceColor) geometryAttribute = object.instanceColor;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (geometryAttribute !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        <span class="keyword">const</span> normalized = geometryAttribute.normalized;</span><br><span class="line">                        <span class="keyword">const</span> size = geometryAttribute.itemSize;</span><br><span class="line">                        <span class="keyword">const</span> attribute = attributes.get(geometryAttribute); <span class="comment">// TODO Attribute may not be available on context restore</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (attribute === <span class="literal">undefined</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">const</span> buffer = attribute.buffer;</span><br><span class="line">                        <span class="keyword">const</span> type = attribute.type;</span><br><span class="line">                        <span class="keyword">const</span> bytesPerElement = attribute.bytesPerElement;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (geometryAttribute.isInterleavedBufferAttribute) &#123;</span><br><span class="line">                            <span class="keyword">const</span> data = geometryAttribute.data;</span><br><span class="line">                            <span class="keyword">const</span> stride = data.stride;</span><br><span class="line">                            <span class="keyword">const</span> offset = geometryAttribute.offset;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (data.isInstancedInterleavedBuffer) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; programAttribute.locationSize; i++) &#123;</span><br><span class="line">                                    enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (object.isInstancedMesh !== <span class="literal">true</span> &amp;&amp; geometry._maxInstanceCount === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                                    geometry._maxInstanceCount = data.meshPerAttribute * data.count;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; programAttribute.locationSize; i++) &#123;</span><br><span class="line">                                    enableAttribute(programAttribute.location + i);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; programAttribute.locationSize; i++) &#123;</span><br><span class="line">                                vertexAttribPointer(programAttribute.location + i, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * i) * bytesPerElement);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (geometryAttribute.isInstancedBufferAttribute) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; programAttribute.locationSize; i++) &#123;</span><br><span class="line">                                    enableAttributeAndDivisor(programAttribute.location + i, geometryAttribute.meshPerAttribute);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (object.isInstancedMesh !== <span class="literal">true</span> &amp;&amp; geometry._maxInstanceCount === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                                    geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; programAttribute.locationSize; i++) &#123;</span><br><span class="line">                                    enableAttribute(programAttribute.location + i);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; programAttribute.locationSize; i++) &#123;</span><br><span class="line">                                vertexAttribPointer(programAttribute.location + i, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * i * bytesPerElement);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (materialDefaultAttributeValues !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        <span class="keyword">const</span> value = materialDefaultAttributeValues[name];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (value !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                            <span class="keyword">switch</span> (value.length) &#123;</span><br><span class="line">                                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                                    gl.vertexAttrib2fv(programAttribute.location, value);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                                    gl.vertexAttrib3fv(programAttribute.location, value);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                                    gl.vertexAttrib4fv(programAttribute.location, value);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">default</span>:</span><br><span class="line">                                    gl.vertexAttrib1fv(programAttribute.location, value);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            disableUnusedAttributes();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">dispose</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            reset();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> geometryId <span class="keyword">in</span> bindingStates) &#123;</span><br><span class="line">                <span class="keyword">const</span> programMap = bindingStates[geometryId];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> programId <span class="keyword">in</span> programMap) &#123;</span><br><span class="line">                    <span class="keyword">const</span> stateMap = programMap[programId];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">const</span> wireframe <span class="keyword">in</span> stateMap) &#123;</span><br><span class="line">                        deleteVertexArrayObject(stateMap[wireframe].object);</span><br><span class="line">                        <span class="keyword">delete</span> stateMap[wireframe];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">delete</span> programMap[programId];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">delete</span> bindingStates[geometryId];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">releaseStatesOfGeometry</span>(<span class="params">geometry</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (bindingStates[geometry.id] === <span class="literal">undefined</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">const</span> programMap = bindingStates[geometry.id];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> programId <span class="keyword">in</span> programMap) &#123;</span><br><span class="line">                <span class="keyword">const</span> stateMap = programMap[programId];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> wireframe <span class="keyword">in</span> stateMap) &#123;</span><br><span class="line">                    deleteVertexArrayObject(stateMap[wireframe].object);</span><br><span class="line">                    <span class="keyword">delete</span> stateMap[wireframe];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">delete</span> programMap[programId];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> bindingStates[geometry.id];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">releaseStatesOfProgram</span>(<span class="params">program</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> geometryId <span class="keyword">in</span> bindingStates) &#123;</span><br><span class="line">                <span class="keyword">const</span> programMap = bindingStates[geometryId];</span><br><span class="line">                <span class="keyword">if</span> (programMap[program.id] === <span class="literal">undefined</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">const</span> stateMap = programMap[program.id];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> wireframe <span class="keyword">in</span> stateMap) &#123;</span><br><span class="line">                    deleteVertexArrayObject(stateMap[wireframe].object);</span><br><span class="line">                    <span class="keyword">delete</span> stateMap[wireframe];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">delete</span> programMap[program.id];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">reset</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resetDefaultState();</span><br><span class="line">            forceUpdate = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (currentState === defaultState) <span class="keyword">return</span>;</span><br><span class="line">            currentState = defaultState;</span><br><span class="line">            bindVertexArrayObject(currentState.object);</span><br><span class="line">        &#125; <span class="comment">// for backward-compatibility</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resetDefaultState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            defaultState.geometry = <span class="literal">null</span>;</span><br><span class="line">            defaultState.program = <span class="literal">null</span>;</span><br><span class="line">            defaultState.wireframe = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">setup</span>: setup,</span><br><span class="line">            <span class="attr">reset</span>: reset,</span><br><span class="line">            <span class="attr">resetDefaultState</span>: resetDefaultState,</span><br><span class="line">            <span class="attr">dispose</span>: dispose,</span><br><span class="line">            <span class="attr">releaseStatesOfGeometry</span>: releaseStatesOfGeometry,</span><br><span class="line">            <span class="attr">releaseStatesOfProgram</span>: releaseStatesOfProgram,</span><br><span class="line">            <span class="attr">initAttributes</span>: initAttributes,</span><br><span class="line">            <span class="attr">enableAttribute</span>: enableAttribute,</span><br><span class="line">            <span class="attr">disableUnusedAttributes</span>: disableUnusedAttributes</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLBufferRenderer</span>(<span class="params">gl, extensions, info, capabilities</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> isWebGL2 = capabilities.isWebGL2;</span><br><span class="line">        <span class="keyword">let</span> mode;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setMode</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">            mode = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">start, count</span>) </span>&#123;</span><br><span class="line">            gl.drawArrays(mode, start, count);</span><br><span class="line">            info.update(count, mode, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">renderInstances</span>(<span class="params">start, count, primcount</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (primcount === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">let</span> extension, methodName;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isWebGL2) &#123;</span><br><span class="line">                extension = gl;</span><br><span class="line">                methodName = <span class="string">&#x27;drawArraysInstanced&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                extension = extensions.get(<span class="string">&#x27;ANGLE_instanced_arrays&#x27;</span>);</span><br><span class="line">                methodName = <span class="string">&#x27;drawArraysInstancedANGLE&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (extension === <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.&#x27;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            extension[methodName](mode, start, count, primcount);</span><br><span class="line">            info.update(count, mode, primcount);</span><br><span class="line">        &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setMode = setMode;</span><br><span class="line">        <span class="built_in">this</span>.render = render;</span><br><span class="line">        <span class="built_in">this</span>.renderInstances = renderInstances;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLCapabilities</span>(<span class="params">gl, extensions, parameters</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> maxAnisotropy;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getMaxAnisotropy</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (maxAnisotropy !== <span class="literal">undefined</span>) <span class="keyword">return</span> maxAnisotropy;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (extensions.has(<span class="string">&#x27;EXT_texture_filter_anisotropic&#x27;</span>) === <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> extension = extensions.get(<span class="string">&#x27;EXT_texture_filter_anisotropic&#x27;</span>);</span><br><span class="line">                maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxAnisotropy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> maxAnisotropy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getMaxPrecision</span>(<span class="params">precision</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (precision === <span class="string">&#x27;highp&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision &gt; <span class="number">0</span> &amp;&amp; gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;highp&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                precision = <span class="string">&#x27;mediump&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (precision === <span class="string">&#x27;mediump&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision &gt; <span class="number">0</span> &amp;&amp; gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;mediump&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;lowp&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> isWebGL2 = <span class="keyword">typeof</span> WebGL2RenderingContext !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; gl <span class="keyword">instanceof</span> WebGL2RenderingContext || <span class="keyword">typeof</span> WebGL2ComputeRenderingContext !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; gl <span class="keyword">instanceof</span> WebGL2ComputeRenderingContext;</span><br><span class="line">        <span class="keyword">let</span> precision = parameters.precision !== <span class="literal">undefined</span> ? parameters.precision : <span class="string">&#x27;highp&#x27;</span>;</span><br><span class="line">        <span class="keyword">const</span> maxPrecision = getMaxPrecision(precision);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (maxPrecision !== precision) &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer:&#x27;</span>, precision, <span class="string">&#x27;not supported, using&#x27;</span>, maxPrecision, <span class="string">&#x27;instead.&#x27;</span>);</span><br><span class="line">            precision = maxPrecision;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> drawBuffers = isWebGL2 || extensions.has(<span class="string">&#x27;WEBGL_draw_buffers&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">const</span> maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);</span><br><span class="line">        <span class="keyword">const</span> maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);</span><br><span class="line">        <span class="keyword">const</span> maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);</span><br><span class="line">        <span class="keyword">const</span> maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);</span><br><span class="line">        <span class="keyword">const</span> maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);</span><br><span class="line">        <span class="keyword">const</span> maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);</span><br><span class="line">        <span class="keyword">const</span> maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);</span><br><span class="line">        <span class="keyword">const</span> maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);</span><br><span class="line">        <span class="keyword">const</span> vertexTextures = maxVertexTextures &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> floatFragmentTextures = isWebGL2 || extensions.has(<span class="string">&#x27;OES_texture_float&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> floatVertexTextures = vertexTextures &amp;&amp; floatFragmentTextures;</span><br><span class="line">        <span class="keyword">const</span> maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">isWebGL2</span>: isWebGL2,</span><br><span class="line">            <span class="attr">drawBuffers</span>: drawBuffers,</span><br><span class="line">            <span class="attr">getMaxAnisotropy</span>: getMaxAnisotropy,</span><br><span class="line">            <span class="attr">getMaxPrecision</span>: getMaxPrecision,</span><br><span class="line">            <span class="attr">precision</span>: precision,</span><br><span class="line">            <span class="attr">logarithmicDepthBuffer</span>: logarithmicDepthBuffer,</span><br><span class="line">            <span class="attr">maxTextures</span>: maxTextures,</span><br><span class="line">            <span class="attr">maxVertexTextures</span>: maxVertexTextures,</span><br><span class="line">            <span class="attr">maxTextureSize</span>: maxTextureSize,</span><br><span class="line">            <span class="attr">maxCubemapSize</span>: maxCubemapSize,</span><br><span class="line">            <span class="attr">maxAttributes</span>: maxAttributes,</span><br><span class="line">            <span class="attr">maxVertexUniforms</span>: maxVertexUniforms,</span><br><span class="line">            <span class="attr">maxVaryings</span>: maxVaryings,</span><br><span class="line">            <span class="attr">maxFragmentUniforms</span>: maxFragmentUniforms,</span><br><span class="line">            <span class="attr">vertexTextures</span>: vertexTextures,</span><br><span class="line">            <span class="attr">floatFragmentTextures</span>: floatFragmentTextures,</span><br><span class="line">            <span class="attr">floatVertexTextures</span>: floatVertexTextures,</span><br><span class="line">            <span class="attr">maxSamples</span>: maxSamples</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLClipping</span>(<span class="params">properties</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> scope = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> globalState = <span class="literal">null</span>,</span><br><span class="line">            numGlobalPlanes = <span class="number">0</span>,</span><br><span class="line">            localClippingEnabled = <span class="literal">false</span>,</span><br><span class="line">            renderingShadows = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">const</span> plane = <span class="keyword">new</span> Plane(),</span><br><span class="line">            viewNormalMatrix = <span class="keyword">new</span> Matrix3(),</span><br><span class="line">            uniform = &#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">needsUpdate</span>: <span class="literal">false</span></span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="built_in">this</span>.uniform = uniform;</span><br><span class="line">        <span class="built_in">this</span>.numPlanes = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.numIntersection = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.init = <span class="function"><span class="keyword">function</span> (<span class="params">planes, enableLocalClipping, camera</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> enabled = planes.length !== <span class="number">0</span> || enableLocalClipping || <span class="comment">// enable state of previous frame - the clipping code has to</span></span><br><span class="line">                <span class="comment">// run another frame in order to reset the state:</span></span><br><span class="line">                numGlobalPlanes !== <span class="number">0</span> || localClippingEnabled;</span><br><span class="line">            localClippingEnabled = enableLocalClipping;</span><br><span class="line">            globalState = projectPlanes(planes, camera, <span class="number">0</span>);</span><br><span class="line">            numGlobalPlanes = planes.length;</span><br><span class="line">            <span class="keyword">return</span> enabled;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.beginShadows = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            renderingShadows = <span class="literal">true</span>;</span><br><span class="line">            projectPlanes(<span class="literal">null</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.endShadows = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            renderingShadows = <span class="literal">false</span>;</span><br><span class="line">            resetGlobalState();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setState = <span class="function"><span class="keyword">function</span> (<span class="params">material, camera, useCache</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> planes = material.clippingPlanes,</span><br><span class="line">                clipIntersection = material.clipIntersection,</span><br><span class="line">                clipShadows = material.clipShadows;</span><br><span class="line">            <span class="keyword">const</span> materialProperties = properties.get(material);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!localClippingEnabled || planes === <span class="literal">null</span> || planes.length === <span class="number">0</span> || renderingShadows &amp;&amp; !clipShadows) &#123;</span><br><span class="line">                <span class="comment">// there&#x27;s no local clipping</span></span><br><span class="line">                <span class="keyword">if</span> (renderingShadows) &#123;</span><br><span class="line">                    <span class="comment">// there&#x27;s no global clipping</span></span><br><span class="line">                    projectPlanes(<span class="literal">null</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resetGlobalState();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> nGlobal = renderingShadows ? <span class="number">0</span> : numGlobalPlanes,</span><br><span class="line">                    lGlobal = nGlobal * <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">let</span> dstArray = materialProperties.clippingState || <span class="literal">null</span>;</span><br><span class="line">                uniform.value = dstArray; <span class="comment">// ensure unique state</span></span><br><span class="line"></span><br><span class="line">                dstArray = projectPlanes(planes, camera, lGlobal, useCache);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i !== lGlobal; ++i) &#123;</span><br><span class="line">                    dstArray[i] = globalState[i];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                materialProperties.clippingState = dstArray;</span><br><span class="line">                <span class="built_in">this</span>.numIntersection = clipIntersection ? <span class="built_in">this</span>.numPlanes : <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">this</span>.numPlanes += nGlobal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resetGlobalState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (uniform.value !== globalState) &#123;</span><br><span class="line">                uniform.value = globalState;</span><br><span class="line">                uniform.needsUpdate = numGlobalPlanes &gt; <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            scope.numPlanes = numGlobalPlanes;</span><br><span class="line">            scope.numIntersection = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">projectPlanes</span>(<span class="params">planes, camera, dstOffset, skipTransform</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> nPlanes = planes !== <span class="literal">null</span> ? planes.length : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> dstArray = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nPlanes !== <span class="number">0</span>) &#123;</span><br><span class="line">                dstArray = uniform.value;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (skipTransform !== <span class="literal">true</span> || dstArray === <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> flatSize = dstOffset + nPlanes * <span class="number">4</span>,</span><br><span class="line">                        viewMatrix = camera.matrixWorldInverse;</span><br><span class="line">                    viewNormalMatrix.getNormalMatrix(viewMatrix);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (dstArray === <span class="literal">null</span> || dstArray.length &lt; flatSize) &#123;</span><br><span class="line">                        dstArray = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(flatSize);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, i4 = dstOffset; i !== nPlanes; ++i, i4 += <span class="number">4</span>) &#123;</span><br><span class="line">                        plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);</span><br><span class="line">                        plane.normal.toArray(dstArray, i4);</span><br><span class="line">                        dstArray[i4 + <span class="number">3</span>] = plane.constant;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                uniform.value = dstArray;</span><br><span class="line">                uniform.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            scope.numPlanes = nPlanes;</span><br><span class="line">            scope.numIntersection = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> dstArray;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLCubeMaps</span>(<span class="params">renderer</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> cubemaps = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">mapTextureMapping</span>(<span class="params">texture, mapping</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mapping === EquirectangularReflectionMapping) &#123;</span><br><span class="line">                texture.mapping = CubeReflectionMapping;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mapping === EquirectangularRefractionMapping) &#123;</span><br><span class="line">                texture.mapping = CubeRefractionMapping;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> texture;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">texture</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (texture &amp;&amp; texture.isTexture &amp;&amp; texture.isRenderTargetTexture === <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> mapping = texture.mapping;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cubemaps.has(texture)) &#123;</span><br><span class="line">                        <span class="keyword">const</span> cubemap = cubemaps.get(texture).texture;</span><br><span class="line">                        <span class="keyword">return</span> mapTextureMapping(cubemap, texture.mapping);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">const</span> image = texture.image;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (image &amp;&amp; image.height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">const</span> renderTarget = <span class="keyword">new</span> WebGLCubeRenderTarget(image.height / <span class="number">2</span>);</span><br><span class="line">                            renderTarget.fromEquirectangularTexture(renderer, texture);</span><br><span class="line">                            cubemaps.set(texture, renderTarget);</span><br><span class="line">                            texture.addEventListener(<span class="string">&#x27;dispose&#x27;</span>, onTextureDispose);</span><br><span class="line">                            <span class="keyword">return</span> mapTextureMapping(renderTarget.texture, texture.mapping);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// image not yet ready. try the conversion next frame</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> texture;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">onTextureDispose</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> texture = event.target;</span><br><span class="line">            texture.removeEventListener(<span class="string">&#x27;dispose&#x27;</span>, onTextureDispose);</span><br><span class="line">            <span class="keyword">const</span> cubemap = cubemaps.get(texture);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cubemap !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                cubemaps.delete(texture);</span><br><span class="line">                cubemap.dispose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">dispose</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            cubemaps = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">get</span>: get,</span><br><span class="line">            <span class="attr">dispose</span>: dispose</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OrthographicCamera</span> <span class="keyword">extends</span> <span class="title">Camera</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">left = -<span class="number">1</span>, right = <span class="number">1</span>, top = <span class="number">1</span>, bottom = -<span class="number">1</span>, near = <span class="number">0.1</span>, far = <span class="number">2000</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;OrthographicCamera&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.zoom = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.view = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">            <span class="built_in">this</span>.top = top;</span><br><span class="line">            <span class="built_in">this</span>.bottom = bottom;</span><br><span class="line">            <span class="built_in">this</span>.near = near;</span><br><span class="line">            <span class="built_in">this</span>.far = far;</span><br><span class="line">            <span class="built_in">this</span>.updateProjectionMatrix();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source, recursive</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source, recursive);</span><br><span class="line">            <span class="built_in">this</span>.left = source.left;</span><br><span class="line">            <span class="built_in">this</span>.right = source.right;</span><br><span class="line">            <span class="built_in">this</span>.top = source.top;</span><br><span class="line">            <span class="built_in">this</span>.bottom = source.bottom;</span><br><span class="line">            <span class="built_in">this</span>.near = source.near;</span><br><span class="line">            <span class="built_in">this</span>.far = source.far;</span><br><span class="line">            <span class="built_in">this</span>.zoom = source.zoom;</span><br><span class="line">            <span class="built_in">this</span>.view = source.view === <span class="literal">null</span> ? <span class="literal">null</span> : <span class="built_in">Object</span>.assign(&#123;&#125;, source.view);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setViewOffset</span>(<span class="params">fullWidth, fullHeight, x, y, width, height</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.view === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.view = &#123;</span><br><span class="line">                    <span class="attr">enabled</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">fullWidth</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="attr">fullHeight</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="attr">offsetX</span>: <span class="number">0</span>,</span><br><span class="line">                    <span class="attr">offsetY</span>: <span class="number">0</span>,</span><br><span class="line">                    <span class="attr">width</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="attr">height</span>: <span class="number">1</span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.view.enabled = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.view.fullWidth = fullWidth;</span><br><span class="line">            <span class="built_in">this</span>.view.fullHeight = fullHeight;</span><br><span class="line">            <span class="built_in">this</span>.view.offsetX = x;</span><br><span class="line">            <span class="built_in">this</span>.view.offsetY = y;</span><br><span class="line">            <span class="built_in">this</span>.view.width = width;</span><br><span class="line">            <span class="built_in">this</span>.view.height = height;</span><br><span class="line">            <span class="built_in">this</span>.updateProjectionMatrix();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clearViewOffset</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.view !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.view.enabled = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.updateProjectionMatrix();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">updateProjectionMatrix</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> dx = (<span class="built_in">this</span>.right - <span class="built_in">this</span>.left) / (<span class="number">2</span> * <span class="built_in">this</span>.zoom);</span><br><span class="line">            <span class="keyword">const</span> dy = (<span class="built_in">this</span>.top - <span class="built_in">this</span>.bottom) / (<span class="number">2</span> * <span class="built_in">this</span>.zoom);</span><br><span class="line">            <span class="keyword">const</span> cx = (<span class="built_in">this</span>.right + <span class="built_in">this</span>.left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">const</span> cy = (<span class="built_in">this</span>.top + <span class="built_in">this</span>.bottom) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">let</span> left = cx - dx;</span><br><span class="line">            <span class="keyword">let</span> right = cx + dx;</span><br><span class="line">            <span class="keyword">let</span> top = cy + dy;</span><br><span class="line">            <span class="keyword">let</span> bottom = cy - dy;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.view !== <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.view.enabled) &#123;</span><br><span class="line">                <span class="keyword">const</span> scaleW = (<span class="built_in">this</span>.right - <span class="built_in">this</span>.left) / <span class="built_in">this</span>.view.fullWidth / <span class="built_in">this</span>.zoom;</span><br><span class="line">                <span class="keyword">const</span> scaleH = (<span class="built_in">this</span>.top - <span class="built_in">this</span>.bottom) / <span class="built_in">this</span>.view.fullHeight / <span class="built_in">this</span>.zoom;</span><br><span class="line">                left += scaleW * <span class="built_in">this</span>.view.offsetX;</span><br><span class="line">                right = left + scaleW * <span class="built_in">this</span>.view.width;</span><br><span class="line">                top -= scaleH * <span class="built_in">this</span>.view.offsetY;</span><br><span class="line">                bottom = top - scaleH * <span class="built_in">this</span>.view.height;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.projectionMatrix.makeOrthographic(left, right, top, bottom, <span class="built_in">this</span>.near, <span class="built_in">this</span>.far);</span><br><span class="line">            <span class="built_in">this</span>.projectionMatrixInverse.copy(<span class="built_in">this</span>.projectionMatrix).invert();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params">meta</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON(meta);</span><br><span class="line">            data.object.zoom = <span class="built_in">this</span>.zoom;</span><br><span class="line">            data.object.left = <span class="built_in">this</span>.left;</span><br><span class="line">            data.object.right = <span class="built_in">this</span>.right;</span><br><span class="line">            data.object.top = <span class="built_in">this</span>.top;</span><br><span class="line">            data.object.bottom = <span class="built_in">this</span>.bottom;</span><br><span class="line">            data.object.near = <span class="built_in">this</span>.near;</span><br><span class="line">            data.object.far = <span class="built_in">this</span>.far;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.view !== <span class="literal">null</span>) data.object.view = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="built_in">this</span>.view);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OrthographicCamera.prototype.isOrthographicCamera = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> LOD_MIN = <span class="number">4</span>; <span class="comment">// The standard deviations (radians) associated with the extra mips. These are</span></span><br><span class="line">    <span class="comment">// chosen to approximate a Trowbridge-Reitz distribution function times the</span></span><br><span class="line">    <span class="comment">// geometric shadowing function. These sigma values squared must match the</span></span><br><span class="line">    <span class="comment">// variance #defines in cube_uv_reflection_fragment.glsl.js.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> EXTRA_LOD_SIGMA = [<span class="number">0.125</span>, <span class="number">0.215</span>, <span class="number">0.35</span>, <span class="number">0.446</span>, <span class="number">0.526</span>, <span class="number">0.582</span>]; <span class="comment">// The maximum length of the blur for loop. Smaller sigmas will use fewer</span></span><br><span class="line">    <span class="comment">// samples and exit early, but not recompile the shader.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> MAX_SAMPLES = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _flatCamera = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> OrthographicCamera();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _clearColor = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Color();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> _oldTarget = <span class="literal">null</span>; <span class="comment">// Golden Ratio</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> PHI = (<span class="number">1</span> + <span class="built_in">Math</span>.sqrt(<span class="number">5</span>)) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> INV_PHI = <span class="number">1</span> / PHI; <span class="comment">// Vertices of a dodecahedron (except the opposites, which represent the</span></span><br><span class="line">    <span class="comment">// same axis), used as axis directions evenly spread on a sphere.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _axisDirections = [<span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>), <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3(-<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>), <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3(<span class="number">0</span>, PHI, INV_PHI), <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3(<span class="number">0</span>, PHI, -INV_PHI), <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3(INV_PHI, <span class="number">0</span>, PHI), <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3(-INV_PHI, <span class="number">0</span>, PHI), <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3(PHI, INV_PHI, <span class="number">0</span>), <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3(-PHI, INV_PHI, <span class="number">0</span>)];</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class generates a Prefiltered, Mipmapped Radiance Environment Map</span></span><br><span class="line"><span class="comment">     * (PMREM) from a cubeMap environment texture. This allows different levels of</span></span><br><span class="line"><span class="comment">     * blur to be quickly accessed based on material roughness. It is packed into a</span></span><br><span class="line"><span class="comment">     * special CubeUV format that allows us to perform custom interpolation so that</span></span><br><span class="line"><span class="comment">     * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap</span></span><br><span class="line"><span class="comment">     * chain, it only goes down to the LOD_MIN level (above), and then creates extra</span></span><br><span class="line"><span class="comment">     * even more filtered &#x27;mips&#x27; at the same LOD_MIN resolution, associated with</span></span><br><span class="line"><span class="comment">     * higher roughness levels. In this way we maintain resolution to smoothly</span></span><br><span class="line"><span class="comment">     * interpolate diffuse lighting while limiting sampling computation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Paper: Fast, Accurate Image-Based Lighting</span></span><br><span class="line"><span class="comment">     * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PMREMGenerator</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">renderer</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._renderer = renderer;</span><br><span class="line">            <span class="built_in">this</span>._pingPongRenderTarget = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>._lodMax = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>._cubeSize = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>._lodPlanes = [];</span><br><span class="line">            <span class="built_in">this</span>._sizeLods = [];</span><br><span class="line">            <span class="built_in">this</span>._sigmas = [];</span><br><span class="line">            <span class="built_in">this</span>._blurMaterial = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>._cubemapMaterial = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>._equirectMaterial = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._compileMaterial(<span class="built_in">this</span>._blurMaterial);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Generates a PMREM from a supplied Scene, which can be faster than using an</span></span><br><span class="line"><span class="comment">         * image if networking bandwidth is low. Optional sigma specifies a blur radius</span></span><br><span class="line"><span class="comment">         * in radians to be applied to the scene before PMREM generation. Optional near</span></span><br><span class="line"><span class="comment">         * and far planes ensure the scene is rendered in its entirety (the cubeCamera</span></span><br><span class="line"><span class="comment">         * is placed at the origin).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromScene</span>(<span class="params">scene, sigma = <span class="number">0</span>, near = <span class="number">0.1</span>, far = <span class="number">100</span></span>)</span> &#123;</span><br><span class="line">            _oldTarget = <span class="built_in">this</span>._renderer.getRenderTarget();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._setSize(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> cubeUVRenderTarget = <span class="built_in">this</span>._allocateTargets();</span><br><span class="line"></span><br><span class="line">            cubeUVRenderTarget.depthBuffer = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sigma &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>._blur(cubeUVRenderTarget, <span class="number">0</span>, <span class="number">0</span>, sigma);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._applyPMREM(cubeUVRenderTarget);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._cleanup(cubeUVRenderTarget);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> cubeUVRenderTarget;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Generates a PMREM from an equirectangular texture, which can be either LDR</span></span><br><span class="line"><span class="comment">         * or HDR. The ideal input image size is 1k (1024 x 512),</span></span><br><span class="line"><span class="comment">         * as this matches best with the 256 x 256 cubemap output.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromEquirectangular</span>(<span class="params">equirectangular, renderTarget = <span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._fromTexture(equirectangular, renderTarget);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Generates a PMREM from an cubemap texture, which can be either LDR</span></span><br><span class="line"><span class="comment">         * or HDR. The ideal input cube size is 256 x 256,</span></span><br><span class="line"><span class="comment">         * as this matches best with the 256 x 256 cubemap output.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromCubemap</span>(<span class="params">cubemap, renderTarget = <span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._fromTexture(cubemap, renderTarget);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during</span></span><br><span class="line"><span class="comment">         * your texture&#x27;s network fetch for increased concurrency.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">compileCubemapShader</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._cubemapMaterial === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>._cubemapMaterial = _getCubemapMaterial();</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>._compileMaterial(<span class="built_in">this</span>._cubemapMaterial);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during</span></span><br><span class="line"><span class="comment">         * your texture&#x27;s network fetch for increased concurrency.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">compileEquirectangularShader</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._equirectMaterial === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>._equirectMaterial = _getEquirectMaterial();</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>._compileMaterial(<span class="built_in">this</span>._equirectMaterial);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Disposes of the PMREMGenerator&#x27;s internal memory. Note that PMREMGenerator is a static class,</span></span><br><span class="line"><span class="comment">         * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on</span></span><br><span class="line"><span class="comment">         * one of them will cause any others to also become unusable.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dispose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._dispose();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._cubemapMaterial !== <span class="literal">null</span>) <span class="built_in">this</span>._cubemapMaterial.dispose();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._equirectMaterial !== <span class="literal">null</span>) <span class="built_in">this</span>._equirectMaterial.dispose();</span><br><span class="line">        &#125; <span class="comment">// private interface</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_setSize</span>(<span class="params">cubeSize</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._lodMax = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.log2(cubeSize));</span><br><span class="line">            <span class="built_in">this</span>._cubeSize = <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="built_in">this</span>._lodMax);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_dispose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._blurMaterial !== <span class="literal">null</span>) <span class="built_in">this</span>._blurMaterial.dispose();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._pingPongRenderTarget !== <span class="literal">null</span>) <span class="built_in">this</span>._pingPongRenderTarget.dispose();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>._lodPlanes.length; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>._lodPlanes[i].dispose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_cleanup</span>(<span class="params">outputTarget</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._renderer.setRenderTarget(_oldTarget);</span><br><span class="line"></span><br><span class="line">            outputTarget.scissorTest = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            _setViewport(outputTarget, <span class="number">0</span>, <span class="number">0</span>, outputTarget.width, outputTarget.height);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_fromTexture</span>(<span class="params">texture, renderTarget</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) &#123;</span><br><span class="line">                <span class="built_in">this</span>._setSize(texture.image.length === <span class="number">0</span> ? <span class="number">16</span> : texture.image[<span class="number">0</span>].width || texture.image[<span class="number">0</span>].image.width);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Equirectangular</span></span><br><span class="line">                <span class="built_in">this</span>._setSize(texture.image.width / <span class="number">4</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _oldTarget = <span class="built_in">this</span>._renderer.getRenderTarget();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> cubeUVRenderTarget = renderTarget || <span class="built_in">this</span>._allocateTargets();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._textureToCubeUV(texture, cubeUVRenderTarget);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._applyPMREM(cubeUVRenderTarget);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._cleanup(cubeUVRenderTarget);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> cubeUVRenderTarget;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_allocateTargets</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> width = <span class="number">3</span> * <span class="built_in">Math</span>.max(<span class="built_in">this</span>._cubeSize, <span class="number">16</span> * <span class="number">7</span>);</span><br><span class="line">            <span class="keyword">const</span> height = <span class="number">4</span> * <span class="built_in">this</span>._cubeSize - <span class="number">32</span>;</span><br><span class="line">            <span class="keyword">const</span> params = &#123;</span><br><span class="line">                <span class="attr">magFilter</span>: LinearFilter,</span><br><span class="line">                <span class="attr">minFilter</span>: LinearFilter,</span><br><span class="line">                <span class="attr">generateMipmaps</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">type</span>: HalfFloatType,</span><br><span class="line">                <span class="attr">format</span>: RGBAFormat,</span><br><span class="line">                <span class="attr">encoding</span>: LinearEncoding,</span><br><span class="line">                <span class="attr">depthBuffer</span>: <span class="literal">false</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> cubeUVRenderTarget = _createRenderTarget(width, height, params);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._pingPongRenderTarget === <span class="literal">null</span> || <span class="built_in">this</span>._pingPongRenderTarget.width !== width) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>._pingPongRenderTarget !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>._dispose();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>._pingPongRenderTarget = _createRenderTarget(width, height, params);</span><br><span class="line">                <span class="keyword">const</span> &#123;</span><br><span class="line">                    _lodMax</span><br><span class="line">                &#125; = <span class="built_in">this</span>;</span><br><span class="line">                (&#123;</span><br><span class="line">                    <span class="attr">sizeLods</span>: <span class="built_in">this</span>._sizeLods,</span><br><span class="line">                    <span class="attr">lodPlanes</span>: <span class="built_in">this</span>._lodPlanes,</span><br><span class="line">                    <span class="attr">sigmas</span>: <span class="built_in">this</span>._sigmas</span><br><span class="line">                &#125; = _createPlanes(_lodMax));</span><br><span class="line">                <span class="built_in">this</span>._blurMaterial = _getBlurShader(_lodMax, width, height);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> cubeUVRenderTarget;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_compileMaterial</span>(<span class="params">material</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> tmpMesh = <span class="keyword">new</span> Mesh(<span class="built_in">this</span>._lodPlanes[<span class="number">0</span>], material);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._renderer.compile(tmpMesh, _flatCamera);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_sceneToCubeUV</span>(<span class="params">scene, near, far, cubeUVRenderTarget</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> fov = <span class="number">90</span>;</span><br><span class="line">            <span class="keyword">const</span> aspect = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">const</span> cubeCamera = <span class="keyword">new</span> PerspectiveCamera(fov, aspect, near, far);</span><br><span class="line">            <span class="keyword">const</span> upSign = [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">const</span> forwardSign = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">const</span> renderer = <span class="built_in">this</span>._renderer;</span><br><span class="line">            <span class="keyword">const</span> originalAutoClear = renderer.autoClear;</span><br><span class="line">            <span class="keyword">const</span> toneMapping = renderer.toneMapping;</span><br><span class="line">            renderer.getClearColor(_clearColor);</span><br><span class="line">            renderer.toneMapping = NoToneMapping;</span><br><span class="line">            renderer.autoClear = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">const</span> backgroundMaterial = <span class="keyword">new</span> MeshBasicMaterial(&#123;</span><br><span class="line">                <span class="attr">name</span>: <span class="string">&#x27;PMREM.Background&#x27;</span>,</span><br><span class="line">                <span class="attr">side</span>: BackSide,</span><br><span class="line">                <span class="attr">depthWrite</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">depthTest</span>: <span class="literal">false</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">const</span> backgroundBox = <span class="keyword">new</span> Mesh(<span class="keyword">new</span> BoxGeometry(), backgroundMaterial);</span><br><span class="line">            <span class="keyword">let</span> useSolidColor = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">const</span> background = scene.background;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (background) &#123;</span><br><span class="line">                <span class="keyword">if</span> (background.isColor) &#123;</span><br><span class="line">                    backgroundMaterial.color.copy(background);</span><br><span class="line">                    scene.background = <span class="literal">null</span>;</span><br><span class="line">                    useSolidColor = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                backgroundMaterial.color.copy(_clearColor);</span><br><span class="line">                useSolidColor = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> col = i % <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (col === <span class="number">0</span>) &#123;</span><br><span class="line">                    cubeCamera.up.set(<span class="number">0</span>, upSign[i], <span class="number">0</span>);</span><br><span class="line">                    cubeCamera.lookAt(forwardSign[i], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (col === <span class="number">1</span>) &#123;</span><br><span class="line">                    cubeCamera.up.set(<span class="number">0</span>, <span class="number">0</span>, upSign[i]);</span><br><span class="line">                    cubeCamera.lookAt(<span class="number">0</span>, forwardSign[i], <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cubeCamera.up.set(<span class="number">0</span>, upSign[i], <span class="number">0</span>);</span><br><span class="line">                    cubeCamera.lookAt(<span class="number">0</span>, <span class="number">0</span>, forwardSign[i]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> size = <span class="built_in">this</span>._cubeSize;</span><br><span class="line"></span><br><span class="line">                _setViewport(cubeUVRenderTarget, col * size, i &gt; <span class="number">2</span> ? size : <span class="number">0</span>, size, size);</span><br><span class="line"></span><br><span class="line">                renderer.setRenderTarget(cubeUVRenderTarget);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (useSolidColor) &#123;</span><br><span class="line">                    renderer.render(backgroundBox, cubeCamera);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                renderer.render(scene, cubeCamera);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            backgroundBox.geometry.dispose();</span><br><span class="line">            backgroundBox.material.dispose();</span><br><span class="line">            renderer.toneMapping = toneMapping;</span><br><span class="line">            renderer.autoClear = originalAutoClear;</span><br><span class="line">            scene.background = background;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_textureToCubeUV</span>(<span class="params">texture, cubeUVRenderTarget</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> renderer = <span class="built_in">this</span>._renderer;</span><br><span class="line">            <span class="keyword">const</span> isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isCubeTexture) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>._cubemapMaterial === <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>._cubemapMaterial = _getCubemapMaterial();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === <span class="literal">false</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>._equirectMaterial === <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>._equirectMaterial = _getEquirectMaterial();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> material = isCubeTexture ? <span class="built_in">this</span>._cubemapMaterial : <span class="built_in">this</span>._equirectMaterial;</span><br><span class="line">            <span class="keyword">const</span> mesh = <span class="keyword">new</span> Mesh(<span class="built_in">this</span>._lodPlanes[<span class="number">0</span>], material);</span><br><span class="line">            <span class="keyword">const</span> uniforms = material.uniforms;</span><br><span class="line">            uniforms[<span class="string">&#x27;envMap&#x27;</span>].value = texture;</span><br><span class="line">            <span class="keyword">const</span> size = <span class="built_in">this</span>._cubeSize;</span><br><span class="line"></span><br><span class="line">            _setViewport(cubeUVRenderTarget, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span> * size, <span class="number">2</span> * size);</span><br><span class="line"></span><br><span class="line">            renderer.setRenderTarget(cubeUVRenderTarget);</span><br><span class="line">            renderer.render(mesh, _flatCamera);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_applyPMREM</span>(<span class="params">cubeUVRenderTarget</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> renderer = <span class="built_in">this</span>._renderer;</span><br><span class="line">            <span class="keyword">const</span> autoClear = renderer.autoClear;</span><br><span class="line">            renderer.autoClear = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">this</span>._lodPlanes.length; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> sigma = <span class="built_in">Math</span>.sqrt(<span class="built_in">this</span>._sigmas[i] * <span class="built_in">this</span>._sigmas[i] - <span class="built_in">this</span>._sigmas[i - <span class="number">1</span>] * <span class="built_in">this</span>._sigmas[i - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">const</span> poleAxis = _axisDirections[(i - <span class="number">1</span>) % _axisDirections.length];</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>._blur(cubeUVRenderTarget, i - <span class="number">1</span>, i, sigma, poleAxis);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            renderer.autoClear = autoClear;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This is a two-pass Gaussian blur for a cubemap. Normally this is done</span></span><br><span class="line"><span class="comment">         * vertically and horizontally, but this breaks down on a cube. Here we apply</span></span><br><span class="line"><span class="comment">         * the blur latitudinally (around the poles), and then longitudinally (towards</span></span><br><span class="line"><span class="comment">         * the poles) to approximate the orthogonally-separable blur. It is least</span></span><br><span class="line"><span class="comment">         * accurate at the poles, but still does a decent job.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_blur</span>(<span class="params">cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> pingPongRenderTarget = <span class="built_in">this</span>._pingPongRenderTarget;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, <span class="string">&#x27;latitudinal&#x27;</span>, poleAxis);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, <span class="string">&#x27;longitudinal&#x27;</span>, poleAxis);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_halfBlur</span>(<span class="params">targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> renderer = <span class="built_in">this</span>._renderer;</span><br><span class="line">            <span class="keyword">const</span> blurMaterial = <span class="built_in">this</span>._blurMaterial;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (direction !== <span class="string">&#x27;latitudinal&#x27;</span> &amp;&amp; direction !== <span class="string">&#x27;longitudinal&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;blur direction must be either latitudinal or longitudinal!&#x27;</span>);</span><br><span class="line">            &#125; <span class="comment">// Number of standard deviations at which to cut off the discrete approximation.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> STANDARD_DEVIATIONS = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">const</span> blurMesh = <span class="keyword">new</span> Mesh(<span class="built_in">this</span>._lodPlanes[lodOut], blurMaterial);</span><br><span class="line">            <span class="keyword">const</span> blurUniforms = blurMaterial.uniforms;</span><br><span class="line">            <span class="keyword">const</span> pixels = <span class="built_in">this</span>._sizeLods[lodIn] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">const</span> radiansPerPixel = <span class="built_in">isFinite</span>(sigmaRadians) ? <span class="built_in">Math</span>.PI / (<span class="number">2</span> * pixels) : <span class="number">2</span> * <span class="built_in">Math</span>.PI / (<span class="number">2</span> * MAX_SAMPLES - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">const</span> sigmaPixels = sigmaRadians / radiansPerPixel;</span><br><span class="line">            <span class="keyword">const</span> samples = <span class="built_in">isFinite</span>(sigmaRadians) ? <span class="number">1</span> + <span class="built_in">Math</span>.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (samples &gt; MAX_SAMPLES) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">`sigmaRadians, <span class="subst">$&#123;sigmaRadians&#125;</span>, is too large and will clip, as it requested <span class="subst">$&#123;samples&#125;</span> samples when the maximum is set to <span class="subst">$&#123;MAX_SAMPLES&#125;</span>`</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> weights = [];</span><br><span class="line">            <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; MAX_SAMPLES; ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> x = i / sigmaPixels;</span><br><span class="line">                <span class="keyword">const</span> weight = <span class="built_in">Math</span>.exp(-x * x / <span class="number">2</span>);</span><br><span class="line">                weights.push(weight);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">                    sum += weight;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; samples) &#123;</span><br><span class="line">                    sum += <span class="number">2</span> * weight;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; weights.length; i++) &#123;</span><br><span class="line">                weights[i] = weights[i] / sum;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            blurUniforms[<span class="string">&#x27;envMap&#x27;</span>].value = targetIn.texture;</span><br><span class="line">            blurUniforms[<span class="string">&#x27;samples&#x27;</span>].value = samples;</span><br><span class="line">            blurUniforms[<span class="string">&#x27;weights&#x27;</span>].value = weights;</span><br><span class="line">            blurUniforms[<span class="string">&#x27;latitudinal&#x27;</span>].value = direction === <span class="string">&#x27;latitudinal&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (poleAxis) &#123;</span><br><span class="line">                blurUniforms[<span class="string">&#x27;poleAxis&#x27;</span>].value = poleAxis;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> &#123;</span><br><span class="line">                _lodMax</span><br><span class="line">            &#125; = <span class="built_in">this</span>;</span><br><span class="line">            blurUniforms[<span class="string">&#x27;dTheta&#x27;</span>].value = radiansPerPixel;</span><br><span class="line">            blurUniforms[<span class="string">&#x27;mipInt&#x27;</span>].value = _lodMax - lodIn;</span><br><span class="line">            <span class="keyword">const</span> outputSize = <span class="built_in">this</span>._sizeLods[lodOut];</span><br><span class="line">            <span class="keyword">const</span> x = <span class="number">3</span> * outputSize * (lodOut &gt; _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">const</span> y = <span class="number">4</span> * (<span class="built_in">this</span>._cubeSize - outputSize);</span><br><span class="line"></span><br><span class="line">            _setViewport(targetOut, x, y, <span class="number">3</span> * outputSize, <span class="number">2</span> * outputSize);</span><br><span class="line"></span><br><span class="line">            renderer.setRenderTarget(targetOut);</span><br><span class="line">            renderer.render(blurMesh, _flatCamera);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_createPlanes</span>(<span class="params">lodMax</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> lodPlanes = [];</span><br><span class="line">        <span class="keyword">const</span> sizeLods = [];</span><br><span class="line">        <span class="keyword">const</span> sigmas = [];</span><br><span class="line">        <span class="keyword">let</span> lod = lodMax;</span><br><span class="line">        <span class="keyword">const</span> totalLods = lodMax - LOD_MIN + <span class="number">1</span> + EXTRA_LOD_SIGMA.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; totalLods; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> sizeLod = <span class="built_in">Math</span>.pow(<span class="number">2</span>, lod);</span><br><span class="line">            sizeLods.push(sizeLod);</span><br><span class="line">            <span class="keyword">let</span> sigma = <span class="number">1.0</span> / sizeLod;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; lodMax - LOD_MIN) &#123;</span><br><span class="line">                sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">                sigma = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sigmas.push(sigma);</span><br><span class="line">            <span class="keyword">const</span> texelSize = <span class="number">1.0</span> / (sizeLod - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">const</span> min = -texelSize / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">const</span> max = <span class="number">1</span> + texelSize / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">const</span> uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];</span><br><span class="line">            <span class="keyword">const</span> cubeFaces = <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">const</span> vertices = <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">const</span> positionSize = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">const</span> uvSize = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">const</span> faceIndexSize = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">const</span> position = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(positionSize * vertices * cubeFaces);</span><br><span class="line">            <span class="keyword">const</span> uv = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(uvSize * vertices * cubeFaces);</span><br><span class="line">            <span class="keyword">const</span> faceIndex = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(faceIndexSize * vertices * cubeFaces);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> face = <span class="number">0</span>; face &lt; cubeFaces; face++) &#123;</span><br><span class="line">                <span class="keyword">const</span> x = face % <span class="number">3</span> * <span class="number">2</span> / <span class="number">3</span> - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">const</span> y = face &gt; <span class="number">2</span> ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">const</span> coordinates = [x, y, <span class="number">0</span>, x + <span class="number">2</span> / <span class="number">3</span>, y, <span class="number">0</span>, x + <span class="number">2</span> / <span class="number">3</span>, y + <span class="number">1</span>, <span class="number">0</span>, x, y, <span class="number">0</span>, x + <span class="number">2</span> / <span class="number">3</span>, y + <span class="number">1</span>, <span class="number">0</span>, x, y + <span class="number">1</span>, <span class="number">0</span>];</span><br><span class="line">                position.set(coordinates, positionSize * vertices * face);</span><br><span class="line">                uv.set(uv1, uvSize * vertices * face);</span><br><span class="line">                <span class="keyword">const</span> fill = [face, face, face, face, face, face];</span><br><span class="line">                faceIndex.set(fill, faceIndexSize * vertices * face);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> planes = <span class="keyword">new</span> BufferGeometry();</span><br><span class="line">            planes.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> BufferAttribute(position, positionSize));</span><br><span class="line">            planes.setAttribute(<span class="string">&#x27;uv&#x27;</span>, <span class="keyword">new</span> BufferAttribute(uv, uvSize));</span><br><span class="line">            planes.setAttribute(<span class="string">&#x27;faceIndex&#x27;</span>, <span class="keyword">new</span> BufferAttribute(faceIndex, faceIndexSize));</span><br><span class="line">            lodPlanes.push(planes);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (lod &gt; LOD_MIN) &#123;</span><br><span class="line">                lod--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            lodPlanes,</span><br><span class="line">            sizeLods,</span><br><span class="line">            sigmas</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_createRenderTarget</span>(<span class="params">width, height, params</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> cubeUVRenderTarget = <span class="keyword">new</span> WebGLRenderTarget(width, height, params);</span><br><span class="line">        cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;</span><br><span class="line">        cubeUVRenderTarget.texture.name = <span class="string">&#x27;PMREM.cubeUv&#x27;</span>;</span><br><span class="line">        cubeUVRenderTarget.scissorTest = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> cubeUVRenderTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_setViewport</span>(<span class="params">target, x, y, width, height</span>) </span>&#123;</span><br><span class="line">        target.viewport.set(x, y, width, height);</span><br><span class="line">        target.scissor.set(x, y, width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_getBlurShader</span>(<span class="params">lodMax, width, height</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> weights = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(MAX_SAMPLES);</span><br><span class="line">        <span class="keyword">const</span> poleAxis = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">const</span> shaderMaterial = <span class="keyword">new</span> ShaderMaterial(&#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;SphericalGaussianBlur&#x27;</span>,</span><br><span class="line">            <span class="attr">defines</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;n&#x27;</span>: MAX_SAMPLES,</span><br><span class="line">                <span class="string">&#x27;CUBEUV_TEXEL_WIDTH&#x27;</span>: <span class="number">1.0</span> / width,</span><br><span class="line">                <span class="string">&#x27;CUBEUV_TEXEL_HEIGHT&#x27;</span>: <span class="number">1.0</span> / height,</span><br><span class="line">                <span class="string">&#x27;CUBEUV_MAX_MIP&#x27;</span>: <span class="string">`<span class="subst">$&#123;lodMax&#125;</span>.0`</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">uniforms</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;envMap&#x27;</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&#x27;samples&#x27;</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&#x27;weights&#x27;</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: weights</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&#x27;latitudinal&#x27;</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="literal">false</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&#x27;dTheta&#x27;</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="number">0</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&#x27;mipInt&#x27;</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="number">0</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&#x27;poleAxis&#x27;</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: poleAxis</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">vertexShader</span>: _getCommonVertexShader(),</span><br><span class="line">            <span class="attr">fragmentShader</span>:</span><br><span class="line">            <span class="comment">/* glsl */</span></span><br><span class="line">                <span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			precision mediump float;</span></span><br><span class="line"><span class="string">			precision mediump int;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			varying vec3 vOutputDirection;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			uniform sampler2D envMap;</span></span><br><span class="line"><span class="string">			uniform int samples;</span></span><br><span class="line"><span class="string">			uniform float weights[ n ];</span></span><br><span class="line"><span class="string">			uniform bool latitudinal;</span></span><br><span class="line"><span class="string">			uniform float dTheta;</span></span><br><span class="line"><span class="string">			uniform float mipInt;</span></span><br><span class="line"><span class="string">			uniform vec3 poleAxis;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			#define ENVMAP_TYPE_CUBE_UV</span></span><br><span class="line"><span class="string">			#include &lt;cube_uv_reflection_fragment&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			vec3 getSample( float theta, vec3 axis ) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				float cosTheta = cos( theta );</span></span><br><span class="line"><span class="string">				// Rodrigues&#x27; axis-angle rotation</span></span><br><span class="line"><span class="string">				vec3 sampleDirection = vOutputDirection * cosTheta</span></span><br><span class="line"><span class="string">					+ cross( axis, vOutputDirection ) * sin( theta )</span></span><br><span class="line"><span class="string">					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				return bilinearCubeUV( envMap, sampleDirection, mipInt );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			void main() &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				if ( all( equal( axis, vec3( 0.0 ) ) ) ) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				axis = normalize( axis );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );</span></span><br><span class="line"><span class="string">				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				for ( int i = 1; i &lt; n; i++ ) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">					if ( i &gt;= samples ) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">						break;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">					&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">					float theta = dTheta * float( i );</span></span><br><span class="line"><span class="string">					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );</span></span><br><span class="line"><span class="string">					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		`</span>,</span><br><span class="line">            <span class="attr">blending</span>: NoBlending,</span><br><span class="line">            <span class="attr">depthTest</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">depthWrite</span>: <span class="literal">false</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> shaderMaterial;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_getEquirectMaterial</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShaderMaterial(&#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;EquirectangularToCubeUV&#x27;</span>,</span><br><span class="line">            <span class="attr">uniforms</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;envMap&#x27;</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">vertexShader</span>: _getCommonVertexShader(),</span><br><span class="line">            <span class="attr">fragmentShader</span>:</span><br><span class="line">            <span class="comment">/* glsl */</span></span><br><span class="line">                <span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			precision mediump float;</span></span><br><span class="line"><span class="string">			precision mediump int;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			varying vec3 vOutputDirection;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			uniform sampler2D envMap;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			#include &lt;common&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			void main() &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				vec3 outputDirection = normalize( vOutputDirection );</span></span><br><span class="line"><span class="string">				vec2 uv = equirectUv( outputDirection );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		`</span>,</span><br><span class="line">            <span class="attr">blending</span>: NoBlending,</span><br><span class="line">            <span class="attr">depthTest</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">depthWrite</span>: <span class="literal">false</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_getCubemapMaterial</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShaderMaterial(&#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;CubemapToCubeUV&#x27;</span>,</span><br><span class="line">            <span class="attr">uniforms</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;envMap&#x27;</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&#x27;flipEnvMap&#x27;</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: -<span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">vertexShader</span>: _getCommonVertexShader(),</span><br><span class="line">            <span class="attr">fragmentShader</span>:</span><br><span class="line">            <span class="comment">/* glsl */</span></span><br><span class="line">                <span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			precision mediump float;</span></span><br><span class="line"><span class="string">			precision mediump int;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			uniform float flipEnvMap;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			varying vec3 vOutputDirection;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			uniform samplerCube envMap;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			void main() &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		`</span>,</span><br><span class="line">            <span class="attr">blending</span>: NoBlending,</span><br><span class="line">            <span class="attr">depthTest</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">depthWrite</span>: <span class="literal">false</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_getCommonVertexShader</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="comment">/* glsl */</span></span><br><span class="line">            <span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		precision mediump float;</span></span><br><span class="line"><span class="string">		precision mediump int;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		attribute float faceIndex;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		varying vec3 vOutputDirection;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		// RH coordinate system; PMREM face-indexing convention</span></span><br><span class="line"><span class="string">		vec3 getDirection( vec2 uv, float face ) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			uv = 2.0 * uv - 1.0;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			vec3 direction = vec3( uv, 1.0 );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			if ( face == 0.0 ) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				direction = direction.zyx; // ( 1, v, u ) pos x</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			&#125; else if ( face == 1.0 ) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				direction = direction.xzy;</span></span><br><span class="line"><span class="string">				direction.xz *= -1.0; // ( -u, 1, -v ) pos y</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			&#125; else if ( face == 2.0 ) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				direction.x *= -1.0; // ( -u, v, 1 ) pos z</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			&#125; else if ( face == 3.0 ) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				direction = direction.zyx;</span></span><br><span class="line"><span class="string">				direction.xz *= -1.0; // ( -1, v, -u ) neg x</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			&#125; else if ( face == 4.0 ) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				direction = direction.xzy;</span></span><br><span class="line"><span class="string">				direction.xy *= -1.0; // ( -u, -1, v ) neg y</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			&#125; else if ( face == 5.0 ) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				direction.z *= -1.0; // ( u, v, -1 ) neg z</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			return direction;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		void main() &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			vOutputDirection = getDirection( uv, faceIndex );</span></span><br><span class="line"><span class="string">			gl_Position = vec4( position, 1.0 );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	`</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLCubeUVMaps</span>(<span class="params">renderer</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> cubeUVmaps = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">        <span class="keyword">let</span> pmremGenerator = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">texture</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (texture &amp;&amp; texture.isTexture) &#123;</span><br><span class="line">                <span class="keyword">const</span> mapping = texture.mapping;</span><br><span class="line">                <span class="keyword">const</span> isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;</span><br><span class="line">                <span class="keyword">const</span> isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping; <span class="comment">// equirect/cube map to cubeUV conversion</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isEquirectMap || isCubeMap) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (texture.isRenderTargetTexture &amp;&amp; texture.needsPMREMUpdate === <span class="literal">true</span>) &#123;</span><br><span class="line">                        texture.needsPMREMUpdate = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">let</span> renderTarget = cubeUVmaps.get(texture);</span><br><span class="line">                        <span class="keyword">if</span> (pmremGenerator === <span class="literal">null</span>) pmremGenerator = <span class="keyword">new</span> PMREMGenerator(renderer);</span><br><span class="line">                        renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);</span><br><span class="line">                        cubeUVmaps.set(texture, renderTarget);</span><br><span class="line">                        <span class="keyword">return</span> renderTarget.texture;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (cubeUVmaps.has(texture)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> cubeUVmaps.get(texture).texture;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">const</span> image = texture.image;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (isEquirectMap &amp;&amp; image &amp;&amp; image.height &gt; <span class="number">0</span> || isCubeMap &amp;&amp; image &amp;&amp; isCubeTextureComplete(image)) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (pmremGenerator === <span class="literal">null</span>) pmremGenerator = <span class="keyword">new</span> PMREMGenerator(renderer);</span><br><span class="line">                                <span class="keyword">const</span> renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);</span><br><span class="line">                                cubeUVmaps.set(texture, renderTarget);</span><br><span class="line">                                texture.addEventListener(<span class="string">&#x27;dispose&#x27;</span>, onTextureDispose);</span><br><span class="line">                                <span class="keyword">return</span> renderTarget.texture;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// image not yet ready. try the conversion next frame</span></span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> texture;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">isCubeTextureComplete</span>(<span class="params">image</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> length = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (image[i] !== <span class="literal">undefined</span>) count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> count === length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">onTextureDispose</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> texture = event.target;</span><br><span class="line">            texture.removeEventListener(<span class="string">&#x27;dispose&#x27;</span>, onTextureDispose);</span><br><span class="line">            <span class="keyword">const</span> cubemapUV = cubeUVmaps.get(texture);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cubemapUV !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                cubeUVmaps.delete(texture);</span><br><span class="line">                cubemapUV.dispose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">dispose</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            cubeUVmaps = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pmremGenerator !== <span class="literal">null</span>) &#123;</span><br><span class="line">                pmremGenerator.dispose();</span><br><span class="line">                pmremGenerator = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">get</span>: get,</span><br><span class="line">            <span class="attr">dispose</span>: dispose</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLExtensions</span>(<span class="params">gl</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> extensions = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getExtension</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (extensions[name] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> extensions[name];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> extension;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;WEBGL_depth_texture&#x27;</span>:</span><br><span class="line">                    extension = gl.getExtension(<span class="string">&#x27;WEBGL_depth_texture&#x27;</span>) || gl.getExtension(<span class="string">&#x27;MOZ_WEBGL_depth_texture&#x27;</span>) || gl.getExtension(<span class="string">&#x27;WEBKIT_WEBGL_depth_texture&#x27;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;EXT_texture_filter_anisotropic&#x27;</span>:</span><br><span class="line">                    extension = gl.getExtension(<span class="string">&#x27;EXT_texture_filter_anisotropic&#x27;</span>) || gl.getExtension(<span class="string">&#x27;MOZ_EXT_texture_filter_anisotropic&#x27;</span>) || gl.getExtension(<span class="string">&#x27;WEBKIT_EXT_texture_filter_anisotropic&#x27;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;WEBGL_compressed_texture_s3tc&#x27;</span>:</span><br><span class="line">                    extension = gl.getExtension(<span class="string">&#x27;WEBGL_compressed_texture_s3tc&#x27;</span>) || gl.getExtension(<span class="string">&#x27;MOZ_WEBGL_compressed_texture_s3tc&#x27;</span>) || gl.getExtension(<span class="string">&#x27;WEBKIT_WEBGL_compressed_texture_s3tc&#x27;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;WEBGL_compressed_texture_pvrtc&#x27;</span>:</span><br><span class="line">                    extension = gl.getExtension(<span class="string">&#x27;WEBGL_compressed_texture_pvrtc&#x27;</span>) || gl.getExtension(<span class="string">&#x27;WEBKIT_WEBGL_compressed_texture_pvrtc&#x27;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    extension = gl.getExtension(name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            extensions[name] = extension;</span><br><span class="line">            <span class="keyword">return</span> extension;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">has</span>: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getExtension(name) !== <span class="literal">null</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params">capabilities</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (capabilities.isWebGL2) &#123;</span><br><span class="line">                    getExtension(<span class="string">&#x27;EXT_color_buffer_float&#x27;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    getExtension(<span class="string">&#x27;WEBGL_depth_texture&#x27;</span>);</span><br><span class="line">                    getExtension(<span class="string">&#x27;OES_texture_float&#x27;</span>);</span><br><span class="line">                    getExtension(<span class="string">&#x27;OES_texture_half_float&#x27;</span>);</span><br><span class="line">                    getExtension(<span class="string">&#x27;OES_texture_half_float_linear&#x27;</span>);</span><br><span class="line">                    getExtension(<span class="string">&#x27;OES_standard_derivatives&#x27;</span>);</span><br><span class="line">                    getExtension(<span class="string">&#x27;OES_element_index_uint&#x27;</span>);</span><br><span class="line">                    getExtension(<span class="string">&#x27;OES_vertex_array_object&#x27;</span>);</span><br><span class="line">                    getExtension(<span class="string">&#x27;ANGLE_instanced_arrays&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                getExtension(<span class="string">&#x27;OES_texture_float_linear&#x27;</span>);</span><br><span class="line">                getExtension(<span class="string">&#x27;EXT_color_buffer_half_float&#x27;</span>);</span><br><span class="line">                getExtension(<span class="string">&#x27;WEBGL_multisampled_render_to_texture&#x27;</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> extension = getExtension(name);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (extension === <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: &#x27;</span> + name + <span class="string">&#x27; extension not supported.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> extension;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLGeometries</span>(<span class="params">gl, attributes, info, bindingStates</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> geometries = &#123;&#125;;</span><br><span class="line">        <span class="keyword">const</span> wireframeAttributes = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">onGeometryDispose</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> geometry = event.target;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (geometry.index !== <span class="literal">null</span>) &#123;</span><br><span class="line">                attributes.remove(geometry.index);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> geometry.attributes) &#123;</span><br><span class="line">                attributes.remove(geometry.attributes[name]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            geometry.removeEventListener(<span class="string">&#x27;dispose&#x27;</span>, onGeometryDispose);</span><br><span class="line">            <span class="keyword">delete</span> geometries[geometry.id];</span><br><span class="line">            <span class="keyword">const</span> attribute = wireframeAttributes.get(geometry);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (attribute) &#123;</span><br><span class="line">                attributes.remove(attribute);</span><br><span class="line">                wireframeAttributes.delete(geometry);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bindingStates.releaseStatesOfGeometry(geometry);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (geometry.isInstancedBufferGeometry === <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> geometry._maxInstanceCount;</span><br><span class="line">            &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            info.memory.geometries--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">object, geometry</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (geometries[geometry.id] === <span class="literal">true</span>) <span class="keyword">return</span> geometry;</span><br><span class="line">            geometry.addEventListener(<span class="string">&#x27;dispose&#x27;</span>, onGeometryDispose);</span><br><span class="line">            geometries[geometry.id] = <span class="literal">true</span>;</span><br><span class="line">            info.memory.geometries++;</span><br><span class="line">            <span class="keyword">return</span> geometry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">geometry</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> geometryAttributes = geometry.attributes; <span class="comment">// Updating index buffer in VAO now. See WebGLBindingStates.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> geometryAttributes) &#123;</span><br><span class="line">                attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);</span><br><span class="line">            &#125; <span class="comment">// morph targets</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> morphAttributes = geometry.morphAttributes;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> morphAttributes) &#123;</span><br><span class="line">                <span class="keyword">const</span> array = morphAttributes[name];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = array.length; i &lt; l; i++) &#123;</span><br><span class="line">                    attributes.update(array[i], gl.ARRAY_BUFFER);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">updateWireframeAttribute</span>(<span class="params">geometry</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> indices = [];</span><br><span class="line">            <span class="keyword">const</span> geometryIndex = geometry.index;</span><br><span class="line">            <span class="keyword">const</span> geometryPosition = geometry.attributes.position;</span><br><span class="line">            <span class="keyword">let</span> version = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (geometryIndex !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> array = geometryIndex.array;</span><br><span class="line">                version = geometryIndex.version;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = array.length; i &lt; l; i += <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> a = array[i + <span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">const</span> b = array[i + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">const</span> c = array[i + <span class="number">2</span>];</span><br><span class="line">                    indices.push(a, b, b, c, c, a);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> array = geometryPosition.array;</span><br><span class="line">                version = geometryPosition.version;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = array.length / <span class="number">3</span> - <span class="number">1</span>; i &lt; l; i += <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> a = i + <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">const</span> b = i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">const</span> c = i + <span class="number">2</span>;</span><br><span class="line">                    indices.push(a, b, b, c, c, a);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> attribute = <span class="keyword">new</span> (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, <span class="number">1</span>);</span><br><span class="line">            attribute.version = version; <span class="comment">// Updating index buffer in VAO now. See WebGLBindingStates</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> previousAttribute = wireframeAttributes.get(geometry);</span><br><span class="line">            <span class="keyword">if</span> (previousAttribute) attributes.remove(previousAttribute); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            wireframeAttributes.set(geometry, attribute);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getWireframeAttribute</span>(<span class="params">geometry</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> currentAttribute = wireframeAttributes.get(geometry);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currentAttribute) &#123;</span><br><span class="line">                <span class="keyword">const</span> geometryIndex = geometry.index;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (geometryIndex !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// if the attribute is obsolete, create a new one</span></span><br><span class="line">                    <span class="keyword">if</span> (currentAttribute.version &lt; geometryIndex.version) &#123;</span><br><span class="line">                        updateWireframeAttribute(geometry);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                updateWireframeAttribute(geometry);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> wireframeAttributes.get(geometry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">get</span>: get,</span><br><span class="line">            <span class="attr">update</span>: update,</span><br><span class="line">            <span class="attr">getWireframeAttribute</span>: getWireframeAttribute</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLIndexedBufferRenderer</span>(<span class="params">gl, extensions, info, capabilities</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> isWebGL2 = capabilities.isWebGL2;</span><br><span class="line">        <span class="keyword">let</span> mode;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setMode</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">            mode = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> type, bytesPerElement;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setIndex</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">            type = value.type;</span><br><span class="line">            bytesPerElement = value.bytesPerElement;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">start, count</span>) </span>&#123;</span><br><span class="line">            gl.drawElements(mode, count, type, start * bytesPerElement);</span><br><span class="line">            info.update(count, mode, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">renderInstances</span>(<span class="params">start, count, primcount</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (primcount === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">let</span> extension, methodName;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isWebGL2) &#123;</span><br><span class="line">                extension = gl;</span><br><span class="line">                methodName = <span class="string">&#x27;drawElementsInstanced&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                extension = extensions.get(<span class="string">&#x27;ANGLE_instanced_arrays&#x27;</span>);</span><br><span class="line">                methodName = <span class="string">&#x27;drawElementsInstancedANGLE&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (extension === <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.&#x27;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            extension[methodName](mode, count, type, start * bytesPerElement, primcount);</span><br><span class="line">            info.update(count, mode, primcount);</span><br><span class="line">        &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setMode = setMode;</span><br><span class="line">        <span class="built_in">this</span>.setIndex = setIndex;</span><br><span class="line">        <span class="built_in">this</span>.render = render;</span><br><span class="line">        <span class="built_in">this</span>.renderInstances = renderInstances;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLInfo</span>(<span class="params">gl</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> memory = &#123;</span><br><span class="line">            <span class="attr">geometries</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">textures</span>: <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> render = &#123;</span><br><span class="line">            <span class="attr">frame</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">calls</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">triangles</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">points</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">lines</span>: <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">count, mode, instanceCount</span>) </span>&#123;</span><br><span class="line">            render.calls++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">                <span class="keyword">case</span> gl.TRIANGLES:</span><br><span class="line">                    render.triangles += instanceCount * (count / <span class="number">3</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> gl.LINES:</span><br><span class="line">                    render.lines += instanceCount * (count / <span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> gl.LINE_STRIP:</span><br><span class="line">                    render.lines += instanceCount * (count - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> gl.LINE_LOOP:</span><br><span class="line">                    render.lines += instanceCount * count;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> gl.POINTS:</span><br><span class="line">                    render.points += instanceCount * count;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLInfo: Unknown draw mode:&#x27;</span>, mode);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">reset</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            render.frame++;</span><br><span class="line">            render.calls = <span class="number">0</span>;</span><br><span class="line">            render.triangles = <span class="number">0</span>;</span><br><span class="line">            render.points = <span class="number">0</span>;</span><br><span class="line">            render.lines = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">memory</span>: memory,</span><br><span class="line">            <span class="attr">render</span>: render,</span><br><span class="line">            <span class="attr">programs</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">autoReset</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">reset</span>: reset,</span><br><span class="line">            <span class="attr">update</span>: update</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">numericalSort</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">absNumericalSort</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.abs(b[<span class="number">1</span>]) - <span class="built_in">Math</span>.abs(a[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">denormalize</span>(<span class="params">morph, attribute</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> denominator = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;</span><br><span class="line">        <span class="keyword">if</span> (array <span class="keyword">instanceof</span> <span class="built_in">Int8Array</span>) denominator = <span class="number">127</span>;<span class="keyword">else</span> <span class="keyword">if</span> (array <span class="keyword">instanceof</span> <span class="built_in">Int16Array</span>) denominator = <span class="number">32767</span>;<span class="keyword">else</span> <span class="keyword">if</span> (array <span class="keyword">instanceof</span> <span class="built_in">Int32Array</span>) denominator = <span class="number">2147483647</span>;<span class="keyword">else</span> <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLMorphtargets: Unsupported morph attribute data type: &#x27;</span>, array);</span><br><span class="line">        morph.divideScalar(denominator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLMorphtargets</span>(<span class="params">gl, capabilities, textures</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> influencesList = &#123;&#125;;</span><br><span class="line">        <span class="keyword">const</span> morphInfluences = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">const</span> morphTextures = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">        <span class="keyword">const</span> morph = <span class="keyword">new</span> Vector4();</span><br><span class="line">        <span class="keyword">const</span> workInfluences = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            workInfluences[i] = [i, <span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">object, geometry, material, program</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> objectInfluences = object.morphTargetInfluences;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (capabilities.isWebGL2 === <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// instead of using attributes, the WebGL 2 code path encodes morph targets</span></span><br><span class="line">                <span class="comment">// into an array of data textures. Each layer represents a single morph target.</span></span><br><span class="line">                <span class="keyword">const</span> morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;</span><br><span class="line">                <span class="keyword">const</span> morphTargetsCount = morphAttribute !== <span class="literal">undefined</span> ? morphAttribute.length : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">let</span> entry = morphTextures.get(geometry);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (entry === <span class="literal">undefined</span> || entry.count !== morphTargetsCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (entry !== <span class="literal">undefined</span>) entry.texture.dispose();</span><br><span class="line">                    <span class="keyword">const</span> hasMorphPosition = geometry.morphAttributes.position !== <span class="literal">undefined</span>;</span><br><span class="line">                    <span class="keyword">const</span> hasMorphNormals = geometry.morphAttributes.normal !== <span class="literal">undefined</span>;</span><br><span class="line">                    <span class="keyword">const</span> hasMorphColors = geometry.morphAttributes.color !== <span class="literal">undefined</span>;</span><br><span class="line">                    <span class="keyword">const</span> morphTargets = geometry.morphAttributes.position || [];</span><br><span class="line">                    <span class="keyword">const</span> morphNormals = geometry.morphAttributes.normal || [];</span><br><span class="line">                    <span class="keyword">const</span> morphColors = geometry.morphAttributes.color || [];</span><br><span class="line">                    <span class="keyword">let</span> vertexDataCount = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (hasMorphPosition === <span class="literal">true</span>) vertexDataCount = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (hasMorphNormals === <span class="literal">true</span>) vertexDataCount = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (hasMorphColors === <span class="literal">true</span>) vertexDataCount = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">let</span> width = geometry.attributes.position.count * vertexDataCount;</span><br><span class="line">                    <span class="keyword">let</span> height = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (width &gt; capabilities.maxTextureSize) &#123;</span><br><span class="line">                        height = <span class="built_in">Math</span>.ceil(width / capabilities.maxTextureSize);</span><br><span class="line">                        width = capabilities.maxTextureSize;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(width * height * <span class="number">4</span> * morphTargetsCount);</span><br><span class="line">                    <span class="keyword">const</span> texture = <span class="keyword">new</span> DataArrayTexture(buffer, width, height, morphTargetsCount);</span><br><span class="line">                    texture.type = FloatType;</span><br><span class="line">                    texture.needsUpdate = <span class="literal">true</span>; <span class="comment">// fill buffer</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> vertexDataStride = vertexDataCount * <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; morphTargetsCount; i++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> morphTarget = morphTargets[i];</span><br><span class="line">                        <span class="keyword">const</span> morphNormal = morphNormals[i];</span><br><span class="line">                        <span class="keyword">const</span> morphColor = morphColors[i];</span><br><span class="line">                        <span class="keyword">const</span> offset = width * height * <span class="number">4</span> * i;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; morphTarget.count; j++) &#123;</span><br><span class="line">                            <span class="keyword">const</span> stride = j * vertexDataStride;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (hasMorphPosition === <span class="literal">true</span>) &#123;</span><br><span class="line">                                morph.fromBufferAttribute(morphTarget, j);</span><br><span class="line">                                <span class="keyword">if</span> (morphTarget.normalized === <span class="literal">true</span>) denormalize(morph, morphTarget);</span><br><span class="line">                                buffer[offset + stride + <span class="number">0</span>] = morph.x;</span><br><span class="line">                                buffer[offset + stride + <span class="number">1</span>] = morph.y;</span><br><span class="line">                                buffer[offset + stride + <span class="number">2</span>] = morph.z;</span><br><span class="line">                                buffer[offset + stride + <span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (hasMorphNormals === <span class="literal">true</span>) &#123;</span><br><span class="line">                                morph.fromBufferAttribute(morphNormal, j);</span><br><span class="line">                                <span class="keyword">if</span> (morphNormal.normalized === <span class="literal">true</span>) denormalize(morph, morphNormal);</span><br><span class="line">                                buffer[offset + stride + <span class="number">4</span>] = morph.x;</span><br><span class="line">                                buffer[offset + stride + <span class="number">5</span>] = morph.y;</span><br><span class="line">                                buffer[offset + stride + <span class="number">6</span>] = morph.z;</span><br><span class="line">                                buffer[offset + stride + <span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (hasMorphColors === <span class="literal">true</span>) &#123;</span><br><span class="line">                                morph.fromBufferAttribute(morphColor, j);</span><br><span class="line">                                <span class="keyword">if</span> (morphColor.normalized === <span class="literal">true</span>) denormalize(morph, morphColor);</span><br><span class="line">                                buffer[offset + stride + <span class="number">8</span>] = morph.x;</span><br><span class="line">                                buffer[offset + stride + <span class="number">9</span>] = morph.y;</span><br><span class="line">                                buffer[offset + stride + <span class="number">10</span>] = morph.z;</span><br><span class="line">                                buffer[offset + stride + <span class="number">11</span>] = morphColor.itemSize === <span class="number">4</span> ? morph.w : <span class="number">1</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    entry = &#123;</span><br><span class="line">                        <span class="attr">count</span>: morphTargetsCount,</span><br><span class="line">                        <span class="attr">texture</span>: texture,</span><br><span class="line">                        <span class="attr">size</span>: <span class="keyword">new</span> Vector2(width, height)</span><br><span class="line">                    &#125;;</span><br><span class="line">                    morphTextures.set(geometry, entry);</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">function</span> <span class="title">disposeTexture</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                        texture.dispose();</span><br><span class="line">                        morphTextures.delete(geometry);</span><br><span class="line">                        geometry.removeEventListener(<span class="string">&#x27;dispose&#x27;</span>, disposeTexture);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    geometry.addEventListener(<span class="string">&#x27;dispose&#x27;</span>, disposeTexture);</span><br><span class="line">                &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> morphInfluencesSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; objectInfluences.length; i++) &#123;</span><br><span class="line">                    morphInfluencesSum += objectInfluences[i];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> morphBaseInfluence = geometry.morphTargetsRelative ? <span class="number">1</span> : <span class="number">1</span> - morphInfluencesSum;</span><br><span class="line">                program.getUniforms().setValue(gl, <span class="string">&#x27;morphTargetBaseInfluence&#x27;</span>, morphBaseInfluence);</span><br><span class="line">                program.getUniforms().setValue(gl, <span class="string">&#x27;morphTargetInfluences&#x27;</span>, objectInfluences);</span><br><span class="line">                program.getUniforms().setValue(gl, <span class="string">&#x27;morphTargetsTexture&#x27;</span>, entry.texture, textures);</span><br><span class="line">                program.getUniforms().setValue(gl, <span class="string">&#x27;morphTargetsTextureSize&#x27;</span>, entry.size);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// When object doesn&#x27;t have morph target influences defined, we treat it as a 0-length array</span></span><br><span class="line">                <span class="comment">// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences</span></span><br><span class="line">                <span class="keyword">const</span> length = objectInfluences === <span class="literal">undefined</span> ? <span class="number">0</span> : objectInfluences.length;</span><br><span class="line">                <span class="keyword">let</span> influences = influencesList[geometry.id];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (influences === <span class="literal">undefined</span> || influences.length !== length) &#123;</span><br><span class="line">                    <span class="comment">// initialise list</span></span><br><span class="line">                    influences = [];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                        influences[i] = [i, <span class="number">0</span>];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    influencesList[geometry.id] = influences;</span><br><span class="line">                &#125; <span class="comment">// Collect influences</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> influence = influences[i];</span><br><span class="line">                    influence[<span class="number">0</span>] = i;</span><br><span class="line">                    influence[<span class="number">1</span>] = objectInfluences[i];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                influences.sort(absNumericalSort);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; length &amp;&amp; influences[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                        workInfluences[i][<span class="number">0</span>] = influences[i][<span class="number">0</span>];</span><br><span class="line">                        workInfluences[i][<span class="number">1</span>] = influences[i][<span class="number">1</span>];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        workInfluences[i][<span class="number">0</span>] = <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line">                        workInfluences[i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                workInfluences.sort(numericalSort);</span><br><span class="line">                <span class="keyword">const</span> morphTargets = geometry.morphAttributes.position;</span><br><span class="line">                <span class="keyword">const</span> morphNormals = geometry.morphAttributes.normal;</span><br><span class="line">                <span class="keyword">let</span> morphInfluencesSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> influence = workInfluences[i];</span><br><span class="line">                    <span class="keyword">const</span> index = influence[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">const</span> value = influence[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (index !== <span class="built_in">Number</span>.MAX_SAFE_INTEGER &amp;&amp; value) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (morphTargets &amp;&amp; geometry.getAttribute(<span class="string">&#x27;morphTarget&#x27;</span> + i) !== morphTargets[index]) &#123;</span><br><span class="line">                            geometry.setAttribute(<span class="string">&#x27;morphTarget&#x27;</span> + i, morphTargets[index]);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (morphNormals &amp;&amp; geometry.getAttribute(<span class="string">&#x27;morphNormal&#x27;</span> + i) !== morphNormals[index]) &#123;</span><br><span class="line">                            geometry.setAttribute(<span class="string">&#x27;morphNormal&#x27;</span> + i, morphNormals[index]);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        morphInfluences[i] = value;</span><br><span class="line">                        morphInfluencesSum += value;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (morphTargets &amp;&amp; geometry.hasAttribute(<span class="string">&#x27;morphTarget&#x27;</span> + i) === <span class="literal">true</span>) &#123;</span><br><span class="line">                            geometry.deleteAttribute(<span class="string">&#x27;morphTarget&#x27;</span> + i);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (morphNormals &amp;&amp; geometry.hasAttribute(<span class="string">&#x27;morphNormal&#x27;</span> + i) === <span class="literal">true</span>) &#123;</span><br><span class="line">                            geometry.deleteAttribute(<span class="string">&#x27;morphNormal&#x27;</span> + i);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        morphInfluences[i] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="comment">// GLSL shader uses formula baseinfluence * base + sum(target * influence)</span></span><br><span class="line">                <span class="comment">// This allows us to switch between absolute morphs and relative morphs without changing shader code</span></span><br><span class="line">                <span class="comment">// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> morphBaseInfluence = geometry.morphTargetsRelative ? <span class="number">1</span> : <span class="number">1</span> - morphInfluencesSum;</span><br><span class="line">                program.getUniforms().setValue(gl, <span class="string">&#x27;morphTargetBaseInfluence&#x27;</span>, morphBaseInfluence);</span><br><span class="line">                program.getUniforms().setValue(gl, <span class="string">&#x27;morphTargetInfluences&#x27;</span>, morphInfluences);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">update</span>: update</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLObjects</span>(<span class="params">gl, geometries, attributes, info</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> updateMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> frame = info.render.frame;</span><br><span class="line">            <span class="keyword">const</span> geometry = object.geometry;</span><br><span class="line">            <span class="keyword">const</span> buffergeometry = geometries.get(object, geometry); <span class="comment">// Update once per frame</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (updateMap.get(buffergeometry) !== frame) &#123;</span><br><span class="line">                geometries.update(buffergeometry);</span><br><span class="line">                updateMap.set(buffergeometry, frame);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (object.isInstancedMesh) &#123;</span><br><span class="line">                <span class="keyword">if</span> (object.hasEventListener(<span class="string">&#x27;dispose&#x27;</span>, onInstancedMeshDispose) === <span class="literal">false</span>) &#123;</span><br><span class="line">                    object.addEventListener(<span class="string">&#x27;dispose&#x27;</span>, onInstancedMeshDispose);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (object.instanceColor !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    attributes.update(object.instanceColor, gl.ARRAY_BUFFER);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> buffergeometry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">dispose</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            updateMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">onInstancedMeshDispose</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> instancedMesh = event.target;</span><br><span class="line">            instancedMesh.removeEventListener(<span class="string">&#x27;dispose&#x27;</span>, onInstancedMeshDispose);</span><br><span class="line">            attributes.remove(instancedMesh.instanceMatrix);</span><br><span class="line">            <span class="keyword">if</span> (instancedMesh.instanceColor !== <span class="literal">null</span>) attributes.remove(instancedMesh.instanceColor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">update</span>: update,</span><br><span class="line">            <span class="attr">dispose</span>: dispose</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Uniforms of a program.</span></span><br><span class="line"><span class="comment">     * Those form a tree structure with a special top-level container for the root,</span></span><br><span class="line"><span class="comment">     * which you get by calling &#x27;new WebGLUniforms( gl, program )&#x27;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Properties of inner nodes including the top-level container:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * .seq - array of nested uniforms</span></span><br><span class="line"><span class="comment">     * .map - nested uniforms by name</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Methods of all nodes except the top-level container:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * .setValue( gl, value, [textures] )</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 		uploads a uniform value(s)</span></span><br><span class="line"><span class="comment">     *		the &#x27;textures&#x27; parameter is needed for sampler uniforms</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Static methods of the top-level container (textures factorizations):</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * .upload( gl, seq, values, textures )</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 		sets uniforms in &#x27;seq&#x27; to &#x27;values[id].value&#x27;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * .seqWithValue( seq, values ) : filteredSeq</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 		filters &#x27;seq&#x27; entries with corresponding entry in values</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Methods of the top-level container (textures factorizations):</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * .setValue( gl, name, value, textures )</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 		sets uniform with	name &#x27;name&#x27; to &#x27;value&#x27;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * .setOptional( gl, obj, prop )</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 		like .set for an optional property of the object</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> emptyTexture = <span class="keyword">new</span> Texture();</span><br><span class="line">    <span class="keyword">const</span> emptyArrayTexture = <span class="keyword">new</span> DataArrayTexture();</span><br><span class="line">    <span class="keyword">const</span> empty3dTexture = <span class="keyword">new</span> Data3DTexture();</span><br><span class="line">    <span class="keyword">const</span> emptyCubeTexture = <span class="keyword">new</span> CubeTexture(); <span class="comment">// --- Utilities ---</span></span><br><span class="line">    <span class="comment">// Array Caches (provide typed arrays for temporary by size)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> arrayCacheF32 = [];</span><br><span class="line">    <span class="keyword">const</span> arrayCacheI32 = []; <span class="comment">// Float32Array caches used for uploading Matrix uniforms</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> mat4array = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">const</span> mat3array = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">const</span> mat2array = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(<span class="number">4</span>); <span class="comment">// Flattening for arrays of vectors and matrices</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">array, nBlocks, blockSize</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> firstElem = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (firstElem &lt;= <span class="number">0</span> || firstElem &gt; <span class="number">0</span>) <span class="keyword">return</span> array; <span class="comment">// unoptimized: ! isNaN( firstElem )</span></span><br><span class="line">        <span class="comment">// see http://jacksondunstan.com/articles/983</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> n = nBlocks * blockSize;</span><br><span class="line">        <span class="keyword">let</span> r = arrayCacheF32[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            r = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(n);</span><br><span class="line">            arrayCacheF32[n] = r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nBlocks !== <span class="number">0</span>) &#123;</span><br><span class="line">            firstElem.toArray(r, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, offset = <span class="number">0</span>; i !== nBlocks; ++i) &#123;</span><br><span class="line">                offset += blockSize;</span><br><span class="line">                array[i].toArray(r, offset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">arraysEqual</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length !== b.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = a.length; i &lt; l; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] !== b[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">copyArray</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = b.length; i &lt; l; i++) &#123;</span><br><span class="line">            a[i] = b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// Texture unit allocation</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">allocTexUnits</span>(<span class="params">textures, n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> r = arrayCacheI32[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            r = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(n);</span><br><span class="line">            arrayCacheI32[n] = r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i !== n; ++i) &#123;</span><br><span class="line">            r[i] = textures.allocateTextureUnit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125; <span class="comment">// --- Setters ---</span></span><br><span class="line">    <span class="comment">// Note: Defining these methods externally, because they come in a bunch</span></span><br><span class="line">    <span class="comment">// and this way their names minify.</span></span><br><span class="line">    <span class="comment">// Single scalar</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueV1f</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="built_in">this</span>.cache;</span><br><span class="line">        <span class="keyword">if</span> (cache[<span class="number">0</span>] === v) <span class="keyword">return</span>;</span><br><span class="line">        gl.uniform1f(<span class="built_in">this</span>.addr, v);</span><br><span class="line">        cache[<span class="number">0</span>] = v;</span><br><span class="line">    &#125; <span class="comment">// Single float vector (from flat array or THREE.VectorN)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueV2f</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="built_in">this</span>.cache;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (v.x !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cache[<span class="number">0</span>] !== v.x || cache[<span class="number">1</span>] !== v.y) &#123;</span><br><span class="line">                gl.uniform2f(<span class="built_in">this</span>.addr, v.x, v.y);</span><br><span class="line">                cache[<span class="number">0</span>] = v.x;</span><br><span class="line">                cache[<span class="number">1</span>] = v.y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (arraysEqual(cache, v)) <span class="keyword">return</span>;</span><br><span class="line">            gl.uniform2fv(<span class="built_in">this</span>.addr, v);</span><br><span class="line">            copyArray(cache, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueV3f</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="built_in">this</span>.cache;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (v.x !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cache[<span class="number">0</span>] !== v.x || cache[<span class="number">1</span>] !== v.y || cache[<span class="number">2</span>] !== v.z) &#123;</span><br><span class="line">                gl.uniform3f(<span class="built_in">this</span>.addr, v.x, v.y, v.z);</span><br><span class="line">                cache[<span class="number">0</span>] = v.x;</span><br><span class="line">                cache[<span class="number">1</span>] = v.y;</span><br><span class="line">                cache[<span class="number">2</span>] = v.z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.r !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cache[<span class="number">0</span>] !== v.r || cache[<span class="number">1</span>] !== v.g || cache[<span class="number">2</span>] !== v.b) &#123;</span><br><span class="line">                gl.uniform3f(<span class="built_in">this</span>.addr, v.r, v.g, v.b);</span><br><span class="line">                cache[<span class="number">0</span>] = v.r;</span><br><span class="line">                cache[<span class="number">1</span>] = v.g;</span><br><span class="line">                cache[<span class="number">2</span>] = v.b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (arraysEqual(cache, v)) <span class="keyword">return</span>;</span><br><span class="line">            gl.uniform3fv(<span class="built_in">this</span>.addr, v);</span><br><span class="line">            copyArray(cache, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueV4f</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="built_in">this</span>.cache;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (v.x !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cache[<span class="number">0</span>] !== v.x || cache[<span class="number">1</span>] !== v.y || cache[<span class="number">2</span>] !== v.z || cache[<span class="number">3</span>] !== v.w) &#123;</span><br><span class="line">                gl.uniform4f(<span class="built_in">this</span>.addr, v.x, v.y, v.z, v.w);</span><br><span class="line">                cache[<span class="number">0</span>] = v.x;</span><br><span class="line">                cache[<span class="number">1</span>] = v.y;</span><br><span class="line">                cache[<span class="number">2</span>] = v.z;</span><br><span class="line">                cache[<span class="number">3</span>] = v.w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (arraysEqual(cache, v)) <span class="keyword">return</span>;</span><br><span class="line">            gl.uniform4fv(<span class="built_in">this</span>.addr, v);</span><br><span class="line">            copyArray(cache, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// Single matrix (from flat array or THREE.MatrixN)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueM2</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="built_in">this</span>.cache;</span><br><span class="line">        <span class="keyword">const</span> elements = v.elements;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (elements === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arraysEqual(cache, v)) <span class="keyword">return</span>;</span><br><span class="line">            gl.uniformMatrix2fv(<span class="built_in">this</span>.addr, <span class="literal">false</span>, v);</span><br><span class="line">            copyArray(cache, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (arraysEqual(cache, elements)) <span class="keyword">return</span>;</span><br><span class="line">            mat2array.set(elements);</span><br><span class="line">            gl.uniformMatrix2fv(<span class="built_in">this</span>.addr, <span class="literal">false</span>, mat2array);</span><br><span class="line">            copyArray(cache, elements);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueM3</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="built_in">this</span>.cache;</span><br><span class="line">        <span class="keyword">const</span> elements = v.elements;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (elements === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arraysEqual(cache, v)) <span class="keyword">return</span>;</span><br><span class="line">            gl.uniformMatrix3fv(<span class="built_in">this</span>.addr, <span class="literal">false</span>, v);</span><br><span class="line">            copyArray(cache, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (arraysEqual(cache, elements)) <span class="keyword">return</span>;</span><br><span class="line">            mat3array.set(elements);</span><br><span class="line">            gl.uniformMatrix3fv(<span class="built_in">this</span>.addr, <span class="literal">false</span>, mat3array);</span><br><span class="line">            copyArray(cache, elements);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueM4</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="built_in">this</span>.cache;</span><br><span class="line">        <span class="keyword">const</span> elements = v.elements;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (elements === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arraysEqual(cache, v)) <span class="keyword">return</span>;</span><br><span class="line">            gl.uniformMatrix4fv(<span class="built_in">this</span>.addr, <span class="literal">false</span>, v);</span><br><span class="line">            copyArray(cache, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (arraysEqual(cache, elements)) <span class="keyword">return</span>;</span><br><span class="line">            mat4array.set(elements);</span><br><span class="line">            gl.uniformMatrix4fv(<span class="built_in">this</span>.addr, <span class="literal">false</span>, mat4array);</span><br><span class="line">            copyArray(cache, elements);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// Single integer / boolean</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueV1i</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="built_in">this</span>.cache;</span><br><span class="line">        <span class="keyword">if</span> (cache[<span class="number">0</span>] === v) <span class="keyword">return</span>;</span><br><span class="line">        gl.uniform1i(<span class="built_in">this</span>.addr, v);</span><br><span class="line">        cache[<span class="number">0</span>] = v;</span><br><span class="line">    &#125; <span class="comment">// Single integer / boolean vector (from flat array)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueV2i</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="built_in">this</span>.cache;</span><br><span class="line">        <span class="keyword">if</span> (arraysEqual(cache, v)) <span class="keyword">return</span>;</span><br><span class="line">        gl.uniform2iv(<span class="built_in">this</span>.addr, v);</span><br><span class="line">        copyArray(cache, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueV3i</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="built_in">this</span>.cache;</span><br><span class="line">        <span class="keyword">if</span> (arraysEqual(cache, v)) <span class="keyword">return</span>;</span><br><span class="line">        gl.uniform3iv(<span class="built_in">this</span>.addr, v);</span><br><span class="line">        copyArray(cache, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueV4i</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="built_in">this</span>.cache;</span><br><span class="line">        <span class="keyword">if</span> (arraysEqual(cache, v)) <span class="keyword">return</span>;</span><br><span class="line">        gl.uniform4iv(<span class="built_in">this</span>.addr, v);</span><br><span class="line">        copyArray(cache, v);</span><br><span class="line">    &#125; <span class="comment">// Single unsigned integer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueV1ui</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="built_in">this</span>.cache;</span><br><span class="line">        <span class="keyword">if</span> (cache[<span class="number">0</span>] === v) <span class="keyword">return</span>;</span><br><span class="line">        gl.uniform1ui(<span class="built_in">this</span>.addr, v);</span><br><span class="line">        cache[<span class="number">0</span>] = v;</span><br><span class="line">    &#125; <span class="comment">// Single unsigned integer vector (from flat array)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueV2ui</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="built_in">this</span>.cache;</span><br><span class="line">        <span class="keyword">if</span> (arraysEqual(cache, v)) <span class="keyword">return</span>;</span><br><span class="line">        gl.uniform2uiv(<span class="built_in">this</span>.addr, v);</span><br><span class="line">        copyArray(cache, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueV3ui</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="built_in">this</span>.cache;</span><br><span class="line">        <span class="keyword">if</span> (arraysEqual(cache, v)) <span class="keyword">return</span>;</span><br><span class="line">        gl.uniform3uiv(<span class="built_in">this</span>.addr, v);</span><br><span class="line">        copyArray(cache, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueV4ui</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="built_in">this</span>.cache;</span><br><span class="line">        <span class="keyword">if</span> (arraysEqual(cache, v)) <span class="keyword">return</span>;</span><br><span class="line">        gl.uniform4uiv(<span class="built_in">this</span>.addr, v);</span><br><span class="line">        copyArray(cache, v);</span><br><span class="line">    &#125; <span class="comment">// Single texture (2D / Cube)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueT1</span>(<span class="params">gl, v, textures</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="built_in">this</span>.cache;</span><br><span class="line">        <span class="keyword">const</span> unit = textures.allocateTextureUnit();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cache[<span class="number">0</span>] !== unit) &#123;</span><br><span class="line">            gl.uniform1i(<span class="built_in">this</span>.addr, unit);</span><br><span class="line">            cache[<span class="number">0</span>] = unit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        textures.setTexture2D(v || emptyTexture, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueT3D1</span>(<span class="params">gl, v, textures</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="built_in">this</span>.cache;</span><br><span class="line">        <span class="keyword">const</span> unit = textures.allocateTextureUnit();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cache[<span class="number">0</span>] !== unit) &#123;</span><br><span class="line">            gl.uniform1i(<span class="built_in">this</span>.addr, unit);</span><br><span class="line">            cache[<span class="number">0</span>] = unit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        textures.setTexture3D(v || empty3dTexture, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueT6</span>(<span class="params">gl, v, textures</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="built_in">this</span>.cache;</span><br><span class="line">        <span class="keyword">const</span> unit = textures.allocateTextureUnit();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cache[<span class="number">0</span>] !== unit) &#123;</span><br><span class="line">            gl.uniform1i(<span class="built_in">this</span>.addr, unit);</span><br><span class="line">            cache[<span class="number">0</span>] = unit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        textures.setTextureCube(v || emptyCubeTexture, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueT2DArray1</span>(<span class="params">gl, v, textures</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="built_in">this</span>.cache;</span><br><span class="line">        <span class="keyword">const</span> unit = textures.allocateTextureUnit();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cache[<span class="number">0</span>] !== unit) &#123;</span><br><span class="line">            gl.uniform1i(<span class="built_in">this</span>.addr, unit);</span><br><span class="line">            cache[<span class="number">0</span>] = unit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        textures.setTexture2DArray(v || emptyArrayTexture, unit);</span><br><span class="line">    &#125; <span class="comment">// Helper to pick the right setter for the singular case</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getSingularSetter</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x1406</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueV1f;</span><br><span class="line">            <span class="comment">// FLOAT</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b50</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueV2f;</span><br><span class="line">            <span class="comment">// _VEC2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b51</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueV3f;</span><br><span class="line">            <span class="comment">// _VEC3</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b52</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueV4f;</span><br><span class="line">            <span class="comment">// _VEC4</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b5a</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueM2;</span><br><span class="line">            <span class="comment">// _MAT2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b5b</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueM3;</span><br><span class="line">            <span class="comment">// _MAT3</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b5c</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueM4;</span><br><span class="line">            <span class="comment">// _MAT4</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x1404</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b56</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueV1i;</span><br><span class="line">            <span class="comment">// INT, BOOL</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b53</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b57</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueV2i;</span><br><span class="line">            <span class="comment">// _VEC2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b54</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b58</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueV3i;</span><br><span class="line">            <span class="comment">// _VEC3</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b55</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b59</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueV4i;</span><br><span class="line">            <span class="comment">// _VEC4</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x1405</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueV1ui;</span><br><span class="line">            <span class="comment">// UINT</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dc6</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueV2ui;</span><br><span class="line">            <span class="comment">// _VEC2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dc7</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueV3ui;</span><br><span class="line">            <span class="comment">// _VEC3</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dc8</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueV4ui;</span><br><span class="line">            <span class="comment">// _VEC4</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b5e</span>: <span class="comment">// SAMPLER_2D</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8d66</span>: <span class="comment">// SAMPLER_EXTERNAL_OES</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dca</span>: <span class="comment">// INT_SAMPLER_2D</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dd2</span>: <span class="comment">// UNSIGNED_INT_SAMPLER_2D</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b62</span>:</span><br><span class="line">                <span class="comment">// SAMPLER_2D_SHADOW</span></span><br><span class="line">                <span class="keyword">return</span> setValueT1;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b5f</span>: <span class="comment">// SAMPLER_3D</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dcb</span>: <span class="comment">// INT_SAMPLER_3D</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dd3</span>:</span><br><span class="line">                <span class="comment">// UNSIGNED_INT_SAMPLER_3D</span></span><br><span class="line">                <span class="keyword">return</span> setValueT3D1;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b60</span>: <span class="comment">// SAMPLER_CUBE</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dcc</span>: <span class="comment">// INT_SAMPLER_CUBE</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dd4</span>: <span class="comment">// UNSIGNED_INT_SAMPLER_CUBE</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dc5</span>:</span><br><span class="line">                <span class="comment">// SAMPLER_CUBE_SHADOW</span></span><br><span class="line">                <span class="keyword">return</span> setValueT6;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dc1</span>: <span class="comment">// SAMPLER_2D_ARRAY</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dcf</span>: <span class="comment">// INT_SAMPLER_2D_ARRAY</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dd7</span>: <span class="comment">// UNSIGNED_INT_SAMPLER_2D_ARRAY</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dc4</span>:</span><br><span class="line">                <span class="comment">// SAMPLER_2D_ARRAY_SHADOW</span></span><br><span class="line">                <span class="keyword">return</span> setValueT2DArray1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// Array of scalars</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueV1fArray</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        gl.uniform1fv(<span class="built_in">this</span>.addr, v);</span><br><span class="line">    &#125; <span class="comment">// Array of vectors (from flat array or array of THREE.VectorN)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueV2fArray</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> data = flatten(v, <span class="built_in">this</span>.size, <span class="number">2</span>);</span><br><span class="line">        gl.uniform2fv(<span class="built_in">this</span>.addr, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueV3fArray</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> data = flatten(v, <span class="built_in">this</span>.size, <span class="number">3</span>);</span><br><span class="line">        gl.uniform3fv(<span class="built_in">this</span>.addr, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueV4fArray</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> data = flatten(v, <span class="built_in">this</span>.size, <span class="number">4</span>);</span><br><span class="line">        gl.uniform4fv(<span class="built_in">this</span>.addr, data);</span><br><span class="line">    &#125; <span class="comment">// Array of matrices (from flat array or array of THREE.MatrixN)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueM2Array</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> data = flatten(v, <span class="built_in">this</span>.size, <span class="number">4</span>);</span><br><span class="line">        gl.uniformMatrix2fv(<span class="built_in">this</span>.addr, <span class="literal">false</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueM3Array</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> data = flatten(v, <span class="built_in">this</span>.size, <span class="number">9</span>);</span><br><span class="line">        gl.uniformMatrix3fv(<span class="built_in">this</span>.addr, <span class="literal">false</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueM4Array</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> data = flatten(v, <span class="built_in">this</span>.size, <span class="number">16</span>);</span><br><span class="line">        gl.uniformMatrix4fv(<span class="built_in">this</span>.addr, <span class="literal">false</span>, data);</span><br><span class="line">    &#125; <span class="comment">// Array of integer / boolean</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueV1iArray</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        gl.uniform1iv(<span class="built_in">this</span>.addr, v);</span><br><span class="line">    &#125; <span class="comment">// Array of integer / boolean vectors (from flat array)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueV2iArray</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        gl.uniform2iv(<span class="built_in">this</span>.addr, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueV3iArray</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        gl.uniform3iv(<span class="built_in">this</span>.addr, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueV4iArray</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        gl.uniform4iv(<span class="built_in">this</span>.addr, v);</span><br><span class="line">    &#125; <span class="comment">// Array of unsigned integer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueV1uiArray</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        gl.uniform1uiv(<span class="built_in">this</span>.addr, v);</span><br><span class="line">    &#125; <span class="comment">// Array of unsigned integer vectors (from flat array)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueV2uiArray</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        gl.uniform2uiv(<span class="built_in">this</span>.addr, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueV3uiArray</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        gl.uniform3uiv(<span class="built_in">this</span>.addr, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueV4uiArray</span>(<span class="params">gl, v</span>) </span>&#123;</span><br><span class="line">        gl.uniform4uiv(<span class="built_in">this</span>.addr, v);</span><br><span class="line">    &#125; <span class="comment">// Array of textures (2D / 3D / Cube / 2DArray)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueT1Array</span>(<span class="params">gl, v, textures</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> n = v.length;</span><br><span class="line">        <span class="keyword">const</span> units = allocTexUnits(textures, n);</span><br><span class="line">        gl.uniform1iv(<span class="built_in">this</span>.addr, units);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i !== n; ++i) &#123;</span><br><span class="line">            textures.setTexture2D(v[i] || emptyTexture, units[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueT3DArray</span>(<span class="params">gl, v, textures</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> n = v.length;</span><br><span class="line">        <span class="keyword">const</span> units = allocTexUnits(textures, n);</span><br><span class="line">        gl.uniform1iv(<span class="built_in">this</span>.addr, units);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i !== n; ++i) &#123;</span><br><span class="line">            textures.setTexture3D(v[i] || empty3dTexture, units[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueT6Array</span>(<span class="params">gl, v, textures</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> n = v.length;</span><br><span class="line">        <span class="keyword">const</span> units = allocTexUnits(textures, n);</span><br><span class="line">        gl.uniform1iv(<span class="built_in">this</span>.addr, units);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i !== n; ++i) &#123;</span><br><span class="line">            textures.setTextureCube(v[i] || emptyCubeTexture, units[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setValueT2DArrayArray</span>(<span class="params">gl, v, textures</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> n = v.length;</span><br><span class="line">        <span class="keyword">const</span> units = allocTexUnits(textures, n);</span><br><span class="line">        gl.uniform1iv(<span class="built_in">this</span>.addr, units);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i !== n; ++i) &#123;</span><br><span class="line">            textures.setTexture2DArray(v[i] || emptyArrayTexture, units[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// Helper to pick the right setter for a pure (bottom-level) array</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getPureArraySetter</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x1406</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueV1fArray;</span><br><span class="line">            <span class="comment">// FLOAT</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b50</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueV2fArray;</span><br><span class="line">            <span class="comment">// _VEC2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b51</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueV3fArray;</span><br><span class="line">            <span class="comment">// _VEC3</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b52</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueV4fArray;</span><br><span class="line">            <span class="comment">// _VEC4</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b5a</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueM2Array;</span><br><span class="line">            <span class="comment">// _MAT2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b5b</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueM3Array;</span><br><span class="line">            <span class="comment">// _MAT3</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b5c</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueM4Array;</span><br><span class="line">            <span class="comment">// _MAT4</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x1404</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b56</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueV1iArray;</span><br><span class="line">            <span class="comment">// INT, BOOL</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b53</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b57</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueV2iArray;</span><br><span class="line">            <span class="comment">// _VEC2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b54</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b58</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueV3iArray;</span><br><span class="line">            <span class="comment">// _VEC3</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b55</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b59</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueV4iArray;</span><br><span class="line">            <span class="comment">// _VEC4</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x1405</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueV1uiArray;</span><br><span class="line">            <span class="comment">// UINT</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dc6</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueV2uiArray;</span><br><span class="line">            <span class="comment">// _VEC2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dc7</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueV3uiArray;</span><br><span class="line">            <span class="comment">// _VEC3</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dc8</span>:</span><br><span class="line">                <span class="keyword">return</span> setValueV4uiArray;</span><br><span class="line">            <span class="comment">// _VEC4</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b5e</span>: <span class="comment">// SAMPLER_2D</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8d66</span>: <span class="comment">// SAMPLER_EXTERNAL_OES</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dca</span>: <span class="comment">// INT_SAMPLER_2D</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dd2</span>: <span class="comment">// UNSIGNED_INT_SAMPLER_2D</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b62</span>:</span><br><span class="line">                <span class="comment">// SAMPLER_2D_SHADOW</span></span><br><span class="line">                <span class="keyword">return</span> setValueT1Array;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b5f</span>: <span class="comment">// SAMPLER_3D</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dcb</span>: <span class="comment">// INT_SAMPLER_3D</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dd3</span>:</span><br><span class="line">                <span class="comment">// UNSIGNED_INT_SAMPLER_3D</span></span><br><span class="line">                <span class="keyword">return</span> setValueT3DArray;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8b60</span>: <span class="comment">// SAMPLER_CUBE</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dcc</span>: <span class="comment">// INT_SAMPLER_CUBE</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dd4</span>: <span class="comment">// UNSIGNED_INT_SAMPLER_CUBE</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dc5</span>:</span><br><span class="line">                <span class="comment">// SAMPLER_CUBE_SHADOW</span></span><br><span class="line">                <span class="keyword">return</span> setValueT6Array;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dc1</span>: <span class="comment">// SAMPLER_2D_ARRAY</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dcf</span>: <span class="comment">// INT_SAMPLER_2D_ARRAY</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dd7</span>: <span class="comment">// UNSIGNED_INT_SAMPLER_2D_ARRAY</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x8dc4</span>:</span><br><span class="line">                <span class="comment">// SAMPLER_2D_ARRAY_SHADOW</span></span><br><span class="line">                <span class="keyword">return</span> setValueT2DArrayArray;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// --- Uniform Classes ---</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">SingleUniform</span>(<span class="params">id, activeInfo, addr</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.addr = addr;</span><br><span class="line">        <span class="built_in">this</span>.cache = [];</span><br><span class="line">        <span class="built_in">this</span>.setValue = getSingularSetter(activeInfo.type); <span class="comment">// this.path = activeInfo.name; // DEBUG</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">PureArrayUniform</span>(<span class="params">id, activeInfo, addr</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.addr = addr;</span><br><span class="line">        <span class="built_in">this</span>.cache = [];</span><br><span class="line">        <span class="built_in">this</span>.size = activeInfo.size;</span><br><span class="line">        <span class="built_in">this</span>.setValue = getPureArraySetter(activeInfo.type); <span class="comment">// this.path = activeInfo.name; // DEBUG</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PureArrayUniform.prototype.updateCache = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="built_in">this</span>.cache;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data <span class="keyword">instanceof</span> <span class="built_in">Float32Array</span> &amp;&amp; cache.length !== data.length) &#123;</span><br><span class="line">            <span class="built_in">this</span>.cache = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(data.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        copyArray(cache, data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">StructuredUniform</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.seq = [];</span><br><span class="line">        <span class="built_in">this</span>.map = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StructuredUniform.prototype.setValue = <span class="function"><span class="keyword">function</span> (<span class="params">gl, value, textures</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> seq = <span class="built_in">this</span>.seq;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = seq.length; i !== n; ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> u = seq[i];</span><br><span class="line">            u.setValue(gl, value[u.id], textures);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;; <span class="comment">// --- Top-level ---</span></span><br><span class="line">    <span class="comment">// Parser - builds up the property tree from the path strings</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> RePathPart = <span class="regexp">/(\w+)(\])?(\[|\.)?/g</span>; <span class="comment">// extracts</span></span><br><span class="line">    <span class="comment">// 	- the identifier (member name or array index)</span></span><br><span class="line">    <span class="comment">//	- followed by an optional right bracket (found when array index)</span></span><br><span class="line">    <span class="comment">//	- followed by an optional left bracket or dot (type of subscript)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Note: These portions can be read in a non-overlapping fashion and</span></span><br><span class="line">    <span class="comment">// allow straightforward parsing of the hierarchy that WebGL encodes</span></span><br><span class="line">    <span class="comment">// in the uniform names.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addUniform</span>(<span class="params">container, uniformObject</span>) </span>&#123;</span><br><span class="line">        container.seq.push(uniformObject);</span><br><span class="line">        container.map[uniformObject.id] = uniformObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">parseUniform</span>(<span class="params">activeInfo, addr, container</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> path = activeInfo.name,</span><br><span class="line">            pathLength = path.length; <span class="comment">// reset RegExp object, because of the early exit of a previous run</span></span><br><span class="line"></span><br><span class="line">        RePathPart.lastIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> match = RePathPart.exec(path),</span><br><span class="line">                matchEnd = RePathPart.lastIndex;</span><br><span class="line">            <span class="keyword">let</span> id = match[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">const</span> idIsIndex = match[<span class="number">2</span>] === <span class="string">&#x27;]&#x27;</span>,</span><br><span class="line">                subscript = match[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span> (idIsIndex) id = id | <span class="number">0</span>; <span class="comment">// convert to integer</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (subscript === <span class="literal">undefined</span> || subscript === <span class="string">&#x27;[&#x27;</span> &amp;&amp; matchEnd + <span class="number">2</span> === pathLength) &#123;</span><br><span class="line">                <span class="comment">// bare name or &quot;pure&quot; bottom-level array &quot;[0]&quot; suffix</span></span><br><span class="line">                addUniform(container, subscript === <span class="literal">undefined</span> ? <span class="keyword">new</span> SingleUniform(id, activeInfo, addr) : <span class="keyword">new</span> PureArrayUniform(id, activeInfo, addr));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// step into inner node / create it in case it doesn&#x27;t exist</span></span><br><span class="line">                <span class="keyword">const</span> map = container.map;</span><br><span class="line">                <span class="keyword">let</span> next = map[id];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (next === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    next = <span class="keyword">new</span> StructuredUniform(id);</span><br><span class="line">                    addUniform(container, next);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                container = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// Root Container</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLUniforms</span>(<span class="params">gl, program</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seq = [];</span><br><span class="line">        <span class="built_in">this</span>.map = &#123;&#125;;</span><br><span class="line">        <span class="keyword">const</span> n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> info = gl.getActiveUniform(program, i),</span><br><span class="line">                addr = gl.getUniformLocation(program, info.name);</span><br><span class="line">            parseUniform(info, addr, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WebGLUniforms.prototype.setValue = <span class="function"><span class="keyword">function</span> (<span class="params">gl, name, value, textures</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> u = <span class="built_in">this</span>.map[name];</span><br><span class="line">        <span class="keyword">if</span> (u !== <span class="literal">undefined</span>) u.setValue(gl, value, textures);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLUniforms.prototype.setOptional = <span class="function"><span class="keyword">function</span> (<span class="params">gl, object, name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> v = object[name];</span><br><span class="line">        <span class="keyword">if</span> (v !== <span class="literal">undefined</span>) <span class="built_in">this</span>.setValue(gl, name, v);</span><br><span class="line">    &#125;; <span class="comment">// Static interface</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    WebGLUniforms.upload = <span class="function"><span class="keyword">function</span> (<span class="params">gl, seq, values, textures</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = seq.length; i !== n; ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> u = seq[i],</span><br><span class="line">                v = values[u.id];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (v.needsUpdate !== <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="comment">// note: always updating when .needsUpdate is undefined</span></span><br><span class="line">                u.setValue(gl, v.value, textures);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLUniforms.seqWithValue = <span class="function"><span class="keyword">function</span> (<span class="params">seq, values</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> r = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = seq.length; i !== n; ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> u = seq[i];</span><br><span class="line">            <span class="keyword">if</span> (u.id <span class="keyword">in</span> values) r.push(u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLShader</span>(<span class="params">gl, type, string</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> shader = gl.createShader(type);</span><br><span class="line">        gl.shaderSource(shader, string);</span><br><span class="line">        gl.compileShader(shader);</span><br><span class="line">        <span class="keyword">return</span> shader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> programIdCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleSource</span>(<span class="params">string, errorLine</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> lines = string.split(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> lines2 = [];</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">from</span> = <span class="built_in">Math</span>.max(errorLine - <span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">const</span> to = <span class="built_in">Math</span>.min(errorLine + <span class="number">6</span>, lines.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">from</span>; i &lt; to; i++) &#123;</span><br><span class="line">            lines2.push(i + <span class="number">1</span> + <span class="string">&#x27;: &#x27;</span> + lines[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lines2.join(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getEncodingComponents</span>(<span class="params">encoding</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (encoding) &#123;</span><br><span class="line">            <span class="keyword">case</span> LinearEncoding:</span><br><span class="line">                <span class="keyword">return</span> [<span class="string">&#x27;Linear&#x27;</span>, <span class="string">&#x27;( value )&#x27;</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> sRGBEncoding:</span><br><span class="line">                <span class="keyword">return</span> [<span class="string">&#x27;sRGB&#x27;</span>, <span class="string">&#x27;( value )&#x27;</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLProgram: Unsupported encoding:&#x27;</span>, encoding);</span><br><span class="line">                <span class="keyword">return</span> [<span class="string">&#x27;Linear&#x27;</span>, <span class="string">&#x27;( value )&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getShaderErrors</span>(<span class="params">gl, shader, type</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);</span><br><span class="line">        <span class="keyword">const</span> errors = gl.getShaderInfoLog(shader).trim();</span><br><span class="line">        <span class="keyword">if</span> (status &amp;&amp; errors === <span class="string">&#x27;&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">const</span> errorLine = <span class="built_in">parseInt</span>(<span class="regexp">/ERROR: 0:(\d+)/</span>.exec(errors)[<span class="number">1</span>]); <span class="comment">// --enable-privileged-webgl-extension</span></span><br><span class="line">        <span class="comment">// console.log( &#x27;**&#x27; + type + &#x27;**&#x27;, gl.getExtension( &#x27;WEBGL_debug_shaders&#x27; ).getTranslatedShaderSource( shader ) );</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> type.toUpperCase() + <span class="string">&#x27;\n\n&#x27;</span> + errors + <span class="string">&#x27;\n\n&#x27;</span> + handleSource(gl.getShaderSource(shader), errorLine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getTexelEncodingFunction</span>(<span class="params">functionName, encoding</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> components = getEncodingComponents(encoding);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;vec4 &#x27;</span> + functionName + <span class="string">&#x27;( vec4 value ) &#123; return LinearTo&#x27;</span> + components[<span class="number">0</span>] + components[<span class="number">1</span>] + <span class="string">&#x27;; &#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getToneMappingFunction</span>(<span class="params">functionName, toneMapping</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> toneMappingName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (toneMapping) &#123;</span><br><span class="line">            <span class="keyword">case</span> LinearToneMapping:</span><br><span class="line">                toneMappingName = <span class="string">&#x27;Linear&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> ReinhardToneMapping:</span><br><span class="line">                toneMappingName = <span class="string">&#x27;Reinhard&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> CineonToneMapping:</span><br><span class="line">                toneMappingName = <span class="string">&#x27;OptimizedCineon&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> ACESFilmicToneMapping:</span><br><span class="line">                toneMappingName = <span class="string">&#x27;ACESFilmic&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> CustomToneMapping:</span><br><span class="line">                toneMappingName = <span class="string">&#x27;Custom&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLProgram: Unsupported toneMapping:&#x27;</span>, toneMapping);</span><br><span class="line">                toneMappingName = <span class="string">&#x27;Linear&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;vec3 &#x27;</span> + functionName + <span class="string">&#x27;( vec3 color ) &#123; return &#x27;</span> + toneMappingName + <span class="string">&#x27;ToneMapping( color ); &#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">generateExtensions</span>(<span class="params">parameters</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> chunks = [parameters.extensionDerivatives || !!parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === <span class="string">&#x27;physical&#x27;</span> ? <span class="string">&#x27;#extension GL_OES_standard_derivatives : enable&#x27;</span> : <span class="string">&#x27;&#x27;</span>, (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) &amp;&amp; parameters.rendererExtensionFragDepth ? <span class="string">&#x27;#extension GL_EXT_frag_depth : enable&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.extensionDrawBuffers &amp;&amp; parameters.rendererExtensionDrawBuffers ? <span class="string">&#x27;#extension GL_EXT_draw_buffers : require&#x27;</span> : <span class="string">&#x27;&#x27;</span>, (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) &amp;&amp; parameters.rendererExtensionShaderTextureLod ? <span class="string">&#x27;#extension GL_EXT_shader_texture_lod : enable&#x27;</span> : <span class="string">&#x27;&#x27;</span>];</span><br><span class="line">        <span class="keyword">return</span> chunks.filter(filterEmptyLine).join(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">generateDefines</span>(<span class="params">defines</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> chunks = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> defines) &#123;</span><br><span class="line">            <span class="keyword">const</span> value = defines[name];</span><br><span class="line">            <span class="keyword">if</span> (value === <span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">            chunks.push(<span class="string">&#x27;#define &#x27;</span> + name + <span class="string">&#x27; &#x27;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> chunks.join(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fetchAttributeLocations</span>(<span class="params">gl, program</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> attributes = &#123;&#125;;</span><br><span class="line">        <span class="keyword">const</span> n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> info = gl.getActiveAttrib(program, i);</span><br><span class="line">            <span class="keyword">const</span> name = info.name;</span><br><span class="line">            <span class="keyword">let</span> locationSize = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (info.type === gl.FLOAT_MAT2) locationSize = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (info.type === gl.FLOAT_MAT3) locationSize = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> (info.type === gl.FLOAT_MAT4) locationSize = <span class="number">4</span>; <span class="comment">// console.log( &#x27;THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:&#x27;, name, i );</span></span><br><span class="line"></span><br><span class="line">            attributes[name] = &#123;</span><br><span class="line">                <span class="attr">type</span>: info.type,</span><br><span class="line">                <span class="attr">location</span>: gl.getAttribLocation(program, name),</span><br><span class="line">                <span class="attr">locationSize</span>: locationSize</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> attributes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">filterEmptyLine</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> string !== <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">replaceLightNums</span>(<span class="params">string, parameters</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> string.replace(<span class="regexp">/NUM_DIR_LIGHTS/g</span>, parameters.numDirLights).replace(<span class="regexp">/NUM_SPOT_LIGHTS/g</span>, parameters.numSpotLights).replace(<span class="regexp">/NUM_RECT_AREA_LIGHTS/g</span>, parameters.numRectAreaLights).replace(<span class="regexp">/NUM_POINT_LIGHTS/g</span>, parameters.numPointLights).replace(<span class="regexp">/NUM_HEMI_LIGHTS/g</span>, parameters.numHemiLights).replace(<span class="regexp">/NUM_DIR_LIGHT_SHADOWS/g</span>, parameters.numDirLightShadows).replace(<span class="regexp">/NUM_SPOT_LIGHT_SHADOWS/g</span>, parameters.numSpotLightShadows).replace(<span class="regexp">/NUM_POINT_LIGHT_SHADOWS/g</span>, parameters.numPointLightShadows);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">replaceClippingPlaneNums</span>(<span class="params">string, parameters</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> string.replace(<span class="regexp">/NUM_CLIPPING_PLANES/g</span>, parameters.numClippingPlanes).replace(<span class="regexp">/UNION_CLIPPING_PLANES/g</span>, parameters.numClippingPlanes - parameters.numClipIntersection);</span><br><span class="line">    &#125; <span class="comment">// Resolve Includes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> includePattern = <span class="regexp">/^[ \t]*#include +&lt;([\w\d./]+)&gt;/gm</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolveIncludes</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> string.replace(includePattern, includeReplacer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">includeReplacer</span>(<span class="params">match, include</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> string = ShaderChunk[include];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (string === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Can not resolve #include &lt;&#x27;</span> + include + <span class="string">&#x27;&gt;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resolveIncludes(string);</span><br><span class="line">    &#125; <span class="comment">// Unroll Loops</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> deprecatedUnrollLoopPattern = <span class="regexp">/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i &lt; (\d+)\; i \+\+ \) \&#123;([\s\S]+?)(?=\&#125;)\&#125;/g</span>;</span><br><span class="line">    <span class="keyword">const</span> unrollLoopPattern = <span class="regexp">/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*&lt;\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*&#123;([\s\S]+?)&#125;\s+#pragma unroll_loop_end/g</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">unrollLoops</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">deprecatedLoopReplacer</span>(<span class="params">match, start, end, snippet</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> loopReplacer(match, start, end, snippet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">loopReplacer</span>(<span class="params">match, start, end, snippet</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> string = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">parseInt</span>(start); i &lt; <span class="built_in">parseInt</span>(end); i++) &#123;</span><br><span class="line">            string += snippet.replace(<span class="regexp">/\[\s*i\s*\]/g</span>, <span class="string">&#x27;[ &#x27;</span> + i + <span class="string">&#x27; ]&#x27;</span>).replace(<span class="regexp">/UNROLLED_LOOP_INDEX/g</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> string;</span><br><span class="line">    &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">generatePrecision</span>(<span class="params">parameters</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> precisionstring = <span class="string">&#x27;precision &#x27;</span> + parameters.precision + <span class="string">&#x27; float;\nprecision &#x27;</span> + parameters.precision + <span class="string">&#x27; int;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parameters.precision === <span class="string">&#x27;highp&#x27;</span>) &#123;</span><br><span class="line">            precisionstring += <span class="string">&#x27;\n#define HIGH_PRECISION&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameters.precision === <span class="string">&#x27;mediump&#x27;</span>) &#123;</span><br><span class="line">            precisionstring += <span class="string">&#x27;\n#define MEDIUM_PRECISION&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameters.precision === <span class="string">&#x27;lowp&#x27;</span>) &#123;</span><br><span class="line">            precisionstring += <span class="string">&#x27;\n#define LOW_PRECISION&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> precisionstring;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">generateShadowMapTypeDefine</span>(<span class="params">parameters</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> shadowMapTypeDefine = <span class="string">&#x27;SHADOWMAP_TYPE_BASIC&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parameters.shadowMapType === PCFShadowMap) &#123;</span><br><span class="line">            shadowMapTypeDefine = <span class="string">&#x27;SHADOWMAP_TYPE_PCF&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameters.shadowMapType === PCFSoftShadowMap) &#123;</span><br><span class="line">            shadowMapTypeDefine = <span class="string">&#x27;SHADOWMAP_TYPE_PCF_SOFT&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameters.shadowMapType === VSMShadowMap) &#123;</span><br><span class="line">            shadowMapTypeDefine = <span class="string">&#x27;SHADOWMAP_TYPE_VSM&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> shadowMapTypeDefine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">generateEnvMapTypeDefine</span>(<span class="params">parameters</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> envMapTypeDefine = <span class="string">&#x27;ENVMAP_TYPE_CUBE&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parameters.envMap) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (parameters.envMapMode) &#123;</span><br><span class="line">                <span class="keyword">case</span> CubeReflectionMapping:</span><br><span class="line">                <span class="keyword">case</span> CubeRefractionMapping:</span><br><span class="line">                    envMapTypeDefine = <span class="string">&#x27;ENVMAP_TYPE_CUBE&#x27;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> CubeUVReflectionMapping:</span><br><span class="line">                    envMapTypeDefine = <span class="string">&#x27;ENVMAP_TYPE_CUBE_UV&#x27;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> envMapTypeDefine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">generateEnvMapModeDefine</span>(<span class="params">parameters</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> envMapModeDefine = <span class="string">&#x27;ENVMAP_MODE_REFLECTION&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parameters.envMap) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (parameters.envMapMode) &#123;</span><br><span class="line">                <span class="keyword">case</span> CubeRefractionMapping:</span><br><span class="line">                    envMapModeDefine = <span class="string">&#x27;ENVMAP_MODE_REFRACTION&#x27;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> envMapModeDefine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">generateEnvMapBlendingDefine</span>(<span class="params">parameters</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> envMapBlendingDefine = <span class="string">&#x27;ENVMAP_BLENDING_NONE&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parameters.envMap) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (parameters.combine) &#123;</span><br><span class="line">                <span class="keyword">case</span> MultiplyOperation:</span><br><span class="line">                    envMapBlendingDefine = <span class="string">&#x27;ENVMAP_BLENDING_MULTIPLY&#x27;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> MixOperation:</span><br><span class="line">                    envMapBlendingDefine = <span class="string">&#x27;ENVMAP_BLENDING_MIX&#x27;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> AddOperation:</span><br><span class="line">                    envMapBlendingDefine = <span class="string">&#x27;ENVMAP_BLENDING_ADD&#x27;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> envMapBlendingDefine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">generateCubeUVSize</span>(<span class="params">parameters</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> imageHeight = parameters.envMapCubeUVHeight;</span><br><span class="line">        <span class="keyword">if</span> (imageHeight === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">const</span> maxMip = <span class="built_in">Math</span>.log2(imageHeight / <span class="number">32</span> + <span class="number">1</span>) + <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">const</span> texelHeight = <span class="number">1.0</span> / imageHeight;</span><br><span class="line">        <span class="keyword">const</span> texelWidth = <span class="number">1.0</span> / (<span class="number">3</span> * <span class="built_in">Math</span>.max(<span class="built_in">Math</span>.pow(<span class="number">2</span>, maxMip), <span class="number">7</span> * <span class="number">16</span>));</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            texelWidth,</span><br><span class="line">            texelHeight,</span><br><span class="line">            maxMip</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLProgram</span>(<span class="params">renderer, cacheKey, parameters, bindingStates</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Send this event to Three.js DevTools</span></span><br><span class="line">        <span class="comment">// console.log( &#x27;WebGLProgram&#x27;, cacheKey );</span></span><br><span class="line">        <span class="keyword">const</span> gl = renderer.getContext();</span><br><span class="line">        <span class="keyword">const</span> defines = parameters.defines;</span><br><span class="line">        <span class="keyword">let</span> vertexShader = parameters.vertexShader;</span><br><span class="line">        <span class="keyword">let</span> fragmentShader = parameters.fragmentShader;</span><br><span class="line">        <span class="keyword">const</span> shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);</span><br><span class="line">        <span class="keyword">const</span> envMapTypeDefine = generateEnvMapTypeDefine(parameters);</span><br><span class="line">        <span class="keyword">const</span> envMapModeDefine = generateEnvMapModeDefine(parameters);</span><br><span class="line">        <span class="keyword">const</span> envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);</span><br><span class="line">        <span class="keyword">const</span> envMapCubeUVSize = generateCubeUVSize(parameters);</span><br><span class="line">        <span class="keyword">const</span> customExtensions = parameters.isWebGL2 ? <span class="string">&#x27;&#x27;</span> : generateExtensions(parameters);</span><br><span class="line">        <span class="keyword">const</span> customDefines = generateDefines(defines);</span><br><span class="line">        <span class="keyword">const</span> program = gl.createProgram();</span><br><span class="line">        <span class="keyword">let</span> prefixVertex, prefixFragment;</span><br><span class="line">        <span class="keyword">let</span> versionString = parameters.glslVersion ? <span class="string">&#x27;#version &#x27;</span> + parameters.glslVersion + <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parameters.isRawShaderMaterial) &#123;</span><br><span class="line">            prefixVertex = [customDefines].filter(filterEmptyLine).join(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (prefixVertex.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                prefixVertex += <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (prefixFragment.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                prefixFragment += <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prefixVertex = [generatePrecision(parameters), <span class="string">&#x27;#define SHADER_NAME &#x27;</span> + parameters.shaderName, customDefines, parameters.instancing ? <span class="string">&#x27;#define USE_INSTANCING&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.instancingColor ? <span class="string">&#x27;#define USE_INSTANCING_COLOR&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.supportsVertexTextures ? <span class="string">&#x27;#define VERTEX_TEXTURES&#x27;</span> : <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;#define MAX_BONES &#x27;</span> + parameters.maxBones, parameters.useFog &amp;&amp; parameters.fog ? <span class="string">&#x27;#define USE_FOG&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.useFog &amp;&amp; parameters.fogExp2 ? <span class="string">&#x27;#define FOG_EXP2&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.map ? <span class="string">&#x27;#define USE_MAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.envMap ? <span class="string">&#x27;#define USE_ENVMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.envMap ? <span class="string">&#x27;#define &#x27;</span> + envMapModeDefine : <span class="string">&#x27;&#x27;</span>, parameters.lightMap ? <span class="string">&#x27;#define USE_LIGHTMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.aoMap ? <span class="string">&#x27;#define USE_AOMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.emissiveMap ? <span class="string">&#x27;#define USE_EMISSIVEMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.bumpMap ? <span class="string">&#x27;#define USE_BUMPMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.normalMap ? <span class="string">&#x27;#define USE_NORMALMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.normalMap &amp;&amp; parameters.objectSpaceNormalMap ? <span class="string">&#x27;#define OBJECTSPACE_NORMALMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.normalMap &amp;&amp; parameters.tangentSpaceNormalMap ? <span class="string">&#x27;#define TANGENTSPACE_NORMALMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.clearcoatMap ? <span class="string">&#x27;#define USE_CLEARCOATMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.clearcoatRoughnessMap ? <span class="string">&#x27;#define USE_CLEARCOAT_ROUGHNESSMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.clearcoatNormalMap ? <span class="string">&#x27;#define USE_CLEARCOAT_NORMALMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.displacementMap &amp;&amp; parameters.supportsVertexTextures ? <span class="string">&#x27;#define USE_DISPLACEMENTMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.specularMap ? <span class="string">&#x27;#define USE_SPECULARMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.specularIntensityMap ? <span class="string">&#x27;#define USE_SPECULARINTENSITYMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.specularColorMap ? <span class="string">&#x27;#define USE_SPECULARCOLORMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.roughnessMap ? <span class="string">&#x27;#define USE_ROUGHNESSMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.metalnessMap ? <span class="string">&#x27;#define USE_METALNESSMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.alphaMap ? <span class="string">&#x27;#define USE_ALPHAMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.transmission ? <span class="string">&#x27;#define USE_TRANSMISSION&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.transmissionMap ? <span class="string">&#x27;#define USE_TRANSMISSIONMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.thicknessMap ? <span class="string">&#x27;#define USE_THICKNESSMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.sheenColorMap ? <span class="string">&#x27;#define USE_SHEENCOLORMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.sheenRoughnessMap ? <span class="string">&#x27;#define USE_SHEENROUGHNESSMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.vertexTangents ? <span class="string">&#x27;#define USE_TANGENT&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.vertexColors ? <span class="string">&#x27;#define USE_COLOR&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.vertexAlphas ? <span class="string">&#x27;#define USE_COLOR_ALPHA&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.vertexUvs ? <span class="string">&#x27;#define USE_UV&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.uvsVertexOnly ? <span class="string">&#x27;#define UVS_VERTEX_ONLY&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.flatShading ? <span class="string">&#x27;#define FLAT_SHADED&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.skinning ? <span class="string">&#x27;#define USE_SKINNING&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.useVertexTexture ? <span class="string">&#x27;#define BONE_TEXTURE&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.morphTargets ? <span class="string">&#x27;#define USE_MORPHTARGETS&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.morphNormals &amp;&amp; parameters.flatShading === <span class="literal">false</span> ? <span class="string">&#x27;#define USE_MORPHNORMALS&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.morphColors &amp;&amp; parameters.isWebGL2 ? <span class="string">&#x27;#define USE_MORPHCOLORS&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.morphTargetsCount &gt; <span class="number">0</span> &amp;&amp; parameters.isWebGL2 ? <span class="string">&#x27;#define MORPHTARGETS_TEXTURE&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.morphTargetsCount &gt; <span class="number">0</span> &amp;&amp; parameters.isWebGL2 ? <span class="string">&#x27;#define MORPHTARGETS_TEXTURE_STRIDE &#x27;</span> + parameters.morphTextureStride : <span class="string">&#x27;&#x27;</span>, parameters.morphTargetsCount &gt; <span class="number">0</span> &amp;&amp; parameters.isWebGL2 ? <span class="string">&#x27;#define MORPHTARGETS_COUNT &#x27;</span> + parameters.morphTargetsCount : <span class="string">&#x27;&#x27;</span>, parameters.doubleSided ? <span class="string">&#x27;#define DOUBLE_SIDED&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.flipSided ? <span class="string">&#x27;#define FLIP_SIDED&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.shadowMapEnabled ? <span class="string">&#x27;#define USE_SHADOWMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.shadowMapEnabled ? <span class="string">&#x27;#define &#x27;</span> + shadowMapTypeDefine : <span class="string">&#x27;&#x27;</span>, parameters.sizeAttenuation ? <span class="string">&#x27;#define USE_SIZEATTENUATION&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.logarithmicDepthBuffer ? <span class="string">&#x27;#define USE_LOGDEPTHBUF&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.logarithmicDepthBuffer &amp;&amp; parameters.rendererExtensionFragDepth ? <span class="string">&#x27;#define USE_LOGDEPTHBUF_EXT&#x27;</span> : <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;uniform mat4 modelMatrix;&#x27;</span>, <span class="string">&#x27;uniform mat4 modelViewMatrix;&#x27;</span>, <span class="string">&#x27;uniform mat4 projectionMatrix;&#x27;</span>, <span class="string">&#x27;uniform mat4 viewMatrix;&#x27;</span>, <span class="string">&#x27;uniform mat3 normalMatrix;&#x27;</span>, <span class="string">&#x27;uniform vec3 cameraPosition;&#x27;</span>, <span class="string">&#x27;uniform bool isOrthographic;&#x27;</span>, <span class="string">&#x27;#ifdef USE_INSTANCING&#x27;</span>, <span class="string">&#x27;	attribute mat4 instanceMatrix;&#x27;</span>, <span class="string">&#x27;#endif&#x27;</span>, <span class="string">&#x27;#ifdef USE_INSTANCING_COLOR&#x27;</span>, <span class="string">&#x27;	attribute vec3 instanceColor;&#x27;</span>, <span class="string">&#x27;#endif&#x27;</span>, <span class="string">&#x27;attribute vec3 position;&#x27;</span>, <span class="string">&#x27;attribute vec3 normal;&#x27;</span>, <span class="string">&#x27;attribute vec2 uv;&#x27;</span>, <span class="string">&#x27;#ifdef USE_TANGENT&#x27;</span>, <span class="string">&#x27;	attribute vec4 tangent;&#x27;</span>, <span class="string">&#x27;#endif&#x27;</span>, <span class="string">&#x27;#if defined( USE_COLOR_ALPHA )&#x27;</span>, <span class="string">&#x27;	attribute vec4 color;&#x27;</span>, <span class="string">&#x27;#elif defined( USE_COLOR )&#x27;</span>, <span class="string">&#x27;	attribute vec3 color;&#x27;</span>, <span class="string">&#x27;#endif&#x27;</span>, <span class="string">&#x27;#if ( defined( USE_MORPHTARGETS ) &amp;&amp; ! defined( MORPHTARGETS_TEXTURE ) )&#x27;</span>, <span class="string">&#x27;	attribute vec3 morphTarget0;&#x27;</span>, <span class="string">&#x27;	attribute vec3 morphTarget1;&#x27;</span>, <span class="string">&#x27;	attribute vec3 morphTarget2;&#x27;</span>, <span class="string">&#x27;	attribute vec3 morphTarget3;&#x27;</span>, <span class="string">&#x27;	#ifdef USE_MORPHNORMALS&#x27;</span>, <span class="string">&#x27;		attribute vec3 morphNormal0;&#x27;</span>, <span class="string">&#x27;		attribute vec3 morphNormal1;&#x27;</span>, <span class="string">&#x27;		attribute vec3 morphNormal2;&#x27;</span>, <span class="string">&#x27;		attribute vec3 morphNormal3;&#x27;</span>, <span class="string">&#x27;	#else&#x27;</span>, <span class="string">&#x27;		attribute vec3 morphTarget4;&#x27;</span>, <span class="string">&#x27;		attribute vec3 morphTarget5;&#x27;</span>, <span class="string">&#x27;		attribute vec3 morphTarget6;&#x27;</span>, <span class="string">&#x27;		attribute vec3 morphTarget7;&#x27;</span>, <span class="string">&#x27;	#endif&#x27;</span>, <span class="string">&#x27;#endif&#x27;</span>, <span class="string">&#x27;#ifdef USE_SKINNING&#x27;</span>, <span class="string">&#x27;	attribute vec4 skinIndex;&#x27;</span>, <span class="string">&#x27;	attribute vec4 skinWeight;&#x27;</span>, <span class="string">&#x27;#endif&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>].filter(filterEmptyLine).join(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            prefixFragment = [customExtensions, generatePrecision(parameters), <span class="string">&#x27;#define SHADER_NAME &#x27;</span> + parameters.shaderName, customDefines, parameters.useFog &amp;&amp; parameters.fog ? <span class="string">&#x27;#define USE_FOG&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.useFog &amp;&amp; parameters.fogExp2 ? <span class="string">&#x27;#define FOG_EXP2&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.map ? <span class="string">&#x27;#define USE_MAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.matcap ? <span class="string">&#x27;#define USE_MATCAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.envMap ? <span class="string">&#x27;#define USE_ENVMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.envMap ? <span class="string">&#x27;#define &#x27;</span> + envMapTypeDefine : <span class="string">&#x27;&#x27;</span>, parameters.envMap ? <span class="string">&#x27;#define &#x27;</span> + envMapModeDefine : <span class="string">&#x27;&#x27;</span>, parameters.envMap ? <span class="string">&#x27;#define &#x27;</span> + envMapBlendingDefine : <span class="string">&#x27;&#x27;</span>, envMapCubeUVSize ? <span class="string">&#x27;#define CUBEUV_TEXEL_WIDTH &#x27;</span> + envMapCubeUVSize.texelWidth : <span class="string">&#x27;&#x27;</span>, envMapCubeUVSize ? <span class="string">&#x27;#define CUBEUV_TEXEL_HEIGHT &#x27;</span> + envMapCubeUVSize.texelHeight : <span class="string">&#x27;&#x27;</span>, envMapCubeUVSize ? <span class="string">&#x27;#define CUBEUV_MAX_MIP &#x27;</span> + envMapCubeUVSize.maxMip + <span class="string">&#x27;.0&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.lightMap ? <span class="string">&#x27;#define USE_LIGHTMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.aoMap ? <span class="string">&#x27;#define USE_AOMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.emissiveMap ? <span class="string">&#x27;#define USE_EMISSIVEMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.bumpMap ? <span class="string">&#x27;#define USE_BUMPMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.normalMap ? <span class="string">&#x27;#define USE_NORMALMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.normalMap &amp;&amp; parameters.objectSpaceNormalMap ? <span class="string">&#x27;#define OBJECTSPACE_NORMALMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.normalMap &amp;&amp; parameters.tangentSpaceNormalMap ? <span class="string">&#x27;#define TANGENTSPACE_NORMALMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.clearcoat ? <span class="string">&#x27;#define USE_CLEARCOAT&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.clearcoatMap ? <span class="string">&#x27;#define USE_CLEARCOATMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.clearcoatRoughnessMap ? <span class="string">&#x27;#define USE_CLEARCOAT_ROUGHNESSMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.clearcoatNormalMap ? <span class="string">&#x27;#define USE_CLEARCOAT_NORMALMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.specularMap ? <span class="string">&#x27;#define USE_SPECULARMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.specularIntensityMap ? <span class="string">&#x27;#define USE_SPECULARINTENSITYMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.specularColorMap ? <span class="string">&#x27;#define USE_SPECULARCOLORMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.roughnessMap ? <span class="string">&#x27;#define USE_ROUGHNESSMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.metalnessMap ? <span class="string">&#x27;#define USE_METALNESSMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.alphaMap ? <span class="string">&#x27;#define USE_ALPHAMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.alphaTest ? <span class="string">&#x27;#define USE_ALPHATEST&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.sheen ? <span class="string">&#x27;#define USE_SHEEN&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.sheenColorMap ? <span class="string">&#x27;#define USE_SHEENCOLORMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.sheenRoughnessMap ? <span class="string">&#x27;#define USE_SHEENROUGHNESSMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.transmission ? <span class="string">&#x27;#define USE_TRANSMISSION&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.transmissionMap ? <span class="string">&#x27;#define USE_TRANSMISSIONMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.thicknessMap ? <span class="string">&#x27;#define USE_THICKNESSMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.decodeVideoTexture ? <span class="string">&#x27;#define DECODE_VIDEO_TEXTURE&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.vertexTangents ? <span class="string">&#x27;#define USE_TANGENT&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.vertexColors || parameters.instancingColor ? <span class="string">&#x27;#define USE_COLOR&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.vertexAlphas ? <span class="string">&#x27;#define USE_COLOR_ALPHA&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.vertexUvs ? <span class="string">&#x27;#define USE_UV&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.uvsVertexOnly ? <span class="string">&#x27;#define UVS_VERTEX_ONLY&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.gradientMap ? <span class="string">&#x27;#define USE_GRADIENTMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.flatShading ? <span class="string">&#x27;#define FLAT_SHADED&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.doubleSided ? <span class="string">&#x27;#define DOUBLE_SIDED&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.flipSided ? <span class="string">&#x27;#define FLIP_SIDED&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.shadowMapEnabled ? <span class="string">&#x27;#define USE_SHADOWMAP&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.shadowMapEnabled ? <span class="string">&#x27;#define &#x27;</span> + shadowMapTypeDefine : <span class="string">&#x27;&#x27;</span>, parameters.premultipliedAlpha ? <span class="string">&#x27;#define PREMULTIPLIED_ALPHA&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.physicallyCorrectLights ? <span class="string">&#x27;#define PHYSICALLY_CORRECT_LIGHTS&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.logarithmicDepthBuffer ? <span class="string">&#x27;#define USE_LOGDEPTHBUF&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.logarithmicDepthBuffer &amp;&amp; parameters.rendererExtensionFragDepth ? <span class="string">&#x27;#define USE_LOGDEPTHBUF_EXT&#x27;</span> : <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;uniform mat4 viewMatrix;&#x27;</span>, <span class="string">&#x27;uniform vec3 cameraPosition;&#x27;</span>, <span class="string">&#x27;uniform bool isOrthographic;&#x27;</span>, parameters.toneMapping !== NoToneMapping ? <span class="string">&#x27;#define TONE_MAPPING&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.toneMapping !== NoToneMapping ? ShaderChunk[<span class="string">&#x27;tonemapping_pars_fragment&#x27;</span>] : <span class="string">&#x27;&#x27;</span>, <span class="comment">// this code is required here because it is used by the toneMapping() function defined below</span></span><br><span class="line">                parameters.toneMapping !== NoToneMapping ? getToneMappingFunction(<span class="string">&#x27;toneMapping&#x27;</span>, parameters.toneMapping) : <span class="string">&#x27;&#x27;</span>, parameters.dithering ? <span class="string">&#x27;#define DITHERING&#x27;</span> : <span class="string">&#x27;&#x27;</span>, parameters.opaque ? <span class="string">&#x27;#define OPAQUE&#x27;</span> : <span class="string">&#x27;&#x27;</span>, ShaderChunk[<span class="string">&#x27;encodings_pars_fragment&#x27;</span>], <span class="comment">// this code is required here because it is used by the various encoding/decoding function defined below</span></span><br><span class="line">                getTexelEncodingFunction(<span class="string">&#x27;linearToOutputTexel&#x27;</span>, parameters.outputEncoding), parameters.depthPacking ? <span class="string">&#x27;#define DEPTH_PACKING &#x27;</span> + parameters.depthPacking : <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>].filter(filterEmptyLine).join(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vertexShader = resolveIncludes(vertexShader);</span><br><span class="line">        vertexShader = replaceLightNums(vertexShader, parameters);</span><br><span class="line">        vertexShader = replaceClippingPlaneNums(vertexShader, parameters);</span><br><span class="line">        fragmentShader = resolveIncludes(fragmentShader);</span><br><span class="line">        fragmentShader = replaceLightNums(fragmentShader, parameters);</span><br><span class="line">        fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);</span><br><span class="line">        vertexShader = unrollLoops(vertexShader);</span><br><span class="line">        fragmentShader = unrollLoops(fragmentShader);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parameters.isWebGL2 &amp;&amp; parameters.isRawShaderMaterial !== <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// GLSL 3.0 conversion for built-in materials and ShaderMaterial</span></span><br><span class="line">            versionString = <span class="string">&#x27;#version 300 es\n&#x27;</span>;</span><br><span class="line">            prefixVertex = [<span class="string">&#x27;precision mediump sampler2DArray;&#x27;</span>, <span class="string">&#x27;#define attribute in&#x27;</span>, <span class="string">&#x27;#define varying out&#x27;</span>, <span class="string">&#x27;#define texture2D texture&#x27;</span>].join(<span class="string">&#x27;\n&#x27;</span>) + <span class="string">&#x27;\n&#x27;</span> + prefixVertex;</span><br><span class="line">            prefixFragment = [<span class="string">&#x27;#define varying in&#x27;</span>, parameters.glslVersion === GLSL3 ? <span class="string">&#x27;&#x27;</span> : <span class="string">&#x27;layout(location = 0) out highp vec4 pc_fragColor;&#x27;</span>, parameters.glslVersion === GLSL3 ? <span class="string">&#x27;&#x27;</span> : <span class="string">&#x27;#define gl_FragColor pc_fragColor&#x27;</span>, <span class="string">&#x27;#define gl_FragDepthEXT gl_FragDepth&#x27;</span>, <span class="string">&#x27;#define texture2D texture&#x27;</span>, <span class="string">&#x27;#define textureCube texture&#x27;</span>, <span class="string">&#x27;#define texture2DProj textureProj&#x27;</span>, <span class="string">&#x27;#define texture2DLodEXT textureLod&#x27;</span>, <span class="string">&#x27;#define texture2DProjLodEXT textureProjLod&#x27;</span>, <span class="string">&#x27;#define textureCubeLodEXT textureLod&#x27;</span>, <span class="string">&#x27;#define texture2DGradEXT textureGrad&#x27;</span>, <span class="string">&#x27;#define texture2DProjGradEXT textureProjGrad&#x27;</span>, <span class="string">&#x27;#define textureCubeGradEXT textureGrad&#x27;</span>].join(<span class="string">&#x27;\n&#x27;</span>) + <span class="string">&#x27;\n&#x27;</span> + prefixFragment;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> vertexGlsl = versionString + prefixVertex + vertexShader;</span><br><span class="line">        <span class="keyword">const</span> fragmentGlsl = versionString + prefixFragment + fragmentShader; <span class="comment">// console.log( &#x27;*VERTEX*&#x27;, vertexGlsl );</span></span><br><span class="line">        <span class="comment">// console.log( &#x27;*FRAGMENT*&#x27;, fragmentGlsl );</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);</span><br><span class="line">        <span class="keyword">const</span> glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);</span><br><span class="line">        gl.attachShader(program, glVertexShader);</span><br><span class="line">        gl.attachShader(program, glFragmentShader); <span class="comment">// Force a particular attribute to index 0.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parameters.index0AttributeName !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            gl.bindAttribLocation(program, <span class="number">0</span>, parameters.index0AttributeName);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameters.morphTargets === <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// programs with morphTargets displace position out of attribute 0</span></span><br><span class="line">            gl.bindAttribLocation(program, <span class="number">0</span>, <span class="string">&#x27;position&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gl.linkProgram(program); <span class="comment">// check for link errors</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (renderer.debug.checkShaderErrors) &#123;</span><br><span class="line">            <span class="keyword">const</span> programLog = gl.getProgramInfoLog(program).trim();</span><br><span class="line">            <span class="keyword">const</span> vertexLog = gl.getShaderInfoLog(glVertexShader).trim();</span><br><span class="line">            <span class="keyword">const</span> fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();</span><br><span class="line">            <span class="keyword">let</span> runnable = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">let</span> haveDiagnostics = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (gl.getProgramParameter(program, gl.LINK_STATUS) === <span class="literal">false</span>) &#123;</span><br><span class="line">                runnable = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">const</span> vertexErrors = getShaderErrors(gl, glVertexShader, <span class="string">&#x27;vertex&#x27;</span>);</span><br><span class="line">                <span class="keyword">const</span> fragmentErrors = getShaderErrors(gl, glFragmentShader, <span class="string">&#x27;fragment&#x27;</span>);</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLProgram: Shader Error &#x27;</span> + gl.getError() + <span class="string">&#x27; - &#x27;</span> + <span class="string">&#x27;VALIDATE_STATUS &#x27;</span> + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + <span class="string">&#x27;\n\n&#x27;</span> + <span class="string">&#x27;Program Info Log: &#x27;</span> + programLog + <span class="string">&#x27;\n&#x27;</span> + vertexErrors + <span class="string">&#x27;\n&#x27;</span> + fragmentErrors);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (programLog !== <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLProgram: Program Info Log:&#x27;</span>, programLog);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vertexLog === <span class="string">&#x27;&#x27;</span> || fragmentLog === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">                haveDiagnostics = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (haveDiagnostics) &#123;</span><br><span class="line">                <span class="built_in">this</span>.diagnostics = &#123;</span><br><span class="line">                    <span class="attr">runnable</span>: runnable,</span><br><span class="line">                    <span class="attr">programLog</span>: programLog,</span><br><span class="line">                    <span class="attr">vertexShader</span>: &#123;</span><br><span class="line">                        <span class="attr">log</span>: vertexLog,</span><br><span class="line">                        <span class="attr">prefix</span>: prefixVertex</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">fragmentShader</span>: &#123;</span><br><span class="line">                        <span class="attr">log</span>: fragmentLog,</span><br><span class="line">                        <span class="attr">prefix</span>: prefixFragment</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// Clean up</span></span><br><span class="line">        <span class="comment">// Crashes in iOS9 and iOS10. #18402</span></span><br><span class="line">        <span class="comment">// gl.detachShader( program, glVertexShader );</span></span><br><span class="line">        <span class="comment">// gl.detachShader( program, glFragmentShader );</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        gl.deleteShader(glVertexShader);</span><br><span class="line">        gl.deleteShader(glFragmentShader); <span class="comment">// set up caching for uniform locations</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> cachedUniforms;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.getUniforms = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (cachedUniforms === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                cachedUniforms = <span class="keyword">new</span> WebGLUniforms(gl, program);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> cachedUniforms;</span><br><span class="line">        &#125;; <span class="comment">// set up caching for attribute locations</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> cachedAttributes;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.getAttributes = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (cachedAttributes === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                cachedAttributes = fetchAttributeLocations(gl, program);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> cachedAttributes;</span><br><span class="line">        &#125;; <span class="comment">// free resource</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.destroy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            bindingStates.releaseStatesOfProgram(<span class="built_in">this</span>);</span><br><span class="line">            gl.deleteProgram(program);</span><br><span class="line">            <span class="built_in">this</span>.program = <span class="literal">undefined</span>;</span><br><span class="line">        &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.name = parameters.shaderName;</span><br><span class="line">        <span class="built_in">this</span>.id = programIdCount++;</span><br><span class="line">        <span class="built_in">this</span>.cacheKey = cacheKey;</span><br><span class="line">        <span class="built_in">this</span>.usedTimes = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">this</span>.program = program;</span><br><span class="line">        <span class="built_in">this</span>.vertexShader = glVertexShader;</span><br><span class="line">        <span class="built_in">this</span>.fragmentShader = glFragmentShader;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> _id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WebGLShaderCache</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.shaderCache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">            <span class="built_in">this</span>.materialCache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">update</span>(<span class="params">material</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> vertexShader = material.vertexShader;</span><br><span class="line">            <span class="keyword">const</span> fragmentShader = material.fragmentShader;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> vertexShaderStage = <span class="built_in">this</span>._getShaderStage(vertexShader);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> fragmentShaderStage = <span class="built_in">this</span>._getShaderStage(fragmentShader);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> materialShaders = <span class="built_in">this</span>._getShaderCacheForMaterial(material);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (materialShaders.has(vertexShaderStage) === <span class="literal">false</span>) &#123;</span><br><span class="line">                materialShaders.add(vertexShaderStage);</span><br><span class="line">                vertexShaderStage.usedTimes++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (materialShaders.has(fragmentShaderStage) === <span class="literal">false</span>) &#123;</span><br><span class="line">                materialShaders.add(fragmentShaderStage);</span><br><span class="line">                fragmentShaderStage.usedTimes++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">remove</span>(<span class="params">material</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> materialShaders = <span class="built_in">this</span>.materialCache.get(material);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> shaderStage <span class="keyword">of</span> materialShaders) &#123;</span><br><span class="line">                shaderStage.usedTimes--;</span><br><span class="line">                <span class="keyword">if</span> (shaderStage.usedTimes === <span class="number">0</span>) <span class="built_in">this</span>.shaderCache.delete(shaderStage.code);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.materialCache.delete(material);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getVertexShaderID</span>(<span class="params">material</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._getShaderStage(material.vertexShader).id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getFragmentShaderID</span>(<span class="params">material</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._getShaderStage(material.fragmentShader).id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dispose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.shaderCache.clear();</span><br><span class="line">            <span class="built_in">this</span>.materialCache.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_getShaderCacheForMaterial</span>(<span class="params">material</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> cache = <span class="built_in">this</span>.materialCache;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cache.has(material) === <span class="literal">false</span>) &#123;</span><br><span class="line">                cache.set(material, <span class="keyword">new</span> <span class="built_in">Set</span>());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> cache.get(material);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_getShaderStage</span>(<span class="params">code</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> cache = <span class="built_in">this</span>.shaderCache;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cache.has(code) === <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> stage = <span class="keyword">new</span> WebGLShaderStage(code);</span><br><span class="line">                cache.set(code, stage);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> cache.get(code);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WebGLShaderStage</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">code</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = _id++;</span><br><span class="line">            <span class="built_in">this</span>.code = code;</span><br><span class="line">            <span class="built_in">this</span>.usedTimes = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLPrograms</span>(<span class="params">renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> _programLayers = <span class="keyword">new</span> Layers();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> _customShaders = <span class="keyword">new</span> WebGLShaderCache();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> programs = [];</span><br><span class="line">        <span class="keyword">const</span> isWebGL2 = capabilities.isWebGL2;</span><br><span class="line">        <span class="keyword">const</span> logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;</span><br><span class="line">        <span class="keyword">const</span> floatVertexTextures = capabilities.floatVertexTextures;</span><br><span class="line">        <span class="keyword">const</span> maxVertexUniforms = capabilities.maxVertexUniforms;</span><br><span class="line">        <span class="keyword">const</span> vertexTextures = capabilities.vertexTextures;</span><br><span class="line">        <span class="keyword">let</span> precision = capabilities.precision;</span><br><span class="line">        <span class="keyword">const</span> shaderIDs = &#123;</span><br><span class="line">            <span class="attr">MeshDepthMaterial</span>: <span class="string">&#x27;depth&#x27;</span>,</span><br><span class="line">            <span class="attr">MeshDistanceMaterial</span>: <span class="string">&#x27;distanceRGBA&#x27;</span>,</span><br><span class="line">            <span class="attr">MeshNormalMaterial</span>: <span class="string">&#x27;normal&#x27;</span>,</span><br><span class="line">            <span class="attr">MeshBasicMaterial</span>: <span class="string">&#x27;basic&#x27;</span>,</span><br><span class="line">            <span class="attr">MeshLambertMaterial</span>: <span class="string">&#x27;lambert&#x27;</span>,</span><br><span class="line">            <span class="attr">MeshPhongMaterial</span>: <span class="string">&#x27;phong&#x27;</span>,</span><br><span class="line">            <span class="attr">MeshToonMaterial</span>: <span class="string">&#x27;toon&#x27;</span>,</span><br><span class="line">            <span class="attr">MeshStandardMaterial</span>: <span class="string">&#x27;physical&#x27;</span>,</span><br><span class="line">            <span class="attr">MeshPhysicalMaterial</span>: <span class="string">&#x27;physical&#x27;</span>,</span><br><span class="line">            <span class="attr">MeshMatcapMaterial</span>: <span class="string">&#x27;matcap&#x27;</span>,</span><br><span class="line">            <span class="attr">LineBasicMaterial</span>: <span class="string">&#x27;basic&#x27;</span>,</span><br><span class="line">            <span class="attr">LineDashedMaterial</span>: <span class="string">&#x27;dashed&#x27;</span>,</span><br><span class="line">            <span class="attr">PointsMaterial</span>: <span class="string">&#x27;points&#x27;</span>,</span><br><span class="line">            <span class="attr">ShadowMaterial</span>: <span class="string">&#x27;shadow&#x27;</span>,</span><br><span class="line">            <span class="attr">SpriteMaterial</span>: <span class="string">&#x27;sprite&#x27;</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getMaxBones</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> skeleton = object.skeleton;</span><br><span class="line">            <span class="keyword">const</span> bones = skeleton.bones;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (floatVertexTextures) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// default for when object is not specified</span></span><br><span class="line">                <span class="comment">// ( for example when prebuilding shader to be used with multiple objects )</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">//	- leave some extra space for other uniforms</span></span><br><span class="line">                <span class="comment">//	- limit here is ANGLE&#x27;s 254 max uniform vectors</span></span><br><span class="line">                <span class="comment">//		(up to 54 should be safe)</span></span><br><span class="line">                <span class="keyword">const</span> nVertexUniforms = maxVertexUniforms;</span><br><span class="line">                <span class="keyword">const</span> nVertexMatrices = <span class="built_in">Math</span>.floor((nVertexUniforms - <span class="number">20</span>) / <span class="number">4</span>);</span><br><span class="line">                <span class="keyword">const</span> maxBones = <span class="built_in">Math</span>.min(nVertexMatrices, bones.length);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (maxBones &lt; bones.length) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: Skeleton has &#x27;</span> + bones.length + <span class="string">&#x27; bones. This GPU supports &#x27;</span> + maxBones + <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> maxBones;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getParameters</span>(<span class="params">material, lights, shadows, scene, object</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> fog = scene.fog;</span><br><span class="line">            <span class="keyword">const</span> geometry = object.geometry;</span><br><span class="line">            <span class="keyword">const</span> environment = material.isMeshStandardMaterial ? scene.environment : <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">const</span> envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);</span><br><span class="line">            <span class="keyword">const</span> envMapCubeUVHeight = !!envMap &amp;&amp; envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">const</span> shaderID = shaderIDs[material.type]; <span class="comment">// heuristics to create shader parameters according to lights in the scene</span></span><br><span class="line">            <span class="comment">// (not to blow over maxLights budget)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> maxBones = object.isSkinnedMesh ? getMaxBones(object) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.precision !== <span class="literal">null</span>) &#123;</span><br><span class="line">                precision = capabilities.getMaxPrecision(material.precision);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (precision !== material.precision) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLProgram.getParameters:&#x27;</span>, material.precision, <span class="string">&#x27;not supported, using&#x27;</span>, precision, <span class="string">&#x27;instead.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;</span><br><span class="line">            <span class="keyword">const</span> morphTargetsCount = morphAttribute !== <span class="literal">undefined</span> ? morphAttribute.length : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> morphTextureStride = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (geometry.morphAttributes.position !== <span class="literal">undefined</span>) morphTextureStride = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (geometry.morphAttributes.normal !== <span class="literal">undefined</span>) morphTextureStride = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (geometry.morphAttributes.color !== <span class="literal">undefined</span>) morphTextureStride = <span class="number">3</span>; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> vertexShader, fragmentShader;</span><br><span class="line">            <span class="keyword">let</span> customVertexShaderID, customFragmentShaderID;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (shaderID) &#123;</span><br><span class="line">                <span class="keyword">const</span> shader = ShaderLib[shaderID];</span><br><span class="line">                vertexShader = shader.vertexShader;</span><br><span class="line">                fragmentShader = shader.fragmentShader;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                vertexShader = material.vertexShader;</span><br><span class="line">                fragmentShader = material.fragmentShader;</span><br><span class="line"></span><br><span class="line">                _customShaders.update(material);</span><br><span class="line"></span><br><span class="line">                customVertexShaderID = _customShaders.getVertexShaderID(material);</span><br><span class="line">                customFragmentShaderID = _customShaders.getFragmentShaderID(material);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> currentRenderTarget = renderer.getRenderTarget();</span><br><span class="line">            <span class="keyword">const</span> useAlphaTest = material.alphaTest &gt; <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> useClearcoat = material.clearcoat &gt; <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> parameters = &#123;</span><br><span class="line">                <span class="attr">isWebGL2</span>: isWebGL2,</span><br><span class="line">                <span class="attr">shaderID</span>: shaderID,</span><br><span class="line">                <span class="attr">shaderName</span>: material.type,</span><br><span class="line">                <span class="attr">vertexShader</span>: vertexShader,</span><br><span class="line">                <span class="attr">fragmentShader</span>: fragmentShader,</span><br><span class="line">                <span class="attr">defines</span>: material.defines,</span><br><span class="line">                <span class="attr">customVertexShaderID</span>: customVertexShaderID,</span><br><span class="line">                <span class="attr">customFragmentShaderID</span>: customFragmentShaderID,</span><br><span class="line">                <span class="attr">isRawShaderMaterial</span>: material.isRawShaderMaterial === <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">glslVersion</span>: material.glslVersion,</span><br><span class="line">                <span class="attr">precision</span>: precision,</span><br><span class="line">                <span class="attr">instancing</span>: object.isInstancedMesh === <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">instancingColor</span>: object.isInstancedMesh === <span class="literal">true</span> &amp;&amp; object.instanceColor !== <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">supportsVertexTextures</span>: vertexTextures,</span><br><span class="line">                <span class="attr">outputEncoding</span>: currentRenderTarget === <span class="literal">null</span> ? renderer.outputEncoding : currentRenderTarget.isXRRenderTarget === <span class="literal">true</span> ? currentRenderTarget.texture.encoding : LinearEncoding,</span><br><span class="line">                <span class="attr">map</span>: !!material.map,</span><br><span class="line">                <span class="attr">matcap</span>: !!material.matcap,</span><br><span class="line">                <span class="attr">envMap</span>: !!envMap,</span><br><span class="line">                <span class="attr">envMapMode</span>: envMap &amp;&amp; envMap.mapping,</span><br><span class="line">                <span class="attr">envMapCubeUVHeight</span>: envMapCubeUVHeight,</span><br><span class="line">                <span class="attr">lightMap</span>: !!material.lightMap,</span><br><span class="line">                <span class="attr">aoMap</span>: !!material.aoMap,</span><br><span class="line">                <span class="attr">emissiveMap</span>: !!material.emissiveMap,</span><br><span class="line">                <span class="attr">bumpMap</span>: !!material.bumpMap,</span><br><span class="line">                <span class="attr">normalMap</span>: !!material.normalMap,</span><br><span class="line">                <span class="attr">objectSpaceNormalMap</span>: material.normalMapType === ObjectSpaceNormalMap,</span><br><span class="line">                <span class="attr">tangentSpaceNormalMap</span>: material.normalMapType === TangentSpaceNormalMap,</span><br><span class="line">                <span class="attr">decodeVideoTexture</span>: !!material.map &amp;&amp; material.map.isVideoTexture === <span class="literal">true</span> &amp;&amp; material.map.encoding === sRGBEncoding,</span><br><span class="line">                <span class="attr">clearcoat</span>: useClearcoat,</span><br><span class="line">                <span class="attr">clearcoatMap</span>: useClearcoat &amp;&amp; !!material.clearcoatMap,</span><br><span class="line">                <span class="attr">clearcoatRoughnessMap</span>: useClearcoat &amp;&amp; !!material.clearcoatRoughnessMap,</span><br><span class="line">                <span class="attr">clearcoatNormalMap</span>: useClearcoat &amp;&amp; !!material.clearcoatNormalMap,</span><br><span class="line">                <span class="attr">displacementMap</span>: !!material.displacementMap,</span><br><span class="line">                <span class="attr">roughnessMap</span>: !!material.roughnessMap,</span><br><span class="line">                <span class="attr">metalnessMap</span>: !!material.metalnessMap,</span><br><span class="line">                <span class="attr">specularMap</span>: !!material.specularMap,</span><br><span class="line">                <span class="attr">specularIntensityMap</span>: !!material.specularIntensityMap,</span><br><span class="line">                <span class="attr">specularColorMap</span>: !!material.specularColorMap,</span><br><span class="line">                <span class="attr">opaque</span>: material.transparent === <span class="literal">false</span> &amp;&amp; material.blending === NormalBlending,</span><br><span class="line">                <span class="attr">alphaMap</span>: !!material.alphaMap,</span><br><span class="line">                <span class="attr">alphaTest</span>: useAlphaTest,</span><br><span class="line">                <span class="attr">gradientMap</span>: !!material.gradientMap,</span><br><span class="line">                <span class="attr">sheen</span>: material.sheen &gt; <span class="number">0</span>,</span><br><span class="line">                <span class="attr">sheenColorMap</span>: !!material.sheenColorMap,</span><br><span class="line">                <span class="attr">sheenRoughnessMap</span>: !!material.sheenRoughnessMap,</span><br><span class="line">                <span class="attr">transmission</span>: material.transmission &gt; <span class="number">0</span>,</span><br><span class="line">                <span class="attr">transmissionMap</span>: !!material.transmissionMap,</span><br><span class="line">                <span class="attr">thicknessMap</span>: !!material.thicknessMap,</span><br><span class="line">                <span class="attr">combine</span>: material.combine,</span><br><span class="line">                <span class="attr">vertexTangents</span>: !!material.normalMap &amp;&amp; !!geometry.attributes.tangent,</span><br><span class="line">                <span class="attr">vertexColors</span>: material.vertexColors,</span><br><span class="line">                <span class="attr">vertexAlphas</span>: material.vertexColors === <span class="literal">true</span> &amp;&amp; !!geometry.attributes.color &amp;&amp; geometry.attributes.color.itemSize === <span class="number">4</span>,</span><br><span class="line">                <span class="attr">vertexUvs</span>: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || !!material.sheenRoughnessMap,</span><br><span class="line">                <span class="attr">uvsVertexOnly</span>: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || material.transmission &gt; <span class="number">0</span> || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || material.sheen &gt; <span class="number">0</span> || !!material.sheenColorMap || !!material.sheenRoughnessMap) &amp;&amp; !!material.displacementMap,</span><br><span class="line">                <span class="attr">fog</span>: !!fog,</span><br><span class="line">                <span class="attr">useFog</span>: material.fog,</span><br><span class="line">                <span class="attr">fogExp2</span>: fog &amp;&amp; fog.isFogExp2,</span><br><span class="line">                <span class="attr">flatShading</span>: !!material.flatShading,</span><br><span class="line">                <span class="attr">sizeAttenuation</span>: material.sizeAttenuation,</span><br><span class="line">                <span class="attr">logarithmicDepthBuffer</span>: logarithmicDepthBuffer,</span><br><span class="line">                <span class="attr">skinning</span>: object.isSkinnedMesh === <span class="literal">true</span> &amp;&amp; maxBones &gt; <span class="number">0</span>,</span><br><span class="line">                <span class="attr">maxBones</span>: maxBones,</span><br><span class="line">                <span class="attr">useVertexTexture</span>: floatVertexTextures,</span><br><span class="line">                <span class="attr">morphTargets</span>: geometry.morphAttributes.position !== <span class="literal">undefined</span>,</span><br><span class="line">                <span class="attr">morphNormals</span>: geometry.morphAttributes.normal !== <span class="literal">undefined</span>,</span><br><span class="line">                <span class="attr">morphColors</span>: geometry.morphAttributes.color !== <span class="literal">undefined</span>,</span><br><span class="line">                <span class="attr">morphTargetsCount</span>: morphTargetsCount,</span><br><span class="line">                <span class="attr">morphTextureStride</span>: morphTextureStride,</span><br><span class="line">                <span class="attr">numDirLights</span>: lights.directional.length,</span><br><span class="line">                <span class="attr">numPointLights</span>: lights.point.length,</span><br><span class="line">                <span class="attr">numSpotLights</span>: lights.spot.length,</span><br><span class="line">                <span class="attr">numRectAreaLights</span>: lights.rectArea.length,</span><br><span class="line">                <span class="attr">numHemiLights</span>: lights.hemi.length,</span><br><span class="line">                <span class="attr">numDirLightShadows</span>: lights.directionalShadowMap.length,</span><br><span class="line">                <span class="attr">numPointLightShadows</span>: lights.pointShadowMap.length,</span><br><span class="line">                <span class="attr">numSpotLightShadows</span>: lights.spotShadowMap.length,</span><br><span class="line">                <span class="attr">numClippingPlanes</span>: clipping.numPlanes,</span><br><span class="line">                <span class="attr">numClipIntersection</span>: clipping.numIntersection,</span><br><span class="line">                <span class="attr">dithering</span>: material.dithering,</span><br><span class="line">                <span class="attr">shadowMapEnabled</span>: renderer.shadowMap.enabled &amp;&amp; shadows.length &gt; <span class="number">0</span>,</span><br><span class="line">                <span class="attr">shadowMapType</span>: renderer.shadowMap.type,</span><br><span class="line">                <span class="attr">toneMapping</span>: material.toneMapped ? renderer.toneMapping : NoToneMapping,</span><br><span class="line">                <span class="attr">physicallyCorrectLights</span>: renderer.physicallyCorrectLights,</span><br><span class="line">                <span class="attr">premultipliedAlpha</span>: material.premultipliedAlpha,</span><br><span class="line">                <span class="attr">doubleSided</span>: material.side === DoubleSide,</span><br><span class="line">                <span class="attr">flipSided</span>: material.side === BackSide,</span><br><span class="line">                <span class="attr">depthPacking</span>: material.depthPacking !== <span class="literal">undefined</span> ? material.depthPacking : <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">index0AttributeName</span>: material.index0AttributeName,</span><br><span class="line">                <span class="attr">extensionDerivatives</span>: material.extensions &amp;&amp; material.extensions.derivatives,</span><br><span class="line">                <span class="attr">extensionFragDepth</span>: material.extensions &amp;&amp; material.extensions.fragDepth,</span><br><span class="line">                <span class="attr">extensionDrawBuffers</span>: material.extensions &amp;&amp; material.extensions.drawBuffers,</span><br><span class="line">                <span class="attr">extensionShaderTextureLOD</span>: material.extensions &amp;&amp; material.extensions.shaderTextureLOD,</span><br><span class="line">                <span class="attr">rendererExtensionFragDepth</span>: isWebGL2 || extensions.has(<span class="string">&#x27;EXT_frag_depth&#x27;</span>),</span><br><span class="line">                <span class="attr">rendererExtensionDrawBuffers</span>: isWebGL2 || extensions.has(<span class="string">&#x27;WEBGL_draw_buffers&#x27;</span>),</span><br><span class="line">                <span class="attr">rendererExtensionShaderTextureLod</span>: isWebGL2 || extensions.has(<span class="string">&#x27;EXT_shader_texture_lod&#x27;</span>),</span><br><span class="line">                <span class="attr">customProgramCacheKey</span>: material.customProgramCacheKey()</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> parameters;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getProgramCacheKey</span>(<span class="params">parameters</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> array = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (parameters.shaderID) &#123;</span><br><span class="line">                array.push(parameters.shaderID);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                array.push(parameters.customVertexShaderID);</span><br><span class="line">                array.push(parameters.customFragmentShaderID);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (parameters.defines !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> parameters.defines) &#123;</span><br><span class="line">                    array.push(name);</span><br><span class="line">                    array.push(parameters.defines[name]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (parameters.isRawShaderMaterial === <span class="literal">false</span>) &#123;</span><br><span class="line">                getProgramCacheKeyParameters(array, parameters);</span><br><span class="line">                getProgramCacheKeyBooleans(array, parameters);</span><br><span class="line">                array.push(renderer.outputEncoding);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            array.push(parameters.customProgramCacheKey);</span><br><span class="line">            <span class="keyword">return</span> array.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getProgramCacheKeyParameters</span>(<span class="params">array, parameters</span>) </span>&#123;</span><br><span class="line">            array.push(parameters.precision);</span><br><span class="line">            array.push(parameters.outputEncoding);</span><br><span class="line">            array.push(parameters.envMapMode);</span><br><span class="line">            array.push(parameters.envMapCubeUVHeight);</span><br><span class="line">            array.push(parameters.combine);</span><br><span class="line">            array.push(parameters.vertexUvs);</span><br><span class="line">            array.push(parameters.fogExp2);</span><br><span class="line">            array.push(parameters.sizeAttenuation);</span><br><span class="line">            array.push(parameters.maxBones);</span><br><span class="line">            array.push(parameters.morphTargetsCount);</span><br><span class="line">            array.push(parameters.morphAttributeCount);</span><br><span class="line">            array.push(parameters.numDirLights);</span><br><span class="line">            array.push(parameters.numPointLights);</span><br><span class="line">            array.push(parameters.numSpotLights);</span><br><span class="line">            array.push(parameters.numHemiLights);</span><br><span class="line">            array.push(parameters.numRectAreaLights);</span><br><span class="line">            array.push(parameters.numDirLightShadows);</span><br><span class="line">            array.push(parameters.numPointLightShadows);</span><br><span class="line">            array.push(parameters.numSpotLightShadows);</span><br><span class="line">            array.push(parameters.shadowMapType);</span><br><span class="line">            array.push(parameters.toneMapping);</span><br><span class="line">            array.push(parameters.numClippingPlanes);</span><br><span class="line">            array.push(parameters.numClipIntersection);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getProgramCacheKeyBooleans</span>(<span class="params">array, parameters</span>) </span>&#123;</span><br><span class="line">            _programLayers.disableAll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (parameters.isWebGL2) _programLayers.enable(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.supportsVertexTextures) _programLayers.enable(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.instancing) _programLayers.enable(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.instancingColor) _programLayers.enable(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.map) _programLayers.enable(<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.matcap) _programLayers.enable(<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.envMap) _programLayers.enable(<span class="number">6</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.lightMap) _programLayers.enable(<span class="number">7</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.aoMap) _programLayers.enable(<span class="number">8</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.emissiveMap) _programLayers.enable(<span class="number">9</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.bumpMap) _programLayers.enable(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.normalMap) _programLayers.enable(<span class="number">11</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.objectSpaceNormalMap) _programLayers.enable(<span class="number">12</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.tangentSpaceNormalMap) _programLayers.enable(<span class="number">13</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.clearcoat) _programLayers.enable(<span class="number">14</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.clearcoatMap) _programLayers.enable(<span class="number">15</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.clearcoatRoughnessMap) _programLayers.enable(<span class="number">16</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.clearcoatNormalMap) _programLayers.enable(<span class="number">17</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.displacementMap) _programLayers.enable(<span class="number">18</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.specularMap) _programLayers.enable(<span class="number">19</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.roughnessMap) _programLayers.enable(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.metalnessMap) _programLayers.enable(<span class="number">21</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.gradientMap) _programLayers.enable(<span class="number">22</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.alphaMap) _programLayers.enable(<span class="number">23</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.alphaTest) _programLayers.enable(<span class="number">24</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.vertexColors) _programLayers.enable(<span class="number">25</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.vertexAlphas) _programLayers.enable(<span class="number">26</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.vertexUvs) _programLayers.enable(<span class="number">27</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.vertexTangents) _programLayers.enable(<span class="number">28</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.uvsVertexOnly) _programLayers.enable(<span class="number">29</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.fog) _programLayers.enable(<span class="number">30</span>);</span><br><span class="line">            array.push(_programLayers.mask);</span><br><span class="line"></span><br><span class="line">            _programLayers.disableAll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (parameters.useFog) _programLayers.enable(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.flatShading) _programLayers.enable(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.logarithmicDepthBuffer) _programLayers.enable(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.skinning) _programLayers.enable(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.useVertexTexture) _programLayers.enable(<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.morphTargets) _programLayers.enable(<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.morphNormals) _programLayers.enable(<span class="number">6</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.morphColors) _programLayers.enable(<span class="number">7</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.premultipliedAlpha) _programLayers.enable(<span class="number">8</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.shadowMapEnabled) _programLayers.enable(<span class="number">9</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.physicallyCorrectLights) _programLayers.enable(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.doubleSided) _programLayers.enable(<span class="number">11</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.flipSided) _programLayers.enable(<span class="number">12</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.depthPacking) _programLayers.enable(<span class="number">13</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.dithering) _programLayers.enable(<span class="number">14</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.specularIntensityMap) _programLayers.enable(<span class="number">15</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.specularColorMap) _programLayers.enable(<span class="number">16</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.transmission) _programLayers.enable(<span class="number">17</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.transmissionMap) _programLayers.enable(<span class="number">18</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.thicknessMap) _programLayers.enable(<span class="number">19</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.sheen) _programLayers.enable(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.sheenColorMap) _programLayers.enable(<span class="number">21</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.sheenRoughnessMap) _programLayers.enable(<span class="number">22</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.decodeVideoTexture) _programLayers.enable(<span class="number">23</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameters.opaque) _programLayers.enable(<span class="number">24</span>);</span><br><span class="line">            array.push(_programLayers.mask);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getUniforms</span>(<span class="params">material</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> shaderID = shaderIDs[material.type];</span><br><span class="line">            <span class="keyword">let</span> uniforms;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (shaderID) &#123;</span><br><span class="line">                <span class="keyword">const</span> shader = ShaderLib[shaderID];</span><br><span class="line">                uniforms = UniformsUtils.clone(shader.uniforms);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                uniforms = material.uniforms;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> uniforms;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">acquireProgram</span>(<span class="params">parameters, cacheKey</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> program; <span class="comment">// Check if code has been already compiled</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> p = <span class="number">0</span>, pl = programs.length; p &lt; pl; p++) &#123;</span><br><span class="line">                <span class="keyword">const</span> preexistingProgram = programs[p];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (preexistingProgram.cacheKey === cacheKey) &#123;</span><br><span class="line">                    program = preexistingProgram;</span><br><span class="line">                    ++program.usedTimes;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (program === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                program = <span class="keyword">new</span> WebGLProgram(renderer, cacheKey, parameters, bindingStates);</span><br><span class="line">                programs.push(program);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> program;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">releaseProgram</span>(<span class="params">program</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (--program.usedTimes === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Remove from unordered set</span></span><br><span class="line">                <span class="keyword">const</span> i = programs.indexOf(program);</span><br><span class="line">                programs[i] = programs[programs.length - <span class="number">1</span>];</span><br><span class="line">                programs.pop(); <span class="comment">// Free WebGL resources</span></span><br><span class="line"></span><br><span class="line">                program.destroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">releaseShaderCache</span>(<span class="params">material</span>) </span>&#123;</span><br><span class="line">            _customShaders.remove(material);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">dispose</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            _customShaders.dispose();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">getParameters</span>: getParameters,</span><br><span class="line">            <span class="attr">getProgramCacheKey</span>: getProgramCacheKey,</span><br><span class="line">            <span class="attr">getUniforms</span>: getUniforms,</span><br><span class="line">            <span class="attr">acquireProgram</span>: acquireProgram,</span><br><span class="line">            <span class="attr">releaseProgram</span>: releaseProgram,</span><br><span class="line">            <span class="attr">releaseShaderCache</span>: releaseShaderCache,</span><br><span class="line">            <span class="comment">// Exposed for resource monitoring &amp; error feedback via renderer.info:</span></span><br><span class="line">            <span class="attr">programs</span>: programs,</span><br><span class="line">            <span class="attr">dispose</span>: dispose</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLProperties</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> properties = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> map = properties.get(object);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (map === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                map = &#123;&#125;;</span><br><span class="line">                properties.set(object, map);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">            properties.delete(object);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">object, key, value</span>) </span>&#123;</span><br><span class="line">            properties.get(object)[key] = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">dispose</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            properties = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">get</span>: get,</span><br><span class="line">            <span class="attr">remove</span>: remove,</span><br><span class="line">            <span class="attr">update</span>: update,</span><br><span class="line">            <span class="attr">dispose</span>: dispose</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">painterSortStable</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.groupOrder !== b.groupOrder) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.groupOrder - b.groupOrder;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.renderOrder !== b.renderOrder) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.renderOrder - b.renderOrder;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.material.id !== b.material.id) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.material.id - b.material.id;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.z !== b.z) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.z - b.z;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a.id - b.id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reversePainterSortStable</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.groupOrder !== b.groupOrder) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.groupOrder - b.groupOrder;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.renderOrder !== b.renderOrder) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.renderOrder - b.renderOrder;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.z !== b.z) &#123;</span><br><span class="line">            <span class="keyword">return</span> b.z - a.z;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a.id - b.id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLRenderList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> renderItems = [];</span><br><span class="line">        <span class="keyword">let</span> renderItemsIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> opaque = [];</span><br><span class="line">        <span class="keyword">const</span> transmissive = [];</span><br><span class="line">        <span class="keyword">const</span> transparent = [];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            renderItemsIndex = <span class="number">0</span>;</span><br><span class="line">            opaque.length = <span class="number">0</span>;</span><br><span class="line">            transmissive.length = <span class="number">0</span>;</span><br><span class="line">            transparent.length = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getNextRenderItem</span>(<span class="params">object, geometry, material, groupOrder, z, group</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> renderItem = renderItems[renderItemsIndex];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (renderItem === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                renderItem = &#123;</span><br><span class="line">                    <span class="attr">id</span>: object.id,</span><br><span class="line">                    <span class="attr">object</span>: object,</span><br><span class="line">                    <span class="attr">geometry</span>: geometry,</span><br><span class="line">                    <span class="attr">material</span>: material,</span><br><span class="line">                    <span class="attr">groupOrder</span>: groupOrder,</span><br><span class="line">                    <span class="attr">renderOrder</span>: object.renderOrder,</span><br><span class="line">                    <span class="attr">z</span>: z,</span><br><span class="line">                    <span class="attr">group</span>: group</span><br><span class="line">                &#125;;</span><br><span class="line">                renderItems[renderItemsIndex] = renderItem;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                renderItem.id = object.id;</span><br><span class="line">                renderItem.object = object;</span><br><span class="line">                renderItem.geometry = geometry;</span><br><span class="line">                renderItem.material = material;</span><br><span class="line">                renderItem.groupOrder = groupOrder;</span><br><span class="line">                renderItem.renderOrder = object.renderOrder;</span><br><span class="line">                renderItem.z = z;</span><br><span class="line">                renderItem.group = group;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            renderItemsIndex++;</span><br><span class="line">            <span class="keyword">return</span> renderItem;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">object, geometry, material, groupOrder, z, group</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.transmission &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">                transmissive.push(renderItem);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.transparent === <span class="literal">true</span>) &#123;</span><br><span class="line">                transparent.push(renderItem);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                opaque.push(renderItem);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">unshift</span>(<span class="params">object, geometry, material, groupOrder, z, group</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.transmission &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">                transmissive.unshift(renderItem);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.transparent === <span class="literal">true</span>) &#123;</span><br><span class="line">                transparent.unshift(renderItem);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                opaque.unshift(renderItem);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">customOpaqueSort, customTransparentSort</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (opaque.length &gt; <span class="number">1</span>) opaque.sort(customOpaqueSort || painterSortStable);</span><br><span class="line">            <span class="keyword">if</span> (transmissive.length &gt; <span class="number">1</span>) transmissive.sort(customTransparentSort || reversePainterSortStable);</span><br><span class="line">            <span class="keyword">if</span> (transparent.length &gt; <span class="number">1</span>) transparent.sort(customTransparentSort || reversePainterSortStable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">finish</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// Clear references from inactive renderItems in the list</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = renderItemsIndex, il = renderItems.length; i &lt; il; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> renderItem = renderItems[i];</span><br><span class="line">                <span class="keyword">if</span> (renderItem.id === <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">                renderItem.id = <span class="literal">null</span>;</span><br><span class="line">                renderItem.object = <span class="literal">null</span>;</span><br><span class="line">                renderItem.geometry = <span class="literal">null</span>;</span><br><span class="line">                renderItem.material = <span class="literal">null</span>;</span><br><span class="line">                renderItem.group = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">opaque</span>: opaque,</span><br><span class="line">            <span class="attr">transmissive</span>: transmissive,</span><br><span class="line">            <span class="attr">transparent</span>: transparent,</span><br><span class="line">            <span class="attr">init</span>: init,</span><br><span class="line">            <span class="attr">push</span>: push,</span><br><span class="line">            <span class="attr">unshift</span>: unshift,</span><br><span class="line">            <span class="attr">finish</span>: finish,</span><br><span class="line">            <span class="attr">sort</span>: sort</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLRenderLists</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> lists = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">scene, renderCallDepth</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> list;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (lists.has(scene) === <span class="literal">false</span>) &#123;</span><br><span class="line">                list = <span class="keyword">new</span> WebGLRenderList();</span><br><span class="line">                lists.set(scene, [list]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (renderCallDepth &gt;= lists.get(scene).length) &#123;</span><br><span class="line">                    list = <span class="keyword">new</span> WebGLRenderList();</span><br><span class="line">                    lists.get(scene).push(list);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    list = lists.get(scene)[renderCallDepth];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">dispose</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            lists = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">get</span>: get,</span><br><span class="line">            <span class="attr">dispose</span>: dispose</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">UniformsCache</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> lights = &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params">light</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (lights[light.id] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> lights[light.id];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> uniforms;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (light.type) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;DirectionalLight&#x27;</span>:</span><br><span class="line">                        uniforms = &#123;</span><br><span class="line">                            <span class="attr">direction</span>: <span class="keyword">new</span> Vector3(),</span><br><span class="line">                            <span class="attr">color</span>: <span class="keyword">new</span> Color()</span><br><span class="line">                        &#125;;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;SpotLight&#x27;</span>:</span><br><span class="line">                        uniforms = &#123;</span><br><span class="line">                            <span class="attr">position</span>: <span class="keyword">new</span> Vector3(),</span><br><span class="line">                            <span class="attr">direction</span>: <span class="keyword">new</span> Vector3(),</span><br><span class="line">                            <span class="attr">color</span>: <span class="keyword">new</span> Color(),</span><br><span class="line">                            <span class="attr">distance</span>: <span class="number">0</span>,</span><br><span class="line">                            <span class="attr">coneCos</span>: <span class="number">0</span>,</span><br><span class="line">                            <span class="attr">penumbraCos</span>: <span class="number">0</span>,</span><br><span class="line">                            <span class="attr">decay</span>: <span class="number">0</span></span><br><span class="line">                        &#125;;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;PointLight&#x27;</span>:</span><br><span class="line">                        uniforms = &#123;</span><br><span class="line">                            <span class="attr">position</span>: <span class="keyword">new</span> Vector3(),</span><br><span class="line">                            <span class="attr">color</span>: <span class="keyword">new</span> Color(),</span><br><span class="line">                            <span class="attr">distance</span>: <span class="number">0</span>,</span><br><span class="line">                            <span class="attr">decay</span>: <span class="number">0</span></span><br><span class="line">                        &#125;;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;HemisphereLight&#x27;</span>:</span><br><span class="line">                        uniforms = &#123;</span><br><span class="line">                            <span class="attr">direction</span>: <span class="keyword">new</span> Vector3(),</span><br><span class="line">                            <span class="attr">skyColor</span>: <span class="keyword">new</span> Color(),</span><br><span class="line">                            <span class="attr">groundColor</span>: <span class="keyword">new</span> Color()</span><br><span class="line">                        &#125;;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;RectAreaLight&#x27;</span>:</span><br><span class="line">                        uniforms = &#123;</span><br><span class="line">                            <span class="attr">color</span>: <span class="keyword">new</span> Color(),</span><br><span class="line">                            <span class="attr">position</span>: <span class="keyword">new</span> Vector3(),</span><br><span class="line">                            <span class="attr">halfWidth</span>: <span class="keyword">new</span> Vector3(),</span><br><span class="line">                            <span class="attr">halfHeight</span>: <span class="keyword">new</span> Vector3()</span><br><span class="line">                        &#125;;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                lights[light.id] = uniforms;</span><br><span class="line">                <span class="keyword">return</span> uniforms;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ShadowUniformsCache</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> lights = &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params">light</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (lights[light.id] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> lights[light.id];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> uniforms;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (light.type) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;DirectionalLight&#x27;</span>:</span><br><span class="line">                        uniforms = &#123;</span><br><span class="line">                            <span class="attr">shadowBias</span>: <span class="number">0</span>,</span><br><span class="line">                            <span class="attr">shadowNormalBias</span>: <span class="number">0</span>,</span><br><span class="line">                            <span class="attr">shadowRadius</span>: <span class="number">1</span>,</span><br><span class="line">                            <span class="attr">shadowMapSize</span>: <span class="keyword">new</span> Vector2()</span><br><span class="line">                        &#125;;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;SpotLight&#x27;</span>:</span><br><span class="line">                        uniforms = &#123;</span><br><span class="line">                            <span class="attr">shadowBias</span>: <span class="number">0</span>,</span><br><span class="line">                            <span class="attr">shadowNormalBias</span>: <span class="number">0</span>,</span><br><span class="line">                            <span class="attr">shadowRadius</span>: <span class="number">1</span>,</span><br><span class="line">                            <span class="attr">shadowMapSize</span>: <span class="keyword">new</span> Vector2()</span><br><span class="line">                        &#125;;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;PointLight&#x27;</span>:</span><br><span class="line">                        uniforms = &#123;</span><br><span class="line">                            <span class="attr">shadowBias</span>: <span class="number">0</span>,</span><br><span class="line">                            <span class="attr">shadowNormalBias</span>: <span class="number">0</span>,</span><br><span class="line">                            <span class="attr">shadowRadius</span>: <span class="number">1</span>,</span><br><span class="line">                            <span class="attr">shadowMapSize</span>: <span class="keyword">new</span> Vector2(),</span><br><span class="line">                            <span class="attr">shadowCameraNear</span>: <span class="number">1</span>,</span><br><span class="line">                            <span class="attr">shadowCameraFar</span>: <span class="number">1000</span></span><br><span class="line">                        &#125;;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// TODO (abelnation): set RectAreaLight shadow uniforms</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                lights[light.id] = uniforms;</span><br><span class="line">                <span class="keyword">return</span> uniforms;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> nextVersion = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">shadowCastingLightsFirst</span>(<span class="params">lightA, lightB</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (lightB.castShadow ? <span class="number">1</span> : <span class="number">0</span>) - (lightA.castShadow ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLLights</span>(<span class="params">extensions, capabilities</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="keyword">new</span> UniformsCache();</span><br><span class="line">        <span class="keyword">const</span> shadowCache = ShadowUniformsCache();</span><br><span class="line">        <span class="keyword">const</span> state = &#123;</span><br><span class="line">            <span class="attr">version</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">hash</span>: &#123;</span><br><span class="line">                <span class="attr">directionalLength</span>: -<span class="number">1</span>,</span><br><span class="line">                <span class="attr">pointLength</span>: -<span class="number">1</span>,</span><br><span class="line">                <span class="attr">spotLength</span>: -<span class="number">1</span>,</span><br><span class="line">                <span class="attr">rectAreaLength</span>: -<span class="number">1</span>,</span><br><span class="line">                <span class="attr">hemiLength</span>: -<span class="number">1</span>,</span><br><span class="line">                <span class="attr">numDirectionalShadows</span>: -<span class="number">1</span>,</span><br><span class="line">                <span class="attr">numPointShadows</span>: -<span class="number">1</span>,</span><br><span class="line">                <span class="attr">numSpotShadows</span>: -<span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">ambient</span>: [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">            <span class="attr">probe</span>: [],</span><br><span class="line">            <span class="attr">directional</span>: [],</span><br><span class="line">            <span class="attr">directionalShadow</span>: [],</span><br><span class="line">            <span class="attr">directionalShadowMap</span>: [],</span><br><span class="line">            <span class="attr">directionalShadowMatrix</span>: [],</span><br><span class="line">            <span class="attr">spot</span>: [],</span><br><span class="line">            <span class="attr">spotShadow</span>: [],</span><br><span class="line">            <span class="attr">spotShadowMap</span>: [],</span><br><span class="line">            <span class="attr">spotShadowMatrix</span>: [],</span><br><span class="line">            <span class="attr">rectArea</span>: [],</span><br><span class="line">            <span class="attr">rectAreaLTC1</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">rectAreaLTC2</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">point</span>: [],</span><br><span class="line">            <span class="attr">pointShadow</span>: [],</span><br><span class="line">            <span class="attr">pointShadowMap</span>: [],</span><br><span class="line">            <span class="attr">pointShadowMatrix</span>: [],</span><br><span class="line">            <span class="attr">hemi</span>: []</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) state.probe.push(<span class="keyword">new</span> Vector3());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> vector3 = <span class="keyword">new</span> Vector3();</span><br><span class="line">        <span class="keyword">const</span> matrix4 = <span class="keyword">new</span> Matrix4();</span><br><span class="line">        <span class="keyword">const</span> matrix42 = <span class="keyword">new</span> Matrix4();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setup</span>(<span class="params">lights, physicallyCorrectLights</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> r = <span class="number">0</span>,</span><br><span class="line">                g = <span class="number">0</span>,</span><br><span class="line">                b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) state.probe[i].set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> directionalLength = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> pointLength = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> spotLength = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> rectAreaLength = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> hemiLength = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> numDirectionalShadows = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> numPointShadows = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> numSpotShadows = <span class="number">0</span>;</span><br><span class="line">            lights.sort(shadowCastingLightsFirst); <span class="comment">// artist-friendly light intensity scaling factor</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> scaleFactor = physicallyCorrectLights !== <span class="literal">true</span> ? <span class="built_in">Math</span>.PI : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = lights.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> light = lights[i];</span><br><span class="line">                <span class="keyword">const</span> color = light.color;</span><br><span class="line">                <span class="keyword">const</span> intensity = light.intensity;</span><br><span class="line">                <span class="keyword">const</span> distance = light.distance;</span><br><span class="line">                <span class="keyword">const</span> shadowMap = light.shadow &amp;&amp; light.shadow.map ? light.shadow.map.texture : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (light.isAmbientLight) &#123;</span><br><span class="line">                    r += color.r * intensity * scaleFactor;</span><br><span class="line">                    g += color.g * intensity * scaleFactor;</span><br><span class="line">                    b += color.b * intensity * scaleFactor;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (light.isLightProbe) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                        state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (light.isDirectionalLight) &#123;</span><br><span class="line">                    <span class="keyword">const</span> uniforms = cache.get(light);</span><br><span class="line">                    uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (light.castShadow) &#123;</span><br><span class="line">                        <span class="keyword">const</span> shadow = light.shadow;</span><br><span class="line">                        <span class="keyword">const</span> shadowUniforms = shadowCache.get(light);</span><br><span class="line">                        shadowUniforms.shadowBias = shadow.bias;</span><br><span class="line">                        shadowUniforms.shadowNormalBias = shadow.normalBias;</span><br><span class="line">                        shadowUniforms.shadowRadius = shadow.radius;</span><br><span class="line">                        shadowUniforms.shadowMapSize = shadow.mapSize;</span><br><span class="line">                        state.directionalShadow[directionalLength] = shadowUniforms;</span><br><span class="line">                        state.directionalShadowMap[directionalLength] = shadowMap;</span><br><span class="line">                        state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;</span><br><span class="line">                        numDirectionalShadows++;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    state.directional[directionalLength] = uniforms;</span><br><span class="line">                    directionalLength++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (light.isSpotLight) &#123;</span><br><span class="line">                    <span class="keyword">const</span> uniforms = cache.get(light);</span><br><span class="line">                    uniforms.position.setFromMatrixPosition(light.matrixWorld);</span><br><span class="line">                    uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);</span><br><span class="line">                    uniforms.distance = distance;</span><br><span class="line">                    uniforms.coneCos = <span class="built_in">Math</span>.cos(light.angle);</span><br><span class="line">                    uniforms.penumbraCos = <span class="built_in">Math</span>.cos(light.angle * (<span class="number">1</span> - light.penumbra));</span><br><span class="line">                    uniforms.decay = light.decay;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (light.castShadow) &#123;</span><br><span class="line">                        <span class="keyword">const</span> shadow = light.shadow;</span><br><span class="line">                        <span class="keyword">const</span> shadowUniforms = shadowCache.get(light);</span><br><span class="line">                        shadowUniforms.shadowBias = shadow.bias;</span><br><span class="line">                        shadowUniforms.shadowNormalBias = shadow.normalBias;</span><br><span class="line">                        shadowUniforms.shadowRadius = shadow.radius;</span><br><span class="line">                        shadowUniforms.shadowMapSize = shadow.mapSize;</span><br><span class="line">                        state.spotShadow[spotLength] = shadowUniforms;</span><br><span class="line">                        state.spotShadowMap[spotLength] = shadowMap;</span><br><span class="line">                        state.spotShadowMatrix[spotLength] = light.shadow.matrix;</span><br><span class="line">                        numSpotShadows++;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    state.spot[spotLength] = uniforms;</span><br><span class="line">                    spotLength++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (light.isRectAreaLight) &#123;</span><br><span class="line">                    <span class="keyword">const</span> uniforms = cache.get(light); <span class="comment">// (a) intensity is the total visible light emitted</span></span><br><span class="line">                    <span class="comment">//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );</span></span><br><span class="line">                    <span class="comment">// (b) intensity is the brightness of the light</span></span><br><span class="line"></span><br><span class="line">                    uniforms.color.copy(color).multiplyScalar(intensity);</span><br><span class="line">                    uniforms.halfWidth.set(light.width * <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">                    uniforms.halfHeight.set(<span class="number">0.0</span>, light.height * <span class="number">0.5</span>, <span class="number">0.0</span>);</span><br><span class="line">                    state.rectArea[rectAreaLength] = uniforms;</span><br><span class="line">                    rectAreaLength++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (light.isPointLight) &#123;</span><br><span class="line">                    <span class="keyword">const</span> uniforms = cache.get(light);</span><br><span class="line">                    uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);</span><br><span class="line">                    uniforms.distance = light.distance;</span><br><span class="line">                    uniforms.decay = light.decay;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (light.castShadow) &#123;</span><br><span class="line">                        <span class="keyword">const</span> shadow = light.shadow;</span><br><span class="line">                        <span class="keyword">const</span> shadowUniforms = shadowCache.get(light);</span><br><span class="line">                        shadowUniforms.shadowBias = shadow.bias;</span><br><span class="line">                        shadowUniforms.shadowNormalBias = shadow.normalBias;</span><br><span class="line">                        shadowUniforms.shadowRadius = shadow.radius;</span><br><span class="line">                        shadowUniforms.shadowMapSize = shadow.mapSize;</span><br><span class="line">                        shadowUniforms.shadowCameraNear = shadow.camera.near;</span><br><span class="line">                        shadowUniforms.shadowCameraFar = shadow.camera.far;</span><br><span class="line">                        state.pointShadow[pointLength] = shadowUniforms;</span><br><span class="line">                        state.pointShadowMap[pointLength] = shadowMap;</span><br><span class="line">                        state.pointShadowMatrix[pointLength] = light.shadow.matrix;</span><br><span class="line">                        numPointShadows++;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    state.point[pointLength] = uniforms;</span><br><span class="line">                    pointLength++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (light.isHemisphereLight) &#123;</span><br><span class="line">                    <span class="keyword">const</span> uniforms = cache.get(light);</span><br><span class="line">                    uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);</span><br><span class="line">                    uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);</span><br><span class="line">                    state.hemi[hemiLength] = uniforms;</span><br><span class="line">                    hemiLength++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rectAreaLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (capabilities.isWebGL2) &#123;</span><br><span class="line">                    <span class="comment">// WebGL 2</span></span><br><span class="line">                    state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;</span><br><span class="line">                    state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// WebGL 1</span></span><br><span class="line">                    <span class="keyword">if</span> (extensions.has(<span class="string">&#x27;OES_texture_float_linear&#x27;</span>) === <span class="literal">true</span>) &#123;</span><br><span class="line">                        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;</span><br><span class="line">                        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (extensions.has(<span class="string">&#x27;OES_texture_half_float_linear&#x27;</span>) === <span class="literal">true</span>) &#123;</span><br><span class="line">                        state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;</span><br><span class="line">                        state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.&#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            state.ambient[<span class="number">0</span>] = r;</span><br><span class="line">            state.ambient[<span class="number">1</span>] = g;</span><br><span class="line">            state.ambient[<span class="number">2</span>] = b;</span><br><span class="line">            <span class="keyword">const</span> hash = state.hash;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) &#123;</span><br><span class="line">                state.directional.length = directionalLength;</span><br><span class="line">                state.spot.length = spotLength;</span><br><span class="line">                state.rectArea.length = rectAreaLength;</span><br><span class="line">                state.point.length = pointLength;</span><br><span class="line">                state.hemi.length = hemiLength;</span><br><span class="line">                state.directionalShadow.length = numDirectionalShadows;</span><br><span class="line">                state.directionalShadowMap.length = numDirectionalShadows;</span><br><span class="line">                state.pointShadow.length = numPointShadows;</span><br><span class="line">                state.pointShadowMap.length = numPointShadows;</span><br><span class="line">                state.spotShadow.length = numSpotShadows;</span><br><span class="line">                state.spotShadowMap.length = numSpotShadows;</span><br><span class="line">                state.directionalShadowMatrix.length = numDirectionalShadows;</span><br><span class="line">                state.pointShadowMatrix.length = numPointShadows;</span><br><span class="line">                state.spotShadowMatrix.length = numSpotShadows;</span><br><span class="line">                hash.directionalLength = directionalLength;</span><br><span class="line">                hash.pointLength = pointLength;</span><br><span class="line">                hash.spotLength = spotLength;</span><br><span class="line">                hash.rectAreaLength = rectAreaLength;</span><br><span class="line">                hash.hemiLength = hemiLength;</span><br><span class="line">                hash.numDirectionalShadows = numDirectionalShadows;</span><br><span class="line">                hash.numPointShadows = numPointShadows;</span><br><span class="line">                hash.numSpotShadows = numSpotShadows;</span><br><span class="line">                state.version = nextVersion++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setupView</span>(<span class="params">lights, camera</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> directionalLength = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> pointLength = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> spotLength = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> rectAreaLength = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> hemiLength = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> viewMatrix = camera.matrixWorldInverse;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = lights.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> light = lights[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (light.isDirectionalLight) &#123;</span><br><span class="line">                    <span class="keyword">const</span> uniforms = state.directional[directionalLength];</span><br><span class="line">                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);</span><br><span class="line">                    vector3.setFromMatrixPosition(light.target.matrixWorld);</span><br><span class="line">                    uniforms.direction.sub(vector3);</span><br><span class="line">                    uniforms.direction.transformDirection(viewMatrix);</span><br><span class="line">                    directionalLength++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (light.isSpotLight) &#123;</span><br><span class="line">                    <span class="keyword">const</span> uniforms = state.spot[spotLength];</span><br><span class="line">                    uniforms.position.setFromMatrixPosition(light.matrixWorld);</span><br><span class="line">                    uniforms.position.applyMatrix4(viewMatrix);</span><br><span class="line">                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);</span><br><span class="line">                    vector3.setFromMatrixPosition(light.target.matrixWorld);</span><br><span class="line">                    uniforms.direction.sub(vector3);</span><br><span class="line">                    uniforms.direction.transformDirection(viewMatrix);</span><br><span class="line">                    spotLength++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (light.isRectAreaLight) &#123;</span><br><span class="line">                    <span class="keyword">const</span> uniforms = state.rectArea[rectAreaLength];</span><br><span class="line">                    uniforms.position.setFromMatrixPosition(light.matrixWorld);</span><br><span class="line">                    uniforms.position.applyMatrix4(viewMatrix); <span class="comment">// extract local rotation of light to derive width/height half vectors</span></span><br><span class="line"></span><br><span class="line">                    matrix42.identity();</span><br><span class="line">                    matrix4.copy(light.matrixWorld);</span><br><span class="line">                    matrix4.premultiply(viewMatrix);</span><br><span class="line">                    matrix42.extractRotation(matrix4);</span><br><span class="line">                    uniforms.halfWidth.set(light.width * <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">                    uniforms.halfHeight.set(<span class="number">0.0</span>, light.height * <span class="number">0.5</span>, <span class="number">0.0</span>);</span><br><span class="line">                    uniforms.halfWidth.applyMatrix4(matrix42);</span><br><span class="line">                    uniforms.halfHeight.applyMatrix4(matrix42);</span><br><span class="line">                    rectAreaLength++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (light.isPointLight) &#123;</span><br><span class="line">                    <span class="keyword">const</span> uniforms = state.point[pointLength];</span><br><span class="line">                    uniforms.position.setFromMatrixPosition(light.matrixWorld);</span><br><span class="line">                    uniforms.position.applyMatrix4(viewMatrix);</span><br><span class="line">                    pointLength++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (light.isHemisphereLight) &#123;</span><br><span class="line">                    <span class="keyword">const</span> uniforms = state.hemi[hemiLength];</span><br><span class="line">                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);</span><br><span class="line">                    uniforms.direction.transformDirection(viewMatrix);</span><br><span class="line">                    uniforms.direction.normalize();</span><br><span class="line">                    hemiLength++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">setup</span>: setup,</span><br><span class="line">            <span class="attr">setupView</span>: setupView,</span><br><span class="line">            <span class="attr">state</span>: state</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLRenderState</span>(<span class="params">extensions, capabilities</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> lights = <span class="keyword">new</span> WebGLLights(extensions, capabilities);</span><br><span class="line">        <span class="keyword">const</span> lightsArray = [];</span><br><span class="line">        <span class="keyword">const</span> shadowsArray = [];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            lightsArray.length = <span class="number">0</span>;</span><br><span class="line">            shadowsArray.length = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">pushLight</span>(<span class="params">light</span>) </span>&#123;</span><br><span class="line">            lightsArray.push(light);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">pushShadow</span>(<span class="params">shadowLight</span>) </span>&#123;</span><br><span class="line">            shadowsArray.push(shadowLight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setupLights</span>(<span class="params">physicallyCorrectLights</span>) </span>&#123;</span><br><span class="line">            lights.setup(lightsArray, physicallyCorrectLights);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setupLightsView</span>(<span class="params">camera</span>) </span>&#123;</span><br><span class="line">            lights.setupView(lightsArray, camera);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> state = &#123;</span><br><span class="line">            <span class="attr">lightsArray</span>: lightsArray,</span><br><span class="line">            <span class="attr">shadowsArray</span>: shadowsArray,</span><br><span class="line">            <span class="attr">lights</span>: lights</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">init</span>: init,</span><br><span class="line">            <span class="attr">state</span>: state,</span><br><span class="line">            <span class="attr">setupLights</span>: setupLights,</span><br><span class="line">            <span class="attr">setupLightsView</span>: setupLightsView,</span><br><span class="line">            <span class="attr">pushLight</span>: pushLight,</span><br><span class="line">            <span class="attr">pushShadow</span>: pushShadow</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLRenderStates</span>(<span class="params">extensions, capabilities</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> renderStates = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">scene, renderCallDepth = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> renderState;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (renderStates.has(scene) === <span class="literal">false</span>) &#123;</span><br><span class="line">                renderState = <span class="keyword">new</span> WebGLRenderState(extensions, capabilities);</span><br><span class="line">                renderStates.set(scene, [renderState]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (renderCallDepth &gt;= renderStates.get(scene).length) &#123;</span><br><span class="line">                    renderState = <span class="keyword">new</span> WebGLRenderState(extensions, capabilities);</span><br><span class="line">                    renderStates.get(scene).push(renderState);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    renderState = renderStates.get(scene)[renderCallDepth];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> renderState;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">dispose</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            renderStates = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">get</span>: get,</span><br><span class="line">            <span class="attr">dispose</span>: dispose</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MeshDepthMaterial</span> <span class="keyword">extends</span> <span class="title">Material</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameters</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;MeshDepthMaterial&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.depthPacking = BasicDepthPacking;</span><br><span class="line">            <span class="built_in">this</span>.map = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.alphaMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.displacementMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.displacementScale = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.displacementBias = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframe = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinewidth = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.fog = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.setValues(parameters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.depthPacking = source.depthPacking;</span><br><span class="line">            <span class="built_in">this</span>.map = source.map;</span><br><span class="line">            <span class="built_in">this</span>.alphaMap = source.alphaMap;</span><br><span class="line">            <span class="built_in">this</span>.displacementMap = source.displacementMap;</span><br><span class="line">            <span class="built_in">this</span>.displacementScale = source.displacementScale;</span><br><span class="line">            <span class="built_in">this</span>.displacementBias = source.displacementBias;</span><br><span class="line">            <span class="built_in">this</span>.wireframe = source.wireframe;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinewidth = source.wireframeLinewidth;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MeshDepthMaterial.prototype.isMeshDepthMaterial = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MeshDistanceMaterial</span> <span class="keyword">extends</span> <span class="title">Material</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameters</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;MeshDistanceMaterial&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.referencePosition = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="built_in">this</span>.nearDistance = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.farDistance = <span class="number">1000</span>;</span><br><span class="line">            <span class="built_in">this</span>.map = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.alphaMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.displacementMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.displacementScale = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.displacementBias = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.fog = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.setValues(parameters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.referencePosition.copy(source.referencePosition);</span><br><span class="line">            <span class="built_in">this</span>.nearDistance = source.nearDistance;</span><br><span class="line">            <span class="built_in">this</span>.farDistance = source.farDistance;</span><br><span class="line">            <span class="built_in">this</span>.map = source.map;</span><br><span class="line">            <span class="built_in">this</span>.alphaMap = source.alphaMap;</span><br><span class="line">            <span class="built_in">this</span>.displacementMap = source.displacementMap;</span><br><span class="line">            <span class="built_in">this</span>.displacementScale = source.displacementScale;</span><br><span class="line">            <span class="built_in">this</span>.displacementBias = source.displacementBias;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MeshDistanceMaterial.prototype.isMeshDistanceMaterial = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> vertex = <span class="string">&quot;void main() &#123;\n\tgl_Position = vec4( position, 1.0 );\n&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> fragment = <span class="string">&quot;uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include &lt;packing&gt;\nvoid main() &#123;\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples &lt;= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples &lt;= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i &lt; samples; i ++ ) &#123;\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t&#125;\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLShadowMap</span>(<span class="params">_renderer, _objects, _capabilities</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> _frustum = <span class="keyword">new</span> Frustum();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> _shadowMapSize = <span class="keyword">new</span> Vector2(),</span><br><span class="line">            _viewportSize = <span class="keyword">new</span> Vector2(),</span><br><span class="line">            _viewport = <span class="keyword">new</span> Vector4(),</span><br><span class="line">            _depthMaterial = <span class="keyword">new</span> MeshDepthMaterial(&#123;</span><br><span class="line">                <span class="attr">depthPacking</span>: RGBADepthPacking</span><br><span class="line">            &#125;),</span><br><span class="line">            _distanceMaterial = <span class="keyword">new</span> MeshDistanceMaterial(),</span><br><span class="line">            _materialCache = &#123;&#125;,</span><br><span class="line">            _maxTextureSize = _capabilities.maxTextureSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> shadowSide = &#123;</span><br><span class="line">            <span class="number">0</span>: BackSide,</span><br><span class="line">            <span class="number">1</span>: FrontSide,</span><br><span class="line">            <span class="number">2</span>: DoubleSide</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> shadowMaterialVertical = <span class="keyword">new</span> ShaderMaterial(&#123;</span><br><span class="line">            <span class="attr">defines</span>: &#123;</span><br><span class="line">                <span class="attr">VSM_SAMPLES</span>: <span class="number">8</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">uniforms</span>: &#123;</span><br><span class="line">                <span class="attr">shadow_pass</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="literal">null</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">resolution</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="keyword">new</span> Vector2()</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">radius</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="number">4.0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">vertexShader</span>: vertex,</span><br><span class="line">            <span class="attr">fragmentShader</span>: fragment</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">const</span> shadowMaterialHorizontal = shadowMaterialVertical.clone();</span><br><span class="line">        shadowMaterialHorizontal.defines.HORIZONTAL_PASS = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> fullScreenTri = <span class="keyword">new</span> BufferGeometry();</span><br><span class="line">        fullScreenTri.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> BufferAttribute(<span class="keyword">new</span> <span class="built_in">Float32Array</span>([-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0.5</span>, <span class="number">3</span>, -<span class="number">1</span>, <span class="number">0.5</span>, -<span class="number">1</span>, <span class="number">3</span>, <span class="number">0.5</span>]), <span class="number">3</span>));</span><br><span class="line">        <span class="keyword">const</span> fullScreenMesh = <span class="keyword">new</span> Mesh(fullScreenTri, shadowMaterialVertical);</span><br><span class="line">        <span class="keyword">const</span> scope = <span class="built_in">this</span>;</span><br><span class="line">        <span class="built_in">this</span>.enabled = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.autoUpdate = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.needsUpdate = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.type = PCFShadowMap;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.render = <span class="function"><span class="keyword">function</span> (<span class="params">lights, scene, camera</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (scope.enabled === <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (scope.autoUpdate === <span class="literal">false</span> &amp;&amp; scope.needsUpdate === <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (lights.length === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> currentRenderTarget = _renderer.getRenderTarget();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> activeCubeFace = _renderer.getActiveCubeFace();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> activeMipmapLevel = _renderer.getActiveMipmapLevel();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> _state = _renderer.state; <span class="comment">// Set GL state for depth map.</span></span><br><span class="line"></span><br><span class="line">            _state.setBlending(NoBlending);</span><br><span class="line"></span><br><span class="line">            _state.buffers.color.setClear(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            _state.buffers.depth.setTest(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            _state.setScissorTest(<span class="literal">false</span>); <span class="comment">// render depth map</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = lights.length; i &lt; il; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> light = lights[i];</span><br><span class="line">                <span class="keyword">const</span> shadow = light.shadow;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (shadow === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLShadowMap:&#x27;</span>, light, <span class="string">&#x27;has no shadow.&#x27;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (shadow.autoUpdate === <span class="literal">false</span> &amp;&amp; shadow.needsUpdate === <span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                _shadowMapSize.copy(shadow.mapSize);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> shadowFrameExtents = shadow.getFrameExtents();</span><br><span class="line"></span><br><span class="line">                _shadowMapSize.multiply(shadowFrameExtents);</span><br><span class="line"></span><br><span class="line">                _viewportSize.copy(shadow.mapSize);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (_shadowMapSize.x &gt; _maxTextureSize || _shadowMapSize.y &gt; _maxTextureSize) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (_shadowMapSize.x &gt; _maxTextureSize) &#123;</span><br><span class="line">                        _viewportSize.x = <span class="built_in">Math</span>.floor(_maxTextureSize / shadowFrameExtents.x);</span><br><span class="line">                        _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;</span><br><span class="line">                        shadow.mapSize.x = _viewportSize.x;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (_shadowMapSize.y &gt; _maxTextureSize) &#123;</span><br><span class="line">                        _viewportSize.y = <span class="built_in">Math</span>.floor(_maxTextureSize / shadowFrameExtents.y);</span><br><span class="line">                        _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;</span><br><span class="line">                        shadow.mapSize.y = _viewportSize.y;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (shadow.map === <span class="literal">null</span> &amp;&amp; !shadow.isPointLightShadow &amp;&amp; <span class="built_in">this</span>.type === VSMShadowMap) &#123;</span><br><span class="line">                    shadow.map = <span class="keyword">new</span> WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);</span><br><span class="line">                    shadow.map.texture.name = light.name + <span class="string">&#x27;.shadowMap&#x27;</span>;</span><br><span class="line">                    shadow.mapPass = <span class="keyword">new</span> WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);</span><br><span class="line">                    shadow.camera.updateProjectionMatrix();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (shadow.map === <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> pars = &#123;</span><br><span class="line">                        <span class="attr">minFilter</span>: NearestFilter,</span><br><span class="line">                        <span class="attr">magFilter</span>: NearestFilter,</span><br><span class="line">                        <span class="attr">format</span>: RGBAFormat</span><br><span class="line">                    &#125;;</span><br><span class="line">                    shadow.map = <span class="keyword">new</span> WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);</span><br><span class="line">                    shadow.map.texture.name = light.name + <span class="string">&#x27;.shadowMap&#x27;</span>;</span><br><span class="line">                    shadow.camera.updateProjectionMatrix();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                _renderer.setRenderTarget(shadow.map);</span><br><span class="line"></span><br><span class="line">                _renderer.clear();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> viewportCount = shadow.getViewportCount();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> vp = <span class="number">0</span>; vp &lt; viewportCount; vp++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> viewport = shadow.getViewport(vp);</span><br><span class="line"></span><br><span class="line">                    _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);</span><br><span class="line"></span><br><span class="line">                    _state.viewport(_viewport);</span><br><span class="line"></span><br><span class="line">                    shadow.updateMatrices(light, vp);</span><br><span class="line">                    _frustum = shadow.getFrustum();</span><br><span class="line">                    renderObject(scene, camera, shadow.camera, light, <span class="built_in">this</span>.type);</span><br><span class="line">                &#125; <span class="comment">// do blur pass for VSM</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!shadow.isPointLightShadow &amp;&amp; <span class="built_in">this</span>.type === VSMShadowMap) &#123;</span><br><span class="line">                    VSMPass(shadow, camera);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                shadow.needsUpdate = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            scope.needsUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">VSMPass</span>(<span class="params">shadow, camera</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> geometry = _objects.update(fullScreenMesh);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) &#123;</span><br><span class="line">                shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;</span><br><span class="line">                shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;</span><br><span class="line">                shadowMaterialVertical.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">                shadowMaterialHorizontal.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="comment">// vertical pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;</span><br><span class="line">            shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;</span><br><span class="line">            shadowMaterialVertical.uniforms.radius.value = shadow.radius;</span><br><span class="line"></span><br><span class="line">            _renderer.setRenderTarget(shadow.mapPass);</span><br><span class="line"></span><br><span class="line">            _renderer.clear();</span><br><span class="line"></span><br><span class="line">            _renderer.renderBufferDirect(camera, <span class="literal">null</span>, geometry, shadowMaterialVertical, fullScreenMesh, <span class="literal">null</span>); <span class="comment">// horizontal pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;</span><br><span class="line">            shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;</span><br><span class="line">            shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;</span><br><span class="line"></span><br><span class="line">            _renderer.setRenderTarget(shadow.map);</span><br><span class="line"></span><br><span class="line">            _renderer.clear();</span><br><span class="line"></span><br><span class="line">            _renderer.renderBufferDirect(camera, <span class="literal">null</span>, geometry, shadowMaterialHorizontal, fullScreenMesh, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getDepthMaterial</span>(<span class="params">object, material, light, shadowCameraNear, shadowCameraFar, type</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">const</span> customMaterial = light.isPointLight === <span class="literal">true</span> ? object.customDistanceMaterial : object.customDepthMaterial;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (customMaterial !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                result = customMaterial;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = light.isPointLight === <span class="literal">true</span> ? _distanceMaterial : _depthMaterial;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_renderer.localClippingEnabled &amp;&amp; material.clipShadows === <span class="literal">true</span> &amp;&amp; material.clippingPlanes.length !== <span class="number">0</span> || material.displacementMap &amp;&amp; material.displacementScale !== <span class="number">0</span> || material.alphaMap &amp;&amp; material.alphaTest &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// in this case we need a unique material instance reflecting the</span></span><br><span class="line">                <span class="comment">// appropriate state</span></span><br><span class="line">                <span class="keyword">const</span> keyA = result.uuid,</span><br><span class="line">                    keyB = material.uuid;</span><br><span class="line">                <span class="keyword">let</span> materialsForVariant = _materialCache[keyA];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (materialsForVariant === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    materialsForVariant = &#123;&#125;;</span><br><span class="line">                    _materialCache[keyA] = materialsForVariant;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> cachedMaterial = materialsForVariant[keyB];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cachedMaterial === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    cachedMaterial = result.clone();</span><br><span class="line">                    materialsForVariant[keyB] = cachedMaterial;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                result = cachedMaterial;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.visible = material.visible;</span><br><span class="line">            result.wireframe = material.wireframe;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (type === VSMShadowMap) &#123;</span><br><span class="line">                result.side = material.shadowSide !== <span class="literal">null</span> ? material.shadowSide : material.side;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.side = material.shadowSide !== <span class="literal">null</span> ? material.shadowSide : shadowSide[material.side];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.alphaMap = material.alphaMap;</span><br><span class="line">            result.alphaTest = material.alphaTest;</span><br><span class="line">            result.clipShadows = material.clipShadows;</span><br><span class="line">            result.clippingPlanes = material.clippingPlanes;</span><br><span class="line">            result.clipIntersection = material.clipIntersection;</span><br><span class="line">            result.displacementMap = material.displacementMap;</span><br><span class="line">            result.displacementScale = material.displacementScale;</span><br><span class="line">            result.displacementBias = material.displacementBias;</span><br><span class="line">            result.wireframeLinewidth = material.wireframeLinewidth;</span><br><span class="line">            result.linewidth = material.linewidth;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (light.isPointLight === <span class="literal">true</span> &amp;&amp; result.isMeshDistanceMaterial === <span class="literal">true</span>) &#123;</span><br><span class="line">                result.referencePosition.setFromMatrixPosition(light.matrixWorld);</span><br><span class="line">                result.nearDistance = shadowCameraNear;</span><br><span class="line">                result.farDistance = shadowCameraFar;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">renderObject</span>(<span class="params">object, camera, shadowCamera, light, type</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (object.visible === <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">const</span> visible = object.layers.test(camera.layers);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (visible &amp;&amp; (object.isMesh || object.isLine || object.isPoints)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((object.castShadow || object.receiveShadow &amp;&amp; type === VSMShadowMap) &amp;&amp; (!object.frustumCulled || _frustum.intersectsObject(object))) &#123;</span><br><span class="line">                    object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> geometry = _objects.update(object);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> material = object.material;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(material)) &#123;</span><br><span class="line">                        <span class="keyword">const</span> groups = geometry.groups;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>, kl = groups.length; k &lt; kl; k++) &#123;</span><br><span class="line">                            <span class="keyword">const</span> group = groups[k];</span><br><span class="line">                            <span class="keyword">const</span> groupMaterial = material[group.materialIndex];</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (groupMaterial &amp;&amp; groupMaterial.visible) &#123;</span><br><span class="line">                                <span class="keyword">const</span> depthMaterial = getDepthMaterial(object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);</span><br><span class="line"></span><br><span class="line">                                _renderer.renderBufferDirect(shadowCamera, <span class="literal">null</span>, geometry, depthMaterial, object, group);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.visible) &#123;</span><br><span class="line">                        <span class="keyword">const</span> depthMaterial = getDepthMaterial(object, material, light, shadowCamera.near, shadowCamera.far, type);</span><br><span class="line"></span><br><span class="line">                        _renderer.renderBufferDirect(shadowCamera, <span class="literal">null</span>, geometry, depthMaterial, object, <span class="literal">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> children = object.children;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = children.length; i &lt; l; i++) &#123;</span><br><span class="line">                renderObject(children[i], camera, shadowCamera, light, type);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLState</span>(<span class="params">gl, extensions, capabilities</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> isWebGL2 = capabilities.isWebGL2;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">ColorBuffer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> locked = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">const</span> color = <span class="keyword">new</span> Vector4();</span><br><span class="line">            <span class="keyword">let</span> currentColorMask = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">const</span> currentColorClear = <span class="keyword">new</span> Vector4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">setMask</span>: <span class="function"><span class="keyword">function</span> (<span class="params">colorMask</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (currentColorMask !== colorMask &amp;&amp; !locked) &#123;</span><br><span class="line">                        gl.colorMask(colorMask, colorMask, colorMask, colorMask);</span><br><span class="line">                        currentColorMask = colorMask;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">setLocked</span>: <span class="function"><span class="keyword">function</span> (<span class="params">lock</span>) </span>&#123;</span><br><span class="line">                    locked = lock;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">setClear</span>: <span class="function"><span class="keyword">function</span> (<span class="params">r, g, b, a, premultipliedAlpha</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (premultipliedAlpha === <span class="literal">true</span>) &#123;</span><br><span class="line">                        r *= a;</span><br><span class="line">                        g *= a;</span><br><span class="line">                        b *= a;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    color.set(r, g, b, a);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (currentColorClear.equals(color) === <span class="literal">false</span>) &#123;</span><br><span class="line">                        gl.clearColor(r, g, b, a);</span><br><span class="line">                        currentColorClear.copy(color);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">reset</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    locked = <span class="literal">false</span>;</span><br><span class="line">                    currentColorMask = <span class="literal">null</span>;</span><br><span class="line">                    currentColorClear.set(-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// set to invalid state</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">DepthBuffer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> locked = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">let</span> currentDepthMask = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">let</span> currentDepthFunc = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">let</span> currentDepthClear = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">setTest</span>: <span class="function"><span class="keyword">function</span> (<span class="params">depthTest</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (depthTest) &#123;</span><br><span class="line">                        enable(gl.DEPTH_TEST);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        disable(gl.DEPTH_TEST);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">setMask</span>: <span class="function"><span class="keyword">function</span> (<span class="params">depthMask</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (currentDepthMask !== depthMask &amp;&amp; !locked) &#123;</span><br><span class="line">                        gl.depthMask(depthMask);</span><br><span class="line">                        currentDepthMask = depthMask;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">setFunc</span>: <span class="function"><span class="keyword">function</span> (<span class="params">depthFunc</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (currentDepthFunc !== depthFunc) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (depthFunc) &#123;</span><br><span class="line">                            <span class="keyword">switch</span> (depthFunc) &#123;</span><br><span class="line">                                <span class="keyword">case</span> NeverDepth:</span><br><span class="line">                                    gl.depthFunc(gl.NEVER);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">case</span> AlwaysDepth:</span><br><span class="line">                                    gl.depthFunc(gl.ALWAYS);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">case</span> LessDepth:</span><br><span class="line">                                    gl.depthFunc(gl.LESS);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">case</span> LessEqualDepth:</span><br><span class="line">                                    gl.depthFunc(gl.LEQUAL);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">case</span> EqualDepth:</span><br><span class="line">                                    gl.depthFunc(gl.EQUAL);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">case</span> GreaterEqualDepth:</span><br><span class="line">                                    gl.depthFunc(gl.GEQUAL);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">case</span> GreaterDepth:</span><br><span class="line">                                    gl.depthFunc(gl.GREATER);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">case</span> NotEqualDepth:</span><br><span class="line">                                    gl.depthFunc(gl.NOTEQUAL);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">default</span>:</span><br><span class="line">                                    gl.depthFunc(gl.LEQUAL);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            gl.depthFunc(gl.LEQUAL);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        currentDepthFunc = depthFunc;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">setLocked</span>: <span class="function"><span class="keyword">function</span> (<span class="params">lock</span>) </span>&#123;</span><br><span class="line">                    locked = lock;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">setClear</span>: <span class="function"><span class="keyword">function</span> (<span class="params">depth</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (currentDepthClear !== depth) &#123;</span><br><span class="line">                        gl.clearDepth(depth);</span><br><span class="line">                        currentDepthClear = depth;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">reset</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    locked = <span class="literal">false</span>;</span><br><span class="line">                    currentDepthMask = <span class="literal">null</span>;</span><br><span class="line">                    currentDepthFunc = <span class="literal">null</span>;</span><br><span class="line">                    currentDepthClear = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">StencilBuffer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> locked = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">let</span> currentStencilMask = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">let</span> currentStencilFunc = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">let</span> currentStencilRef = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">let</span> currentStencilFuncMask = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">let</span> currentStencilFail = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">let</span> currentStencilZFail = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">let</span> currentStencilZPass = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">let</span> currentStencilClear = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">setTest</span>: <span class="function"><span class="keyword">function</span> (<span class="params">stencilTest</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!locked) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (stencilTest) &#123;</span><br><span class="line">                            enable(gl.STENCIL_TEST);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            disable(gl.STENCIL_TEST);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">setMask</span>: <span class="function"><span class="keyword">function</span> (<span class="params">stencilMask</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (currentStencilMask !== stencilMask &amp;&amp; !locked) &#123;</span><br><span class="line">                        gl.stencilMask(stencilMask);</span><br><span class="line">                        currentStencilMask = stencilMask;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">setFunc</span>: <span class="function"><span class="keyword">function</span> (<span class="params">stencilFunc, stencilRef, stencilMask</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) &#123;</span><br><span class="line">                        gl.stencilFunc(stencilFunc, stencilRef, stencilMask);</span><br><span class="line">                        currentStencilFunc = stencilFunc;</span><br><span class="line">                        currentStencilRef = stencilRef;</span><br><span class="line">                        currentStencilFuncMask = stencilMask;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">setOp</span>: <span class="function"><span class="keyword">function</span> (<span class="params">stencilFail, stencilZFail, stencilZPass</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) &#123;</span><br><span class="line">                        gl.stencilOp(stencilFail, stencilZFail, stencilZPass);</span><br><span class="line">                        currentStencilFail = stencilFail;</span><br><span class="line">                        currentStencilZFail = stencilZFail;</span><br><span class="line">                        currentStencilZPass = stencilZPass;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">setLocked</span>: <span class="function"><span class="keyword">function</span> (<span class="params">lock</span>) </span>&#123;</span><br><span class="line">                    locked = lock;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">setClear</span>: <span class="function"><span class="keyword">function</span> (<span class="params">stencil</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (currentStencilClear !== stencil) &#123;</span><br><span class="line">                        gl.clearStencil(stencil);</span><br><span class="line">                        currentStencilClear = stencil;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">reset</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    locked = <span class="literal">false</span>;</span><br><span class="line">                    currentStencilMask = <span class="literal">null</span>;</span><br><span class="line">                    currentStencilFunc = <span class="literal">null</span>;</span><br><span class="line">                    currentStencilRef = <span class="literal">null</span>;</span><br><span class="line">                    currentStencilFuncMask = <span class="literal">null</span>;</span><br><span class="line">                    currentStencilFail = <span class="literal">null</span>;</span><br><span class="line">                    currentStencilZFail = <span class="literal">null</span>;</span><br><span class="line">                    currentStencilZPass = <span class="literal">null</span>;</span><br><span class="line">                    currentStencilClear = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> colorBuffer = <span class="keyword">new</span> ColorBuffer();</span><br><span class="line">        <span class="keyword">const</span> depthBuffer = <span class="keyword">new</span> DepthBuffer();</span><br><span class="line">        <span class="keyword">const</span> stencilBuffer = <span class="keyword">new</span> StencilBuffer();</span><br><span class="line">        <span class="keyword">let</span> enabledCapabilities = &#123;&#125;;</span><br><span class="line">        <span class="keyword">let</span> currentBoundFramebuffers = &#123;&#125;;</span><br><span class="line">        <span class="keyword">let</span> currentDrawbuffers = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">        <span class="keyword">let</span> defaultDrawbuffers = [];</span><br><span class="line">        <span class="keyword">let</span> currentProgram = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> currentBlendingEnabled = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">let</span> currentBlending = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> currentBlendEquation = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> currentBlendSrc = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> currentBlendDst = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> currentBlendEquationAlpha = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> currentBlendSrcAlpha = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> currentBlendDstAlpha = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> currentPremultipledAlpha = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">let</span> currentFlipSided = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> currentCullFace = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> currentLineWidth = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> currentPolygonOffsetFactor = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> currentPolygonOffsetUnits = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">const</span> maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);</span><br><span class="line">        <span class="keyword">let</span> lineWidthAvailable = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">let</span> version = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> glVersion = gl.getParameter(gl.VERSION);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (glVersion.indexOf(<span class="string">&#x27;WebGL&#x27;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">            version = <span class="built_in">parseFloat</span>(<span class="regexp">/^WebGL (\d)/</span>.exec(glVersion)[<span class="number">1</span>]);</span><br><span class="line">            lineWidthAvailable = version &gt;= <span class="number">1.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (glVersion.indexOf(<span class="string">&#x27;OpenGL ES&#x27;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">            version = <span class="built_in">parseFloat</span>(<span class="regexp">/^OpenGL ES (\d)/</span>.exec(glVersion)[<span class="number">1</span>]);</span><br><span class="line">            lineWidthAvailable = version &gt;= <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentTextureSlot = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> currentBoundTextures = &#123;&#125;;</span><br><span class="line">        <span class="keyword">const</span> scissorParam = gl.getParameter(gl.SCISSOR_BOX);</span><br><span class="line">        <span class="keyword">const</span> viewportParam = gl.getParameter(gl.VIEWPORT);</span><br><span class="line">        <span class="keyword">const</span> currentScissor = <span class="keyword">new</span> Vector4().fromArray(scissorParam);</span><br><span class="line">        <span class="keyword">const</span> currentViewport = <span class="keyword">new</span> Vector4().fromArray(viewportParam);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">createTexture</span>(<span class="params">type, target, count</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">4</span>); <span class="comment">// 4 is required to match default unpack alignment of 4.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> texture = gl.createTexture();</span><br><span class="line">            gl.bindTexture(type, texture);</span><br><span class="line">            gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);</span><br><span class="line">            gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                gl.texImage2D(target + i, <span class="number">0</span>, gl.RGBA, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, gl.RGBA, gl.UNSIGNED_BYTE, data);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> texture;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> emptyTextures = &#123;&#125;;</span><br><span class="line">        emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, <span class="number">1</span>);</span><br><span class="line">        emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, <span class="number">6</span>); <span class="comment">// init</span></span><br><span class="line"></span><br><span class="line">        colorBuffer.setClear(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        depthBuffer.setClear(<span class="number">1</span>);</span><br><span class="line">        stencilBuffer.setClear(<span class="number">0</span>);</span><br><span class="line">        enable(gl.DEPTH_TEST);</span><br><span class="line">        depthBuffer.setFunc(LessEqualDepth);</span><br><span class="line">        setFlipSided(<span class="literal">false</span>);</span><br><span class="line">        setCullFace(CullFaceBack);</span><br><span class="line">        enable(gl.CULL_FACE);</span><br><span class="line">        setBlending(NoBlending); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">enable</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (enabledCapabilities[id] !== <span class="literal">true</span>) &#123;</span><br><span class="line">                gl.enable(id);</span><br><span class="line">                enabledCapabilities[id] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">disable</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (enabledCapabilities[id] !== <span class="literal">false</span>) &#123;</span><br><span class="line">                gl.disable(id);</span><br><span class="line">                enabledCapabilities[id] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">bindFramebuffer</span>(<span class="params">target, framebuffer</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (currentBoundFramebuffers[target] !== framebuffer) &#123;</span><br><span class="line">                gl.bindFramebuffer(target, framebuffer);</span><br><span class="line">                currentBoundFramebuffers[target] = framebuffer;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isWebGL2) &#123;</span><br><span class="line">                    <span class="comment">// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER</span></span><br><span class="line">                    <span class="keyword">if</span> (target === gl.DRAW_FRAMEBUFFER) &#123;</span><br><span class="line">                        currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (target === gl.FRAMEBUFFER) &#123;</span><br><span class="line">                        currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">drawBuffers</span>(<span class="params">renderTarget, framebuffer</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> drawBuffers = defaultDrawbuffers;</span><br><span class="line">            <span class="keyword">let</span> needsUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (renderTarget) &#123;</span><br><span class="line">                drawBuffers = currentDrawbuffers.get(framebuffer);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (drawBuffers === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    drawBuffers = [];</span><br><span class="line">                    currentDrawbuffers.set(framebuffer, drawBuffers);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (renderTarget.isWebGLMultipleRenderTargets) &#123;</span><br><span class="line">                    <span class="keyword">const</span> textures = renderTarget.texture;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (drawBuffers.length !== textures.length || drawBuffers[<span class="number">0</span>] !== gl.COLOR_ATTACHMENT0) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = textures.length; i &lt; il; i++) &#123;</span><br><span class="line">                            drawBuffers[i] = gl.COLOR_ATTACHMENT0 + i;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        drawBuffers.length = textures.length;</span><br><span class="line">                        needsUpdate = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (drawBuffers[<span class="number">0</span>] !== gl.COLOR_ATTACHMENT0) &#123;</span><br><span class="line">                        drawBuffers[<span class="number">0</span>] = gl.COLOR_ATTACHMENT0;</span><br><span class="line">                        needsUpdate = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (drawBuffers[<span class="number">0</span>] !== gl.BACK) &#123;</span><br><span class="line">                    drawBuffers[<span class="number">0</span>] = gl.BACK;</span><br><span class="line">                    needsUpdate = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (needsUpdate) &#123;</span><br><span class="line">                <span class="keyword">if</span> (capabilities.isWebGL2) &#123;</span><br><span class="line">                    gl.drawBuffers(drawBuffers);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    extensions.get(<span class="string">&#x27;WEBGL_draw_buffers&#x27;</span>).drawBuffersWEBGL(drawBuffers);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">useProgram</span>(<span class="params">program</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (currentProgram !== program) &#123;</span><br><span class="line">                gl.useProgram(program);</span><br><span class="line">                currentProgram = program;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> equationToGL = &#123;</span><br><span class="line">            [AddEquation]: gl.FUNC_ADD,</span><br><span class="line">            [SubtractEquation]: gl.FUNC_SUBTRACT,</span><br><span class="line">            [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isWebGL2) &#123;</span><br><span class="line">            equationToGL[MinEquation] = gl.MIN;</span><br><span class="line">            equationToGL[MaxEquation] = gl.MAX;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> extension = extensions.get(<span class="string">&#x27;EXT_blend_minmax&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (extension !== <span class="literal">null</span>) &#123;</span><br><span class="line">                equationToGL[MinEquation] = extension.MIN_EXT;</span><br><span class="line">                equationToGL[MaxEquation] = extension.MAX_EXT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> factorToGL = &#123;</span><br><span class="line">            [ZeroFactor]: gl.ZERO,</span><br><span class="line">            [OneFactor]: gl.ONE,</span><br><span class="line">            [SrcColorFactor]: gl.SRC_COLOR,</span><br><span class="line">            [SrcAlphaFactor]: gl.SRC_ALPHA,</span><br><span class="line">            [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,</span><br><span class="line">            [DstColorFactor]: gl.DST_COLOR,</span><br><span class="line">            [DstAlphaFactor]: gl.DST_ALPHA,</span><br><span class="line">            [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,</span><br><span class="line">            [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,</span><br><span class="line">            [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,</span><br><span class="line">            [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setBlending</span>(<span class="params">blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (blending === NoBlending) &#123;</span><br><span class="line">                <span class="keyword">if</span> (currentBlendingEnabled === <span class="literal">true</span>) &#123;</span><br><span class="line">                    disable(gl.BLEND);</span><br><span class="line">                    currentBlendingEnabled = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currentBlendingEnabled === <span class="literal">false</span>) &#123;</span><br><span class="line">                enable(gl.BLEND);</span><br><span class="line">                currentBlendingEnabled = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (blending !== CustomBlending) &#123;</span><br><span class="line">                <span class="keyword">if</span> (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) &#123;</span><br><span class="line">                        gl.blendEquation(gl.FUNC_ADD);</span><br><span class="line">                        currentBlendEquation = AddEquation;</span><br><span class="line">                        currentBlendEquationAlpha = AddEquation;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (premultipliedAlpha) &#123;</span><br><span class="line">                        <span class="keyword">switch</span> (blending) &#123;</span><br><span class="line">                            <span class="keyword">case</span> NormalBlending:</span><br><span class="line">                                gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">case</span> AdditiveBlending:</span><br><span class="line">                                gl.blendFunc(gl.ONE, gl.ONE);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">case</span> SubtractiveBlending:</span><br><span class="line">                                gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">case</span> MultiplyBlending:</span><br><span class="line">                                gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">default</span>:</span><br><span class="line">                                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLState: Invalid blending: &#x27;</span>, blending);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">switch</span> (blending) &#123;</span><br><span class="line">                            <span class="keyword">case</span> NormalBlending:</span><br><span class="line">                                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">case</span> AdditiveBlending:</span><br><span class="line">                                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">case</span> SubtractiveBlending:</span><br><span class="line">                                gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">case</span> MultiplyBlending:</span><br><span class="line">                                gl.blendFunc(gl.ZERO, gl.SRC_COLOR);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">default</span>:</span><br><span class="line">                                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLState: Invalid blending: &#x27;</span>, blending);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    currentBlendSrc = <span class="literal">null</span>;</span><br><span class="line">                    currentBlendDst = <span class="literal">null</span>;</span><br><span class="line">                    currentBlendSrcAlpha = <span class="literal">null</span>;</span><br><span class="line">                    currentBlendDstAlpha = <span class="literal">null</span>;</span><br><span class="line">                    currentBlending = blending;</span><br><span class="line">                    currentPremultipledAlpha = premultipliedAlpha;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="comment">// custom blending</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            blendEquationAlpha = blendEquationAlpha || blendEquation;</span><br><span class="line">            blendSrcAlpha = blendSrcAlpha || blendSrc;</span><br><span class="line">            blendDstAlpha = blendDstAlpha || blendDst;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) &#123;</span><br><span class="line">                gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);</span><br><span class="line">                currentBlendEquation = blendEquation;</span><br><span class="line">                currentBlendEquationAlpha = blendEquationAlpha;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) &#123;</span><br><span class="line">                gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);</span><br><span class="line">                currentBlendSrc = blendSrc;</span><br><span class="line">                currentBlendDst = blendDst;</span><br><span class="line">                currentBlendSrcAlpha = blendSrcAlpha;</span><br><span class="line">                currentBlendDstAlpha = blendDstAlpha;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currentBlending = blending;</span><br><span class="line">            currentPremultipledAlpha = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setMaterial</span>(<span class="params">material, frontFaceCW</span>) </span>&#123;</span><br><span class="line">            material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);</span><br><span class="line">            <span class="keyword">let</span> flipSided = material.side === BackSide;</span><br><span class="line">            <span class="keyword">if</span> (frontFaceCW) flipSided = !flipSided;</span><br><span class="line">            setFlipSided(flipSided);</span><br><span class="line">            material.blending === NormalBlending &amp;&amp; material.transparent === <span class="literal">false</span> ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);</span><br><span class="line">            depthBuffer.setFunc(material.depthFunc);</span><br><span class="line">            depthBuffer.setTest(material.depthTest);</span><br><span class="line">            depthBuffer.setMask(material.depthWrite);</span><br><span class="line">            colorBuffer.setMask(material.colorWrite);</span><br><span class="line">            <span class="keyword">const</span> stencilWrite = material.stencilWrite;</span><br><span class="line">            stencilBuffer.setTest(stencilWrite);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stencilWrite) &#123;</span><br><span class="line">                stencilBuffer.setMask(material.stencilWriteMask);</span><br><span class="line">                stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);</span><br><span class="line">                stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);</span><br><span class="line">            material.alphaToCoverage === <span class="literal">true</span> ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);</span><br><span class="line">        &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setFlipSided</span>(<span class="params">flipSided</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (currentFlipSided !== flipSided) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flipSided) &#123;</span><br><span class="line">                    gl.frontFace(gl.CW);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    gl.frontFace(gl.CCW);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                currentFlipSided = flipSided;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setCullFace</span>(<span class="params">cullFace</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (cullFace !== CullFaceNone) &#123;</span><br><span class="line">                enable(gl.CULL_FACE);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cullFace !== currentCullFace) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cullFace === CullFaceBack) &#123;</span><br><span class="line">                        gl.cullFace(gl.BACK);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cullFace === CullFaceFront) &#123;</span><br><span class="line">                        gl.cullFace(gl.FRONT);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        gl.cullFace(gl.FRONT_AND_BACK);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                disable(gl.CULL_FACE);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currentCullFace = cullFace;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setLineWidth</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (width !== currentLineWidth) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lineWidthAvailable) gl.lineWidth(width);</span><br><span class="line">                currentLineWidth = width;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setPolygonOffset</span>(<span class="params">polygonOffset, factor, units</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (polygonOffset) &#123;</span><br><span class="line">                enable(gl.POLYGON_OFFSET_FILL);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) &#123;</span><br><span class="line">                    gl.polygonOffset(factor, units);</span><br><span class="line">                    currentPolygonOffsetFactor = factor;</span><br><span class="line">                    currentPolygonOffsetUnits = units;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                disable(gl.POLYGON_OFFSET_FILL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setScissorTest</span>(<span class="params">scissorTest</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (scissorTest) &#123;</span><br><span class="line">                enable(gl.SCISSOR_TEST);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                disable(gl.SCISSOR_TEST);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// texture</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">activeTexture</span>(<span class="params">webglSlot</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (webglSlot === <span class="literal">undefined</span>) webglSlot = gl.TEXTURE0 + maxTextures - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currentTextureSlot !== webglSlot) &#123;</span><br><span class="line">                gl.activeTexture(webglSlot);</span><br><span class="line">                currentTextureSlot = webglSlot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">bindTexture</span>(<span class="params">webglType, webglTexture</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (currentTextureSlot === <span class="literal">null</span>) &#123;</span><br><span class="line">                activeTexture();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> boundTexture = currentBoundTextures[currentTextureSlot];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (boundTexture === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                boundTexture = &#123;</span><br><span class="line">                    <span class="attr">type</span>: <span class="literal">undefined</span>,</span><br><span class="line">                    <span class="attr">texture</span>: <span class="literal">undefined</span></span><br><span class="line">                &#125;;</span><br><span class="line">                currentBoundTextures[currentTextureSlot] = boundTexture;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) &#123;</span><br><span class="line">                gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);</span><br><span class="line">                boundTexture.type = webglType;</span><br><span class="line">                boundTexture.texture = webglTexture;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">unbindTexture</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> boundTexture = currentBoundTextures[currentTextureSlot];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (boundTexture !== <span class="literal">undefined</span> &amp;&amp; boundTexture.type !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                gl.bindTexture(boundTexture.type, <span class="literal">null</span>);</span><br><span class="line">                boundTexture.type = <span class="literal">undefined</span>;</span><br><span class="line">                boundTexture.texture = <span class="literal">undefined</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">compressedTexImage2D</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                gl.compressedTexImage2D.apply(gl, <span class="built_in">arguments</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLState:&#x27;</span>, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">texSubImage2D</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                gl.texSubImage2D.apply(gl, <span class="built_in">arguments</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLState:&#x27;</span>, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">texSubImage3D</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                gl.texSubImage3D.apply(gl, <span class="built_in">arguments</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLState:&#x27;</span>, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">compressedTexSubImage2D</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                gl.compressedTexSubImage2D.apply(gl, <span class="built_in">arguments</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLState:&#x27;</span>, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">texStorage2D</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                gl.texStorage2D.apply(gl, <span class="built_in">arguments</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLState:&#x27;</span>, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">texStorage3D</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                gl.texStorage3D.apply(gl, <span class="built_in">arguments</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLState:&#x27;</span>, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">texImage2D</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                gl.texImage2D.apply(gl, <span class="built_in">arguments</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLState:&#x27;</span>, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">texImage3D</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                gl.texImage3D.apply(gl, <span class="built_in">arguments</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLState:&#x27;</span>, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">scissor</span>(<span class="params">scissor</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (currentScissor.equals(scissor) === <span class="literal">false</span>) &#123;</span><br><span class="line">                gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);</span><br><span class="line">                currentScissor.copy(scissor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">viewport</span>(<span class="params">viewport</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (currentViewport.equals(viewport) === <span class="literal">false</span>) &#123;</span><br><span class="line">                gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);</span><br><span class="line">                currentViewport.copy(viewport);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">reset</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// reset state</span></span><br><span class="line">            gl.disable(gl.BLEND);</span><br><span class="line">            gl.disable(gl.CULL_FACE);</span><br><span class="line">            gl.disable(gl.DEPTH_TEST);</span><br><span class="line">            gl.disable(gl.POLYGON_OFFSET_FILL);</span><br><span class="line">            gl.disable(gl.SCISSOR_TEST);</span><br><span class="line">            gl.disable(gl.STENCIL_TEST);</span><br><span class="line">            gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);</span><br><span class="line">            gl.blendEquation(gl.FUNC_ADD);</span><br><span class="line">            gl.blendFunc(gl.ONE, gl.ZERO);</span><br><span class="line">            gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);</span><br><span class="line">            gl.colorMask(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">            gl.clearColor(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            gl.depthMask(<span class="literal">true</span>);</span><br><span class="line">            gl.depthFunc(gl.LESS);</span><br><span class="line">            gl.clearDepth(<span class="number">1</span>);</span><br><span class="line">            gl.stencilMask(<span class="number">0xffffffff</span>);</span><br><span class="line">            gl.stencilFunc(gl.ALWAYS, <span class="number">0</span>, <span class="number">0xffffffff</span>);</span><br><span class="line">            gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);</span><br><span class="line">            gl.clearStencil(<span class="number">0</span>);</span><br><span class="line">            gl.cullFace(gl.BACK);</span><br><span class="line">            gl.frontFace(gl.CCW);</span><br><span class="line">            gl.polygonOffset(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            gl.activeTexture(gl.TEXTURE0);</span><br><span class="line">            gl.bindFramebuffer(gl.FRAMEBUFFER, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isWebGL2 === <span class="literal">true</span>) &#123;</span><br><span class="line">                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, <span class="literal">null</span>);</span><br><span class="line">                gl.bindFramebuffer(gl.READ_FRAMEBUFFER, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            gl.useProgram(<span class="literal">null</span>);</span><br><span class="line">            gl.lineWidth(<span class="number">1</span>);</span><br><span class="line">            gl.scissor(<span class="number">0</span>, <span class="number">0</span>, gl.canvas.width, gl.canvas.height);</span><br><span class="line">            gl.viewport(<span class="number">0</span>, <span class="number">0</span>, gl.canvas.width, gl.canvas.height); <span class="comment">// reset internals</span></span><br><span class="line"></span><br><span class="line">            enabledCapabilities = &#123;&#125;;</span><br><span class="line">            currentTextureSlot = <span class="literal">null</span>;</span><br><span class="line">            currentBoundTextures = &#123;&#125;;</span><br><span class="line">            currentBoundFramebuffers = &#123;&#125;;</span><br><span class="line">            currentDrawbuffers = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">            defaultDrawbuffers = [];</span><br><span class="line">            currentProgram = <span class="literal">null</span>;</span><br><span class="line">            currentBlendingEnabled = <span class="literal">false</span>;</span><br><span class="line">            currentBlending = <span class="literal">null</span>;</span><br><span class="line">            currentBlendEquation = <span class="literal">null</span>;</span><br><span class="line">            currentBlendSrc = <span class="literal">null</span>;</span><br><span class="line">            currentBlendDst = <span class="literal">null</span>;</span><br><span class="line">            currentBlendEquationAlpha = <span class="literal">null</span>;</span><br><span class="line">            currentBlendSrcAlpha = <span class="literal">null</span>;</span><br><span class="line">            currentBlendDstAlpha = <span class="literal">null</span>;</span><br><span class="line">            currentPremultipledAlpha = <span class="literal">false</span>;</span><br><span class="line">            currentFlipSided = <span class="literal">null</span>;</span><br><span class="line">            currentCullFace = <span class="literal">null</span>;</span><br><span class="line">            currentLineWidth = <span class="literal">null</span>;</span><br><span class="line">            currentPolygonOffsetFactor = <span class="literal">null</span>;</span><br><span class="line">            currentPolygonOffsetUnits = <span class="literal">null</span>;</span><br><span class="line">            currentScissor.set(<span class="number">0</span>, <span class="number">0</span>, gl.canvas.width, gl.canvas.height);</span><br><span class="line">            currentViewport.set(<span class="number">0</span>, <span class="number">0</span>, gl.canvas.width, gl.canvas.height);</span><br><span class="line">            colorBuffer.reset();</span><br><span class="line">            depthBuffer.reset();</span><br><span class="line">            stencilBuffer.reset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">buffers</span>: &#123;</span><br><span class="line">                <span class="attr">color</span>: colorBuffer,</span><br><span class="line">                <span class="attr">depth</span>: depthBuffer,</span><br><span class="line">                <span class="attr">stencil</span>: stencilBuffer</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">enable</span>: enable,</span><br><span class="line">            <span class="attr">disable</span>: disable,</span><br><span class="line">            <span class="attr">bindFramebuffer</span>: bindFramebuffer,</span><br><span class="line">            <span class="attr">drawBuffers</span>: drawBuffers,</span><br><span class="line">            <span class="attr">useProgram</span>: useProgram,</span><br><span class="line">            <span class="attr">setBlending</span>: setBlending,</span><br><span class="line">            <span class="attr">setMaterial</span>: setMaterial,</span><br><span class="line">            <span class="attr">setFlipSided</span>: setFlipSided,</span><br><span class="line">            <span class="attr">setCullFace</span>: setCullFace,</span><br><span class="line">            <span class="attr">setLineWidth</span>: setLineWidth,</span><br><span class="line">            <span class="attr">setPolygonOffset</span>: setPolygonOffset,</span><br><span class="line">            <span class="attr">setScissorTest</span>: setScissorTest,</span><br><span class="line">            <span class="attr">activeTexture</span>: activeTexture,</span><br><span class="line">            <span class="attr">bindTexture</span>: bindTexture,</span><br><span class="line">            <span class="attr">unbindTexture</span>: unbindTexture,</span><br><span class="line">            <span class="attr">compressedTexImage2D</span>: compressedTexImage2D,</span><br><span class="line">            <span class="attr">texImage2D</span>: texImage2D,</span><br><span class="line">            <span class="attr">texImage3D</span>: texImage3D,</span><br><span class="line">            <span class="attr">texStorage2D</span>: texStorage2D,</span><br><span class="line">            <span class="attr">texStorage3D</span>: texStorage3D,</span><br><span class="line">            <span class="attr">texSubImage2D</span>: texSubImage2D,</span><br><span class="line">            <span class="attr">texSubImage3D</span>: texSubImage3D,</span><br><span class="line">            <span class="attr">compressedTexSubImage2D</span>: compressedTexSubImage2D,</span><br><span class="line">            <span class="attr">scissor</span>: scissor,</span><br><span class="line">            <span class="attr">viewport</span>: viewport,</span><br><span class="line">            <span class="attr">reset</span>: reset</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLTextures</span>(<span class="params">_gl, extensions, state, properties, capabilities, utils, info</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> isWebGL2 = capabilities.isWebGL2;</span><br><span class="line">        <span class="keyword">const</span> maxTextures = capabilities.maxTextures;</span><br><span class="line">        <span class="keyword">const</span> maxCubemapSize = capabilities.maxCubemapSize;</span><br><span class="line">        <span class="keyword">const</span> maxTextureSize = capabilities.maxTextureSize;</span><br><span class="line">        <span class="keyword">const</span> maxSamples = capabilities.maxSamples;</span><br><span class="line">        <span class="keyword">const</span> multisampledRTTExt = extensions.has(<span class="string">&#x27;WEBGL_multisampled_render_to_texture&#x27;</span>) ? extensions.get(<span class="string">&#x27;WEBGL_multisampled_render_to_texture&#x27;</span>) : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">const</span> supportsInvalidateFramebuffer = <span class="regexp">/OculusBrowser/g</span>.test(navigator.userAgent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> _videoTextures = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> _canvas;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> _sources = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(); <span class="comment">// maps WebglTexture objects to instances of Source</span></span><br><span class="line">        <span class="comment">// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,</span></span><br><span class="line">        <span class="comment">// also OffscreenCanvas.getContext(&quot;webgl&quot;), but not OffscreenCanvas.getContext(&quot;2d&quot;)!</span></span><br><span class="line">        <span class="comment">// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> useOffscreenCanvas = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            useOffscreenCanvas = <span class="keyword">typeof</span> OffscreenCanvas !== <span class="string">&#x27;undefined&#x27;</span> <span class="comment">// eslint-disable-next-line compat/compat</span></span><br><span class="line">                &amp;&amp; <span class="keyword">new</span> OffscreenCanvas(<span class="number">1</span>, <span class="number">1</span>).getContext(<span class="string">&#x27;2d&#x27;</span>) !== <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;<span class="comment">// Ignore any errors</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">createCanvas</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// Use OffscreenCanvas when available. Specially needed in web workers</span></span><br><span class="line">            <span class="keyword">return</span> useOffscreenCanvas ? <span class="comment">// eslint-disable-next-line compat/compat</span></span><br><span class="line">                <span class="keyword">new</span> OffscreenCanvas(width, height) : createElementNS(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resizeImage</span>(<span class="params">image, needsPowerOfTwo, needsNewCanvas, maxSize</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> scale = <span class="number">1</span>; <span class="comment">// handle case if texture exceeds max size</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (image.width &gt; maxSize || image.height &gt; maxSize) &#123;</span><br><span class="line">                scale = maxSize / <span class="built_in">Math</span>.max(image.width, image.height);</span><br><span class="line">            &#125; <span class="comment">// only perform resize if necessary</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (scale &lt; <span class="number">1</span> || needsPowerOfTwo === <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// only perform resize for certain image types</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> HTMLImageElement !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; image <span class="keyword">instanceof</span> HTMLImageElement || <span class="keyword">typeof</span> HTMLCanvasElement !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; image <span class="keyword">instanceof</span> HTMLCanvasElement || <span class="keyword">typeof</span> ImageBitmap !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; image <span class="keyword">instanceof</span> ImageBitmap) &#123;</span><br><span class="line">                    <span class="keyword">const</span> floor = needsPowerOfTwo ? floorPowerOfTwo : <span class="built_in">Math</span>.floor;</span><br><span class="line">                    <span class="keyword">const</span> width = floor(scale * image.width);</span><br><span class="line">                    <span class="keyword">const</span> height = floor(scale * image.height);</span><br><span class="line">                    <span class="keyword">if</span> (_canvas === <span class="literal">undefined</span>) _canvas = createCanvas(width, height); <span class="comment">// cube textures can&#x27;t reuse the same canvas</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;</span><br><span class="line">                    canvas.width = width;</span><br><span class="line">                    canvas.height = height;</span><br><span class="line">                    <span class="keyword">const</span> context = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">                    context.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: Texture has been resized from (&#x27;</span> + image.width + <span class="string">&#x27;x&#x27;</span> + image.height + <span class="string">&#x27;) to (&#x27;</span> + width + <span class="string">&#x27;x&#x27;</span> + height + <span class="string">&#x27;).&#x27;</span>);</span><br><span class="line">                    <span class="keyword">return</span> canvas;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&#x27;data&#x27;</span> <span class="keyword">in</span> image) &#123;</span><br><span class="line">                        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: Image in DataTexture is too big (&#x27;</span> + image.width + <span class="string">&#x27;x&#x27;</span> + image.height + <span class="string">&#x27;).&#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> image;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> image;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">isPowerOfTwo$1</span>(<span class="params">image</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> isPowerOfTwo(image.width) &amp;&amp; isPowerOfTwo(image.height);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">textureNeedsPowerOfTwo</span>(<span class="params">texture</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isWebGL2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter &amp;&amp; texture.minFilter !== LinearFilter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">textureNeedsGenerateMipmaps</span>(<span class="params">texture, supportsMips</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> texture.generateMipmaps &amp;&amp; supportsMips &amp;&amp; texture.minFilter !== NearestFilter &amp;&amp; texture.minFilter !== LinearFilter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">generateMipmap</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">            _gl.generateMipmap(target);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getInternalFormat</span>(<span class="params">internalFormatName, glFormat, glType, encoding, isVideoTexture = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isWebGL2 === <span class="literal">false</span>) <span class="keyword">return</span> glFormat;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (internalFormatName !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_gl[internalFormatName] !== <span class="literal">undefined</span>) <span class="keyword">return</span> _gl[internalFormatName];</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \&#x27;&#x27;</span> + internalFormatName + <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> internalFormat = glFormat;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (glFormat === _gl.RED) &#123;</span><br><span class="line">                <span class="keyword">if</span> (glType === _gl.FLOAT) internalFormat = _gl.R32F;</span><br><span class="line">                <span class="keyword">if</span> (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;</span><br><span class="line">                <span class="keyword">if</span> (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (glFormat === _gl.RG) &#123;</span><br><span class="line">                <span class="keyword">if</span> (glType === _gl.FLOAT) internalFormat = _gl.RG32F;</span><br><span class="line">                <span class="keyword">if</span> (glType === _gl.HALF_FLOAT) internalFormat = _gl.RG16F;</span><br><span class="line">                <span class="keyword">if</span> (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (glFormat === _gl.RGBA) &#123;</span><br><span class="line">                <span class="keyword">if</span> (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;</span><br><span class="line">                <span class="keyword">if</span> (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;</span><br><span class="line">                <span class="keyword">if</span> (glType === _gl.UNSIGNED_BYTE) internalFormat = encoding === sRGBEncoding &amp;&amp; isVideoTexture === <span class="literal">false</span> ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;</span><br><span class="line">                <span class="keyword">if</span> (glType === _gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = _gl.RGBA4;</span><br><span class="line">                <span class="keyword">if</span> (glType === _gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = _gl.RGB5_A1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) &#123;</span><br><span class="line">                extensions.get(<span class="string">&#x27;EXT_color_buffer_float&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> internalFormat;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getMipLevels</span>(<span class="params">texture, image, supportsMips</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (textureNeedsGenerateMipmaps(texture, supportsMips) === <span class="literal">true</span> || texture.isFramebufferTexture &amp;&amp; texture.minFilter !== NearestFilter &amp;&amp; texture.minFilter !== LinearFilter) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Math</span>.log2(<span class="built_in">Math</span>.max(image.width, image.height)) + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (texture.mipmaps !== <span class="literal">undefined</span> &amp;&amp; texture.mipmaps.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// user-defined mipmaps</span></span><br><span class="line">                <span class="keyword">return</span> texture.mipmaps.length;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (texture.isCompressedTexture &amp;&amp; <span class="built_in">Array</span>.isArray(texture.image)) &#123;</span><br><span class="line">                <span class="keyword">return</span> image.mipmaps.length;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// texture without mipmaps (only base level)</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// Fallback filters for non-power-of-2 textures</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">filterFallback</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) &#123;</span><br><span class="line">                <span class="keyword">return</span> _gl.NEAREST;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> _gl.LINEAR;</span><br><span class="line">        &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">onTextureDispose</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> texture = event.target;</span><br><span class="line">            texture.removeEventListener(<span class="string">&#x27;dispose&#x27;</span>, onTextureDispose);</span><br><span class="line">            deallocateTexture(texture);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (texture.isVideoTexture) &#123;</span><br><span class="line">                _videoTextures.delete(texture);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">onRenderTargetDispose</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> renderTarget = event.target;</span><br><span class="line">            renderTarget.removeEventListener(<span class="string">&#x27;dispose&#x27;</span>, onRenderTargetDispose);</span><br><span class="line">            deallocateRenderTarget(renderTarget);</span><br><span class="line">        &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">deallocateTexture</span>(<span class="params">texture</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> textureProperties = properties.get(texture);</span><br><span class="line">            <span class="keyword">if</span> (textureProperties.__webglInit === <span class="literal">undefined</span>) <span class="keyword">return</span>; <span class="comment">// check if it&#x27;s necessary to remove the WebGLTexture object</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> source = texture.source;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> webglTextures = _sources.get(source);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (webglTextures) &#123;</span><br><span class="line">                <span class="keyword">const</span> webglTexture = webglTextures[textureProperties.__cacheKey];</span><br><span class="line">                webglTexture.usedTimes--; <span class="comment">// the WebGLTexture object is not used anymore, remove it</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (webglTexture.usedTimes === <span class="number">0</span>) &#123;</span><br><span class="line">                    deleteTexture(texture);</span><br><span class="line">                &#125; <span class="comment">// remove the weak map entry if no WebGLTexture uses the source anymore</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(webglTextures).length === <span class="number">0</span>) &#123;</span><br><span class="line">                    _sources.delete(source);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            properties.remove(texture);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">deleteTexture</span>(<span class="params">texture</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> textureProperties = properties.get(texture);</span><br><span class="line"></span><br><span class="line">            _gl.deleteTexture(textureProperties.__webglTexture);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> source = texture.source;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> webglTextures = _sources.get(source);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> webglTextures[textureProperties.__cacheKey];</span><br><span class="line">            info.memory.textures--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">deallocateRenderTarget</span>(<span class="params">renderTarget</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> texture = renderTarget.texture;</span><br><span class="line">            <span class="keyword">const</span> renderTargetProperties = properties.get(renderTarget);</span><br><span class="line">            <span class="keyword">const</span> textureProperties = properties.get(texture);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (textureProperties.__webglTexture !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                _gl.deleteTexture(textureProperties.__webglTexture);</span><br><span class="line"></span><br><span class="line">                info.memory.textures--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (renderTarget.depthTexture) &#123;</span><br><span class="line">                renderTarget.depthTexture.dispose();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (renderTarget.isWebGLCubeRenderTarget) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                    _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);</span><br><span class="line">                <span class="keyword">if</span> (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);</span><br><span class="line">                <span class="keyword">if</span> (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);</span><br><span class="line">                <span class="keyword">if</span> (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (renderTarget.isWebGLMultipleRenderTargets) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = texture.length; i &lt; il; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> attachmentProperties = properties.get(texture[i]);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (attachmentProperties.__webglTexture) &#123;</span><br><span class="line">                        _gl.deleteTexture(attachmentProperties.__webglTexture);</span><br><span class="line"></span><br><span class="line">                        info.memory.textures--;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    properties.remove(texture[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            properties.remove(texture);</span><br><span class="line">            properties.remove(renderTarget);</span><br><span class="line">        &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> textureUnits = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resetTextureUnits</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            textureUnits = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">allocateTextureUnit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> textureUnit = textureUnits;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (textureUnit &gt;= maxTextures) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLTextures: Trying to use &#x27;</span> + textureUnit + <span class="string">&#x27; texture units while this GPU supports only &#x27;</span> + maxTextures);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            textureUnits += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> textureUnit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getTextureCacheKey</span>(<span class="params">texture</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> array = [];</span><br><span class="line">            array.push(texture.wrapS);</span><br><span class="line">            array.push(texture.wrapT);</span><br><span class="line">            array.push(texture.magFilter);</span><br><span class="line">            array.push(texture.minFilter);</span><br><span class="line">            array.push(texture.anisotropy);</span><br><span class="line">            array.push(texture.internalFormat);</span><br><span class="line">            array.push(texture.format);</span><br><span class="line">            array.push(texture.type);</span><br><span class="line">            array.push(texture.generateMipmaps);</span><br><span class="line">            array.push(texture.premultiplyAlpha);</span><br><span class="line">            array.push(texture.flipY);</span><br><span class="line">            array.push(texture.unpackAlignment);</span><br><span class="line">            array.push(texture.encoding);</span><br><span class="line">            <span class="keyword">return</span> array.join();</span><br><span class="line">        &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setTexture2D</span>(<span class="params">texture, slot</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> textureProperties = properties.get(texture);</span><br><span class="line">            <span class="keyword">if</span> (texture.isVideoTexture) updateVideoTexture(texture);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (texture.isRenderTargetTexture === <span class="literal">false</span> &amp;&amp; texture.version &gt; <span class="number">0</span> &amp;&amp; textureProperties.__version !== texture.version) &#123;</span><br><span class="line">                <span class="keyword">const</span> image = texture.image;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (image === <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: Texture marked for update but no image data found.&#x27;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (image.complete === <span class="literal">false</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: Texture marked for update but image is incomplete&#x27;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    uploadTexture(textureProperties, texture, slot);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            state.activeTexture(_gl.TEXTURE0 + slot);</span><br><span class="line">            state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setTexture2DArray</span>(<span class="params">texture, slot</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> textureProperties = properties.get(texture);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (texture.version &gt; <span class="number">0</span> &amp;&amp; textureProperties.__version !== texture.version) &#123;</span><br><span class="line">                uploadTexture(textureProperties, texture, slot);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            state.activeTexture(_gl.TEXTURE0 + slot);</span><br><span class="line">            state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setTexture3D</span>(<span class="params">texture, slot</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> textureProperties = properties.get(texture);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (texture.version &gt; <span class="number">0</span> &amp;&amp; textureProperties.__version !== texture.version) &#123;</span><br><span class="line">                uploadTexture(textureProperties, texture, slot);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            state.activeTexture(_gl.TEXTURE0 + slot);</span><br><span class="line">            state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setTextureCube</span>(<span class="params">texture, slot</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> textureProperties = properties.get(texture);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (texture.version &gt; <span class="number">0</span> &amp;&amp; textureProperties.__version !== texture.version) &#123;</span><br><span class="line">                uploadCubeTexture(textureProperties, texture, slot);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            state.activeTexture(_gl.TEXTURE0 + slot);</span><br><span class="line">            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> wrappingToGL = &#123;</span><br><span class="line">            [RepeatWrapping]: _gl.REPEAT,</span><br><span class="line">            [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,</span><br><span class="line">            [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> filterToGL = &#123;</span><br><span class="line">            [NearestFilter]: _gl.NEAREST,</span><br><span class="line">            [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,</span><br><span class="line">            [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,</span><br><span class="line">            [LinearFilter]: _gl.LINEAR,</span><br><span class="line">            [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,</span><br><span class="line">            [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setTextureParameters</span>(<span class="params">textureType, texture, supportsMips</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (supportsMips) &#123;</span><br><span class="line">                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);</span><br><span class="line"></span><br><span class="line">                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) &#123;</span><br><span class="line">                    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);</span><br><span class="line"></span><br><span class="line">                _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);</span><br><span class="line"></span><br><span class="line">                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) &#123;</span><br><span class="line">                    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));</span><br><span class="line"></span><br><span class="line">                _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (texture.minFilter !== NearestFilter &amp;&amp; texture.minFilter !== LinearFilter) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (extensions.has(<span class="string">&#x27;EXT_texture_filter_anisotropic&#x27;</span>) === <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> extension = extensions.get(<span class="string">&#x27;EXT_texture_filter_anisotropic&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (texture.type === FloatType &amp;&amp; extensions.has(<span class="string">&#x27;OES_texture_float_linear&#x27;</span>) === <span class="literal">false</span>) <span class="keyword">return</span>; <span class="comment">// verify extension for WebGL 1 and WebGL 2</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isWebGL2 === <span class="literal">false</span> &amp;&amp; texture.type === HalfFloatType &amp;&amp; extensions.has(<span class="string">&#x27;OES_texture_half_float_linear&#x27;</span>) === <span class="literal">false</span>) <span class="keyword">return</span>; <span class="comment">// verify extension for WebGL 1 only</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (texture.anisotropy &gt; <span class="number">1</span> || properties.get(texture).__currentAnisotropy) &#123;</span><br><span class="line">                    _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, <span class="built_in">Math</span>.min(texture.anisotropy, capabilities.getMaxAnisotropy()));</span><br><span class="line"></span><br><span class="line">                    properties.get(texture).__currentAnisotropy = texture.anisotropy;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">initTexture</span>(<span class="params">textureProperties, texture</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> forceUpload = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (textureProperties.__webglInit === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                textureProperties.__webglInit = <span class="literal">true</span>;</span><br><span class="line">                texture.addEventListener(<span class="string">&#x27;dispose&#x27;</span>, onTextureDispose);</span><br><span class="line">            &#125; <span class="comment">// create Source &lt;-&gt; WebGLTextures mapping if necessary</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> source = texture.source;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> webglTextures = _sources.get(source);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (webglTextures === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                webglTextures = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">                _sources.set(source, webglTextures);</span><br><span class="line">            &#125; <span class="comment">// check if there is already a WebGLTexture object for the given texture parameters</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> textureCacheKey = getTextureCacheKey(texture);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (textureCacheKey !== textureProperties.__cacheKey) &#123;</span><br><span class="line">                <span class="comment">// if not, create a new instance of WebGLTexture</span></span><br><span class="line">                <span class="keyword">if</span> (webglTextures[textureCacheKey] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="comment">// create new entry</span></span><br><span class="line">                    webglTextures[textureCacheKey] = &#123;</span><br><span class="line">                        <span class="attr">texture</span>: _gl.createTexture(),</span><br><span class="line">                        <span class="attr">usedTimes</span>: <span class="number">0</span></span><br><span class="line">                    &#125;;</span><br><span class="line">                    info.memory.textures++; <span class="comment">// when a new instance of WebGLTexture was created, a texture upload is required</span></span><br><span class="line">                    <span class="comment">// even if the image contents are identical</span></span><br><span class="line"></span><br><span class="line">                    forceUpload = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                webglTextures[textureCacheKey].usedTimes++; <span class="comment">// every time the texture cache key changes, it&#x27;s necessary to check if an instance of</span></span><br><span class="line">                <span class="comment">// WebGLTexture can be deleted in order to avoid a memory leak.</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> webglTexture = webglTextures[textureProperties.__cacheKey];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (webglTexture !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    webglTextures[textureProperties.__cacheKey].usedTimes--;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (webglTexture.usedTimes === <span class="number">0</span>) &#123;</span><br><span class="line">                        deleteTexture(texture);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="comment">// store references to cache key and WebGLTexture object</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                textureProperties.__cacheKey = textureCacheKey;</span><br><span class="line">                textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> forceUpload;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">uploadTexture</span>(<span class="params">textureProperties, texture, slot</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> textureType = _gl.TEXTURE_2D;</span><br><span class="line">            <span class="keyword">if</span> (texture.isDataArrayTexture) textureType = _gl.TEXTURE_2D_ARRAY;</span><br><span class="line">            <span class="keyword">if</span> (texture.isData3DTexture) textureType = _gl.TEXTURE_3D;</span><br><span class="line">            <span class="keyword">const</span> forceUpload = initTexture(textureProperties, texture);</span><br><span class="line">            <span class="keyword">const</span> source = texture.source;</span><br><span class="line">            state.activeTexture(_gl.TEXTURE0 + slot);</span><br><span class="line">            state.bindTexture(textureType, textureProperties.__webglTexture);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (source.version !== source.__currentVersion || forceUpload === <span class="literal">true</span>) &#123;</span><br><span class="line">                _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);</span><br><span class="line"></span><br><span class="line">                _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);</span><br><span class="line"></span><br><span class="line">                _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);</span><br><span class="line"></span><br><span class="line">                _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> needsPowerOfTwo = textureNeedsPowerOfTwo(texture) &amp;&amp; isPowerOfTwo$<span class="number">1</span>(texture.image) === <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">let</span> image = resizeImage(texture.image, needsPowerOfTwo, <span class="literal">false</span>, maxTextureSize);</span><br><span class="line">                image = verifyColorSpace(texture, image);</span><br><span class="line">                <span class="keyword">const</span> supportsMips = isPowerOfTwo$<span class="number">1</span>(image) || isWebGL2,</span><br><span class="line">                    glFormat = utils.convert(texture.format, texture.encoding);</span><br><span class="line">                <span class="keyword">let</span> glType = utils.convert(texture.type),</span><br><span class="line">                    glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture);</span><br><span class="line">                setTextureParameters(textureType, texture, supportsMips);</span><br><span class="line">                <span class="keyword">let</span> mipmap;</span><br><span class="line">                <span class="keyword">const</span> mipmaps = texture.mipmaps;</span><br><span class="line">                <span class="keyword">const</span> useTexStorage = isWebGL2 &amp;&amp; texture.isVideoTexture !== <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">const</span> allocateMemory = textureProperties.__version === <span class="literal">undefined</span>;</span><br><span class="line">                <span class="keyword">const</span> levels = getMipLevels(texture, image, supportsMips);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (texture.isDepthTexture) &#123;</span><br><span class="line">                    <span class="comment">// populate depth texture with dummy data</span></span><br><span class="line">                    glInternalFormat = _gl.DEPTH_COMPONENT;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (isWebGL2) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (texture.type === FloatType) &#123;</span><br><span class="line">                            glInternalFormat = _gl.DEPTH_COMPONENT32F;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (texture.type === UnsignedIntType) &#123;</span><br><span class="line">                            glInternalFormat = _gl.DEPTH_COMPONENT24;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (texture.type === UnsignedInt248Type) &#123;</span><br><span class="line">                            glInternalFormat = _gl.DEPTH24_STENCIL8;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            glInternalFormat = _gl.DEPTH_COMPONENT16; <span class="comment">// WebGL2 requires sized internalformat for glTexImage2D</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (texture.type === FloatType) &#123;</span><br><span class="line">                            <span class="built_in">console</span>.error(<span class="string">&#x27;WebGLRenderer: Floating point depth texture requires WebGL2.&#x27;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="comment">// validation checks for WebGL 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (texture.format === DepthFormat &amp;&amp; glInternalFormat === _gl.DEPTH_COMPONENT) &#123;</span><br><span class="line">                        <span class="comment">// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are</span></span><br><span class="line">                        <span class="comment">// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT</span></span><br><span class="line">                        <span class="comment">// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)</span></span><br><span class="line">                        <span class="keyword">if</span> (texture.type !== UnsignedShortType &amp;&amp; texture.type !== UnsignedIntType) &#123;</span><br><span class="line">                            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.&#x27;</span>);</span><br><span class="line">                            texture.type = UnsignedShortType;</span><br><span class="line">                            glType = utils.convert(texture.type);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (texture.format === DepthStencilFormat &amp;&amp; glInternalFormat === _gl.DEPTH_COMPONENT) &#123;</span><br><span class="line">                        <span class="comment">// Depth stencil textures need the DEPTH_STENCIL internal format</span></span><br><span class="line">                        <span class="comment">// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)</span></span><br><span class="line">                        glInternalFormat = _gl.DEPTH_STENCIL; <span class="comment">// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are</span></span><br><span class="line">                        <span class="comment">// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.</span></span><br><span class="line">                        <span class="comment">// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (texture.type !== UnsignedInt248Type) &#123;</span><br><span class="line">                            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.&#x27;</span>);</span><br><span class="line">                            texture.type = UnsignedInt248Type;</span><br><span class="line">                            glType = utils.convert(texture.type);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (useTexStorage &amp;&amp; allocateMemory) &#123;</span><br><span class="line">                        state.texStorage2D(_gl.TEXTURE_2D, <span class="number">1</span>, glInternalFormat, image.width, image.height);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        state.texImage2D(_gl.TEXTURE_2D, <span class="number">0</span>, glInternalFormat, image.width, image.height, <span class="number">0</span>, glFormat, glType, <span class="literal">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (texture.isDataTexture) &#123;</span><br><span class="line">                    <span class="comment">// use manually created mipmaps if available</span></span><br><span class="line">                    <span class="comment">// if there are no manual mipmaps</span></span><br><span class="line">                    <span class="comment">// set 0 level mipmap and then use GL to generate other mipmap levels</span></span><br><span class="line">                    <span class="keyword">if</span> (mipmaps.length &gt; <span class="number">0</span> &amp;&amp; supportsMips) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (useTexStorage &amp;&amp; allocateMemory) &#123;</span><br><span class="line">                            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[<span class="number">0</span>].width, mipmaps[<span class="number">0</span>].height);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = mipmaps.length; i &lt; il; i++) &#123;</span><br><span class="line">                            mipmap = mipmaps[i];</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (useTexStorage) &#123;</span><br><span class="line">                                state.texSubImage2D(_gl.TEXTURE_2D, i, <span class="number">0</span>, <span class="number">0</span>, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, <span class="number">0</span>, glFormat, glType, mipmap.data);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        texture.generateMipmaps = <span class="literal">false</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (useTexStorage) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (allocateMemory) &#123;</span><br><span class="line">                                state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            state.texSubImage2D(_gl.TEXTURE_2D, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, image.width, image.height, glFormat, glType, image.data);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            state.texImage2D(_gl.TEXTURE_2D, <span class="number">0</span>, glInternalFormat, image.width, image.height, <span class="number">0</span>, glFormat, glType, image.data);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (texture.isCompressedTexture) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (useTexStorage &amp;&amp; allocateMemory) &#123;</span><br><span class="line">                        state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[<span class="number">0</span>].width, mipmaps[<span class="number">0</span>].height);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = mipmaps.length; i &lt; il; i++) &#123;</span><br><span class="line">                        mipmap = mipmaps[i];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (texture.format !== RGBAFormat) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (glFormat !== <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (useTexStorage) &#123;</span><br><span class="line">                                    state.compressedTexSubImage2D(_gl.TEXTURE_2D, i, <span class="number">0</span>, <span class="number">0</span>, mipmap.width, mipmap.height, glFormat, mipmap.data);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, <span class="number">0</span>, mipmap.data);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()&#x27;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (useTexStorage) &#123;</span><br><span class="line">                                state.texSubImage2D(_gl.TEXTURE_2D, i, <span class="number">0</span>, <span class="number">0</span>, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, <span class="number">0</span>, glFormat, glType, mipmap.data);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (texture.isDataArrayTexture) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (useTexStorage) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (allocateMemory) &#123;</span><br><span class="line">                            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, image.width, image.height, image.depth, glFormat, glType, image.data);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        state.texImage3D(_gl.TEXTURE_2D_ARRAY, <span class="number">0</span>, glInternalFormat, image.width, image.height, image.depth, <span class="number">0</span>, glFormat, glType, image.data);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (texture.isData3DTexture) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (useTexStorage) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (allocateMemory) &#123;</span><br><span class="line">                            state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        state.texSubImage3D(_gl.TEXTURE_3D, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, image.width, image.height, image.depth, glFormat, glType, image.data);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        state.texImage3D(_gl.TEXTURE_3D, <span class="number">0</span>, glInternalFormat, image.width, image.height, image.depth, <span class="number">0</span>, glFormat, glType, image.data);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (texture.isFramebufferTexture) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (useTexStorage &amp;&amp; allocateMemory) &#123;</span><br><span class="line">                        state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        state.texImage2D(_gl.TEXTURE_2D, <span class="number">0</span>, glInternalFormat, image.width, image.height, <span class="number">0</span>, glFormat, glType, <span class="literal">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// regular Texture (image, video, canvas)</span></span><br><span class="line">                    <span class="comment">// use manually created mipmaps if available</span></span><br><span class="line">                    <span class="comment">// if there are no manual mipmaps</span></span><br><span class="line">                    <span class="comment">// set 0 level mipmap and then use GL to generate other mipmap levels</span></span><br><span class="line">                    <span class="keyword">if</span> (mipmaps.length &gt; <span class="number">0</span> &amp;&amp; supportsMips) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (useTexStorage &amp;&amp; allocateMemory) &#123;</span><br><span class="line">                            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[<span class="number">0</span>].width, mipmaps[<span class="number">0</span>].height);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = mipmaps.length; i &lt; il; i++) &#123;</span><br><span class="line">                            mipmap = mipmaps[i];</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (useTexStorage) &#123;</span><br><span class="line">                                state.texSubImage2D(_gl.TEXTURE_2D, i, <span class="number">0</span>, <span class="number">0</span>, glFormat, glType, mipmap);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        texture.generateMipmaps = <span class="literal">false</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (useTexStorage) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (allocateMemory) &#123;</span><br><span class="line">                                state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            state.texSubImage2D(_gl.TEXTURE_2D, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, glFormat, glType, image);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            state.texImage2D(_gl.TEXTURE_2D, <span class="number">0</span>, glInternalFormat, glFormat, glType, image);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (textureNeedsGenerateMipmaps(texture, supportsMips)) &#123;</span><br><span class="line">                    generateMipmap(textureType);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                source.__currentVersion = source.version;</span><br><span class="line">                <span class="keyword">if</span> (texture.onUpdate) texture.onUpdate(texture);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            textureProperties.__version = texture.version;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">uploadCubeTexture</span>(<span class="params">textureProperties, texture, slot</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (texture.image.length !== <span class="number">6</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">const</span> forceUpload = initTexture(textureProperties, texture);</span><br><span class="line">            <span class="keyword">const</span> source = texture.source;</span><br><span class="line">            state.activeTexture(_gl.TEXTURE0 + slot);</span><br><span class="line">            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (source.version !== source.__currentVersion || forceUpload === <span class="literal">true</span>) &#123;</span><br><span class="line">                _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);</span><br><span class="line"></span><br><span class="line">                _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);</span><br><span class="line"></span><br><span class="line">                _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);</span><br><span class="line"></span><br><span class="line">                _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> isCompressed = texture.isCompressedTexture || texture.image[<span class="number">0</span>].isCompressedTexture;</span><br><span class="line">                <span class="keyword">const</span> isDataTexture = texture.image[<span class="number">0</span>] &amp;&amp; texture.image[<span class="number">0</span>].isDataTexture;</span><br><span class="line">                <span class="keyword">const</span> cubeImage = [];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!isCompressed &amp;&amp; !isDataTexture) &#123;</span><br><span class="line">                        cubeImage[i] = resizeImage(texture.image[i], <span class="literal">false</span>, <span class="literal">true</span>, maxCubemapSize);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    cubeImage[i] = verifyColorSpace(texture, cubeImage[i]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> image = cubeImage[<span class="number">0</span>],</span><br><span class="line">                    supportsMips = isPowerOfTwo$<span class="number">1</span>(image) || isWebGL2,</span><br><span class="line">                    glFormat = utils.convert(texture.format, texture.encoding),</span><br><span class="line">                    glType = utils.convert(texture.type),</span><br><span class="line">                    glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);</span><br><span class="line">                <span class="keyword">const</span> useTexStorage = isWebGL2 &amp;&amp; texture.isVideoTexture !== <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">const</span> allocateMemory = textureProperties.__version === <span class="literal">undefined</span>;</span><br><span class="line">                <span class="keyword">let</span> levels = getMipLevels(texture, image, supportsMips);</span><br><span class="line">                setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);</span><br><span class="line">                <span class="keyword">let</span> mipmaps;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isCompressed) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (useTexStorage &amp;&amp; allocateMemory) &#123;</span><br><span class="line">                        state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                        mipmaps = cubeImage[i].mipmaps;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; mipmaps.length; j++) &#123;</span><br><span class="line">                            <span class="keyword">const</span> mipmap = mipmaps[j];</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (texture.format !== RGBAFormat) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (glFormat !== <span class="literal">null</span>) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (useTexStorage) &#123;</span><br><span class="line">                                        state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, <span class="number">0</span>, <span class="number">0</span>, mipmap.width, mipmap.height, glFormat, mipmap.data);</span><br><span class="line">                                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, <span class="number">0</span>, mipmap.data);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()&#x27;</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (useTexStorage) &#123;</span><br><span class="line">                                    state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, <span class="number">0</span>, <span class="number">0</span>, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, <span class="number">0</span>, glFormat, glType, mipmap.data);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mipmaps = texture.mipmaps;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (useTexStorage &amp;&amp; allocateMemory) &#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span> Uniformly handle mipmap definitions</span></span><br><span class="line">                        <span class="comment">// Normal textures and compressed cube textures define base level + mips with their mipmap array</span></span><br><span class="line">                        <span class="comment">// Uncompressed cube textures use their mipmap array only for mips (no base level)</span></span><br><span class="line">                        <span class="keyword">if</span> (mipmaps.length &gt; <span class="number">0</span>) levels++;</span><br><span class="line">                        state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, cubeImage[<span class="number">0</span>].width, cubeImage[<span class="number">0</span>].height);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (isDataTexture) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (useTexStorage) &#123;</span><br><span class="line">                                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, cubeImage[i].width, cubeImage[i].height, glFormat, glType, cubeImage[i].data);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, <span class="number">0</span>, glInternalFormat, cubeImage[i].width, cubeImage[i].height, <span class="number">0</span>, glFormat, glType, cubeImage[i].data);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; mipmaps.length; j++) &#123;</span><br><span class="line">                                <span class="keyword">const</span> mipmap = mipmaps[j];</span><br><span class="line">                                <span class="keyword">const</span> mipmapImage = mipmap.image[i].image;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (useTexStorage) &#123;</span><br><span class="line">                                    state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + <span class="number">1</span>, glInternalFormat, mipmapImage.width, mipmapImage.height, <span class="number">0</span>, glFormat, glType, mipmapImage.data);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (useTexStorage) &#123;</span><br><span class="line">                                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, glFormat, glType, cubeImage[i]);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, <span class="number">0</span>, glInternalFormat, glFormat, glType, cubeImage[i]);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; mipmaps.length; j++) &#123;</span><br><span class="line">                                <span class="keyword">const</span> mipmap = mipmaps[j];</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (useTexStorage) &#123;</span><br><span class="line">                                    state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, glFormat, glType, mipmap.image[i]);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + <span class="number">1</span>, glInternalFormat, glFormat, glType, mipmap.image[i]);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (textureNeedsGenerateMipmaps(texture, supportsMips)) &#123;</span><br><span class="line">                    <span class="comment">// We assume images for cube map have the same size.</span></span><br><span class="line">                    generateMipmap(_gl.TEXTURE_CUBE_MAP);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                source.__currentVersion = source.version;</span><br><span class="line">                <span class="keyword">if</span> (texture.onUpdate) texture.onUpdate(texture);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            textureProperties.__version = texture.version;</span><br><span class="line">        &#125; <span class="comment">// Render targets</span></span><br><span class="line">        <span class="comment">// Setup storage for target texture and bind it to correct framebuffer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setupFrameBufferTexture</span>(<span class="params">framebuffer, renderTarget, texture, attachment, textureTarget</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> glFormat = utils.convert(texture.format, texture.encoding);</span><br><span class="line">            <span class="keyword">const</span> glType = utils.convert(texture.type);</span><br><span class="line">            <span class="keyword">const</span> glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);</span><br><span class="line">            <span class="keyword">const</span> renderTargetProperties = properties.get(renderTarget);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!renderTargetProperties.__hasExternalTextures) &#123;</span><br><span class="line">                <span class="keyword">if</span> (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) &#123;</span><br><span class="line">                    state.texImage3D(textureTarget, <span class="number">0</span>, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, <span class="number">0</span>, glFormat, glType, <span class="literal">null</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    state.texImage2D(textureTarget, <span class="number">0</span>, glInternalFormat, renderTarget.width, renderTarget.height, <span class="number">0</span>, glFormat, glType, <span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (useMultisampledRTT(renderTarget)) &#123;</span><br><span class="line">                multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, <span class="number">0</span>, getRenderTargetSamples(renderTarget));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            state.bindFramebuffer(_gl.FRAMEBUFFER, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="comment">// Setup storage for internal depth/stencil buffers and bind to correct framebuffer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setupRenderBufferStorage</span>(<span class="params">renderbuffer, renderTarget, isMultisample</span>) </span>&#123;</span><br><span class="line">            _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (renderTarget.depthBuffer &amp;&amp; !renderTarget.stencilBuffer) &#123;</span><br><span class="line">                <span class="keyword">let</span> glInternalFormat = _gl.DEPTH_COMPONENT16;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isMultisample || useMultisampledRTT(renderTarget)) &#123;</span><br><span class="line">                    <span class="keyword">const</span> depthTexture = renderTarget.depthTexture;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (depthTexture &amp;&amp; depthTexture.isDepthTexture) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (depthTexture.type === FloatType) &#123;</span><br><span class="line">                            glInternalFormat = _gl.DEPTH_COMPONENT32F;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (depthTexture.type === UnsignedIntType) &#123;</span><br><span class="line">                            glInternalFormat = _gl.DEPTH_COMPONENT24;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> samples = getRenderTargetSamples(renderTarget);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (useMultisampledRTT(renderTarget)) &#123;</span><br><span class="line">                        multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (renderTarget.depthBuffer &amp;&amp; renderTarget.stencilBuffer) &#123;</span><br><span class="line">                <span class="keyword">const</span> samples = getRenderTargetSamples(renderTarget);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isMultisample &amp;&amp; useMultisampledRTT(renderTarget) === <span class="literal">false</span>) &#123;</span><br><span class="line">                    _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (useMultisampledRTT(renderTarget)) &#123;</span><br><span class="line">                    multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Use the first texture for MRT so far</span></span><br><span class="line">                <span class="keyword">const</span> texture = renderTarget.isWebGLMultipleRenderTargets === <span class="literal">true</span> ? renderTarget.texture[<span class="number">0</span>] : renderTarget.texture;</span><br><span class="line">                <span class="keyword">const</span> glFormat = utils.convert(texture.format, texture.encoding);</span><br><span class="line">                <span class="keyword">const</span> glType = utils.convert(texture.type);</span><br><span class="line">                <span class="keyword">const</span> glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);</span><br><span class="line">                <span class="keyword">const</span> samples = getRenderTargetSamples(renderTarget);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isMultisample &amp;&amp; useMultisampledRTT(renderTarget) === <span class="literal">false</span>) &#123;</span><br><span class="line">                    _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (useMultisampledRTT(renderTarget)) &#123;</span><br><span class="line">                    multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _gl.bindRenderbuffer(_gl.RENDERBUFFER, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="comment">// Setup resources for a Depth Texture for a FBO (needs an extension)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setupDepthTexture</span>(<span class="params">framebuffer, renderTarget</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> isCube = renderTarget &amp;&amp; renderTarget.isWebGLCubeRenderTarget;</span><br><span class="line">            <span class="keyword">if</span> (isCube) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Depth Texture with cube render targets is not supported&#x27;</span>);</span><br><span class="line">            state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!(renderTarget.depthTexture &amp;&amp; renderTarget.depthTexture.isDepthTexture)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;renderTarget.depthTexture must be an instance of THREE.DepthTexture&#x27;</span>);</span><br><span class="line">            &#125; <span class="comment">// upload an empty depth texture with framebuffer size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) &#123;</span><br><span class="line">                renderTarget.depthTexture.image.width = renderTarget.width;</span><br><span class="line">                renderTarget.depthTexture.image.height = renderTarget.height;</span><br><span class="line">                renderTarget.depthTexture.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            setTexture2D(renderTarget.depthTexture, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> samples = getRenderTargetSamples(renderTarget);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (renderTarget.depthTexture.format === DepthFormat) &#123;</span><br><span class="line">                <span class="keyword">if</span> (useMultisampledRTT(renderTarget)) &#123;</span><br><span class="line">                    multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, <span class="number">0</span>, samples);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (renderTarget.depthTexture.format === DepthStencilFormat) &#123;</span><br><span class="line">                <span class="keyword">if</span> (useMultisampledRTT(renderTarget)) &#123;</span><br><span class="line">                    multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, <span class="number">0</span>, samples);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Unknown depthTexture format&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// Setup GL resources for a non-texture depth buffer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setupDepthRenderbuffer</span>(<span class="params">renderTarget</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> renderTargetProperties = properties.get(renderTarget);</span><br><span class="line">            <span class="keyword">const</span> isCube = renderTarget.isWebGLCubeRenderTarget === <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (renderTarget.depthTexture &amp;&amp; !renderTargetProperties.__autoAllocateDepthBuffer) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isCube) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;target.depthTexture not supported in Cube render targets&#x27;</span>);</span><br><span class="line">                setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isCube) &#123;</span><br><span class="line">                    renderTargetProperties.__webglDepthbuffer = [];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);</span><br><span class="line">                        renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();</span><br><span class="line">                        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, <span class="literal">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);</span><br><span class="line">                    renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();</span><br><span class="line">                    setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, <span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            state.bindFramebuffer(_gl.FRAMEBUFFER, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="comment">// rebind framebuffer with external textures</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">rebindTextures</span>(<span class="params">renderTarget, colorTexture, depthTexture</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> renderTargetProperties = properties.get(renderTarget);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorTexture !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (depthTexture !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                setupDepthRenderbuffer(renderTarget);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// Set up GL resources for the render target</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setupRenderTarget</span>(<span class="params">renderTarget</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> texture = renderTarget.texture;</span><br><span class="line">            <span class="keyword">const</span> renderTargetProperties = properties.get(renderTarget);</span><br><span class="line">            <span class="keyword">const</span> textureProperties = properties.get(texture);</span><br><span class="line">            renderTarget.addEventListener(<span class="string">&#x27;dispose&#x27;</span>, onRenderTargetDispose);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (renderTarget.isWebGLMultipleRenderTargets !== <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (textureProperties.__webglTexture === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    textureProperties.__webglTexture = _gl.createTexture();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                textureProperties.__version = texture.version;</span><br><span class="line">                info.memory.textures++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> isCube = renderTarget.isWebGLCubeRenderTarget === <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">const</span> isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">const</span> supportsMips = isPowerOfTwo$<span class="number">1</span>(renderTarget) || isWebGL2; <span class="comment">// Setup framebuffer</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isCube) &#123;</span><br><span class="line">                renderTargetProperties.__webglFramebuffer = [];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                    renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isMultipleRenderTargets) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (capabilities.drawBuffers) &#123;</span><br><span class="line">                        <span class="keyword">const</span> textures = renderTarget.texture;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = textures.length; i &lt; il; i++) &#123;</span><br><span class="line">                            <span class="keyword">const</span> attachmentProperties = properties.get(textures[i]);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (attachmentProperties.__webglTexture === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                                attachmentProperties.__webglTexture = _gl.createTexture();</span><br><span class="line">                                info.memory.textures++;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.&#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWebGL2 &amp;&amp; renderTarget.samples &gt; <span class="number">0</span> &amp;&amp; useMultisampledRTT(renderTarget) === <span class="literal">false</span>) &#123;</span><br><span class="line">                    renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();</span><br><span class="line">                    renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();</span><br><span class="line"></span><br><span class="line">                    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> glFormat = utils.convert(texture.format, texture.encoding);</span><br><span class="line">                    <span class="keyword">const</span> glType = utils.convert(texture.type);</span><br><span class="line">                    <span class="keyword">const</span> glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);</span><br><span class="line">                    <span class="keyword">const</span> samples = getRenderTargetSamples(renderTarget);</span><br><span class="line"></span><br><span class="line">                    _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);</span><br><span class="line"></span><br><span class="line">                    state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);</span><br><span class="line"></span><br><span class="line">                    _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);</span><br><span class="line"></span><br><span class="line">                    _gl.bindRenderbuffer(_gl.RENDERBUFFER, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (renderTarget.depthBuffer) &#123;</span><br><span class="line">                        renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();</span><br><span class="line">                        setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, <span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    state.bindFramebuffer(_gl.FRAMEBUFFER, <span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// Setup color buffer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isCube) &#123;</span><br><span class="line">                state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);</span><br><span class="line">                setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                    setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (textureNeedsGenerateMipmaps(texture, supportsMips)) &#123;</span><br><span class="line">                    generateMipmap(_gl.TEXTURE_CUBE_MAP);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                state.unbindTexture();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isMultipleRenderTargets) &#123;</span><br><span class="line">                <span class="keyword">const</span> textures = renderTarget.texture;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = textures.length; i &lt; il; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> attachment = textures[i];</span><br><span class="line">                    <span class="keyword">const</span> attachmentProperties = properties.get(attachment);</span><br><span class="line">                    state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);</span><br><span class="line">                    setTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips);</span><br><span class="line">                    setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (textureNeedsGenerateMipmaps(attachment, supportsMips)) &#123;</span><br><span class="line">                        generateMipmap(_gl.TEXTURE_2D);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                state.unbindTexture();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> glTextureType = _gl.TEXTURE_2D;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isWebGL2) &#123;</span><br><span class="line">                        glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.&#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                state.bindTexture(glTextureType, textureProperties.__webglTexture);</span><br><span class="line">                setTextureParameters(glTextureType, texture, supportsMips);</span><br><span class="line">                setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (textureNeedsGenerateMipmaps(texture, supportsMips)) &#123;</span><br><span class="line">                    generateMipmap(glTextureType);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                state.unbindTexture();</span><br><span class="line">            &#125; <span class="comment">// Setup depth and stencil buffers</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (renderTarget.depthBuffer) &#123;</span><br><span class="line">                setupDepthRenderbuffer(renderTarget);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">updateRenderTargetMipmap</span>(<span class="params">renderTarget</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> supportsMips = isPowerOfTwo$<span class="number">1</span>(renderTarget) || isWebGL2;</span><br><span class="line">            <span class="keyword">const</span> textures = renderTarget.isWebGLMultipleRenderTargets === <span class="literal">true</span> ? renderTarget.texture : [renderTarget.texture];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = textures.length; i &lt; il; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> texture = textures[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (textureNeedsGenerateMipmaps(texture, supportsMips)) &#123;</span><br><span class="line">                    <span class="keyword">const</span> target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> webglTexture = properties.get(texture).__webglTexture;</span><br><span class="line"></span><br><span class="line">                    state.bindTexture(target, webglTexture);</span><br><span class="line">                    generateMipmap(target);</span><br><span class="line">                    state.unbindTexture();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">updateMultisampleRenderTarget</span>(<span class="params">renderTarget</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isWebGL2 &amp;&amp; renderTarget.samples &gt; <span class="number">0</span> &amp;&amp; useMultisampledRTT(renderTarget) === <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> width = renderTarget.width;</span><br><span class="line">                <span class="keyword">const</span> height = renderTarget.height;</span><br><span class="line">                <span class="keyword">let</span> mask = _gl.COLOR_BUFFER_BIT;</span><br><span class="line">                <span class="keyword">const</span> invalidationArray = [_gl.COLOR_ATTACHMENT0];</span><br><span class="line">                <span class="keyword">const</span> depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (renderTarget.depthBuffer) &#123;</span><br><span class="line">                    invalidationArray.push(depthStyle);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> renderTargetProperties = properties.get(renderTarget);</span><br><span class="line">                <span class="keyword">const</span> ignoreDepthValues = renderTargetProperties.__ignoreDepthValues !== <span class="literal">undefined</span> ? renderTargetProperties.__ignoreDepthValues : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ignoreDepthValues === <span class="literal">false</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;</span><br><span class="line">                    <span class="keyword">if</span> (renderTarget.stencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);</span><br><span class="line">                state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ignoreDepthValues === <span class="literal">true</span>) &#123;</span><br><span class="line">                    _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, [depthStyle]);</span><br><span class="line"></span><br><span class="line">                    _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                _gl.blitFramebuffer(<span class="number">0</span>, <span class="number">0</span>, width, height, <span class="number">0</span>, <span class="number">0</span>, width, height, mask, _gl.NEAREST);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (supportsInvalidateFramebuffer) &#123;</span><br><span class="line">                    _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArray);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                state.bindFramebuffer(_gl.READ_FRAMEBUFFER, <span class="literal">null</span>);</span><br><span class="line">                state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getRenderTargetSamples</span>(<span class="params">renderTarget</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.min(maxSamples, renderTarget.samples);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">useMultisampledRTT</span>(<span class="params">renderTarget</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> renderTargetProperties = properties.get(renderTarget);</span><br><span class="line">            <span class="keyword">return</span> isWebGL2 &amp;&amp; renderTarget.samples &gt; <span class="number">0</span> &amp;&amp; extensions.has(<span class="string">&#x27;WEBGL_multisampled_render_to_texture&#x27;</span>) === <span class="literal">true</span> &amp;&amp; renderTargetProperties.__useRenderToTexture !== <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">updateVideoTexture</span>(<span class="params">texture</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> frame = info.render.frame; <span class="comment">// Check the last frame we updated the VideoTexture</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_videoTextures.get(texture) !== frame) &#123;</span><br><span class="line">                _videoTextures.set(texture, frame);</span><br><span class="line"></span><br><span class="line">                texture.update();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">verifyColorSpace</span>(<span class="params">texture, image</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> encoding = texture.encoding;</span><br><span class="line">            <span class="keyword">const</span> format = texture.format;</span><br><span class="line">            <span class="keyword">const</span> type = texture.type;</span><br><span class="line">            <span class="keyword">if</span> (texture.isCompressedTexture === <span class="literal">true</span> || texture.isVideoTexture === <span class="literal">true</span> || texture.format === _SRGBAFormat) <span class="keyword">return</span> image;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (encoding !== LinearEncoding) &#123;</span><br><span class="line">                <span class="comment">// sRGB</span></span><br><span class="line">                <span class="keyword">if</span> (encoding === sRGBEncoding) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isWebGL2 === <span class="literal">false</span>) &#123;</span><br><span class="line">                        <span class="comment">// in WebGL 1, try to use EXT_sRGB extension and unsized formats</span></span><br><span class="line">                        <span class="keyword">if</span> (extensions.has(<span class="string">&#x27;EXT_sRGB&#x27;</span>) === <span class="literal">true</span> &amp;&amp; format === RGBAFormat) &#123;</span><br><span class="line">                            texture.format = _SRGBAFormat; <span class="comment">// it&#x27;s not possible to generate mips in WebGL 1 with this extension</span></span><br><span class="line"></span><br><span class="line">                            texture.minFilter = LinearFilter;</span><br><span class="line">                            texture.generateMipmaps = <span class="literal">false</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// slow fallback (CPU decode)</span></span><br><span class="line">                            image = ImageUtils.sRGBToLinear(image);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format</span></span><br><span class="line">                        <span class="keyword">if</span> (format !== RGBAFormat || type !== UnsignedByteType) &#123;</span><br><span class="line">                            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.&#x27;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLTextures: Unsupported texture encoding:&#x27;</span>, encoding);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> image;</span><br><span class="line">        &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.allocateTextureUnit = allocateTextureUnit;</span><br><span class="line">        <span class="built_in">this</span>.resetTextureUnits = resetTextureUnits;</span><br><span class="line">        <span class="built_in">this</span>.setTexture2D = setTexture2D;</span><br><span class="line">        <span class="built_in">this</span>.setTexture2DArray = setTexture2DArray;</span><br><span class="line">        <span class="built_in">this</span>.setTexture3D = setTexture3D;</span><br><span class="line">        <span class="built_in">this</span>.setTextureCube = setTextureCube;</span><br><span class="line">        <span class="built_in">this</span>.rebindTextures = rebindTextures;</span><br><span class="line">        <span class="built_in">this</span>.setupRenderTarget = setupRenderTarget;</span><br><span class="line">        <span class="built_in">this</span>.updateRenderTargetMipmap = updateRenderTargetMipmap;</span><br><span class="line">        <span class="built_in">this</span>.updateMultisampleRenderTarget = updateMultisampleRenderTarget;</span><br><span class="line">        <span class="built_in">this</span>.setupDepthRenderbuffer = setupDepthRenderbuffer;</span><br><span class="line">        <span class="built_in">this</span>.setupFrameBufferTexture = setupFrameBufferTexture;</span><br><span class="line">        <span class="built_in">this</span>.useMultisampledRTT = useMultisampledRTT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLUtils</span>(<span class="params">gl, extensions, capabilities</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> isWebGL2 = capabilities.isWebGL2;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">p, encoding = <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> extension;</span><br><span class="line">            <span class="keyword">if</span> (p === UnsignedByteType) <span class="keyword">return</span> gl.UNSIGNED_BYTE;</span><br><span class="line">            <span class="keyword">if</span> (p === UnsignedShort4444Type) <span class="keyword">return</span> gl.UNSIGNED_SHORT_4_4_4_4;</span><br><span class="line">            <span class="keyword">if</span> (p === UnsignedShort5551Type) <span class="keyword">return</span> gl.UNSIGNED_SHORT_5_5_5_1;</span><br><span class="line">            <span class="keyword">if</span> (p === ByteType) <span class="keyword">return</span> gl.BYTE;</span><br><span class="line">            <span class="keyword">if</span> (p === ShortType) <span class="keyword">return</span> gl.SHORT;</span><br><span class="line">            <span class="keyword">if</span> (p === UnsignedShortType) <span class="keyword">return</span> gl.UNSIGNED_SHORT;</span><br><span class="line">            <span class="keyword">if</span> (p === IntType) <span class="keyword">return</span> gl.INT;</span><br><span class="line">            <span class="keyword">if</span> (p === UnsignedIntType) <span class="keyword">return</span> gl.UNSIGNED_INT;</span><br><span class="line">            <span class="keyword">if</span> (p === FloatType) <span class="keyword">return</span> gl.FLOAT;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p === HalfFloatType) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isWebGL2) <span class="keyword">return</span> gl.HALF_FLOAT;</span><br><span class="line">                extension = extensions.get(<span class="string">&#x27;OES_texture_half_float&#x27;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (extension !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> extension.HALF_FLOAT_OES;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p === AlphaFormat) <span class="keyword">return</span> gl.ALPHA;</span><br><span class="line">            <span class="keyword">if</span> (p === RGBAFormat) <span class="keyword">return</span> gl.RGBA;</span><br><span class="line">            <span class="keyword">if</span> (p === LuminanceFormat) <span class="keyword">return</span> gl.LUMINANCE;</span><br><span class="line">            <span class="keyword">if</span> (p === LuminanceAlphaFormat) <span class="keyword">return</span> gl.LUMINANCE_ALPHA;</span><br><span class="line">            <span class="keyword">if</span> (p === DepthFormat) <span class="keyword">return</span> gl.DEPTH_COMPONENT;</span><br><span class="line">            <span class="keyword">if</span> (p === DepthStencilFormat) <span class="keyword">return</span> gl.DEPTH_STENCIL;</span><br><span class="line">            <span class="keyword">if</span> (p === RedFormat) <span class="keyword">return</span> gl.RED;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p === RGBFormat) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> gl.RGBA;</span><br><span class="line">            &#125; <span class="comment">// WebGL 1 sRGB fallback</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p === _SRGBAFormat) &#123;</span><br><span class="line">                extension = extensions.get(<span class="string">&#x27;EXT_sRGB&#x27;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (extension !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> extension.SRGB_ALPHA_EXT;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// WebGL2 formats.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p === RedIntegerFormat) <span class="keyword">return</span> gl.RED_INTEGER;</span><br><span class="line">            <span class="keyword">if</span> (p === RGFormat) <span class="keyword">return</span> gl.RG;</span><br><span class="line">            <span class="keyword">if</span> (p === RGIntegerFormat) <span class="keyword">return</span> gl.RG_INTEGER;</span><br><span class="line">            <span class="keyword">if</span> (p === RGBAIntegerFormat) <span class="keyword">return</span> gl.RGBA_INTEGER; <span class="comment">// S3TC</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) &#123;</span><br><span class="line">                <span class="keyword">if</span> (encoding === sRGBEncoding) &#123;</span><br><span class="line">                    extension = extensions.get(<span class="string">&#x27;WEBGL_compressed_texture_s3tc_srgb&#x27;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (extension !== <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (p === RGB_S3TC_DXT1_Format) <span class="keyword">return</span> extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;</span><br><span class="line">                        <span class="keyword">if</span> (p === RGBA_S3TC_DXT1_Format) <span class="keyword">return</span> extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;</span><br><span class="line">                        <span class="keyword">if</span> (p === RGBA_S3TC_DXT3_Format) <span class="keyword">return</span> extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;</span><br><span class="line">                        <span class="keyword">if</span> (p === RGBA_S3TC_DXT5_Format) <span class="keyword">return</span> extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    extension = extensions.get(<span class="string">&#x27;WEBGL_compressed_texture_s3tc&#x27;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (extension !== <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (p === RGB_S3TC_DXT1_Format) <span class="keyword">return</span> extension.COMPRESSED_RGB_S3TC_DXT1_EXT;</span><br><span class="line">                        <span class="keyword">if</span> (p === RGBA_S3TC_DXT1_Format) <span class="keyword">return</span> extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;</span><br><span class="line">                        <span class="keyword">if</span> (p === RGBA_S3TC_DXT3_Format) <span class="keyword">return</span> extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;</span><br><span class="line">                        <span class="keyword">if</span> (p === RGBA_S3TC_DXT5_Format) <span class="keyword">return</span> extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// PVRTC</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) &#123;</span><br><span class="line">                extension = extensions.get(<span class="string">&#x27;WEBGL_compressed_texture_pvrtc&#x27;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (extension !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p === RGB_PVRTC_4BPPV1_Format) <span class="keyword">return</span> extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;</span><br><span class="line">                    <span class="keyword">if</span> (p === RGB_PVRTC_2BPPV1_Format) <span class="keyword">return</span> extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;</span><br><span class="line">                    <span class="keyword">if</span> (p === RGBA_PVRTC_4BPPV1_Format) <span class="keyword">return</span> extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;</span><br><span class="line">                    <span class="keyword">if</span> (p === RGBA_PVRTC_2BPPV1_Format) <span class="keyword">return</span> extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// ETC1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p === RGB_ETC1_Format) &#123;</span><br><span class="line">                extension = extensions.get(<span class="string">&#x27;WEBGL_compressed_texture_etc1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (extension !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> extension.COMPRESSED_RGB_ETC1_WEBGL;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// ETC2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) &#123;</span><br><span class="line">                extension = extensions.get(<span class="string">&#x27;WEBGL_compressed_texture_etc&#x27;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (extension !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p === RGB_ETC2_Format) <span class="keyword">return</span> encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;</span><br><span class="line">                    <span class="keyword">if</span> (p === RGBA_ETC2_EAC_Format) <span class="keyword">return</span> encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// ASTC</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) &#123;</span><br><span class="line">                extension = extensions.get(<span class="string">&#x27;WEBGL_compressed_texture_astc&#x27;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (extension !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p === RGBA_ASTC_4x4_Format) <span class="keyword">return</span> encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;</span><br><span class="line">                    <span class="keyword">if</span> (p === RGBA_ASTC_5x4_Format) <span class="keyword">return</span> encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;</span><br><span class="line">                    <span class="keyword">if</span> (p === RGBA_ASTC_5x5_Format) <span class="keyword">return</span> encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;</span><br><span class="line">                    <span class="keyword">if</span> (p === RGBA_ASTC_6x5_Format) <span class="keyword">return</span> encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;</span><br><span class="line">                    <span class="keyword">if</span> (p === RGBA_ASTC_6x6_Format) <span class="keyword">return</span> encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;</span><br><span class="line">                    <span class="keyword">if</span> (p === RGBA_ASTC_8x5_Format) <span class="keyword">return</span> encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;</span><br><span class="line">                    <span class="keyword">if</span> (p === RGBA_ASTC_8x6_Format) <span class="keyword">return</span> encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;</span><br><span class="line">                    <span class="keyword">if</span> (p === RGBA_ASTC_8x8_Format) <span class="keyword">return</span> encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;</span><br><span class="line">                    <span class="keyword">if</span> (p === RGBA_ASTC_10x5_Format) <span class="keyword">return</span> encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;</span><br><span class="line">                    <span class="keyword">if</span> (p === RGBA_ASTC_10x6_Format) <span class="keyword">return</span> encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;</span><br><span class="line">                    <span class="keyword">if</span> (p === RGBA_ASTC_10x8_Format) <span class="keyword">return</span> encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;</span><br><span class="line">                    <span class="keyword">if</span> (p === RGBA_ASTC_10x10_Format) <span class="keyword">return</span> encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;</span><br><span class="line">                    <span class="keyword">if</span> (p === RGBA_ASTC_12x10_Format) <span class="keyword">return</span> encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;</span><br><span class="line">                    <span class="keyword">if</span> (p === RGBA_ASTC_12x12_Format) <span class="keyword">return</span> encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// BPTC</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p === RGBA_BPTC_Format) &#123;</span><br><span class="line">                extension = extensions.get(<span class="string">&#x27;EXT_texture_compression_bptc&#x27;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (extension !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p === RGBA_BPTC_Format) <span class="keyword">return</span> encoding === sRGBEncoding ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p === UnsignedInt248Type) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isWebGL2) <span class="keyword">return</span> gl.UNSIGNED_INT_24_8;</span><br><span class="line">                extension = extensions.get(<span class="string">&#x27;WEBGL_depth_texture&#x27;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (extension !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> extension.UNSIGNED_INT_24_8_WEBGL;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">convert</span>: convert</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ArrayCamera</span> <span class="keyword">extends</span> <span class="title">PerspectiveCamera</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array = []</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.cameras = array;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayCamera.prototype.isArrayCamera = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Group</span> <span class="keyword">extends</span> <span class="title">Object3D</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;Group&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Group.prototype.isGroup = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _moveEvent = &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;move&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WebXRController</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._targetRay = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>._grip = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>._hand = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getHandSpace</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._hand === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>._hand = <span class="keyword">new</span> Group();</span><br><span class="line">                <span class="built_in">this</span>._hand.matrixAutoUpdate = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">this</span>._hand.visible = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">this</span>._hand.joints = &#123;&#125;;</span><br><span class="line">                <span class="built_in">this</span>._hand.inputState = &#123;</span><br><span class="line">                    <span class="attr">pinching</span>: <span class="literal">false</span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._hand;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getTargetRaySpace</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._targetRay === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>._targetRay = <span class="keyword">new</span> Group();</span><br><span class="line">                <span class="built_in">this</span>._targetRay.matrixAutoUpdate = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">this</span>._targetRay.visible = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">this</span>._targetRay.hasLinearVelocity = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">this</span>._targetRay.linearVelocity = <span class="keyword">new</span> Vector3();</span><br><span class="line">                <span class="built_in">this</span>._targetRay.hasAngularVelocity = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">this</span>._targetRay.angularVelocity = <span class="keyword">new</span> Vector3();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._targetRay;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getGripSpace</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._grip === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>._grip = <span class="keyword">new</span> Group();</span><br><span class="line">                <span class="built_in">this</span>._grip.matrixAutoUpdate = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">this</span>._grip.visible = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">this</span>._grip.hasLinearVelocity = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">this</span>._grip.linearVelocity = <span class="keyword">new</span> Vector3();</span><br><span class="line">                <span class="built_in">this</span>._grip.hasAngularVelocity = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">this</span>._grip.angularVelocity = <span class="keyword">new</span> Vector3();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._grip;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dispatchEvent</span>(<span class="params">event</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._targetRay !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>._targetRay.dispatchEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._grip !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>._grip.dispatchEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._hand !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>._hand.dispatchEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">disconnect</span>(<span class="params">inputSource</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.dispatchEvent(&#123;</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;disconnected&#x27;</span>,</span><br><span class="line">                <span class="attr">data</span>: inputSource</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._targetRay !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>._targetRay.visible = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._grip !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>._grip.visible = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._hand !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>._hand.visible = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">update</span>(<span class="params">inputSource, frame, referenceSpace</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> inputPose = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">let</span> gripPose = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">let</span> handPose = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">const</span> targetRay = <span class="built_in">this</span>._targetRay;</span><br><span class="line">            <span class="keyword">const</span> grip = <span class="built_in">this</span>._grip;</span><br><span class="line">            <span class="keyword">const</span> hand = <span class="built_in">this</span>._hand;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (inputSource &amp;&amp; frame.session.visibilityState !== <span class="string">&#x27;visible-blurred&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (targetRay !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (inputPose !== <span class="literal">null</span>) &#123;</span><br><span class="line">                        targetRay.matrix.fromArray(inputPose.transform.matrix);</span><br><span class="line">                        targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (inputPose.linearVelocity) &#123;</span><br><span class="line">                            targetRay.hasLinearVelocity = <span class="literal">true</span>;</span><br><span class="line">                            targetRay.linearVelocity.copy(inputPose.linearVelocity);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            targetRay.hasLinearVelocity = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (inputPose.angularVelocity) &#123;</span><br><span class="line">                            targetRay.hasAngularVelocity = <span class="literal">true</span>;</span><br><span class="line">                            targetRay.angularVelocity.copy(inputPose.angularVelocity);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            targetRay.hasAngularVelocity = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">this</span>.dispatchEvent(_moveEvent);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (hand &amp;&amp; inputSource.hand) &#123;</span><br><span class="line">                    handPose = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">const</span> inputjoint <span class="keyword">of</span> inputSource.hand.values()) &#123;</span><br><span class="line">                        <span class="comment">// Update the joints groups with the XRJoint poses</span></span><br><span class="line">                        <span class="keyword">const</span> jointPose = frame.getJointPose(inputjoint, referenceSpace);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (hand.joints[inputjoint.jointName] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                            <span class="comment">// The transform of this joint will be updated with the joint pose on each frame</span></span><br><span class="line">                            <span class="keyword">const</span> joint = <span class="keyword">new</span> Group();</span><br><span class="line">                            joint.matrixAutoUpdate = <span class="literal">false</span>;</span><br><span class="line">                            joint.visible = <span class="literal">false</span>;</span><br><span class="line">                            hand.joints[inputjoint.jointName] = joint; <span class="comment">// ??</span></span><br><span class="line"></span><br><span class="line">                            hand.add(joint);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">const</span> joint = hand.joints[inputjoint.jointName];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (jointPose !== <span class="literal">null</span>) &#123;</span><br><span class="line">                            joint.matrix.fromArray(jointPose.transform.matrix);</span><br><span class="line">                            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);</span><br><span class="line">                            joint.jointRadius = jointPose.radius;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        joint.visible = jointPose !== <span class="literal">null</span>;</span><br><span class="line">                    &#125; <span class="comment">// Custom events</span></span><br><span class="line">                    <span class="comment">// Check pinchz</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> indexTip = hand.joints[<span class="string">&#x27;index-finger-tip&#x27;</span>];</span><br><span class="line">                    <span class="keyword">const</span> thumbTip = hand.joints[<span class="string">&#x27;thumb-tip&#x27;</span>];</span><br><span class="line">                    <span class="keyword">const</span> distance = indexTip.position.distanceTo(thumbTip.position);</span><br><span class="line">                    <span class="keyword">const</span> distanceToPinch = <span class="number">0.02</span>;</span><br><span class="line">                    <span class="keyword">const</span> threshold = <span class="number">0.005</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (hand.inputState.pinching &amp;&amp; distance &gt; distanceToPinch + threshold) &#123;</span><br><span class="line">                        hand.inputState.pinching = <span class="literal">false</span>;</span><br><span class="line">                        <span class="built_in">this</span>.dispatchEvent(&#123;</span><br><span class="line">                            <span class="attr">type</span>: <span class="string">&#x27;pinchend&#x27;</span>,</span><br><span class="line">                            <span class="attr">handedness</span>: inputSource.handedness,</span><br><span class="line">                            <span class="attr">target</span>: <span class="built_in">this</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hand.inputState.pinching &amp;&amp; distance &lt;= distanceToPinch - threshold) &#123;</span><br><span class="line">                        hand.inputState.pinching = <span class="literal">true</span>;</span><br><span class="line">                        <span class="built_in">this</span>.dispatchEvent(&#123;</span><br><span class="line">                            <span class="attr">type</span>: <span class="string">&#x27;pinchstart&#x27;</span>,</span><br><span class="line">                            <span class="attr">handedness</span>: inputSource.handedness,</span><br><span class="line">                            <span class="attr">target</span>: <span class="built_in">this</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grip !== <span class="literal">null</span> &amp;&amp; inputSource.gripSpace) &#123;</span><br><span class="line">                        gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (gripPose !== <span class="literal">null</span>) &#123;</span><br><span class="line">                            grip.matrix.fromArray(gripPose.transform.matrix);</span><br><span class="line">                            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (gripPose.linearVelocity) &#123;</span><br><span class="line">                                grip.hasLinearVelocity = <span class="literal">true</span>;</span><br><span class="line">                                grip.linearVelocity.copy(gripPose.linearVelocity);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                grip.hasLinearVelocity = <span class="literal">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (gripPose.angularVelocity) &#123;</span><br><span class="line">                                grip.hasAngularVelocity = <span class="literal">true</span>;</span><br><span class="line">                                grip.angularVelocity.copy(gripPose.angularVelocity);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                grip.hasAngularVelocity = <span class="literal">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (targetRay !== <span class="literal">null</span>) &#123;</span><br><span class="line">                targetRay.visible = inputPose !== <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (grip !== <span class="literal">null</span>) &#123;</span><br><span class="line">                grip.visible = gripPose !== <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hand !== <span class="literal">null</span>) &#123;</span><br><span class="line">                hand.visible = handPose !== <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DepthTexture</span> <span class="keyword">extends</span> <span class="title">Texture</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format</span>)</span> &#123;</span><br><span class="line">            format = format !== <span class="literal">undefined</span> ? format : DepthFormat;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (format !== DepthFormat &amp;&amp; format !== DepthStencilFormat) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (type === <span class="literal">undefined</span> &amp;&amp; format === DepthFormat) type = UnsignedShortType;</span><br><span class="line">            <span class="keyword">if</span> (type === <span class="literal">undefined</span> &amp;&amp; format === DepthStencilFormat) type = UnsignedInt248Type;</span><br><span class="line">            <span class="built_in">super</span>(<span class="literal">null</span>, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);</span><br><span class="line">            <span class="built_in">this</span>.image = &#123;</span><br><span class="line">                <span class="attr">width</span>: width,</span><br><span class="line">                <span class="attr">height</span>: height</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">this</span>.magFilter = magFilter !== <span class="literal">undefined</span> ? magFilter : NearestFilter;</span><br><span class="line">            <span class="built_in">this</span>.minFilter = minFilter !== <span class="literal">undefined</span> ? minFilter : NearestFilter;</span><br><span class="line">            <span class="built_in">this</span>.flipY = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.generateMipmaps = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DepthTexture.prototype.isDepthTexture = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WebXRManager</span> <span class="keyword">extends</span> <span class="title">EventDispatcher</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">renderer, gl</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="keyword">const</span> scope = <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">let</span> session = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">let</span> framebufferScaleFactor = <span class="number">1.0</span>;</span><br><span class="line">            <span class="keyword">let</span> referenceSpace = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">let</span> referenceSpaceType = <span class="string">&#x27;local-floor&#x27;</span>;</span><br><span class="line">            <span class="keyword">let</span> pose = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">let</span> glBinding = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">let</span> glProjLayer = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">let</span> glBaseLayer = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">let</span> xrFrame = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">const</span> attributes = gl.getContextAttributes();</span><br><span class="line">            <span class="keyword">let</span> initialRenderTarget = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">let</span> newRenderTarget = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">const</span> controllers = [];</span><br><span class="line">            <span class="keyword">const</span> inputSourcesMap = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> cameraL = <span class="keyword">new</span> PerspectiveCamera();</span><br><span class="line">            cameraL.layers.enable(<span class="number">1</span>);</span><br><span class="line">            cameraL.viewport = <span class="keyword">new</span> Vector4();</span><br><span class="line">            <span class="keyword">const</span> cameraR = <span class="keyword">new</span> PerspectiveCamera();</span><br><span class="line">            cameraR.layers.enable(<span class="number">2</span>);</span><br><span class="line">            cameraR.viewport = <span class="keyword">new</span> Vector4();</span><br><span class="line">            <span class="keyword">const</span> cameras = [cameraL, cameraR];</span><br><span class="line">            <span class="keyword">const</span> cameraVR = <span class="keyword">new</span> ArrayCamera();</span><br><span class="line">            cameraVR.layers.enable(<span class="number">1</span>);</span><br><span class="line">            cameraVR.layers.enable(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">let</span> _currentDepthNear = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">let</span> _currentDepthFar = <span class="literal">null</span>; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.cameraAutoUpdate = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.enabled = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.isPresenting = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.getController = <span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">let</span> controller = controllers[index];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (controller === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    controller = <span class="keyword">new</span> WebXRController();</span><br><span class="line">                    controllers[index] = controller;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> controller.getTargetRaySpace();</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.getControllerGrip = <span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">let</span> controller = controllers[index];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (controller === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    controller = <span class="keyword">new</span> WebXRController();</span><br><span class="line">                    controllers[index] = controller;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> controller.getGripSpace();</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.getHand = <span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">let</span> controller = controllers[index];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (controller === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    controller = <span class="keyword">new</span> WebXRController();</span><br><span class="line">                    controllers[index] = controller;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> controller.getHandSpace();</span><br><span class="line">            &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">onSessionEvent</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> controller = inputSourcesMap.get(event.inputSource);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (controller) &#123;</span><br><span class="line">                    controller.dispatchEvent(&#123;</span><br><span class="line">                        <span class="attr">type</span>: event.type,</span><br><span class="line">                        <span class="attr">data</span>: event.inputSource</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">onSessionEnd</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                inputSourcesMap.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">controller, inputSource</span>) </span>&#123;</span><br><span class="line">                    controller.disconnect(inputSource);</span><br><span class="line">                &#125;);</span><br><span class="line">                inputSourcesMap.clear();</span><br><span class="line">                _currentDepthNear = <span class="literal">null</span>;</span><br><span class="line">                _currentDepthFar = <span class="literal">null</span>; <span class="comment">// restore framebuffer/rendering state</span></span><br><span class="line"></span><br><span class="line">                renderer.setRenderTarget(initialRenderTarget);</span><br><span class="line">                glBaseLayer = <span class="literal">null</span>;</span><br><span class="line">                glProjLayer = <span class="literal">null</span>;</span><br><span class="line">                glBinding = <span class="literal">null</span>;</span><br><span class="line">                session = <span class="literal">null</span>;</span><br><span class="line">                newRenderTarget = <span class="literal">null</span>; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">                animation.stop();</span><br><span class="line">                scope.isPresenting = <span class="literal">false</span>;</span><br><span class="line">                scope.dispatchEvent(&#123;</span><br><span class="line">                    <span class="attr">type</span>: <span class="string">&#x27;sessionend&#x27;</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setFramebufferScaleFactor = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                framebufferScaleFactor = value;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (scope.isPresenting === <span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebXRManager: Cannot change framebuffer scale while presenting.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setReferenceSpaceType = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                referenceSpaceType = value;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (scope.isPresenting === <span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebXRManager: Cannot change reference space type while presenting.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.getReferenceSpace = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> referenceSpace;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.getBaseLayer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> glProjLayer !== <span class="literal">null</span> ? glProjLayer : glBaseLayer;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.getBinding = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> glBinding;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.getFrame = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> xrFrame;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.getSession = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> session;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setSession = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                session = value;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (session !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    initialRenderTarget = renderer.getRenderTarget();</span><br><span class="line">                    session.addEventListener(<span class="string">&#x27;select&#x27;</span>, onSessionEvent);</span><br><span class="line">                    session.addEventListener(<span class="string">&#x27;selectstart&#x27;</span>, onSessionEvent);</span><br><span class="line">                    session.addEventListener(<span class="string">&#x27;selectend&#x27;</span>, onSessionEvent);</span><br><span class="line">                    session.addEventListener(<span class="string">&#x27;squeeze&#x27;</span>, onSessionEvent);</span><br><span class="line">                    session.addEventListener(<span class="string">&#x27;squeezestart&#x27;</span>, onSessionEvent);</span><br><span class="line">                    session.addEventListener(<span class="string">&#x27;squeezeend&#x27;</span>, onSessionEvent);</span><br><span class="line">                    session.addEventListener(<span class="string">&#x27;end&#x27;</span>, onSessionEnd);</span><br><span class="line">                    session.addEventListener(<span class="string">&#x27;inputsourceschange&#x27;</span>, onInputSourcesChange);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (attributes.xrCompatible !== <span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">await</span> gl.makeXRCompatible();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (session.renderState.layers === <span class="literal">undefined</span> || renderer.capabilities.isWebGL2 === <span class="literal">false</span>) &#123;</span><br><span class="line">                        <span class="keyword">const</span> layerInit = &#123;</span><br><span class="line">                            <span class="attr">antialias</span>: session.renderState.layers === <span class="literal">undefined</span> ? attributes.antialias : <span class="literal">true</span>,</span><br><span class="line">                            <span class="attr">alpha</span>: attributes.alpha,</span><br><span class="line">                            <span class="attr">depth</span>: attributes.depth,</span><br><span class="line">                            <span class="attr">stencil</span>: attributes.stencil,</span><br><span class="line">                            <span class="attr">framebufferScaleFactor</span>: framebufferScaleFactor</span><br><span class="line">                        &#125;;</span><br><span class="line">                        glBaseLayer = <span class="keyword">new</span> XRWebGLLayer(session, gl, layerInit);</span><br><span class="line">                        session.updateRenderState(&#123;</span><br><span class="line">                            <span class="attr">baseLayer</span>: glBaseLayer</span><br><span class="line">                        &#125;);</span><br><span class="line">                        newRenderTarget = <span class="keyword">new</span> WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, &#123;</span><br><span class="line">                            <span class="attr">format</span>: RGBAFormat,</span><br><span class="line">                            <span class="attr">type</span>: UnsignedByteType,</span><br><span class="line">                            <span class="attr">encoding</span>: renderer.outputEncoding</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> depthFormat = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">let</span> depthType = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">let</span> glDepthFormat = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (attributes.depth) &#123;</span><br><span class="line">                            glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;</span><br><span class="line">                            depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;</span><br><span class="line">                            depthType = attributes.stencil ? UnsignedInt248Type : UnsignedShortType;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">const</span> projectionlayerInit = &#123;</span><br><span class="line">                            <span class="attr">colorFormat</span>: renderer.outputEncoding === sRGBEncoding ? gl.SRGB8_ALPHA8 : gl.RGBA8,</span><br><span class="line">                            <span class="attr">depthFormat</span>: glDepthFormat,</span><br><span class="line">                            <span class="attr">scaleFactor</span>: framebufferScaleFactor</span><br><span class="line">                        &#125;;</span><br><span class="line">                        glBinding = <span class="keyword">new</span> XRWebGLBinding(session, gl);</span><br><span class="line">                        glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);</span><br><span class="line">                        session.updateRenderState(&#123;</span><br><span class="line">                            <span class="attr">layers</span>: [glProjLayer]</span><br><span class="line">                        &#125;);</span><br><span class="line">                        newRenderTarget = <span class="keyword">new</span> WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, &#123;</span><br><span class="line">                            <span class="attr">format</span>: RGBAFormat,</span><br><span class="line">                            <span class="attr">type</span>: UnsignedByteType,</span><br><span class="line">                            <span class="attr">depthTexture</span>: <span class="keyword">new</span> DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, depthFormat),</span><br><span class="line">                            <span class="attr">stencilBuffer</span>: attributes.stencil,</span><br><span class="line">                            <span class="attr">encoding</span>: renderer.outputEncoding,</span><br><span class="line">                            <span class="attr">samples</span>: attributes.antialias ? <span class="number">4</span> : <span class="number">0</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                        <span class="keyword">const</span> renderTargetProperties = renderer.properties.get(newRenderTarget);</span><br><span class="line">                        renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    newRenderTarget.isXRRenderTarget = <span class="literal">true</span>; <span class="comment">// TODO Remove this when possible, see #23278</span></span><br><span class="line">                    <span class="comment">// Set foveation to maximum.</span></span><br><span class="line"></span><br><span class="line">                    <span class="built_in">this</span>.setFoveation(<span class="number">1.0</span>);</span><br><span class="line">                    referenceSpace = <span class="keyword">await</span> session.requestReferenceSpace(referenceSpaceType);</span><br><span class="line">                    animation.setContext(session);</span><br><span class="line">                    animation.start();</span><br><span class="line">                    scope.isPresenting = <span class="literal">true</span>;</span><br><span class="line">                    scope.dispatchEvent(&#123;</span><br><span class="line">                        <span class="attr">type</span>: <span class="string">&#x27;sessionstart&#x27;</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">onInputSourcesChange</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> inputSources = session.inputSources; <span class="comment">// Assign inputSources to available controllers</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; controllers.length; i++) &#123;</span><br><span class="line">                    inputSourcesMap.set(inputSources[i], controllers[i]);</span><br><span class="line">                &#125; <span class="comment">// Notify disconnected</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; event.removed.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> inputSource = event.removed[i];</span><br><span class="line">                    <span class="keyword">const</span> controller = inputSourcesMap.get(inputSource);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (controller) &#123;</span><br><span class="line">                        controller.dispatchEvent(&#123;</span><br><span class="line">                            <span class="attr">type</span>: <span class="string">&#x27;disconnected&#x27;</span>,</span><br><span class="line">                            <span class="attr">data</span>: inputSource</span><br><span class="line">                        &#125;);</span><br><span class="line">                        inputSourcesMap.delete(inputSource);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="comment">// Notify connected</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; event.added.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> inputSource = event.added[i];</span><br><span class="line">                    <span class="keyword">const</span> controller = inputSourcesMap.get(inputSource);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (controller) &#123;</span><br><span class="line">                        controller.dispatchEvent(&#123;</span><br><span class="line">                            <span class="attr">type</span>: <span class="string">&#x27;connected&#x27;</span>,</span><br><span class="line">                            <span class="attr">data</span>: inputSource</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> cameraLPos = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> cameraRPos = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Assumes 2 cameras that are parallel and share an X-axis, and that</span></span><br><span class="line"><span class="comment">             * the cameras&#x27; projection and world matrices have already been set.</span></span><br><span class="line"><span class="comment">             * And that near and far planes are identical for both cameras.</span></span><br><span class="line"><span class="comment">             * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">setProjectionFromUnion</span>(<span class="params">camera, cameraL, cameraR</span>) </span>&#123;</span><br><span class="line">                cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);</span><br><span class="line">                cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);</span><br><span class="line">                <span class="keyword">const</span> ipd = cameraLPos.distanceTo(cameraRPos);</span><br><span class="line">                <span class="keyword">const</span> projL = cameraL.projectionMatrix.elements;</span><br><span class="line">                <span class="keyword">const</span> projR = cameraR.projectionMatrix.elements; <span class="comment">// VR systems will have identical far and near planes, and</span></span><br><span class="line">                <span class="comment">// most likely identical top and bottom frustum extents.</span></span><br><span class="line">                <span class="comment">// Use the left camera for these values.</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> near = projL[<span class="number">14</span>] / (projL[<span class="number">10</span>] - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">const</span> far = projL[<span class="number">14</span>] / (projL[<span class="number">10</span>] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">const</span> topFov = (projL[<span class="number">9</span>] + <span class="number">1</span>) / projL[<span class="number">5</span>];</span><br><span class="line">                <span class="keyword">const</span> bottomFov = (projL[<span class="number">9</span>] - <span class="number">1</span>) / projL[<span class="number">5</span>];</span><br><span class="line">                <span class="keyword">const</span> leftFov = (projL[<span class="number">8</span>] - <span class="number">1</span>) / projL[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">const</span> rightFov = (projR[<span class="number">8</span>] + <span class="number">1</span>) / projR[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">const</span> left = near * leftFov;</span><br><span class="line">                <span class="keyword">const</span> right = near * rightFov; <span class="comment">// Calculate the new camera&#x27;s position offset from the</span></span><br><span class="line">                <span class="comment">// left camera. xOffset should be roughly half `ipd`.</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> zOffset = ipd / (-leftFov + rightFov);</span><br><span class="line">                <span class="keyword">const</span> xOffset = zOffset * -leftFov; <span class="comment">// <span class="doctag">TODO:</span> Better way to apply this offset?</span></span><br><span class="line"></span><br><span class="line">                cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);</span><br><span class="line">                camera.translateX(xOffset);</span><br><span class="line">                camera.translateZ(zOffset);</span><br><span class="line">                camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);</span><br><span class="line">                camera.matrixWorldInverse.copy(camera.matrixWorld).invert(); <span class="comment">// Find the union of the frustum values of the cameras and scale</span></span><br><span class="line">                <span class="comment">// the values so that the near plane&#x27;s position does not change in world space,</span></span><br><span class="line">                <span class="comment">// although must now be relative to the new union camera.</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> near2 = near + zOffset;</span><br><span class="line">                <span class="keyword">const</span> far2 = far + zOffset;</span><br><span class="line">                <span class="keyword">const</span> left2 = left - xOffset;</span><br><span class="line">                <span class="keyword">const</span> right2 = right + (ipd - xOffset);</span><br><span class="line">                <span class="keyword">const</span> top2 = topFov * far / far2 * near2;</span><br><span class="line">                <span class="keyword">const</span> bottom2 = bottomFov * far / far2 * near2;</span><br><span class="line">                camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">updateCamera</span>(<span class="params">camera, parent</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (parent === <span class="literal">null</span>) &#123;</span><br><span class="line">                    camera.matrixWorld.copy(camera.matrix);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                camera.matrixWorldInverse.copy(camera.matrixWorld).invert();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.updateCamera = <span class="function"><span class="keyword">function</span> (<span class="params">camera</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (session === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">                cameraVR.near = cameraR.near = cameraL.near = camera.near;</span><br><span class="line">                cameraVR.far = cameraR.far = cameraL.far = camera.far;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) &#123;</span><br><span class="line">                    <span class="comment">// Note that the new renderState won&#x27;t apply until the next frame. See #18320</span></span><br><span class="line">                    session.updateRenderState(&#123;</span><br><span class="line">                        <span class="attr">depthNear</span>: cameraVR.near,</span><br><span class="line">                        <span class="attr">depthFar</span>: cameraVR.far</span><br><span class="line">                    &#125;);</span><br><span class="line">                    _currentDepthNear = cameraVR.near;</span><br><span class="line">                    _currentDepthFar = cameraVR.far;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> parent = camera.parent;</span><br><span class="line">                <span class="keyword">const</span> cameras = cameraVR.cameras;</span><br><span class="line">                updateCamera(cameraVR, parent);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cameras.length; i++) &#123;</span><br><span class="line">                    updateCamera(cameras[i], parent);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale); <span class="comment">// update user camera and its children</span></span><br><span class="line"></span><br><span class="line">                camera.position.copy(cameraVR.position);</span><br><span class="line">                camera.quaternion.copy(cameraVR.quaternion);</span><br><span class="line">                camera.scale.copy(cameraVR.scale);</span><br><span class="line">                camera.matrix.copy(cameraVR.matrix);</span><br><span class="line">                camera.matrixWorld.copy(cameraVR.matrixWorld);</span><br><span class="line">                <span class="keyword">const</span> children = camera.children;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = children.length; i &lt; l; i++) &#123;</span><br><span class="line">                    children[i].updateMatrixWorld(<span class="literal">true</span>);</span><br><span class="line">                &#125; <span class="comment">// update projection matrix for proper view frustum culling</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cameras.length === <span class="number">2</span>) &#123;</span><br><span class="line">                    setProjectionFromUnion(cameraVR, cameraL, cameraR);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// assume single camera setup (AR)</span></span><br><span class="line">                    cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.getCamera = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cameraVR;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.getFoveation = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (glProjLayer !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> glProjLayer.fixedFoveation;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (glBaseLayer !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> glBaseLayer.fixedFoveation;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setFoveation = <span class="function"><span class="keyword">function</span> (<span class="params">foveation</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 0 = no foveation = full resolution</span></span><br><span class="line">                <span class="comment">// 1 = maximum foveation = the edges render at lower resolution</span></span><br><span class="line">                <span class="keyword">if</span> (glProjLayer !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    glProjLayer.fixedFoveation = foveation;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (glBaseLayer !== <span class="literal">null</span> &amp;&amp; glBaseLayer.fixedFoveation !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    glBaseLayer.fixedFoveation = foveation;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;; <span class="comment">// Animation Loop</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> onAnimationFrameCallback = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">onAnimationFrame</span>(<span class="params">time, frame</span>) </span>&#123;</span><br><span class="line">                pose = frame.getViewerPose(referenceSpace);</span><br><span class="line">                xrFrame = frame;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pose !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> views = pose.views;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (glBaseLayer !== <span class="literal">null</span>) &#123;</span><br><span class="line">                        renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);</span><br><span class="line">                        renderer.setRenderTarget(newRenderTarget);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">let</span> cameraVRNeedsUpdate = <span class="literal">false</span>; <span class="comment">// check if it&#x27;s necessary to rebuild cameraVR&#x27;s camera list</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (views.length !== cameraVR.cameras.length) &#123;</span><br><span class="line">                        cameraVR.cameras.length = <span class="number">0</span>;</span><br><span class="line">                        cameraVRNeedsUpdate = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; views.length; i++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> view = views[i];</span><br><span class="line">                        <span class="keyword">let</span> viewport = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (glBaseLayer !== <span class="literal">null</span>) &#123;</span><br><span class="line">                            viewport = glBaseLayer.getViewport(view);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">const</span> glSubImage = glBinding.getViewSubImage(glProjLayer, view);</span><br><span class="line">                            viewport = glSubImage.viewport; <span class="comment">// For side-by-side projection, we only produce a single texture for both eyes.</span></span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">                                renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? <span class="literal">undefined</span> : glSubImage.depthStencilTexture);</span><br><span class="line">                                renderer.setRenderTarget(newRenderTarget);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">const</span> camera = cameras[i];</span><br><span class="line">                        camera.matrix.fromArray(view.transform.matrix);</span><br><span class="line">                        camera.projectionMatrix.fromArray(view.projectionMatrix);</span><br><span class="line">                        camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">                            cameraVR.matrix.copy(camera.matrix);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (cameraVRNeedsUpdate === <span class="literal">true</span>) &#123;</span><br><span class="line">                            cameraVR.cameras.push(camera);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> inputSources = session.inputSources;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; controllers.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> controller = controllers[i];</span><br><span class="line">                    <span class="keyword">const</span> inputSource = inputSources[i];</span><br><span class="line">                    controller.update(inputSource, frame, referenceSpace);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);</span><br><span class="line">                xrFrame = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> animation = <span class="keyword">new</span> WebGLAnimation();</span><br><span class="line">            animation.setAnimationLoop(onAnimationFrame);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setAnimationLoop = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">                onAnimationFrameCallback = callback;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.dispose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLMaterials</span>(<span class="params">renderer, properties</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">refreshFogUniforms</span>(<span class="params">uniforms, fog</span>) </span>&#123;</span><br><span class="line">            uniforms.fogColor.value.copy(fog.color);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fog.isFog) &#123;</span><br><span class="line">                uniforms.fogNear.value = fog.near;</span><br><span class="line">                uniforms.fogFar.value = fog.far;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fog.isFogExp2) &#123;</span><br><span class="line">                uniforms.fogDensity.value = fog.density;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">refreshMaterialUniforms</span>(<span class="params">uniforms, material, pixelRatio, height, transmissionRenderTarget</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (material.isMeshBasicMaterial) &#123;</span><br><span class="line">                refreshUniformsCommon(uniforms, material);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.isMeshLambertMaterial) &#123;</span><br><span class="line">                refreshUniformsCommon(uniforms, material);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.isMeshToonMaterial) &#123;</span><br><span class="line">                refreshUniformsCommon(uniforms, material);</span><br><span class="line">                refreshUniformsToon(uniforms, material);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.isMeshPhongMaterial) &#123;</span><br><span class="line">                refreshUniformsCommon(uniforms, material);</span><br><span class="line">                refreshUniformsPhong(uniforms, material);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.isMeshStandardMaterial) &#123;</span><br><span class="line">                refreshUniformsCommon(uniforms, material);</span><br><span class="line">                refreshUniformsStandard(uniforms, material);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (material.isMeshPhysicalMaterial) &#123;</span><br><span class="line">                    refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.isMeshMatcapMaterial) &#123;</span><br><span class="line">                refreshUniformsCommon(uniforms, material);</span><br><span class="line">                refreshUniformsMatcap(uniforms, material);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.isMeshDepthMaterial) &#123;</span><br><span class="line">                refreshUniformsCommon(uniforms, material);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.isMeshDistanceMaterial) &#123;</span><br><span class="line">                refreshUniformsCommon(uniforms, material);</span><br><span class="line">                refreshUniformsDistance(uniforms, material);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.isMeshNormalMaterial) &#123;</span><br><span class="line">                refreshUniformsCommon(uniforms, material);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.isLineBasicMaterial) &#123;</span><br><span class="line">                refreshUniformsLine(uniforms, material);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (material.isLineDashedMaterial) &#123;</span><br><span class="line">                    refreshUniformsDash(uniforms, material);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.isPointsMaterial) &#123;</span><br><span class="line">                refreshUniformsPoints(uniforms, material, pixelRatio, height);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.isSpriteMaterial) &#123;</span><br><span class="line">                refreshUniformsSprites(uniforms, material);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.isShadowMaterial) &#123;</span><br><span class="line">                uniforms.color.value.copy(material.color);</span><br><span class="line">                uniforms.opacity.value = material.opacity;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.isShaderMaterial) &#123;</span><br><span class="line">                material.uniformsNeedUpdate = <span class="literal">false</span>; <span class="comment">// #15581</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">refreshUniformsCommon</span>(<span class="params">uniforms, material</span>) </span>&#123;</span><br><span class="line">            uniforms.opacity.value = material.opacity;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.color) &#123;</span><br><span class="line">                uniforms.diffuse.value.copy(material.color);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.emissive) &#123;</span><br><span class="line">                uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.map) &#123;</span><br><span class="line">                uniforms.map.value = material.map;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.alphaMap) &#123;</span><br><span class="line">                uniforms.alphaMap.value = material.alphaMap;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.bumpMap) &#123;</span><br><span class="line">                uniforms.bumpMap.value = material.bumpMap;</span><br><span class="line">                uniforms.bumpScale.value = material.bumpScale;</span><br><span class="line">                <span class="keyword">if</span> (material.side === BackSide) uniforms.bumpScale.value *= -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.displacementMap) &#123;</span><br><span class="line">                uniforms.displacementMap.value = material.displacementMap;</span><br><span class="line">                uniforms.displacementScale.value = material.displacementScale;</span><br><span class="line">                uniforms.displacementBias.value = material.displacementBias;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.emissiveMap) &#123;</span><br><span class="line">                uniforms.emissiveMap.value = material.emissiveMap;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.normalMap) &#123;</span><br><span class="line">                uniforms.normalMap.value = material.normalMap;</span><br><span class="line">                uniforms.normalScale.value.copy(material.normalScale);</span><br><span class="line">                <span class="keyword">if</span> (material.side === BackSide) uniforms.normalScale.value.negate();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.specularMap) &#123;</span><br><span class="line">                uniforms.specularMap.value = material.specularMap;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.alphaTest &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                uniforms.alphaTest.value = material.alphaTest;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> envMap = properties.get(material).envMap;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (envMap) &#123;</span><br><span class="line">                uniforms.envMap.value = envMap;</span><br><span class="line">                uniforms.flipEnvMap.value = envMap.isCubeTexture &amp;&amp; envMap.isRenderTargetTexture === <span class="literal">false</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">                uniforms.reflectivity.value = material.reflectivity;</span><br><span class="line">                uniforms.ior.value = material.ior;</span><br><span class="line">                uniforms.refractionRatio.value = material.refractionRatio;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.lightMap) &#123;</span><br><span class="line">                uniforms.lightMap.value = material.lightMap; <span class="comment">// artist-friendly light intensity scaling factor</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> scaleFactor = renderer.physicallyCorrectLights !== <span class="literal">true</span> ? <span class="built_in">Math</span>.PI : <span class="number">1</span>;</span><br><span class="line">                uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.aoMap) &#123;</span><br><span class="line">                uniforms.aoMap.value = material.aoMap;</span><br><span class="line">                uniforms.aoMapIntensity.value = material.aoMapIntensity;</span><br><span class="line">            &#125; <span class="comment">// uv repeat and offset setting priorities</span></span><br><span class="line">            <span class="comment">// 1. color map</span></span><br><span class="line">            <span class="comment">// 2. specular map</span></span><br><span class="line">            <span class="comment">// 3. displacementMap map</span></span><br><span class="line">            <span class="comment">// 4. normal map</span></span><br><span class="line">            <span class="comment">// 5. bump map</span></span><br><span class="line">            <span class="comment">// 6. roughnessMap map</span></span><br><span class="line">            <span class="comment">// 7. metalnessMap map</span></span><br><span class="line">            <span class="comment">// 8. alphaMap map</span></span><br><span class="line">            <span class="comment">// 9. emissiveMap map</span></span><br><span class="line">            <span class="comment">// 10. clearcoat map</span></span><br><span class="line">            <span class="comment">// 11. clearcoat normal map</span></span><br><span class="line">            <span class="comment">// 12. clearcoat roughnessMap map</span></span><br><span class="line">            <span class="comment">// 13. specular intensity map</span></span><br><span class="line">            <span class="comment">// 14. specular tint map</span></span><br><span class="line">            <span class="comment">// 15. transmission map</span></span><br><span class="line">            <span class="comment">// 16. thickness map</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> uvScaleMap;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.map) &#123;</span><br><span class="line">                uvScaleMap = material.map;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.specularMap) &#123;</span><br><span class="line">                uvScaleMap = material.specularMap;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.displacementMap) &#123;</span><br><span class="line">                uvScaleMap = material.displacementMap;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.normalMap) &#123;</span><br><span class="line">                uvScaleMap = material.normalMap;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.bumpMap) &#123;</span><br><span class="line">                uvScaleMap = material.bumpMap;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.roughnessMap) &#123;</span><br><span class="line">                uvScaleMap = material.roughnessMap;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.metalnessMap) &#123;</span><br><span class="line">                uvScaleMap = material.metalnessMap;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.alphaMap) &#123;</span><br><span class="line">                uvScaleMap = material.alphaMap;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.emissiveMap) &#123;</span><br><span class="line">                uvScaleMap = material.emissiveMap;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.clearcoatMap) &#123;</span><br><span class="line">                uvScaleMap = material.clearcoatMap;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.clearcoatNormalMap) &#123;</span><br><span class="line">                uvScaleMap = material.clearcoatNormalMap;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.clearcoatRoughnessMap) &#123;</span><br><span class="line">                uvScaleMap = material.clearcoatRoughnessMap;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.specularIntensityMap) &#123;</span><br><span class="line">                uvScaleMap = material.specularIntensityMap;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.specularColorMap) &#123;</span><br><span class="line">                uvScaleMap = material.specularColorMap;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.transmissionMap) &#123;</span><br><span class="line">                uvScaleMap = material.transmissionMap;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.thicknessMap) &#123;</span><br><span class="line">                uvScaleMap = material.thicknessMap;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.sheenColorMap) &#123;</span><br><span class="line">                uvScaleMap = material.sheenColorMap;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.sheenRoughnessMap) &#123;</span><br><span class="line">                uvScaleMap = material.sheenRoughnessMap;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (uvScaleMap !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="comment">// backwards compatibility</span></span><br><span class="line">                <span class="keyword">if</span> (uvScaleMap.isWebGLRenderTarget) &#123;</span><br><span class="line">                    uvScaleMap = uvScaleMap.texture;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (uvScaleMap.matrixAutoUpdate === <span class="literal">true</span>) &#123;</span><br><span class="line">                    uvScaleMap.updateMatrix();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                uniforms.uvTransform.value.copy(uvScaleMap.matrix);</span><br><span class="line">            &#125; <span class="comment">// uv repeat and offset setting priorities for uv2</span></span><br><span class="line">            <span class="comment">// 1. ao map</span></span><br><span class="line">            <span class="comment">// 2. light map</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> uv2ScaleMap;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.aoMap) &#123;</span><br><span class="line">                uv2ScaleMap = material.aoMap;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.lightMap) &#123;</span><br><span class="line">                uv2ScaleMap = material.lightMap;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (uv2ScaleMap !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="comment">// backwards compatibility</span></span><br><span class="line">                <span class="keyword">if</span> (uv2ScaleMap.isWebGLRenderTarget) &#123;</span><br><span class="line">                    uv2ScaleMap = uv2ScaleMap.texture;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (uv2ScaleMap.matrixAutoUpdate === <span class="literal">true</span>) &#123;</span><br><span class="line">                    uv2ScaleMap.updateMatrix();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">refreshUniformsLine</span>(<span class="params">uniforms, material</span>) </span>&#123;</span><br><span class="line">            uniforms.diffuse.value.copy(material.color);</span><br><span class="line">            uniforms.opacity.value = material.opacity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">refreshUniformsDash</span>(<span class="params">uniforms, material</span>) </span>&#123;</span><br><span class="line">            uniforms.dashSize.value = material.dashSize;</span><br><span class="line">            uniforms.totalSize.value = material.dashSize + material.gapSize;</span><br><span class="line">            uniforms.scale.value = material.scale;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">refreshUniformsPoints</span>(<span class="params">uniforms, material, pixelRatio, height</span>) </span>&#123;</span><br><span class="line">            uniforms.diffuse.value.copy(material.color);</span><br><span class="line">            uniforms.opacity.value = material.opacity;</span><br><span class="line">            uniforms.size.value = material.size * pixelRatio;</span><br><span class="line">            uniforms.scale.value = height * <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.map) &#123;</span><br><span class="line">                uniforms.map.value = material.map;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.alphaMap) &#123;</span><br><span class="line">                uniforms.alphaMap.value = material.alphaMap;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.alphaTest &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                uniforms.alphaTest.value = material.alphaTest;</span><br><span class="line">            &#125; <span class="comment">// uv repeat and offset setting priorities</span></span><br><span class="line">            <span class="comment">// 1. color map</span></span><br><span class="line">            <span class="comment">// 2. alpha map</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> uvScaleMap;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.map) &#123;</span><br><span class="line">                uvScaleMap = material.map;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.alphaMap) &#123;</span><br><span class="line">                uvScaleMap = material.alphaMap;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (uvScaleMap !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uvScaleMap.matrixAutoUpdate === <span class="literal">true</span>) &#123;</span><br><span class="line">                    uvScaleMap.updateMatrix();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                uniforms.uvTransform.value.copy(uvScaleMap.matrix);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">refreshUniformsSprites</span>(<span class="params">uniforms, material</span>) </span>&#123;</span><br><span class="line">            uniforms.diffuse.value.copy(material.color);</span><br><span class="line">            uniforms.opacity.value = material.opacity;</span><br><span class="line">            uniforms.rotation.value = material.rotation;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.map) &#123;</span><br><span class="line">                uniforms.map.value = material.map;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.alphaMap) &#123;</span><br><span class="line">                uniforms.alphaMap.value = material.alphaMap;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.alphaTest &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                uniforms.alphaTest.value = material.alphaTest;</span><br><span class="line">            &#125; <span class="comment">// uv repeat and offset setting priorities</span></span><br><span class="line">            <span class="comment">// 1. color map</span></span><br><span class="line">            <span class="comment">// 2. alpha map</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> uvScaleMap;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.map) &#123;</span><br><span class="line">                uvScaleMap = material.map;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.alphaMap) &#123;</span><br><span class="line">                uvScaleMap = material.alphaMap;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (uvScaleMap !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uvScaleMap.matrixAutoUpdate === <span class="literal">true</span>) &#123;</span><br><span class="line">                    uvScaleMap.updateMatrix();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                uniforms.uvTransform.value.copy(uvScaleMap.matrix);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">refreshUniformsPhong</span>(<span class="params">uniforms, material</span>) </span>&#123;</span><br><span class="line">            uniforms.specular.value.copy(material.specular);</span><br><span class="line">            uniforms.shininess.value = <span class="built_in">Math</span>.max(material.shininess, <span class="number">1e-4</span>); <span class="comment">// to prevent pow( 0.0, 0.0 )</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">refreshUniformsToon</span>(<span class="params">uniforms, material</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (material.gradientMap) &#123;</span><br><span class="line">                uniforms.gradientMap.value = material.gradientMap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">refreshUniformsStandard</span>(<span class="params">uniforms, material</span>) </span>&#123;</span><br><span class="line">            uniforms.roughness.value = material.roughness;</span><br><span class="line">            uniforms.metalness.value = material.metalness;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.roughnessMap) &#123;</span><br><span class="line">                uniforms.roughnessMap.value = material.roughnessMap;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.metalnessMap) &#123;</span><br><span class="line">                uniforms.metalnessMap.value = material.metalnessMap;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> envMap = properties.get(material).envMap;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (envMap) &#123;</span><br><span class="line">                <span class="comment">//uniforms.envMap.value = material.envMap; // part of uniforms common</span></span><br><span class="line">                uniforms.envMapIntensity.value = material.envMapIntensity;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">refreshUniformsPhysical</span>(<span class="params">uniforms, material, transmissionRenderTarget</span>) </span>&#123;</span><br><span class="line">            uniforms.ior.value = material.ior; <span class="comment">// also part of uniforms common</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.sheen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);</span><br><span class="line">                uniforms.sheenRoughness.value = material.sheenRoughness;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (material.sheenColorMap) &#123;</span><br><span class="line">                    uniforms.sheenColorMap.value = material.sheenColorMap;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (material.sheenRoughnessMap) &#123;</span><br><span class="line">                    uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.clearcoat &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                uniforms.clearcoat.value = material.clearcoat;</span><br><span class="line">                uniforms.clearcoatRoughness.value = material.clearcoatRoughness;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (material.clearcoatMap) &#123;</span><br><span class="line">                    uniforms.clearcoatMap.value = material.clearcoatMap;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (material.clearcoatRoughnessMap) &#123;</span><br><span class="line">                    uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (material.clearcoatNormalMap) &#123;</span><br><span class="line">                    uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);</span><br><span class="line">                    uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (material.side === BackSide) &#123;</span><br><span class="line">                        uniforms.clearcoatNormalScale.value.negate();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.transmission &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                uniforms.transmission.value = material.transmission;</span><br><span class="line">                uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;</span><br><span class="line">                uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (material.transmissionMap) &#123;</span><br><span class="line">                    uniforms.transmissionMap.value = material.transmissionMap;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                uniforms.thickness.value = material.thickness;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (material.thicknessMap) &#123;</span><br><span class="line">                    uniforms.thicknessMap.value = material.thicknessMap;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                uniforms.attenuationDistance.value = material.attenuationDistance;</span><br><span class="line">                uniforms.attenuationColor.value.copy(material.attenuationColor);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            uniforms.specularIntensity.value = material.specularIntensity;</span><br><span class="line">            uniforms.specularColor.value.copy(material.specularColor);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.specularIntensityMap) &#123;</span><br><span class="line">                uniforms.specularIntensityMap.value = material.specularIntensityMap;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.specularColorMap) &#123;</span><br><span class="line">                uniforms.specularColorMap.value = material.specularColorMap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">refreshUniformsMatcap</span>(<span class="params">uniforms, material</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (material.matcap) &#123;</span><br><span class="line">                uniforms.matcap.value = material.matcap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">refreshUniformsDistance</span>(<span class="params">uniforms, material</span>) </span>&#123;</span><br><span class="line">            uniforms.referencePosition.value.copy(material.referencePosition);</span><br><span class="line">            uniforms.nearDistance.value = material.nearDistance;</span><br><span class="line">            uniforms.farDistance.value = material.farDistance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">refreshFogUniforms</span>: refreshFogUniforms,</span><br><span class="line">            <span class="attr">refreshMaterialUniforms</span>: refreshMaterialUniforms</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createCanvasElement</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> canvas = createElementNS(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">        canvas.style.display = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> canvas;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">WebGLRenderer</span>(<span class="params">parameters = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> _canvas = parameters.canvas !== <span class="literal">undefined</span> ? parameters.canvas : createCanvasElement(),</span><br><span class="line">            _context = parameters.context !== <span class="literal">undefined</span> ? parameters.context : <span class="literal">null</span>,</span><br><span class="line">            _depth = parameters.depth !== <span class="literal">undefined</span> ? parameters.depth : <span class="literal">true</span>,</span><br><span class="line">            _stencil = parameters.stencil !== <span class="literal">undefined</span> ? parameters.stencil : <span class="literal">true</span>,</span><br><span class="line">            _antialias = parameters.antialias !== <span class="literal">undefined</span> ? parameters.antialias : <span class="literal">false</span>,</span><br><span class="line">            _premultipliedAlpha = parameters.premultipliedAlpha !== <span class="literal">undefined</span> ? parameters.premultipliedAlpha : <span class="literal">true</span>,</span><br><span class="line">            _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== <span class="literal">undefined</span> ? parameters.preserveDrawingBuffer : <span class="literal">false</span>,</span><br><span class="line">            _powerPreference = parameters.powerPreference !== <span class="literal">undefined</span> ? parameters.powerPreference : <span class="string">&#x27;default&#x27;</span>,</span><br><span class="line">            _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== <span class="literal">undefined</span> ? parameters.failIfMajorPerformanceCaveat : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> _alpha;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parameters.context !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            _alpha = _context.getContextAttributes().alpha;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _alpha = parameters.alpha !== <span class="literal">undefined</span> ? parameters.alpha : <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentRenderList = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> currentRenderState = <span class="literal">null</span>; <span class="comment">// render() can be called from within a callback triggered by another render.</span></span><br><span class="line">        <span class="comment">// We track this so that the nested render call gets its list and state isolated from the parent render call.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> renderListStack = [];</span><br><span class="line">        <span class="keyword">const</span> renderStateStack = []; <span class="comment">// public properties</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.domElement = _canvas; <span class="comment">// Debug configuration container</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.debug = &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Enables error checking and reporting when shader programs are being compiled</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@type <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="attr">checkShaderErrors</span>: <span class="literal">true</span></span><br><span class="line">        &#125;; <span class="comment">// clearing</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.autoClear = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.autoClearColor = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.autoClearDepth = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.autoClearStencil = <span class="literal">true</span>; <span class="comment">// scene graph</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.sortObjects = <span class="literal">true</span>; <span class="comment">// user-defined clipping</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.clippingPlanes = [];</span><br><span class="line">        <span class="built_in">this</span>.localClippingEnabled = <span class="literal">false</span>; <span class="comment">// physically based shading</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.outputEncoding = LinearEncoding; <span class="comment">// physical lights</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.physicallyCorrectLights = <span class="literal">false</span>; <span class="comment">// tone mapping</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.toneMapping = NoToneMapping;</span><br><span class="line">        <span class="built_in">this</span>.toneMappingExposure = <span class="number">1.0</span>; <span class="comment">// internal properties</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> _this = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> _isContextLost = <span class="literal">false</span>; <span class="comment">// internal state cache</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> _currentActiveCubeFace = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> _currentActiveMipmapLevel = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> _currentRenderTarget = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> _currentMaterialId = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> _currentCamera = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> _currentViewport = <span class="keyword">new</span> Vector4();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> _currentScissor = <span class="keyword">new</span> Vector4();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> _currentScissorTest = <span class="literal">null</span>; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> _width = _canvas.width;</span><br><span class="line">        <span class="keyword">let</span> _height = _canvas.height;</span><br><span class="line">        <span class="keyword">let</span> _pixelRatio = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> _opaqueSort = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> _transparentSort = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> _viewport = <span class="keyword">new</span> Vector4(<span class="number">0</span>, <span class="number">0</span>, _width, _height);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> _scissor = <span class="keyword">new</span> Vector4(<span class="number">0</span>, <span class="number">0</span>, _width, _height);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> _scissorTest = <span class="literal">false</span>; <span class="comment">// frustum</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> _frustum = <span class="keyword">new</span> Frustum(); <span class="comment">// clipping</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> _clippingEnabled = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">let</span> _localClippingEnabled = <span class="literal">false</span>; <span class="comment">// transmission</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> _transmissionRenderTarget = <span class="literal">null</span>; <span class="comment">// camera matrices cache</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> _projScreenMatrix = <span class="keyword">new</span> Matrix4();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> _vector2 = <span class="keyword">new</span> Vector2();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> _vector3 = <span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> _emptyScene = &#123;</span><br><span class="line">            <span class="attr">background</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">fog</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">environment</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">overrideMaterial</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">isScene</span>: <span class="literal">true</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getTargetPixelRatio</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _currentRenderTarget === <span class="literal">null</span> ? _pixelRatio : <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="comment">// initialize</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> _gl = _context;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getContext</span>(<span class="params">contextNames, contextAttributes</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; contextNames.length; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> contextName = contextNames[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> context = _canvas.getContext(contextName, contextAttributes);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (context !== <span class="literal">null</span>) <span class="keyword">return</span> context;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> contextAttributes = &#123;</span><br><span class="line">                <span class="attr">alpha</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">depth</span>: _depth,</span><br><span class="line">                <span class="attr">stencil</span>: _stencil,</span><br><span class="line">                <span class="attr">antialias</span>: _antialias,</span><br><span class="line">                <span class="attr">premultipliedAlpha</span>: _premultipliedAlpha,</span><br><span class="line">                <span class="attr">preserveDrawingBuffer</span>: _preserveDrawingBuffer,</span><br><span class="line">                <span class="attr">powerPreference</span>: _powerPreference,</span><br><span class="line">                <span class="attr">failIfMajorPerformanceCaveat</span>: _failIfMajorPerformanceCaveat</span><br><span class="line">            &#125;; <span class="comment">// OffscreenCanvas does not have setAttribute, see #22811</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;setAttribute&#x27;</span> <span class="keyword">in</span> _canvas) _canvas.setAttribute(<span class="string">&#x27;data-engine&#x27;</span>, <span class="string">`three.js r<span class="subst">$&#123;REVISION&#125;</span>`</span>); <span class="comment">// event listeners must be registered before WebGL context is created, see #12753</span></span><br><span class="line"></span><br><span class="line">            _canvas.addEventListener(<span class="string">&#x27;webglcontextlost&#x27;</span>, onContextLost, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            _canvas.addEventListener(<span class="string">&#x27;webglcontextrestored&#x27;</span>, onContextRestore, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_gl === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> contextNames = [<span class="string">&#x27;webgl2&#x27;</span>, <span class="string">&#x27;webgl&#x27;</span>, <span class="string">&#x27;experimental-webgl&#x27;</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (_this.isWebGL1Renderer === <span class="literal">true</span>) &#123;</span><br><span class="line">                    contextNames.shift();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                _gl = getContext(contextNames, contextAttributes);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (_gl === <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (getContext(contextNames)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Error creating WebGL context with your selected attributes.&#x27;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Error creating WebGL context.&#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// Some experimental-webgl implementations do not have getShaderPrecisionFormat</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_gl.getShaderPrecisionFormat === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                _gl.getShaderPrecisionFormat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        <span class="string">&#x27;rangeMin&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                        <span class="string">&#x27;rangeMax&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                        <span class="string">&#x27;precision&#x27;</span>: <span class="number">1</span></span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLRenderer: &#x27;</span> + error.message);</span><br><span class="line">            <span class="keyword">throw</span> error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> extensions, capabilities, state, info;</span><br><span class="line">        <span class="keyword">let</span> properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;</span><br><span class="line">        <span class="keyword">let</span> programCache, materials, renderLists, renderStates, clipping, shadowMap;</span><br><span class="line">        <span class="keyword">let</span> background, morphtargets, bufferRenderer, indexedBufferRenderer;</span><br><span class="line">        <span class="keyword">let</span> utils, bindingStates;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">initGLContext</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            extensions = <span class="keyword">new</span> WebGLExtensions(_gl);</span><br><span class="line">            capabilities = <span class="keyword">new</span> WebGLCapabilities(_gl, extensions, parameters);</span><br><span class="line">            extensions.init(capabilities);</span><br><span class="line">            utils = <span class="keyword">new</span> WebGLUtils(_gl, extensions, capabilities);</span><br><span class="line">            state = <span class="keyword">new</span> WebGLState(_gl, extensions, capabilities);</span><br><span class="line">            info = <span class="keyword">new</span> WebGLInfo(_gl);</span><br><span class="line">            properties = <span class="keyword">new</span> WebGLProperties();</span><br><span class="line">            textures = <span class="keyword">new</span> WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);</span><br><span class="line">            cubemaps = <span class="keyword">new</span> WebGLCubeMaps(_this);</span><br><span class="line">            cubeuvmaps = <span class="keyword">new</span> WebGLCubeUVMaps(_this);</span><br><span class="line">            attributes = <span class="keyword">new</span> WebGLAttributes(_gl, capabilities);</span><br><span class="line">            bindingStates = <span class="keyword">new</span> WebGLBindingStates(_gl, extensions, attributes, capabilities);</span><br><span class="line">            geometries = <span class="keyword">new</span> WebGLGeometries(_gl, attributes, info, bindingStates);</span><br><span class="line">            objects = <span class="keyword">new</span> WebGLObjects(_gl, geometries, attributes, info);</span><br><span class="line">            morphtargets = <span class="keyword">new</span> WebGLMorphtargets(_gl, capabilities, textures);</span><br><span class="line">            clipping = <span class="keyword">new</span> WebGLClipping(properties);</span><br><span class="line">            programCache = <span class="keyword">new</span> WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);</span><br><span class="line">            materials = <span class="keyword">new</span> WebGLMaterials(_this, properties);</span><br><span class="line">            renderLists = <span class="keyword">new</span> WebGLRenderLists();</span><br><span class="line">            renderStates = <span class="keyword">new</span> WebGLRenderStates(extensions, capabilities);</span><br><span class="line">            background = <span class="keyword">new</span> WebGLBackground(_this, cubemaps, state, objects, _alpha, _premultipliedAlpha);</span><br><span class="line">            shadowMap = <span class="keyword">new</span> WebGLShadowMap(_this, objects, capabilities);</span><br><span class="line">            bufferRenderer = <span class="keyword">new</span> WebGLBufferRenderer(_gl, extensions, info, capabilities);</span><br><span class="line">            indexedBufferRenderer = <span class="keyword">new</span> WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);</span><br><span class="line">            info.programs = programCache.programs;</span><br><span class="line">            _this.capabilities = capabilities;</span><br><span class="line">            _this.extensions = extensions;</span><br><span class="line">            _this.properties = properties;</span><br><span class="line">            _this.renderLists = renderLists;</span><br><span class="line">            _this.shadowMap = shadowMap;</span><br><span class="line">            _this.state = state;</span><br><span class="line">            _this.info = info;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        initGLContext(); <span class="comment">// xr</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> xr = <span class="keyword">new</span> WebXRManager(_this, _gl);</span><br><span class="line">        <span class="built_in">this</span>.xr = xr; <span class="comment">// API</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.getContext = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _gl;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.getContextAttributes = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _gl.getContextAttributes();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.forceContextLoss = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> extension = extensions.get(<span class="string">&#x27;WEBGL_lose_context&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (extension) extension.loseContext();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.forceContextRestore = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> extension = extensions.get(<span class="string">&#x27;WEBGL_lose_context&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (extension) extension.restoreContext();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.getPixelRatio = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _pixelRatio;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setPixelRatio = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (value === <span class="literal">undefined</span>) <span class="keyword">return</span>;</span><br><span class="line">            _pixelRatio = value;</span><br><span class="line">            <span class="built_in">this</span>.setSize(_width, _height, <span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.getSize = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> target.set(_width, _height);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setSize = <span class="function"><span class="keyword">function</span> (<span class="params">width, height, updateStyle</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (xr.isPresenting) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: Can\&#x27;t change size while VR device is presenting.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _width = width;</span><br><span class="line">            _height = height;</span><br><span class="line">            _canvas.width = <span class="built_in">Math</span>.floor(width * _pixelRatio);</span><br><span class="line">            _canvas.height = <span class="built_in">Math</span>.floor(height * _pixelRatio);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (updateStyle !== <span class="literal">false</span>) &#123;</span><br><span class="line">                _canvas.style.width = width + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">                _canvas.style.height = height + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.getDrawingBufferSize = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> target.set(_width * _pixelRatio, _height * _pixelRatio).floor();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setDrawingBufferSize = <span class="function"><span class="keyword">function</span> (<span class="params">width, height, pixelRatio</span>) </span>&#123;</span><br><span class="line">            _width = width;</span><br><span class="line">            _height = height;</span><br><span class="line">            _pixelRatio = pixelRatio;</span><br><span class="line">            _canvas.width = <span class="built_in">Math</span>.floor(width * pixelRatio);</span><br><span class="line">            _canvas.height = <span class="built_in">Math</span>.floor(height * pixelRatio);</span><br><span class="line">            <span class="built_in">this</span>.setViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.getCurrentViewport = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> target.copy(_currentViewport);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.getViewport = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> target.copy(_viewport);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setViewport = <span class="function"><span class="keyword">function</span> (<span class="params">x, y, width, height</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (x.isVector4) &#123;</span><br><span class="line">                _viewport.set(x.x, x.y, x.z, x.w);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _viewport.set(x, y, width, height);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.getScissor = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> target.copy(_scissor);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setScissor = <span class="function"><span class="keyword">function</span> (<span class="params">x, y, width, height</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (x.isVector4) &#123;</span><br><span class="line">                _scissor.set(x.x, x.y, x.z, x.w);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _scissor.set(x, y, width, height);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.getScissorTest = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _scissorTest;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setScissorTest = <span class="function"><span class="keyword">function</span> (<span class="params">boolean</span>) </span>&#123;</span><br><span class="line">            state.setScissorTest(_scissorTest = boolean);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setOpaqueSort = <span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">            _opaqueSort = method;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setTransparentSort = <span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">            _transparentSort = method;</span><br><span class="line">        &#125;; <span class="comment">// Clearing</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.getClearColor = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> target.copy(background.getClearColor());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setClearColor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            background.setClearColor.apply(background, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.getClearAlpha = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> background.getClearAlpha();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setClearAlpha = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            background.setClearAlpha.apply(background, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params">color = <span class="literal">true</span>, depth = <span class="literal">true</span>, stencil = <span class="literal">true</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> bits = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (color) bits |= _gl.COLOR_BUFFER_BIT;</span><br><span class="line">            <span class="keyword">if</span> (depth) bits |= _gl.DEPTH_BUFFER_BIT;</span><br><span class="line">            <span class="keyword">if</span> (stencil) bits |= _gl.STENCIL_BUFFER_BIT;</span><br><span class="line"></span><br><span class="line">            _gl.clear(bits);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.clearColor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.clear(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.clearDepth = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.clear(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.clearStencil = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.clear(<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.dispose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            _canvas.removeEventListener(<span class="string">&#x27;webglcontextlost&#x27;</span>, onContextLost, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            _canvas.removeEventListener(<span class="string">&#x27;webglcontextrestored&#x27;</span>, onContextRestore, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            renderLists.dispose();</span><br><span class="line">            renderStates.dispose();</span><br><span class="line">            properties.dispose();</span><br><span class="line">            cubemaps.dispose();</span><br><span class="line">            cubeuvmaps.dispose();</span><br><span class="line">            objects.dispose();</span><br><span class="line">            bindingStates.dispose();</span><br><span class="line">            programCache.dispose();</span><br><span class="line">            xr.dispose();</span><br><span class="line">            xr.removeEventListener(<span class="string">&#x27;sessionstart&#x27;</span>, onXRSessionStart);</span><br><span class="line">            xr.removeEventListener(<span class="string">&#x27;sessionend&#x27;</span>, onXRSessionEnd);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_transmissionRenderTarget) &#123;</span><br><span class="line">                _transmissionRenderTarget.dispose();</span><br><span class="line"></span><br><span class="line">                _transmissionRenderTarget = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            animation.stop();</span><br><span class="line">        &#125;; <span class="comment">// Events</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">onContextLost</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">            event.preventDefault();</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;THREE.WebGLRenderer: Context Lost.&#x27;</span>);</span><br><span class="line">            _isContextLost = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">        /* <span class="title">event</span> */</span></span><br><span class="line"><span class="function">        <span class="title">onContextRestore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;THREE.WebGLRenderer: Context Restored.&#x27;</span>);</span><br><span class="line">            _isContextLost = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">const</span> infoAutoReset = info.autoReset;</span><br><span class="line">            <span class="keyword">const</span> shadowMapEnabled = shadowMap.enabled;</span><br><span class="line">            <span class="keyword">const</span> shadowMapAutoUpdate = shadowMap.autoUpdate;</span><br><span class="line">            <span class="keyword">const</span> shadowMapNeedsUpdate = shadowMap.needsUpdate;</span><br><span class="line">            <span class="keyword">const</span> shadowMapType = shadowMap.type;</span><br><span class="line">            initGLContext();</span><br><span class="line">            info.autoReset = infoAutoReset;</span><br><span class="line">            shadowMap.enabled = shadowMapEnabled;</span><br><span class="line">            shadowMap.autoUpdate = shadowMapAutoUpdate;</span><br><span class="line">            shadowMap.needsUpdate = shadowMapNeedsUpdate;</span><br><span class="line">            shadowMap.type = shadowMapType;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">onMaterialDispose</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> material = event.target;</span><br><span class="line">            material.removeEventListener(<span class="string">&#x27;dispose&#x27;</span>, onMaterialDispose);</span><br><span class="line">            deallocateMaterial(material);</span><br><span class="line">        &#125; <span class="comment">// Buffer deallocation</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">deallocateMaterial</span>(<span class="params">material</span>) </span>&#123;</span><br><span class="line">            releaseMaterialProgramReferences(material);</span><br><span class="line">            properties.remove(material);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">releaseMaterialProgramReferences</span>(<span class="params">material</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> programs = properties.get(material).programs;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (programs !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                programs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">program</span>) </span>&#123;</span><br><span class="line">                    programCache.releaseProgram(program);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (material.isShaderMaterial) &#123;</span><br><span class="line">                    programCache.releaseShaderCache(material);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// Buffer rendering</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.renderBufferDirect = <span class="function"><span class="keyword">function</span> (<span class="params">camera, scene, geometry, material, object, group</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (scene === <span class="literal">null</span>) scene = _emptyScene; <span class="comment">// renderBufferDirect second parameter used to be fog (could be null)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> frontFaceCW = object.isMesh &amp;&amp; object.matrixWorld.determinant() &lt; <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> program = setProgram(camera, scene, geometry, material, object);</span><br><span class="line">            state.setMaterial(material, frontFaceCW); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> index = geometry.index;</span><br><span class="line">            <span class="keyword">const</span> position = geometry.attributes.position; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (position === <span class="literal">undefined</span> || position.count === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index.count === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> rangeFactor = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.wireframe === <span class="literal">true</span>) &#123;</span><br><span class="line">                index = geometries.getWireframeAttribute(geometry);</span><br><span class="line">                rangeFactor = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bindingStates.setup(object, material, program, geometry, index);</span><br><span class="line">            <span class="keyword">let</span> attribute;</span><br><span class="line">            <span class="keyword">let</span> renderer = bufferRenderer;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index !== <span class="literal">null</span>) &#123;</span><br><span class="line">                attribute = attributes.get(index);</span><br><span class="line">                renderer = indexedBufferRenderer;</span><br><span class="line">                renderer.setIndex(attribute);</span><br><span class="line">            &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> dataCount = index !== <span class="literal">null</span> ? index.count : position.count;</span><br><span class="line">            <span class="keyword">const</span> rangeStart = geometry.drawRange.start * rangeFactor;</span><br><span class="line">            <span class="keyword">const</span> rangeCount = geometry.drawRange.count * rangeFactor;</span><br><span class="line">            <span class="keyword">const</span> groupStart = group !== <span class="literal">null</span> ? group.start * rangeFactor : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> groupCount = group !== <span class="literal">null</span> ? group.count * rangeFactor : <span class="literal">Infinity</span>;</span><br><span class="line">            <span class="keyword">const</span> drawStart = <span class="built_in">Math</span>.max(rangeStart, groupStart);</span><br><span class="line">            <span class="keyword">const</span> drawEnd = <span class="built_in">Math</span>.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">const</span> drawCount = <span class="built_in">Math</span>.max(<span class="number">0</span>, drawEnd - drawStart + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (drawCount === <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (object.isMesh) &#123;</span><br><span class="line">                <span class="keyword">if</span> (material.wireframe === <span class="literal">true</span>) &#123;</span><br><span class="line">                    state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());</span><br><span class="line">                    renderer.setMode(_gl.LINES);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    renderer.setMode(_gl.TRIANGLES);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object.isLine) &#123;</span><br><span class="line">                <span class="keyword">let</span> lineWidth = material.linewidth;</span><br><span class="line">                <span class="keyword">if</span> (lineWidth === <span class="literal">undefined</span>) lineWidth = <span class="number">1</span>; <span class="comment">// Not using Line*Material</span></span><br><span class="line"></span><br><span class="line">                state.setLineWidth(lineWidth * getTargetPixelRatio());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (object.isLineSegments) &#123;</span><br><span class="line">                    renderer.setMode(_gl.LINES);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object.isLineLoop) &#123;</span><br><span class="line">                    renderer.setMode(_gl.LINE_LOOP);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    renderer.setMode(_gl.LINE_STRIP);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object.isPoints) &#123;</span><br><span class="line">                renderer.setMode(_gl.POINTS);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object.isSprite) &#123;</span><br><span class="line">                renderer.setMode(_gl.TRIANGLES);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (object.isInstancedMesh) &#123;</span><br><span class="line">                renderer.renderInstances(drawStart, drawCount, object.count);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (geometry.isInstancedBufferGeometry) &#123;</span><br><span class="line">                <span class="keyword">const</span> instanceCount = <span class="built_in">Math</span>.min(geometry.instanceCount, geometry._maxInstanceCount);</span><br><span class="line">                renderer.renderInstances(drawStart, drawCount, instanceCount);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                renderer.render(drawStart, drawCount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; <span class="comment">// Compile</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.compile = <span class="function"><span class="keyword">function</span> (<span class="params">scene, camera</span>) </span>&#123;</span><br><span class="line">            currentRenderState = renderStates.get(scene);</span><br><span class="line">            currentRenderState.init();</span><br><span class="line">            renderStateStack.push(currentRenderState);</span><br><span class="line">            scene.traverseVisible(<span class="function"><span class="keyword">function</span> (<span class="params">object</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (object.isLight &amp;&amp; object.layers.test(camera.layers)) &#123;</span><br><span class="line">                    currentRenderState.pushLight(object);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (object.castShadow) &#123;</span><br><span class="line">                        currentRenderState.pushShadow(object);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            currentRenderState.setupLights(_this.physicallyCorrectLights);</span><br><span class="line">            scene.traverse(<span class="function"><span class="keyword">function</span> (<span class="params">object</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> material = object.material;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (material) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(material)) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; material.length; i++) &#123;</span><br><span class="line">                            <span class="keyword">const</span> material2 = material[i];</span><br><span class="line">                            getProgram(material2, scene, object);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        getProgram(material, scene, object);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            renderStateStack.pop();</span><br><span class="line">            currentRenderState = <span class="literal">null</span>;</span><br><span class="line">        &#125;; <span class="comment">// Animation Loop</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> onAnimationFrameCallback = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">onAnimationFrame</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (onAnimationFrameCallback) onAnimationFrameCallback(time);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">onXRSessionStart</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            animation.stop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">onXRSessionEnd</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            animation.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> animation = <span class="keyword">new</span> WebGLAnimation();</span><br><span class="line">        animation.setAnimationLoop(onAnimationFrame);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">&#x27;undefined&#x27;</span>) animation.setContext(self);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setAnimationLoop = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            onAnimationFrameCallback = callback;</span><br><span class="line">            xr.setAnimationLoop(callback);</span><br><span class="line">            callback === <span class="literal">null</span> ? animation.stop() : animation.start();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        xr.addEventListener(<span class="string">&#x27;sessionstart&#x27;</span>, onXRSessionStart);</span><br><span class="line">        xr.addEventListener(<span class="string">&#x27;sessionend&#x27;</span>, onXRSessionEnd); <span class="comment">// Rendering</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.render = <span class="function"><span class="keyword">function</span> (<span class="params">scene, camera</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (camera !== <span class="literal">undefined</span> &amp;&amp; camera.isCamera !== <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_isContextLost === <span class="literal">true</span>) <span class="keyword">return</span>; <span class="comment">// update scene graph</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (scene.autoUpdate === <span class="literal">true</span>) scene.updateMatrixWorld(); <span class="comment">// update camera matrices and frustum</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (camera.parent === <span class="literal">null</span>) camera.updateMatrixWorld();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (xr.enabled === <span class="literal">true</span> &amp;&amp; xr.isPresenting === <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (xr.cameraAutoUpdate === <span class="literal">true</span>) xr.updateCamera(camera);</span><br><span class="line">                camera = xr.getCamera(); <span class="comment">// use XR camera for rendering</span></span><br><span class="line">            &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (scene.isScene === <span class="literal">true</span>) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);</span><br><span class="line">            currentRenderState = renderStates.get(scene, renderStateStack.length);</span><br><span class="line">            currentRenderState.init();</span><br><span class="line">            renderStateStack.push(currentRenderState);</span><br><span class="line"></span><br><span class="line">            _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);</span><br><span class="line"></span><br><span class="line">            _frustum.setFromProjectionMatrix(_projScreenMatrix);</span><br><span class="line"></span><br><span class="line">            _localClippingEnabled = <span class="built_in">this</span>.localClippingEnabled;</span><br><span class="line">            _clippingEnabled = clipping.init(<span class="built_in">this</span>.clippingPlanes, _localClippingEnabled, camera);</span><br><span class="line">            currentRenderList = renderLists.get(scene, renderListStack.length);</span><br><span class="line">            currentRenderList.init();</span><br><span class="line">            renderListStack.push(currentRenderList);</span><br><span class="line">            projectObject(scene, camera, <span class="number">0</span>, _this.sortObjects);</span><br><span class="line">            currentRenderList.finish();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_this.sortObjects === <span class="literal">true</span>) &#123;</span><br><span class="line">                currentRenderList.sort(_opaqueSort, _transparentSort);</span><br><span class="line">            &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_clippingEnabled === <span class="literal">true</span>) clipping.beginShadows();</span><br><span class="line">            <span class="keyword">const</span> shadowsArray = currentRenderState.state.shadowsArray;</span><br><span class="line">            shadowMap.render(shadowsArray, scene, camera);</span><br><span class="line">            <span class="keyword">if</span> (_clippingEnabled === <span class="literal">true</span>) clipping.endShadows(); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.info.autoReset === <span class="literal">true</span>) <span class="built_in">this</span>.info.reset(); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            background.render(currentRenderList, scene); <span class="comment">// render scene</span></span><br><span class="line"></span><br><span class="line">            currentRenderState.setupLights(_this.physicallyCorrectLights);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (camera.isArrayCamera) &#123;</span><br><span class="line">                <span class="keyword">const</span> cameras = camera.cameras;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = cameras.length; i &lt; l; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> camera2 = cameras[i];</span><br><span class="line">                    renderScene(currentRenderList, scene, camera2, camera2.viewport);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                renderScene(currentRenderList, scene, camera);</span><br><span class="line">            &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_currentRenderTarget !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// resolve multisample renderbuffers to a single-sample texture if necessary</span></span><br><span class="line">                textures.updateMultisampleRenderTarget(_currentRenderTarget); <span class="comment">// Generate mipmap if we&#x27;re using any kind of mipmap filtering</span></span><br><span class="line"></span><br><span class="line">                textures.updateRenderTargetMipmap(_currentRenderTarget);</span><br><span class="line">            &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (scene.isScene === <span class="literal">true</span>) scene.onAfterRender(_this, scene, camera); <span class="comment">// _gl.finish();</span></span><br><span class="line"></span><br><span class="line">            bindingStates.resetDefaultState();</span><br><span class="line">            _currentMaterialId = -<span class="number">1</span>;</span><br><span class="line">            _currentCamera = <span class="literal">null</span>;</span><br><span class="line">            renderStateStack.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (renderStateStack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                currentRenderState = renderStateStack[renderStateStack.length - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currentRenderState = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            renderListStack.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (renderListStack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                currentRenderList = renderListStack[renderListStack.length - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currentRenderList = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">projectObject</span>(<span class="params">object, camera, groupOrder, sortObjects</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (object.visible === <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">const</span> visible = object.layers.test(camera.layers);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (visible) &#123;</span><br><span class="line">                <span class="keyword">if</span> (object.isGroup) &#123;</span><br><span class="line">                    groupOrder = object.renderOrder;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object.isLOD) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (object.autoUpdate === <span class="literal">true</span>) object.update(camera);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object.isLight) &#123;</span><br><span class="line">                    currentRenderState.pushLight(object);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (object.castShadow) &#123;</span><br><span class="line">                        currentRenderState.pushShadow(object);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object.isSprite) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!object.frustumCulled || _frustum.intersectsSprite(object)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sortObjects) &#123;</span><br><span class="line">                            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">const</span> geometry = objects.update(object);</span><br><span class="line">                        <span class="keyword">const</span> material = object.material;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (material.visible) &#123;</span><br><span class="line">                            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, <span class="literal">null</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object.isMesh || object.isLine || object.isPoints) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (object.isSkinnedMesh) &#123;</span><br><span class="line">                        <span class="comment">// update skeleton only once in a frame</span></span><br><span class="line">                        <span class="keyword">if</span> (object.skeleton.frame !== info.render.frame) &#123;</span><br><span class="line">                            object.skeleton.update();</span><br><span class="line">                            object.skeleton.frame = info.render.frame;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!object.frustumCulled || _frustum.intersectsObject(object)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sortObjects) &#123;</span><br><span class="line">                            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">const</span> geometry = objects.update(object);</span><br><span class="line">                        <span class="keyword">const</span> material = object.material;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(material)) &#123;</span><br><span class="line">                            <span class="keyword">const</span> groups = geometry.groups;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = groups.length; i &lt; l; i++) &#123;</span><br><span class="line">                                <span class="keyword">const</span> group = groups[i];</span><br><span class="line">                                <span class="keyword">const</span> groupMaterial = material[group.materialIndex];</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (groupMaterial &amp;&amp; groupMaterial.visible) &#123;</span><br><span class="line">                                    currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.visible) &#123;</span><br><span class="line">                            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, <span class="literal">null</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> children = object.children;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = children.length; i &lt; l; i++) &#123;</span><br><span class="line">                projectObject(children[i], camera, groupOrder, sortObjects);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">renderScene</span>(<span class="params">currentRenderList, scene, camera, viewport</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> opaqueObjects = currentRenderList.opaque;</span><br><span class="line">            <span class="keyword">const</span> transmissiveObjects = currentRenderList.transmissive;</span><br><span class="line">            <span class="keyword">const</span> transparentObjects = currentRenderList.transparent;</span><br><span class="line">            currentRenderState.setupLightsView(camera);</span><br><span class="line">            <span class="keyword">if</span> (transmissiveObjects.length &gt; <span class="number">0</span>) renderTransmissionPass(opaqueObjects, scene, camera);</span><br><span class="line">            <span class="keyword">if</span> (viewport) state.viewport(_currentViewport.copy(viewport));</span><br><span class="line">            <span class="keyword">if</span> (opaqueObjects.length &gt; <span class="number">0</span>) renderObjects(opaqueObjects, scene, camera);</span><br><span class="line">            <span class="keyword">if</span> (transmissiveObjects.length &gt; <span class="number">0</span>) renderObjects(transmissiveObjects, scene, camera);</span><br><span class="line">            <span class="keyword">if</span> (transparentObjects.length &gt; <span class="number">0</span>) renderObjects(transparentObjects, scene, camera); <span class="comment">// Ensure depth buffer writing is enabled so it can be cleared on next render</span></span><br><span class="line"></span><br><span class="line">            state.buffers.depth.setTest(<span class="literal">true</span>);</span><br><span class="line">            state.buffers.depth.setMask(<span class="literal">true</span>);</span><br><span class="line">            state.buffers.color.setMask(<span class="literal">true</span>);</span><br><span class="line">            state.setPolygonOffset(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">renderTransmissionPass</span>(<span class="params">opaqueObjects, scene, camera</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> isWebGL2 = capabilities.isWebGL2;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_transmissionRenderTarget === <span class="literal">null</span>) &#123;</span><br><span class="line">                _transmissionRenderTarget = <span class="keyword">new</span> WebGLRenderTarget(<span class="number">1</span>, <span class="number">1</span>, &#123;</span><br><span class="line">                    <span class="attr">generateMipmaps</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">type</span>: utils.convert(HalfFloatType) !== <span class="literal">null</span> ? HalfFloatType : UnsignedByteType,</span><br><span class="line">                    <span class="attr">minFilter</span>: LinearMipmapLinearFilter,</span><br><span class="line">                    <span class="attr">samples</span>: isWebGL2 &amp;&amp; _antialias === <span class="literal">true</span> ? <span class="number">4</span> : <span class="number">0</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _this.getDrawingBufferSize(_vector2);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isWebGL2) &#123;</span><br><span class="line">                _transmissionRenderTarget.setSize(_vector2.x, _vector2.y);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _transmissionRenderTarget.setSize(floorPowerOfTwo(_vector2.x), floorPowerOfTwo(_vector2.y));</span><br><span class="line">            &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> currentRenderTarget = _this.getRenderTarget();</span><br><span class="line"></span><br><span class="line">            _this.setRenderTarget(_transmissionRenderTarget);</span><br><span class="line"></span><br><span class="line">            _this.clear(); <span class="comment">// Turn off the features which can affect the frag color for opaque objects pass.</span></span><br><span class="line">            <span class="comment">// Otherwise they are applied twice in opaque objects pass and transmission objects pass.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> currentToneMapping = _this.toneMapping;</span><br><span class="line">            _this.toneMapping = NoToneMapping;</span><br><span class="line">            renderObjects(opaqueObjects, scene, camera);</span><br><span class="line">            _this.toneMapping = currentToneMapping;</span><br><span class="line">            textures.updateMultisampleRenderTarget(_transmissionRenderTarget);</span><br><span class="line">            textures.updateRenderTargetMipmap(_transmissionRenderTarget);</span><br><span class="line"></span><br><span class="line">            _this.setRenderTarget(currentRenderTarget);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">renderObjects</span>(<span class="params">renderList, scene, camera</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> overrideMaterial = scene.isScene === <span class="literal">true</span> ? scene.overrideMaterial : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = renderList.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> renderItem = renderList[i];</span><br><span class="line">                <span class="keyword">const</span> object = renderItem.object;</span><br><span class="line">                <span class="keyword">const</span> geometry = renderItem.geometry;</span><br><span class="line">                <span class="keyword">const</span> material = overrideMaterial === <span class="literal">null</span> ? renderItem.material : overrideMaterial;</span><br><span class="line">                <span class="keyword">const</span> group = renderItem.group;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (object.layers.test(camera.layers)) &#123;</span><br><span class="line">                    renderObject(object, scene, camera, geometry, material, group);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">renderObject</span>(<span class="params">object, scene, camera, geometry, material, group</span>) </span>&#123;</span><br><span class="line">            object.onBeforeRender(_this, scene, camera, geometry, material, group);</span><br><span class="line">            object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);</span><br><span class="line">            object.normalMatrix.getNormalMatrix(object.modelViewMatrix);</span><br><span class="line">            material.onBeforeRender(_this, scene, camera, geometry, object, group);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.transparent === <span class="literal">true</span> &amp;&amp; material.side === DoubleSide) &#123;</span><br><span class="line">                material.side = BackSide;</span><br><span class="line">                material.needsUpdate = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                _this.renderBufferDirect(camera, scene, geometry, material, object, group);</span><br><span class="line"></span><br><span class="line">                material.side = FrontSide;</span><br><span class="line">                material.needsUpdate = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                _this.renderBufferDirect(camera, scene, geometry, material, object, group);</span><br><span class="line"></span><br><span class="line">                material.side = DoubleSide;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _this.renderBufferDirect(camera, scene, geometry, material, object, group);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            object.onAfterRender(_this, scene, camera, geometry, material, group);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getProgram</span>(<span class="params">material, scene, object</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (scene.isScene !== <span class="literal">true</span>) scene = _emptyScene; <span class="comment">// scene could be a Mesh, Line, Points, ...</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> materialProperties = properties.get(material);</span><br><span class="line">            <span class="keyword">const</span> lights = currentRenderState.state.lights;</span><br><span class="line">            <span class="keyword">const</span> shadowsArray = currentRenderState.state.shadowsArray;</span><br><span class="line">            <span class="keyword">const</span> lightsStateVersion = lights.state.version;</span><br><span class="line">            <span class="keyword">const</span> parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);</span><br><span class="line">            <span class="keyword">const</span> programCacheKey = programCache.getProgramCacheKey(parameters);</span><br><span class="line">            <span class="keyword">let</span> programs = materialProperties.programs; <span class="comment">// always update environment and fog - changing these trigger an getProgram call, but it&#x27;s possible that the program doesn&#x27;t change</span></span><br><span class="line"></span><br><span class="line">            materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : <span class="literal">null</span>;</span><br><span class="line">            materialProperties.fog = scene.fog;</span><br><span class="line">            materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (programs === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="comment">// new material</span></span><br><span class="line">                material.addEventListener(<span class="string">&#x27;dispose&#x27;</span>, onMaterialDispose);</span><br><span class="line">                programs = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">                materialProperties.programs = programs;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> program = programs.get(programCacheKey);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (program !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="comment">// early out if program and light state is identical</span></span><br><span class="line">                <span class="keyword">if</span> (materialProperties.currentProgram === program &amp;&amp; materialProperties.lightsStateVersion === lightsStateVersion) &#123;</span><br><span class="line">                    updateCommonMaterialProperties(material, parameters);</span><br><span class="line">                    <span class="keyword">return</span> program;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parameters.uniforms = programCache.getUniforms(material);</span><br><span class="line">                material.onBuild(object, parameters, _this);</span><br><span class="line">                material.onBeforeCompile(parameters, _this);</span><br><span class="line">                program = programCache.acquireProgram(parameters, programCacheKey);</span><br><span class="line">                programs.set(programCacheKey, program);</span><br><span class="line">                materialProperties.uniforms = parameters.uniforms;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> uniforms = materialProperties.uniforms;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!material.isShaderMaterial &amp;&amp; !material.isRawShaderMaterial || material.clipping === <span class="literal">true</span>) &#123;</span><br><span class="line">                uniforms.clippingPlanes = clipping.uniform;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            updateCommonMaterialProperties(material, parameters); <span class="comment">// store the light setup it was created for</span></span><br><span class="line"></span><br><span class="line">            materialProperties.needsLights = materialNeedsLights(material);</span><br><span class="line">            materialProperties.lightsStateVersion = lightsStateVersion;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (materialProperties.needsLights) &#123;</span><br><span class="line">                <span class="comment">// wire up the material to this renderer&#x27;s lighting state</span></span><br><span class="line">                uniforms.ambientLightColor.value = lights.state.ambient;</span><br><span class="line">                uniforms.lightProbe.value = lights.state.probe;</span><br><span class="line">                uniforms.directionalLights.value = lights.state.directional;</span><br><span class="line">                uniforms.directionalLightShadows.value = lights.state.directionalShadow;</span><br><span class="line">                uniforms.spotLights.value = lights.state.spot;</span><br><span class="line">                uniforms.spotLightShadows.value = lights.state.spotShadow;</span><br><span class="line">                uniforms.rectAreaLights.value = lights.state.rectArea;</span><br><span class="line">                uniforms.ltc_1.value = lights.state.rectAreaLTC1;</span><br><span class="line">                uniforms.ltc_2.value = lights.state.rectAreaLTC2;</span><br><span class="line">                uniforms.pointLights.value = lights.state.point;</span><br><span class="line">                uniforms.pointLightShadows.value = lights.state.pointShadow;</span><br><span class="line">                uniforms.hemisphereLights.value = lights.state.hemi;</span><br><span class="line">                uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;</span><br><span class="line">                uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;</span><br><span class="line">                uniforms.spotShadowMap.value = lights.state.spotShadowMap;</span><br><span class="line">                uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;</span><br><span class="line">                uniforms.pointShadowMap.value = lights.state.pointShadowMap;</span><br><span class="line">                uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; <span class="comment">// TODO (abelnation): add area lights shadow info to uniforms</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> progUniforms = program.getUniforms();</span><br><span class="line">            <span class="keyword">const</span> uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);</span><br><span class="line">            materialProperties.currentProgram = program;</span><br><span class="line">            materialProperties.uniformsList = uniformsList;</span><br><span class="line">            <span class="keyword">return</span> program;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">updateCommonMaterialProperties</span>(<span class="params">material, parameters</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> materialProperties = properties.get(material);</span><br><span class="line">            materialProperties.outputEncoding = parameters.outputEncoding;</span><br><span class="line">            materialProperties.instancing = parameters.instancing;</span><br><span class="line">            materialProperties.skinning = parameters.skinning;</span><br><span class="line">            materialProperties.morphTargets = parameters.morphTargets;</span><br><span class="line">            materialProperties.morphNormals = parameters.morphNormals;</span><br><span class="line">            materialProperties.morphColors = parameters.morphColors;</span><br><span class="line">            materialProperties.morphTargetsCount = parameters.morphTargetsCount;</span><br><span class="line">            materialProperties.numClippingPlanes = parameters.numClippingPlanes;</span><br><span class="line">            materialProperties.numIntersection = parameters.numClipIntersection;</span><br><span class="line">            materialProperties.vertexAlphas = parameters.vertexAlphas;</span><br><span class="line">            materialProperties.vertexTangents = parameters.vertexTangents;</span><br><span class="line">            materialProperties.toneMapping = parameters.toneMapping;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">setProgram</span>(<span class="params">camera, scene, geometry, material, object</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (scene.isScene !== <span class="literal">true</span>) scene = _emptyScene; <span class="comment">// scene could be a Mesh, Line, Points, ...</span></span><br><span class="line"></span><br><span class="line">            textures.resetTextureUnits();</span><br><span class="line">            <span class="keyword">const</span> fog = scene.fog;</span><br><span class="line">            <span class="keyword">const</span> environment = material.isMeshStandardMaterial ? scene.environment : <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">const</span> encoding = _currentRenderTarget === <span class="literal">null</span> ? _this.outputEncoding : _currentRenderTarget.isXRRenderTarget === <span class="literal">true</span> ? _currentRenderTarget.texture.encoding : LinearEncoding;</span><br><span class="line">            <span class="keyword">const</span> envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);</span><br><span class="line">            <span class="keyword">const</span> vertexAlphas = material.vertexColors === <span class="literal">true</span> &amp;&amp; !!geometry.attributes.color &amp;&amp; geometry.attributes.color.itemSize === <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">const</span> vertexTangents = !!material.normalMap &amp;&amp; !!geometry.attributes.tangent;</span><br><span class="line">            <span class="keyword">const</span> morphTargets = !!geometry.morphAttributes.position;</span><br><span class="line">            <span class="keyword">const</span> morphNormals = !!geometry.morphAttributes.normal;</span><br><span class="line">            <span class="keyword">const</span> morphColors = !!geometry.morphAttributes.color;</span><br><span class="line">            <span class="keyword">const</span> toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;</span><br><span class="line">            <span class="keyword">const</span> morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;</span><br><span class="line">            <span class="keyword">const</span> morphTargetsCount = morphAttribute !== <span class="literal">undefined</span> ? morphAttribute.length : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> materialProperties = properties.get(material);</span><br><span class="line">            <span class="keyword">const</span> lights = currentRenderState.state.lights;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_clippingEnabled === <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_localClippingEnabled === <span class="literal">true</span> || camera !== _currentCamera) &#123;</span><br><span class="line">                    <span class="keyword">const</span> useCache = camera === _currentCamera &amp;&amp; material.id === _currentMaterialId; <span class="comment">// we might want to call this function with some ClippingGroup</span></span><br><span class="line">                    <span class="comment">// object instead of the material, once it becomes feasible</span></span><br><span class="line">                    <span class="comment">// (#8465, #8379)</span></span><br><span class="line"></span><br><span class="line">                    clipping.setState(material, camera, useCache);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> needsProgramChange = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.version === materialProperties.__version) &#123;</span><br><span class="line">                <span class="keyword">if</span> (materialProperties.needsLights &amp;&amp; materialProperties.lightsStateVersion !== lights.state.version) &#123;</span><br><span class="line">                    needsProgramChange = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (materialProperties.outputEncoding !== encoding) &#123;</span><br><span class="line">                    needsProgramChange = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object.isInstancedMesh &amp;&amp; materialProperties.instancing === <span class="literal">false</span>) &#123;</span><br><span class="line">                    needsProgramChange = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!object.isInstancedMesh &amp;&amp; materialProperties.instancing === <span class="literal">true</span>) &#123;</span><br><span class="line">                    needsProgramChange = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object.isSkinnedMesh &amp;&amp; materialProperties.skinning === <span class="literal">false</span>) &#123;</span><br><span class="line">                    needsProgramChange = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!object.isSkinnedMesh &amp;&amp; materialProperties.skinning === <span class="literal">true</span>) &#123;</span><br><span class="line">                    needsProgramChange = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (materialProperties.envMap !== envMap) &#123;</span><br><span class="line">                    needsProgramChange = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (material.fog &amp;&amp; materialProperties.fog !== fog) &#123;</span><br><span class="line">                    needsProgramChange = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (materialProperties.numClippingPlanes !== <span class="literal">undefined</span> &amp;&amp; (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) &#123;</span><br><span class="line">                    needsProgramChange = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (materialProperties.vertexAlphas !== vertexAlphas) &#123;</span><br><span class="line">                    needsProgramChange = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (materialProperties.vertexTangents !== vertexTangents) &#123;</span><br><span class="line">                    needsProgramChange = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (materialProperties.morphTargets !== morphTargets) &#123;</span><br><span class="line">                    needsProgramChange = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (materialProperties.morphNormals !== morphNormals) &#123;</span><br><span class="line">                    needsProgramChange = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (materialProperties.morphColors !== morphColors) &#123;</span><br><span class="line">                    needsProgramChange = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (materialProperties.toneMapping !== toneMapping) &#123;</span><br><span class="line">                    needsProgramChange = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (capabilities.isWebGL2 === <span class="literal">true</span> &amp;&amp; materialProperties.morphTargetsCount !== morphTargetsCount) &#123;</span><br><span class="line">                    needsProgramChange = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                needsProgramChange = <span class="literal">true</span>;</span><br><span class="line">                materialProperties.__version = material.version;</span><br><span class="line">            &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> program = materialProperties.currentProgram;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (needsProgramChange === <span class="literal">true</span>) &#123;</span><br><span class="line">                program = getProgram(material, scene, object);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> refreshProgram = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">let</span> refreshMaterial = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">let</span> refreshLights = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">const</span> p_uniforms = program.getUniforms(),</span><br><span class="line">                m_uniforms = materialProperties.uniforms;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (state.useProgram(program.program)) &#123;</span><br><span class="line">                refreshProgram = <span class="literal">true</span>;</span><br><span class="line">                refreshMaterial = <span class="literal">true</span>;</span><br><span class="line">                refreshLights = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.id !== _currentMaterialId) &#123;</span><br><span class="line">                _currentMaterialId = material.id;</span><br><span class="line">                refreshMaterial = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (refreshProgram || _currentCamera !== camera) &#123;</span><br><span class="line">                p_uniforms.setValue(_gl, <span class="string">&#x27;projectionMatrix&#x27;</span>, camera.projectionMatrix);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (capabilities.logarithmicDepthBuffer) &#123;</span><br><span class="line">                    p_uniforms.setValue(_gl, <span class="string">&#x27;logDepthBufFC&#x27;</span>, <span class="number">2.0</span> / (<span class="built_in">Math</span>.log(camera.far + <span class="number">1.0</span>) / <span class="built_in">Math</span>.LN2));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (_currentCamera !== camera) &#123;</span><br><span class="line">                    _currentCamera = camera; <span class="comment">// lighting uniforms depend on the camera so enforce an update</span></span><br><span class="line">                    <span class="comment">// now, in case this material supports lights - or later, when</span></span><br><span class="line">                    <span class="comment">// the next material that does gets activated:</span></span><br><span class="line"></span><br><span class="line">                    refreshMaterial = <span class="literal">true</span>; <span class="comment">// set to true on material change</span></span><br><span class="line"></span><br><span class="line">                    refreshLights = <span class="literal">true</span>; <span class="comment">// remains set until update done</span></span><br><span class="line">                &#125; <span class="comment">// load material specific uniforms</span></span><br><span class="line">                <span class="comment">// (shader material also gets them for the sake of genericity)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) &#123;</span><br><span class="line">                    <span class="keyword">const</span> uCamPos = p_uniforms.map.cameraPosition;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (uCamPos !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) &#123;</span><br><span class="line">                    p_uniforms.setValue(_gl, <span class="string">&#x27;isOrthographic&#x27;</span>, camera.isOrthographicCamera === <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) &#123;</span><br><span class="line">                    p_uniforms.setValue(_gl, <span class="string">&#x27;viewMatrix&#x27;</span>, camera.matrixWorldInverse);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// skinning and morph target uniforms must be set even if material didn&#x27;t change</span></span><br><span class="line">            <span class="comment">// auto-setting of texture unit for bone and morph texture must go before other textures</span></span><br><span class="line">            <span class="comment">// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (object.isSkinnedMesh) &#123;</span><br><span class="line">                p_uniforms.setOptional(_gl, object, <span class="string">&#x27;bindMatrix&#x27;</span>);</span><br><span class="line">                p_uniforms.setOptional(_gl, object, <span class="string">&#x27;bindMatrixInverse&#x27;</span>);</span><br><span class="line">                <span class="keyword">const</span> skeleton = object.skeleton;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (skeleton) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (capabilities.floatVertexTextures) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (skeleton.boneTexture === <span class="literal">null</span>) skeleton.computeBoneTexture();</span><br><span class="line">                        p_uniforms.setValue(_gl, <span class="string">&#x27;boneTexture&#x27;</span>, skeleton.boneTexture, textures);</span><br><span class="line">                        p_uniforms.setValue(_gl, <span class="string">&#x27;boneTextureSize&#x27;</span>, skeleton.boneTextureSize);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        p_uniforms.setOptional(_gl, skeleton, <span class="string">&#x27;boneMatrices&#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> morphAttributes = geometry.morphAttributes;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (morphAttributes.position !== <span class="literal">undefined</span> || morphAttributes.normal !== <span class="literal">undefined</span> || morphAttributes.color !== <span class="literal">undefined</span> &amp;&amp; capabilities.isWebGL2 === <span class="literal">true</span>) &#123;</span><br><span class="line">                morphtargets.update(object, geometry, material, program);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) &#123;</span><br><span class="line">                materialProperties.receiveShadow = object.receiveShadow;</span><br><span class="line">                p_uniforms.setValue(_gl, <span class="string">&#x27;receiveShadow&#x27;</span>, object.receiveShadow);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (refreshMaterial) &#123;</span><br><span class="line">                p_uniforms.setValue(_gl, <span class="string">&#x27;toneMappingExposure&#x27;</span>, _this.toneMappingExposure);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (materialProperties.needsLights) &#123;</span><br><span class="line">                    <span class="comment">// the current material requires lighting info</span></span><br><span class="line">                    <span class="comment">// note: all lighting uniforms are always set correctly</span></span><br><span class="line">                    <span class="comment">// they simply reference the renderer&#x27;s state for their</span></span><br><span class="line">                    <span class="comment">// values</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// use the current material&#x27;s .needsUpdate flags to set</span></span><br><span class="line">                    <span class="comment">// the GL state when required</span></span><br><span class="line">                    markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);</span><br><span class="line">                &#125; <span class="comment">// refresh uniforms common to several materials</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (fog &amp;&amp; material.fog) &#123;</span><br><span class="line">                    materials.refreshFogUniforms(m_uniforms, fog);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);</span><br><span class="line">                WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.isShaderMaterial &amp;&amp; material.uniformsNeedUpdate === <span class="literal">true</span>) &#123;</span><br><span class="line">                WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);</span><br><span class="line">                material.uniformsNeedUpdate = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (material.isSpriteMaterial) &#123;</span><br><span class="line">                p_uniforms.setValue(_gl, <span class="string">&#x27;center&#x27;</span>, object.center);</span><br><span class="line">            &#125; <span class="comment">// common matrices</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            p_uniforms.setValue(_gl, <span class="string">&#x27;modelViewMatrix&#x27;</span>, object.modelViewMatrix);</span><br><span class="line">            p_uniforms.setValue(_gl, <span class="string">&#x27;normalMatrix&#x27;</span>, object.normalMatrix);</span><br><span class="line">            p_uniforms.setValue(_gl, <span class="string">&#x27;modelMatrix&#x27;</span>, object.matrixWorld);</span><br><span class="line">            <span class="keyword">return</span> program;</span><br><span class="line">        &#125; <span class="comment">// If uniforms are marked as clean, they don&#x27;t need to be loaded to the GPU.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">markUniformsLightsNeedsUpdate</span>(<span class="params">uniforms, value</span>) </span>&#123;</span><br><span class="line">            uniforms.ambientLightColor.needsUpdate = value;</span><br><span class="line">            uniforms.lightProbe.needsUpdate = value;</span><br><span class="line">            uniforms.directionalLights.needsUpdate = value;</span><br><span class="line">            uniforms.directionalLightShadows.needsUpdate = value;</span><br><span class="line">            uniforms.pointLights.needsUpdate = value;</span><br><span class="line">            uniforms.pointLightShadows.needsUpdate = value;</span><br><span class="line">            uniforms.spotLights.needsUpdate = value;</span><br><span class="line">            uniforms.spotLightShadows.needsUpdate = value;</span><br><span class="line">            uniforms.rectAreaLights.needsUpdate = value;</span><br><span class="line">            uniforms.hemisphereLights.needsUpdate = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">materialNeedsLights</span>(<span class="params">material</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial &amp;&amp; material.lights === <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.getActiveCubeFace = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _currentActiveCubeFace;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.getActiveMipmapLevel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _currentActiveMipmapLevel;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.getRenderTarget = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _currentRenderTarget;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setRenderTargetTextures = <span class="function"><span class="keyword">function</span> (<span class="params">renderTarget, colorTexture, depthTexture</span>) </span>&#123;</span><br><span class="line">            properties.get(renderTarget.texture).__webglTexture = colorTexture;</span><br><span class="line">            properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;</span><br><span class="line">            <span class="keyword">const</span> renderTargetProperties = properties.get(renderTarget);</span><br><span class="line">            renderTargetProperties.__hasExternalTextures = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (renderTargetProperties.__hasExternalTextures) &#123;</span><br><span class="line">                renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!renderTargetProperties.__autoAllocateDepthBuffer) &#123;</span><br><span class="line">                    <span class="comment">// The multisample_render_to_texture extension doesn&#x27;t work properly if there</span></span><br><span class="line">                    <span class="comment">// are midframe flushes and an external depth buffer. Disable use of the extension.</span></span><br><span class="line">                    <span class="keyword">if</span> (extensions.has(<span class="string">&#x27;WEBGL_multisampled_render_to_texture&#x27;</span>) === <span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided&#x27;</span>);</span><br><span class="line">                        renderTargetProperties.__useRenderToTexture = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setRenderTargetFramebuffer = <span class="function"><span class="keyword">function</span> (<span class="params">renderTarget, defaultFramebuffer</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> renderTargetProperties = properties.get(renderTarget);</span><br><span class="line">            renderTargetProperties.__webglFramebuffer = defaultFramebuffer;</span><br><span class="line">            renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === <span class="literal">undefined</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setRenderTarget = <span class="function"><span class="keyword">function</span> (<span class="params">renderTarget, activeCubeFace = <span class="number">0</span>, activeMipmapLevel = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">            _currentRenderTarget = renderTarget;</span><br><span class="line">            _currentActiveCubeFace = activeCubeFace;</span><br><span class="line">            _currentActiveMipmapLevel = activeMipmapLevel;</span><br><span class="line">            <span class="keyword">let</span> useDefaultFramebuffer = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (renderTarget) &#123;</span><br><span class="line">                <span class="keyword">const</span> renderTargetProperties = properties.get(renderTarget);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (renderTargetProperties.__useDefaultFramebuffer !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="comment">// We need to make sure to rebind the framebuffer.</span></span><br><span class="line">                    state.bindFramebuffer(_gl.FRAMEBUFFER, <span class="literal">null</span>);</span><br><span class="line">                    useDefaultFramebuffer = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (renderTargetProperties.__webglFramebuffer === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    textures.setupRenderTarget(renderTarget);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (renderTargetProperties.__hasExternalTextures) &#123;</span><br><span class="line">                    <span class="comment">// Color and depth texture must be rebound in order for the swapchain to update.</span></span><br><span class="line">                    textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> framebuffer = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">let</span> isCube = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">let</span> isRenderTarget3D = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (renderTarget) &#123;</span><br><span class="line">                <span class="keyword">const</span> texture = renderTarget.texture;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (texture.isData3DTexture || texture.isDataArrayTexture) &#123;</span><br><span class="line">                    isRenderTarget3D = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (renderTarget.isWebGLCubeRenderTarget) &#123;</span><br><span class="line">                    framebuffer = __webglFramebuffer[activeCubeFace];</span><br><span class="line">                    isCube = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (capabilities.isWebGL2 &amp;&amp; renderTarget.samples &gt; <span class="number">0</span> &amp;&amp; textures.useMultisampledRTT(renderTarget) === <span class="literal">false</span>) &#123;</span><br><span class="line">                    framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    framebuffer = __webglFramebuffer;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                _currentViewport.copy(renderTarget.viewport);</span><br><span class="line"></span><br><span class="line">                _currentScissor.copy(renderTarget.scissor);</span><br><span class="line"></span><br><span class="line">                _currentScissorTest = renderTarget.scissorTest;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();</span><br><span class="line"></span><br><span class="line">                _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();</span><br><span class="line"></span><br><span class="line">                _currentScissorTest = _scissorTest;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (framebufferBound &amp;&amp; capabilities.drawBuffers &amp;&amp; useDefaultFramebuffer) &#123;</span><br><span class="line">                state.drawBuffers(renderTarget, framebuffer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            state.viewport(_currentViewport);</span><br><span class="line">            state.scissor(_currentScissor);</span><br><span class="line">            state.setScissorTest(_currentScissorTest);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isCube) &#123;</span><br><span class="line">                <span class="keyword">const</span> textureProperties = properties.get(renderTarget.texture);</span><br><span class="line"></span><br><span class="line">                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isRenderTarget3D) &#123;</span><br><span class="line">                <span class="keyword">const</span> textureProperties = properties.get(renderTarget.texture);</span><br><span class="line">                <span class="keyword">const</span> layer = activeCubeFace || <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || <span class="number">0</span>, layer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _currentMaterialId = -<span class="number">1</span>; <span class="comment">// reset current material to ensure correct uniform bindings</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.readRenderTargetPixels = <span class="function"><span class="keyword">function</span> (<span class="params">renderTarget, x, y, width, height, buffer, activeCubeFaceIndex</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(renderTarget &amp;&amp; renderTarget.isWebGLRenderTarget)) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> framebuffer = properties.get(renderTarget).__webglFramebuffer;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (renderTarget.isWebGLCubeRenderTarget &amp;&amp; activeCubeFaceIndex !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                framebuffer = framebuffer[activeCubeFaceIndex];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (framebuffer) &#123;</span><br><span class="line">                state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> texture = renderTarget.texture;</span><br><span class="line">                    <span class="keyword">const</span> textureFormat = texture.format;</span><br><span class="line">                    <span class="keyword">const</span> textureType = texture.type;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (textureFormat !== RGBAFormat &amp;&amp; utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) &#123;</span><br><span class="line">                        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.&#x27;</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> halfFloatSupportedByExt = textureType === HalfFloatType &amp;&amp; (extensions.has(<span class="string">&#x27;EXT_color_buffer_half_float&#x27;</span>) || capabilities.isWebGL2 &amp;&amp; extensions.has(<span class="string">&#x27;EXT_color_buffer_float&#x27;</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (textureType !== UnsignedByteType &amp;&amp; utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) &amp;&amp; <span class="comment">// Edge and Chrome Mac &lt; 52 (#9513)</span></span><br><span class="line">                        !(textureType === FloatType &amp;&amp; (capabilities.isWebGL2 || extensions.has(<span class="string">&#x27;OES_texture_float&#x27;</span>) || extensions.has(<span class="string">&#x27;WEBGL_color_buffer_float&#x27;</span>))) &amp;&amp; <span class="comment">// Chrome Mac &gt;= 52 and Firefox</span></span><br><span class="line">                        !halfFloatSupportedByExt) &#123;</span><br><span class="line">                        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.&#x27;</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125; <span class="comment">// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= renderTarget.width - width &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt;= renderTarget.height - height) &#123;</span><br><span class="line">                        _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// restore framebuffer of current render target if necessary</span></span><br><span class="line">                    <span class="keyword">const</span> framebuffer = _currentRenderTarget !== <span class="literal">null</span> ? properties.get(_currentRenderTarget).__webglFramebuffer : <span class="literal">null</span>;</span><br><span class="line">                    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.copyFramebufferToTexture = <span class="function"><span class="keyword">function</span> (<span class="params">position, texture, level = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (texture.isFramebufferTexture !== <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> levelScale = <span class="built_in">Math</span>.pow(<span class="number">2</span>, -level);</span><br><span class="line">            <span class="keyword">const</span> width = <span class="built_in">Math</span>.floor(texture.image.width * levelScale);</span><br><span class="line">            <span class="keyword">const</span> height = <span class="built_in">Math</span>.floor(texture.image.height * levelScale);</span><br><span class="line">            textures.setTexture2D(texture, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            _gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, <span class="number">0</span>, <span class="number">0</span>, position.x, position.y, width, height);</span><br><span class="line"></span><br><span class="line">            state.unbindTexture();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.copyTextureToTexture = <span class="function"><span class="keyword">function</span> (<span class="params">position, srcTexture, dstTexture, level = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> width = srcTexture.image.width;</span><br><span class="line">            <span class="keyword">const</span> height = srcTexture.image.height;</span><br><span class="line">            <span class="keyword">const</span> glFormat = utils.convert(dstTexture.format);</span><br><span class="line">            <span class="keyword">const</span> glType = utils.convert(dstTexture.type);</span><br><span class="line">            textures.setTexture2D(dstTexture, <span class="number">0</span>); <span class="comment">// As another texture upload may have changed pixelStorei</span></span><br><span class="line">            <span class="comment">// parameters, make sure they are correct for the dstTexture</span></span><br><span class="line"></span><br><span class="line">            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);</span><br><span class="line"></span><br><span class="line">            _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);</span><br><span class="line"></span><br><span class="line">            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (srcTexture.isDataTexture) &#123;</span><br><span class="line">                _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (srcTexture.isCompressedTexture) &#123;</span><br><span class="line">                    _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[<span class="number">0</span>].width, srcTexture.mipmaps[<span class="number">0</span>].height, glFormat, srcTexture.mipmaps[<span class="number">0</span>].data);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// Generate mipmaps only when copying level 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (level === <span class="number">0</span> &amp;&amp; dstTexture.generateMipmaps) _gl.generateMipmap(_gl.TEXTURE_2D);</span><br><span class="line">            state.unbindTexture();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.copyTextureToTexture3D = <span class="function"><span class="keyword">function</span> (<span class="params">sourceBox, position, srcTexture, dstTexture, level = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (_this.isWebGL1Renderer) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> width = sourceBox.max.x - sourceBox.min.x + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">const</span> height = sourceBox.max.y - sourceBox.min.y + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">const</span> depth = sourceBox.max.z - sourceBox.min.z + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">const</span> glFormat = utils.convert(dstTexture.format);</span><br><span class="line">            <span class="keyword">const</span> glType = utils.convert(dstTexture.type);</span><br><span class="line">            <span class="keyword">let</span> glTarget;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dstTexture.isData3DTexture) &#123;</span><br><span class="line">                textures.setTexture3D(dstTexture, <span class="number">0</span>);</span><br><span class="line">                glTarget = _gl.TEXTURE_3D;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dstTexture.isDataArrayTexture) &#123;</span><br><span class="line">                textures.setTexture2DArray(dstTexture, <span class="number">0</span>);</span><br><span class="line">                glTarget = _gl.TEXTURE_2D_ARRAY;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);</span><br><span class="line"></span><br><span class="line">            _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);</span><br><span class="line"></span><br><span class="line">            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[<span class="number">0</span>] : srcTexture.image;</span><br><span class="line"></span><br><span class="line">            _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);</span><br><span class="line"></span><br><span class="line">            _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);</span><br><span class="line"></span><br><span class="line">            _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);</span><br><span class="line"></span><br><span class="line">            _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);</span><br><span class="line"></span><br><span class="line">            _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (srcTexture.isDataTexture || srcTexture.isData3DTexture) &#123;</span><br><span class="line">                _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (srcTexture.isCompressedTexture) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">                    _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);</span><br><span class="line"></span><br><span class="line">            _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);</span><br><span class="line"></span><br><span class="line">            _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);</span><br><span class="line"></span><br><span class="line">            _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);</span><br><span class="line"></span><br><span class="line">            _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages); <span class="comment">// Generate mipmaps only when copying level 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (level === <span class="number">0</span> &amp;&amp; dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);</span><br><span class="line">            state.unbindTexture();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.initTexture = <span class="function"><span class="keyword">function</span> (<span class="params">texture</span>) </span>&#123;</span><br><span class="line">            textures.setTexture2D(texture, <span class="number">0</span>);</span><br><span class="line">            state.unbindTexture();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.resetState = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            _currentActiveCubeFace = <span class="number">0</span>;</span><br><span class="line">            _currentActiveMipmapLevel = <span class="number">0</span>;</span><br><span class="line">            _currentRenderTarget = <span class="literal">null</span>;</span><br><span class="line">            state.reset();</span><br><span class="line">            bindingStates.reset();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> __THREE_DEVTOOLS__ !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">            __THREE_DEVTOOLS__.dispatchEvent(<span class="keyword">new</span> CustomEvent(<span class="string">&#x27;observe&#x27;</span>, &#123;</span><br><span class="line">                <span class="attr">detail</span>: <span class="built_in">this</span></span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.isWebGLRenderer = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WebGL1Renderer</span> <span class="keyword">extends</span> <span class="title">WebGLRenderer</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    WebGL1Renderer.prototype.isWebGL1Renderer = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FogExp2</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">color, density = <span class="number">0.00025</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.color = <span class="keyword">new</span> Color(color);</span><br><span class="line">            <span class="built_in">this</span>.density = density;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> FogExp2(<span class="built_in">this</span>.color, <span class="built_in">this</span>.density);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;FogExp2&#x27;</span>,</span><br><span class="line">                <span class="attr">color</span>: <span class="built_in">this</span>.color.getHex(),</span><br><span class="line">                <span class="attr">density</span>: <span class="built_in">this</span>.density</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FogExp2.prototype.isFogExp2 = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Fog</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">color, near = <span class="number">1</span>, far = <span class="number">1000</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.color = <span class="keyword">new</span> Color(color);</span><br><span class="line">            <span class="built_in">this</span>.near = near;</span><br><span class="line">            <span class="built_in">this</span>.far = far;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Fog(<span class="built_in">this</span>.color, <span class="built_in">this</span>.near, <span class="built_in">this</span>.far);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;Fog&#x27;</span>,</span><br><span class="line">                <span class="attr">color</span>: <span class="built_in">this</span>.color.getHex(),</span><br><span class="line">                <span class="attr">near</span>: <span class="built_in">this</span>.near,</span><br><span class="line">                <span class="attr">far</span>: <span class="built_in">this</span>.far</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fog.prototype.isFog = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Scene</span> <span class="keyword">extends</span> <span class="title">Object3D</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;Scene&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.background = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.environment = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.fog = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.overrideMaterial = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.autoUpdate = <span class="literal">true</span>; <span class="comment">// checked by the renderer</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> __THREE_DEVTOOLS__ !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">                __THREE_DEVTOOLS__.dispatchEvent(<span class="keyword">new</span> CustomEvent(<span class="string">&#x27;observe&#x27;</span>, &#123;</span><br><span class="line">                    <span class="attr">detail</span>: <span class="built_in">this</span></span><br><span class="line">                &#125;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source, recursive</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source, recursive);</span><br><span class="line">            <span class="keyword">if</span> (source.background !== <span class="literal">null</span>) <span class="built_in">this</span>.background = source.background.clone();</span><br><span class="line">            <span class="keyword">if</span> (source.environment !== <span class="literal">null</span>) <span class="built_in">this</span>.environment = source.environment.clone();</span><br><span class="line">            <span class="keyword">if</span> (source.fog !== <span class="literal">null</span>) <span class="built_in">this</span>.fog = source.fog.clone();</span><br><span class="line">            <span class="keyword">if</span> (source.overrideMaterial !== <span class="literal">null</span>) <span class="built_in">this</span>.overrideMaterial = source.overrideMaterial.clone();</span><br><span class="line">            <span class="built_in">this</span>.autoUpdate = source.autoUpdate;</span><br><span class="line">            <span class="built_in">this</span>.matrixAutoUpdate = source.matrixAutoUpdate;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params">meta</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON(meta);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.fog !== <span class="literal">null</span>) data.object.fog = <span class="built_in">this</span>.fog.toJSON();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Scene.prototype.isScene = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InterleavedBuffer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array, stride</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.array = array;</span><br><span class="line">            <span class="built_in">this</span>.stride = stride;</span><br><span class="line">            <span class="built_in">this</span>.count = array !== <span class="literal">undefined</span> ? array.length / stride : <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.usage = StaticDrawUsage;</span><br><span class="line">            <span class="built_in">this</span>.updateRange = &#123;</span><br><span class="line">                <span class="attr">offset</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">count</span>: -<span class="number">1</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">this</span>.version = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.uuid = generateUUID();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">onUploadCallback</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">needsUpdate</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value === <span class="literal">true</span>) <span class="built_in">this</span>.version++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setUsage</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.usage = value;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.array = <span class="keyword">new</span> source.array.constructor(source.array);</span><br><span class="line">            <span class="built_in">this</span>.count = source.count;</span><br><span class="line">            <span class="built_in">this</span>.stride = source.stride;</span><br><span class="line">            <span class="built_in">this</span>.usage = source.usage;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copyAt</span>(<span class="params">index1, attribute, index2</span>)</span> &#123;</span><br><span class="line">            index1 *= <span class="built_in">this</span>.stride;</span><br><span class="line">            index2 *= attribute.stride;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">this</span>.stride; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.array[index1 + i] = attribute.array[index2 + i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">value, offset = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.array.set(value, offset);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (data.arrayBuffers === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                data.arrayBuffers = &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.array.buffer._uuid === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.array.buffer._uuid = generateUUID();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (data.arrayBuffers[<span class="built_in">this</span>.array.buffer._uuid] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                data.arrayBuffers[<span class="built_in">this</span>.array.buffer._uuid] = <span class="built_in">this</span>.array.slice(<span class="number">0</span>).buffer;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> array = <span class="keyword">new</span> <span class="built_in">this</span>.array.constructor(data.arrayBuffers[<span class="built_in">this</span>.array.buffer._uuid]);</span><br><span class="line">            <span class="keyword">const</span> ib = <span class="keyword">new</span> <span class="built_in">this</span>.constructor(array, <span class="built_in">this</span>.stride);</span><br><span class="line">            ib.setUsage(<span class="built_in">this</span>.usage);</span><br><span class="line">            <span class="keyword">return</span> ib;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">onUpload</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.onUploadCallback = callback;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (data.arrayBuffers === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                data.arrayBuffers = &#123;&#125;;</span><br><span class="line">            &#125; <span class="comment">// generate UUID for array buffer if necessary</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.array.buffer._uuid === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.array.buffer._uuid = generateUUID();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (data.arrayBuffers[<span class="built_in">this</span>.array.buffer._uuid] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                data.arrayBuffers[<span class="built_in">this</span>.array.buffer._uuid] = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">new</span> <span class="built_in">Uint32Array</span>(<span class="built_in">this</span>.array.buffer));</span><br><span class="line">            &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">uuid</span>: <span class="built_in">this</span>.uuid,</span><br><span class="line">                <span class="attr">buffer</span>: <span class="built_in">this</span>.array.buffer._uuid,</span><br><span class="line">                <span class="attr">type</span>: <span class="built_in">this</span>.array.constructor.name,</span><br><span class="line">                <span class="attr">stride</span>: <span class="built_in">this</span>.stride</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InterleavedBuffer.prototype.isInterleavedBuffer = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vector$<span class="number">6</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InterleavedBufferAttribute</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">interleavedBuffer, itemSize, offset, normalized = <span class="literal">false</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.data = interleavedBuffer;</span><br><span class="line">            <span class="built_in">this</span>.itemSize = itemSize;</span><br><span class="line">            <span class="built_in">this</span>.offset = offset;</span><br><span class="line">            <span class="built_in">this</span>.normalized = normalized === <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">count</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.data.count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">array</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.data.array;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">needsUpdate</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.data.needsUpdate = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">applyMatrix4</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">this</span>.data.count; i &lt; l; i++) &#123;</span><br><span class="line">                _vector$<span class="number">6.</span>fromBufferAttribute(<span class="built_in">this</span>, i);</span><br><span class="line"></span><br><span class="line">                _vector$<span class="number">6.</span>applyMatrix4(m);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.setXYZ(i, _vector$<span class="number">6.</span>x, _vector$<span class="number">6.</span>y, _vector$<span class="number">6.</span>z);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">applyNormalMatrix</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">this</span>.count; i &lt; l; i++) &#123;</span><br><span class="line">                _vector$<span class="number">6.</span>fromBufferAttribute(<span class="built_in">this</span>, i);</span><br><span class="line"></span><br><span class="line">                _vector$<span class="number">6.</span>applyNormalMatrix(m);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.setXYZ(i, _vector$<span class="number">6.</span>x, _vector$<span class="number">6.</span>y, _vector$<span class="number">6.</span>z);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">transformDirection</span>(<span class="params">m</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">this</span>.count; i &lt; l; i++) &#123;</span><br><span class="line">                _vector$<span class="number">6.</span>fromBufferAttribute(<span class="built_in">this</span>, i);</span><br><span class="line"></span><br><span class="line">                _vector$<span class="number">6.</span>transformDirection(m);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.setXYZ(i, _vector$<span class="number">6.</span>x, _vector$<span class="number">6.</span>y, _vector$<span class="number">6.</span>z);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setX</span>(<span class="params">index, x</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.data.array[index * <span class="built_in">this</span>.data.stride + <span class="built_in">this</span>.offset] = x;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setY</span>(<span class="params">index, y</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.data.array[index * <span class="built_in">this</span>.data.stride + <span class="built_in">this</span>.offset + <span class="number">1</span>] = y;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setZ</span>(<span class="params">index, z</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.data.array[index * <span class="built_in">this</span>.data.stride + <span class="built_in">this</span>.offset + <span class="number">2</span>] = z;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setW</span>(<span class="params">index, w</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.data.array[index * <span class="built_in">this</span>.data.stride + <span class="built_in">this</span>.offset + <span class="number">3</span>] = w;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getX</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.data.array[index * <span class="built_in">this</span>.data.stride + <span class="built_in">this</span>.offset];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getY</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.data.array[index * <span class="built_in">this</span>.data.stride + <span class="built_in">this</span>.offset + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getZ</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.data.array[index * <span class="built_in">this</span>.data.stride + <span class="built_in">this</span>.offset + <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getW</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.data.array[index * <span class="built_in">this</span>.data.stride + <span class="built_in">this</span>.offset + <span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setXY</span>(<span class="params">index, x, y</span>)</span> &#123;</span><br><span class="line">            index = index * <span class="built_in">this</span>.data.stride + <span class="built_in">this</span>.offset;</span><br><span class="line">            <span class="built_in">this</span>.data.array[index + <span class="number">0</span>] = x;</span><br><span class="line">            <span class="built_in">this</span>.data.array[index + <span class="number">1</span>] = y;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setXYZ</span>(<span class="params">index, x, y, z</span>)</span> &#123;</span><br><span class="line">            index = index * <span class="built_in">this</span>.data.stride + <span class="built_in">this</span>.offset;</span><br><span class="line">            <span class="built_in">this</span>.data.array[index + <span class="number">0</span>] = x;</span><br><span class="line">            <span class="built_in">this</span>.data.array[index + <span class="number">1</span>] = y;</span><br><span class="line">            <span class="built_in">this</span>.data.array[index + <span class="number">2</span>] = z;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setXYZW</span>(<span class="params">index, x, y, z, w</span>)</span> &#123;</span><br><span class="line">            index = index * <span class="built_in">this</span>.data.stride + <span class="built_in">this</span>.offset;</span><br><span class="line">            <span class="built_in">this</span>.data.array[index + <span class="number">0</span>] = x;</span><br><span class="line">            <span class="built_in">this</span>.data.array[index + <span class="number">1</span>] = y;</span><br><span class="line">            <span class="built_in">this</span>.data.array[index + <span class="number">2</span>] = z;</span><br><span class="line">            <span class="built_in">this</span>.data.array[index + <span class="number">3</span>] = w;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (data === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.&#x27;</span>);</span><br><span class="line">                <span class="keyword">const</span> array = [];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.count; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> index = i * <span class="built_in">this</span>.data.stride + <span class="built_in">this</span>.offset;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="built_in">this</span>.itemSize; j++) &#123;</span><br><span class="line">                        array.push(<span class="built_in">this</span>.data.array[index + j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> BufferAttribute(<span class="keyword">new</span> <span class="built_in">this</span>.array.constructor(array), <span class="built_in">this</span>.itemSize, <span class="built_in">this</span>.normalized);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (data.interleavedBuffers === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    data.interleavedBuffers = &#123;&#125;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (data.interleavedBuffers[<span class="built_in">this</span>.data.uuid] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    data.interleavedBuffers[<span class="built_in">this</span>.data.uuid] = <span class="built_in">this</span>.data.clone(data);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> InterleavedBufferAttribute(data.interleavedBuffers[<span class="built_in">this</span>.data.uuid], <span class="built_in">this</span>.itemSize, <span class="built_in">this</span>.offset, <span class="built_in">this</span>.normalized);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (data === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.&#x27;</span>);</span><br><span class="line">                <span class="keyword">const</span> array = [];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.count; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> index = i * <span class="built_in">this</span>.data.stride + <span class="built_in">this</span>.offset;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="built_in">this</span>.itemSize; j++) &#123;</span><br><span class="line">                        array.push(<span class="built_in">this</span>.data.array[index + j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="comment">// deinterleave data and save it as an ordinary buffer attribute for now</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">itemSize</span>: <span class="built_in">this</span>.itemSize,</span><br><span class="line">                    <span class="attr">type</span>: <span class="built_in">this</span>.array.constructor.name,</span><br><span class="line">                    <span class="attr">array</span>: array,</span><br><span class="line">                    <span class="attr">normalized</span>: <span class="built_in">this</span>.normalized</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// save as true interlaved attribtue</span></span><br><span class="line">                <span class="keyword">if</span> (data.interleavedBuffers === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    data.interleavedBuffers = &#123;&#125;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (data.interleavedBuffers[<span class="built_in">this</span>.data.uuid] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    data.interleavedBuffers[<span class="built_in">this</span>.data.uuid] = <span class="built_in">this</span>.data.toJSON(data);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">isInterleavedBufferAttribute</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">itemSize</span>: <span class="built_in">this</span>.itemSize,</span><br><span class="line">                    <span class="attr">data</span>: <span class="built_in">this</span>.data.uuid,</span><br><span class="line">                    <span class="attr">offset</span>: <span class="built_in">this</span>.offset,</span><br><span class="line">                    <span class="attr">normalized</span>: <span class="built_in">this</span>.normalized</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SpriteMaterial</span> <span class="keyword">extends</span> <span class="title">Material</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameters</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;SpriteMaterial&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.color = <span class="keyword">new</span> Color(<span class="number">0xffffff</span>);</span><br><span class="line">            <span class="built_in">this</span>.map = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.alphaMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.rotation = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.sizeAttenuation = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.transparent = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.setValues(parameters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.color.copy(source.color);</span><br><span class="line">            <span class="built_in">this</span>.map = source.map;</span><br><span class="line">            <span class="built_in">this</span>.alphaMap = source.alphaMap;</span><br><span class="line">            <span class="built_in">this</span>.rotation = source.rotation;</span><br><span class="line">            <span class="built_in">this</span>.sizeAttenuation = source.sizeAttenuation;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SpriteMaterial.prototype.isSpriteMaterial = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> _geometry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _intersectPoint = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _worldScale = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _mvPosition = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _alignedPosition = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector2();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _rotatedPosition = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector2();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _viewWorldMatrix = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Matrix4();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vA = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vB = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vC = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _uvA = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector2();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _uvB = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector2();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _uvC = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector2();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Sprite</span> <span class="keyword">extends</span> <span class="title">Object3D</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">material</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;Sprite&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_geometry === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                _geometry = <span class="keyword">new</span> BufferGeometry();</span><br><span class="line">                <span class="keyword">const</span> float32Array = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([-<span class="number">0.5</span>, -<span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>, -<span class="number">0.5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">const</span> interleavedBuffer = <span class="keyword">new</span> InterleavedBuffer(float32Array, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">                _geometry.setIndex([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">                _geometry.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> InterleavedBufferAttribute(interleavedBuffer, <span class="number">3</span>, <span class="number">0</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">                _geometry.setAttribute(<span class="string">&#x27;uv&#x27;</span>, <span class="keyword">new</span> InterleavedBufferAttribute(interleavedBuffer, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">false</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.geometry = _geometry;</span><br><span class="line">            <span class="built_in">this</span>.material = material !== <span class="literal">undefined</span> ? material : <span class="keyword">new</span> SpriteMaterial();</span><br><span class="line">            <span class="built_in">this</span>.center = <span class="keyword">new</span> Vector2(<span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">raycast</span>(<span class="params">raycaster, intersects</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (raycaster.camera === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Sprite: &quot;Raycaster.camera&quot; needs to be set in order to raycast against sprites.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _worldScale.setFromMatrixScale(<span class="built_in">this</span>.matrixWorld);</span><br><span class="line"></span><br><span class="line">            _viewWorldMatrix.copy(raycaster.camera.matrixWorld);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, <span class="built_in">this</span>.matrixWorld);</span><br><span class="line"></span><br><span class="line">            _mvPosition.setFromMatrixPosition(<span class="built_in">this</span>.modelViewMatrix);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (raycaster.camera.isPerspectiveCamera &amp;&amp; <span class="built_in">this</span>.material.sizeAttenuation === <span class="literal">false</span>) &#123;</span><br><span class="line">                _worldScale.multiplyScalar(-_mvPosition.z);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> rotation = <span class="built_in">this</span>.material.rotation;</span><br><span class="line">            <span class="keyword">let</span> sin, cos;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rotation !== <span class="number">0</span>) &#123;</span><br><span class="line">                cos = <span class="built_in">Math</span>.cos(rotation);</span><br><span class="line">                sin = <span class="built_in">Math</span>.sin(rotation);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> center = <span class="built_in">this</span>.center;</span><br><span class="line">            transformVertex(_vA.set(-<span class="number">0.5</span>, -<span class="number">0.5</span>, <span class="number">0</span>), _mvPosition, center, _worldScale, sin, cos);</span><br><span class="line">            transformVertex(_vB.set(<span class="number">0.5</span>, -<span class="number">0.5</span>, <span class="number">0</span>), _mvPosition, center, _worldScale, sin, cos);</span><br><span class="line">            transformVertex(_vC.set(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0</span>), _mvPosition, center, _worldScale, sin, cos);</span><br><span class="line"></span><br><span class="line">            _uvA.set(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            _uvB.set(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            _uvC.set(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// check first triangle</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, <span class="literal">false</span>, _intersectPoint);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (intersect === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// check second triangle</span></span><br><span class="line">                transformVertex(_vB.set(-<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0</span>), _mvPosition, center, _worldScale, sin, cos);</span><br><span class="line"></span><br><span class="line">                _uvB.set(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, <span class="literal">false</span>, _intersectPoint);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (intersect === <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> distance = raycaster.ray.origin.distanceTo(_intersectPoint);</span><br><span class="line">            <span class="keyword">if</span> (distance &lt; raycaster.near || distance &gt; raycaster.far) <span class="keyword">return</span>;</span><br><span class="line">            intersects.push(&#123;</span><br><span class="line">                <span class="attr">distance</span>: distance,</span><br><span class="line">                <span class="attr">point</span>: _intersectPoint.clone(),</span><br><span class="line">                <span class="attr">uv</span>: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, <span class="keyword">new</span> Vector2()),</span><br><span class="line">                <span class="attr">face</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">object</span>: <span class="built_in">this</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="keyword">if</span> (source.center !== <span class="literal">undefined</span>) <span class="built_in">this</span>.center.copy(source.center);</span><br><span class="line">            <span class="built_in">this</span>.material = source.material;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Sprite.prototype.isSprite = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transformVertex</span>(<span class="params">vertexPosition, mvPosition, center, scale, sin, cos</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// compute position in camera space</span></span><br><span class="line">        _alignedPosition.subVectors(vertexPosition, center).addScalar(<span class="number">0.5</span>).multiply(scale); <span class="comment">// to check if rotation is not zero</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sin !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;</span><br><span class="line">            _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _rotatedPosition.copy(_alignedPosition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vertexPosition.copy(mvPosition);</span><br><span class="line">        vertexPosition.x += _rotatedPosition.x;</span><br><span class="line">        vertexPosition.y += _rotatedPosition.y; <span class="comment">// transform to world space</span></span><br><span class="line"></span><br><span class="line">        vertexPosition.applyMatrix4(_viewWorldMatrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _v1$<span class="number">2</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _v2$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LOD</span> <span class="keyword">extends</span> <span class="title">Object3D</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>._currentLevel = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;LOD&#x27;</span>;</span><br><span class="line">            <span class="built_in">Object</span>.defineProperties(<span class="built_in">this</span>, &#123;</span><br><span class="line">                <span class="attr">levels</span>: &#123;</span><br><span class="line">                    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">value</span>: []</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">isLOD</span>: &#123;</span><br><span class="line">                    <span class="attr">value</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">this</span>.autoUpdate = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">const</span> levels = source.levels;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = levels.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> level = levels[i];</span><br><span class="line">                <span class="built_in">this</span>.addLevel(level.object.clone(), level.distance);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.autoUpdate = source.autoUpdate;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">addLevel</span>(<span class="params">object, distance = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            distance = <span class="built_in">Math</span>.abs(distance);</span><br><span class="line">            <span class="keyword">const</span> levels = <span class="built_in">this</span>.levels;</span><br><span class="line">            <span class="keyword">let</span> l;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (l = <span class="number">0</span>; l &lt; levels.length; l++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (distance &lt; levels[l].distance) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            levels.splice(l, <span class="number">0</span>, &#123;</span><br><span class="line">                <span class="attr">distance</span>: distance,</span><br><span class="line">                <span class="attr">object</span>: object</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">this</span>.add(object);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getCurrentLevel</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._currentLevel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getObjectForDistance</span>(<span class="params">distance</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> levels = <span class="built_in">this</span>.levels;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (levels.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> i, l;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">1</span>, l = levels.length; i &lt; l; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (distance &lt; levels[i].distance) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> levels[i - <span class="number">1</span>].object;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">raycast</span>(<span class="params">raycaster, intersects</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> levels = <span class="built_in">this</span>.levels;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (levels.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                _v1$<span class="number">2.</span>setFromMatrixPosition(<span class="built_in">this</span>.matrixWorld);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> distance = raycaster.ray.origin.distanceTo(_v1$<span class="number">2</span>);</span><br><span class="line">                <span class="built_in">this</span>.getObjectForDistance(distance).raycast(raycaster, intersects);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">update</span>(<span class="params">camera</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> levels = <span class="built_in">this</span>.levels;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (levels.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                _v1$<span class="number">2.</span>setFromMatrixPosition(camera.matrixWorld);</span><br><span class="line"></span><br><span class="line">                _v2$<span class="number">1.</span>setFromMatrixPosition(<span class="built_in">this</span>.matrixWorld);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> distance = _v1$<span class="number">2.</span>distanceTo(_v2$<span class="number">1</span>) / camera.zoom;</span><br><span class="line">                levels[<span class="number">0</span>].object.visible = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">let</span> i, l;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">1</span>, l = levels.length; i &lt; l; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (distance &gt;= levels[i].distance) &#123;</span><br><span class="line">                        levels[i - <span class="number">1</span>].object.visible = <span class="literal">false</span>;</span><br><span class="line">                        levels[i].object.visible = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>._currentLevel = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (; i &lt; l; i++) &#123;</span><br><span class="line">                    levels[i].object.visible = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params">meta</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON(meta);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.autoUpdate === <span class="literal">false</span>) data.object.autoUpdate = <span class="literal">false</span>;</span><br><span class="line">            data.object.levels = [];</span><br><span class="line">            <span class="keyword">const</span> levels = <span class="built_in">this</span>.levels;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = levels.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> level = levels[i];</span><br><span class="line">                data.object.levels.push(&#123;</span><br><span class="line">                    <span class="attr">object</span>: level.object.uuid,</span><br><span class="line">                    <span class="attr">distance</span>: level.distance</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _basePosition = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _skinIndex = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector4();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _skinWeight = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector4();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vector$<span class="number">5</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _matrix = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Matrix4();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SkinnedMesh</span> <span class="keyword">extends</span> <span class="title">Mesh</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">geometry, material</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(geometry, material);</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;SkinnedMesh&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.bindMode = <span class="string">&#x27;attached&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.bindMatrix = <span class="keyword">new</span> Matrix4();</span><br><span class="line">            <span class="built_in">this</span>.bindMatrixInverse = <span class="keyword">new</span> Matrix4();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.bindMode = source.bindMode;</span><br><span class="line">            <span class="built_in">this</span>.bindMatrix.copy(source.bindMatrix);</span><br><span class="line">            <span class="built_in">this</span>.bindMatrixInverse.copy(source.bindMatrixInverse);</span><br><span class="line">            <span class="built_in">this</span>.skeleton = source.skeleton;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">bind</span>(<span class="params">skeleton, bindMatrix</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.skeleton = skeleton;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bindMatrix === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.updateMatrixWorld(<span class="literal">true</span>);</span><br><span class="line">                <span class="built_in">this</span>.skeleton.calculateInverses();</span><br><span class="line">                bindMatrix = <span class="built_in">this</span>.matrixWorld;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.bindMatrix.copy(bindMatrix);</span><br><span class="line">            <span class="built_in">this</span>.bindMatrixInverse.copy(bindMatrix).invert();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">pose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.skeleton.pose();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">normalizeSkinWeights</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> vector = <span class="keyword">new</span> Vector4();</span><br><span class="line">            <span class="keyword">const</span> skinWeight = <span class="built_in">this</span>.geometry.attributes.skinWeight;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = skinWeight.count; i &lt; l; i++) &#123;</span><br><span class="line">                vector.fromBufferAttribute(skinWeight, i);</span><br><span class="line">                <span class="keyword">const</span> scale = <span class="number">1.0</span> / vector.manhattanLength();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (scale !== <span class="literal">Infinity</span>) &#123;</span><br><span class="line">                    vector.multiplyScalar(scale);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    vector.set(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// do something reasonable</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">updateMatrixWorld</span>(<span class="params">force</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.updateMatrixWorld(force);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.bindMode === <span class="string">&#x27;attached&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.bindMatrixInverse.copy(<span class="built_in">this</span>.matrixWorld).invert();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.bindMode === <span class="string">&#x27;detached&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.bindMatrixInverse.copy(<span class="built_in">this</span>.bindMatrix).invert();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.SkinnedMesh: Unrecognized bindMode: &#x27;</span> + <span class="built_in">this</span>.bindMode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">boneTransform</span>(<span class="params">index, target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> skeleton = <span class="built_in">this</span>.skeleton;</span><br><span class="line">            <span class="keyword">const</span> geometry = <span class="built_in">this</span>.geometry;</span><br><span class="line"></span><br><span class="line">            _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);</span><br><span class="line"></span><br><span class="line">            _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);</span><br><span class="line"></span><br><span class="line">            _basePosition.copy(target).applyMatrix4(<span class="built_in">this</span>.bindMatrix);</span><br><span class="line"></span><br><span class="line">            target.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> weight = _skinWeight.getComponent(i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (weight !== <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> boneIndex = _skinIndex.getComponent(i);</span><br><span class="line"></span><br><span class="line">                    _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);</span><br><span class="line"></span><br><span class="line">                    target.addScaledVector(_vector$<span class="number">5.</span>copy(_basePosition).applyMatrix4(_matrix), weight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> target.applyMatrix4(<span class="built_in">this</span>.bindMatrixInverse);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SkinnedMesh.prototype.isSkinnedMesh = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Bone</span> <span class="keyword">extends</span> <span class="title">Object3D</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;Bone&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Bone.prototype.isBone = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DataTexture</span> <span class="keyword">extends</span> <span class="title">Texture</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">data = <span class="literal">null</span>, width = <span class="number">1</span>, height = <span class="number">1</span>, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="literal">null</span>, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);</span><br><span class="line">            <span class="built_in">this</span>.image = &#123;</span><br><span class="line">                <span class="attr">data</span>: data,</span><br><span class="line">                <span class="attr">width</span>: width,</span><br><span class="line">                <span class="attr">height</span>: height</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">this</span>.generateMipmaps = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.flipY = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.unpackAlignment = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DataTexture.prototype.isDataTexture = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _offsetMatrix = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Matrix4();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _identityMatrix = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Matrix4();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Skeleton</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">bones = [], boneInverses = []</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.uuid = generateUUID();</span><br><span class="line">            <span class="built_in">this</span>.bones = bones.slice(<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">this</span>.boneInverses = boneInverses;</span><br><span class="line">            <span class="built_in">this</span>.boneMatrices = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.boneTexture = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.boneTextureSize = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.frame = -<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.init();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> bones = <span class="built_in">this</span>.bones;</span><br><span class="line">            <span class="keyword">const</span> boneInverses = <span class="built_in">this</span>.boneInverses;</span><br><span class="line">            <span class="built_in">this</span>.boneMatrices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(bones.length * <span class="number">16</span>); <span class="comment">// calculate inverse bone matrices if necessary</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (boneInverses.length === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.calculateInverses();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// handle special case</span></span><br><span class="line">                <span class="keyword">if</span> (bones.length !== boneInverses.length) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.&#x27;</span>);</span><br><span class="line">                    <span class="built_in">this</span>.boneInverses = [];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = <span class="built_in">this</span>.bones.length; i &lt; il; i++) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.boneInverses.push(<span class="keyword">new</span> Matrix4());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">calculateInverses</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.boneInverses.length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = <span class="built_in">this</span>.bones.length; i &lt; il; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> inverse = <span class="keyword">new</span> Matrix4();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.bones[i]) &#123;</span><br><span class="line">                    inverse.copy(<span class="built_in">this</span>.bones[i].matrixWorld).invert();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.boneInverses.push(inverse);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">pose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// recover the bind-time world matrices</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = <span class="built_in">this</span>.bones.length; i &lt; il; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> bone = <span class="built_in">this</span>.bones[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bone) &#123;</span><br><span class="line">                    bone.matrixWorld.copy(<span class="built_in">this</span>.boneInverses[i]).invert();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// compute the local matrices, positions, rotations and scales</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = <span class="built_in">this</span>.bones.length; i &lt; il; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> bone = <span class="built_in">this</span>.bones[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bone) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (bone.parent &amp;&amp; bone.parent.isBone) &#123;</span><br><span class="line">                        bone.matrix.copy(bone.parent.matrixWorld).invert();</span><br><span class="line">                        bone.matrix.multiply(bone.matrixWorld);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        bone.matrix.copy(bone.matrixWorld);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> bones = <span class="built_in">this</span>.bones;</span><br><span class="line">            <span class="keyword">const</span> boneInverses = <span class="built_in">this</span>.boneInverses;</span><br><span class="line">            <span class="keyword">const</span> boneMatrices = <span class="built_in">this</span>.boneMatrices;</span><br><span class="line">            <span class="keyword">const</span> boneTexture = <span class="built_in">this</span>.boneTexture; <span class="comment">// flatten bone matrices to array</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = bones.length; i &lt; il; i++) &#123;</span><br><span class="line">                <span class="comment">// compute the offset between the current and the original transform</span></span><br><span class="line">                <span class="keyword">const</span> matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;</span><br><span class="line"></span><br><span class="line">                _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);</span><br><span class="line"></span><br><span class="line">                _offsetMatrix.toArray(boneMatrices, i * <span class="number">16</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (boneTexture !== <span class="literal">null</span>) &#123;</span><br><span class="line">                boneTexture.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Skeleton(<span class="built_in">this</span>.bones, <span class="built_in">this</span>.boneInverses);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">computeBoneTexture</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// layout (1 matrix = 4 pixels)</span></span><br><span class="line">            <span class="comment">//			RGBA RGBA RGBA RGBA (=&gt; column1, column2, column3, column4)</span></span><br><span class="line">            <span class="comment">//	with	8x8	pixel texture max	 16 bones * 4 pixels =	(8 * 8)</span></span><br><span class="line">            <span class="comment">//			 16x16 pixel texture max	 64 bones * 4 pixels = (16 * 16)</span></span><br><span class="line">            <span class="comment">//			 32x32 pixel texture max	256 bones * 4 pixels = (32 * 32)</span></span><br><span class="line">            <span class="comment">//			 64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)</span></span><br><span class="line">            <span class="keyword">let</span> size = <span class="built_in">Math</span>.sqrt(<span class="built_in">this</span>.bones.length * <span class="number">4</span>); <span class="comment">// 4 pixels needed for 1 matrix</span></span><br><span class="line"></span><br><span class="line">            size = ceilPowerOfTwo(size);</span><br><span class="line">            size = <span class="built_in">Math</span>.max(size, <span class="number">4</span>);</span><br><span class="line">            <span class="keyword">const</span> boneMatrices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(size * size * <span class="number">4</span>); <span class="comment">// 4 floats per RGBA pixel</span></span><br><span class="line"></span><br><span class="line">            boneMatrices.set(<span class="built_in">this</span>.boneMatrices); <span class="comment">// copy current values</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> boneTexture = <span class="keyword">new</span> DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);</span><br><span class="line">            boneTexture.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.boneMatrices = boneMatrices;</span><br><span class="line">            <span class="built_in">this</span>.boneTexture = boneTexture;</span><br><span class="line">            <span class="built_in">this</span>.boneTextureSize = size;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getBoneByName</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = <span class="built_in">this</span>.bones.length; i &lt; il; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> bone = <span class="built_in">this</span>.bones[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bone.name === name) &#123;</span><br><span class="line">                    <span class="keyword">return</span> bone;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dispose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.boneTexture !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.boneTexture.dispose();</span><br><span class="line">                <span class="built_in">this</span>.boneTexture = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromJSON</span>(<span class="params">json, bones</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.uuid = json.uuid;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = json.bones.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> uuid = json.bones[i];</span><br><span class="line">                <span class="keyword">let</span> bone = bones[uuid];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bone === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Skeleton: No bone found with UUID:&#x27;</span>, uuid);</span><br><span class="line">                    bone = <span class="keyword">new</span> Bone();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.bones.push(bone);</span><br><span class="line">                <span class="built_in">this</span>.boneInverses.push(<span class="keyword">new</span> Matrix4().fromArray(json.boneInverses[i]));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.init();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = &#123;</span><br><span class="line">                <span class="attr">metadata</span>: &#123;</span><br><span class="line">                    <span class="attr">version</span>: <span class="number">4.5</span>,</span><br><span class="line">                    <span class="attr">type</span>: <span class="string">&#x27;Skeleton&#x27;</span>,</span><br><span class="line">                    <span class="attr">generator</span>: <span class="string">&#x27;Skeleton.toJSON&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">bones</span>: [],</span><br><span class="line">                <span class="attr">boneInverses</span>: []</span><br><span class="line">            &#125;;</span><br><span class="line">            data.uuid = <span class="built_in">this</span>.uuid;</span><br><span class="line">            <span class="keyword">const</span> bones = <span class="built_in">this</span>.bones;</span><br><span class="line">            <span class="keyword">const</span> boneInverses = <span class="built_in">this</span>.boneInverses;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = bones.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> bone = bones[i];</span><br><span class="line">                data.bones.push(bone.uuid);</span><br><span class="line">                <span class="keyword">const</span> boneInverse = boneInverses[i];</span><br><span class="line">                data.boneInverses.push(boneInverse.toArray());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InstancedBufferAttribute</span> <span class="keyword">extends</span> <span class="title">BufferAttribute</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array, itemSize, normalized, meshPerAttribute = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> normalized === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">                meshPerAttribute = normalized;</span><br><span class="line">                normalized = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">super</span>(array, itemSize, normalized);</span><br><span class="line">            <span class="built_in">this</span>.meshPerAttribute = meshPerAttribute;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.meshPerAttribute = source.meshPerAttribute;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON();</span><br><span class="line">            data.meshPerAttribute = <span class="built_in">this</span>.meshPerAttribute;</span><br><span class="line">            data.isInstancedBufferAttribute = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InstancedBufferAttribute.prototype.isInstancedBufferAttribute = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _instanceLocalMatrix = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Matrix4();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _instanceWorldMatrix = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Matrix4();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _instanceIntersects = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _mesh = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Mesh();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InstancedMesh</span> <span class="keyword">extends</span> <span class="title">Mesh</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">geometry, material, count</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(geometry, material);</span><br><span class="line">            <span class="built_in">this</span>.instanceMatrix = <span class="keyword">new</span> InstancedBufferAttribute(<span class="keyword">new</span> <span class="built_in">Float32Array</span>(count * <span class="number">16</span>), <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">this</span>.instanceColor = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.count = count;</span><br><span class="line">            <span class="built_in">this</span>.frustumCulled = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.instanceMatrix.copy(source.instanceMatrix);</span><br><span class="line">            <span class="keyword">if</span> (source.instanceColor !== <span class="literal">null</span>) <span class="built_in">this</span>.instanceColor = source.instanceColor.clone();</span><br><span class="line">            <span class="built_in">this</span>.count = source.count;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getColorAt</span>(<span class="params">index, color</span>)</span> &#123;</span><br><span class="line">            color.fromArray(<span class="built_in">this</span>.instanceColor.array, index * <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getMatrixAt</span>(<span class="params">index, matrix</span>)</span> &#123;</span><br><span class="line">            matrix.fromArray(<span class="built_in">this</span>.instanceMatrix.array, index * <span class="number">16</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">raycast</span>(<span class="params">raycaster, intersects</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> matrixWorld = <span class="built_in">this</span>.matrixWorld;</span><br><span class="line">            <span class="keyword">const</span> raycastTimes = <span class="built_in">this</span>.count;</span><br><span class="line">            _mesh.geometry = <span class="built_in">this</span>.geometry;</span><br><span class="line">            _mesh.material = <span class="built_in">this</span>.material;</span><br><span class="line">            <span class="keyword">if</span> (_mesh.material === <span class="literal">undefined</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> instanceId = <span class="number">0</span>; instanceId &lt; raycastTimes; instanceId++) &#123;</span><br><span class="line">                <span class="comment">// calculate the world matrix for each instance</span></span><br><span class="line">                <span class="built_in">this</span>.getMatrixAt(instanceId, _instanceLocalMatrix);</span><br><span class="line"></span><br><span class="line">                _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); <span class="comment">// the mesh represents this single instance</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                _mesh.matrixWorld = _instanceWorldMatrix;</span><br><span class="line"></span><br><span class="line">                _mesh.raycast(raycaster, _instanceIntersects); <span class="comment">// process the result of raycast</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = _instanceIntersects.length; i &lt; l; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> intersect = _instanceIntersects[i];</span><br><span class="line">                    intersect.instanceId = instanceId;</span><br><span class="line">                    intersect.object = <span class="built_in">this</span>;</span><br><span class="line">                    intersects.push(intersect);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                _instanceIntersects.length = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setColorAt</span>(<span class="params">index, color</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.instanceColor === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.instanceColor = <span class="keyword">new</span> InstancedBufferAttribute(<span class="keyword">new</span> <span class="built_in">Float32Array</span>(<span class="built_in">this</span>.instanceMatrix.count * <span class="number">3</span>), <span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            color.toArray(<span class="built_in">this</span>.instanceColor.array, index * <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setMatrixAt</span>(<span class="params">index, matrix</span>)</span> &#123;</span><br><span class="line">            matrix.toArray(<span class="built_in">this</span>.instanceMatrix.array, index * <span class="number">16</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">updateMorphTargets</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dispose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.dispatchEvent(&#123;</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;dispose&#x27;</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InstancedMesh.prototype.isInstancedMesh = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LineBasicMaterial</span> <span class="keyword">extends</span> <span class="title">Material</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameters</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;LineBasicMaterial&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.color = <span class="keyword">new</span> Color(<span class="number">0xffffff</span>);</span><br><span class="line">            <span class="built_in">this</span>.linewidth = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.linecap = <span class="string">&#x27;round&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.linejoin = <span class="string">&#x27;round&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.setValues(parameters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.color.copy(source.color);</span><br><span class="line">            <span class="built_in">this</span>.linewidth = source.linewidth;</span><br><span class="line">            <span class="built_in">this</span>.linecap = source.linecap;</span><br><span class="line">            <span class="built_in">this</span>.linejoin = source.linejoin;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LineBasicMaterial.prototype.isLineBasicMaterial = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _start$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _end$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _inverseMatrix$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Matrix4();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _ray$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Ray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _sphere$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Sphere();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Line</span> <span class="keyword">extends</span> <span class="title">Object3D</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">geometry = <span class="keyword">new</span> BufferGeometry(), material = <span class="keyword">new</span> LineBasicMaterial()</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;Line&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.geometry = geometry;</span><br><span class="line">            <span class="built_in">this</span>.material = material;</span><br><span class="line">            <span class="built_in">this</span>.updateMorphTargets();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.material = source.material;</span><br><span class="line">            <span class="built_in">this</span>.geometry = source.geometry;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">computeLineDistances</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> geometry = <span class="built_in">this</span>.geometry;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (geometry.isBufferGeometry) &#123;</span><br><span class="line">                <span class="comment">// we assume non-indexed geometry</span></span><br><span class="line">                <span class="keyword">if</span> (geometry.index === <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> positionAttribute = geometry.attributes.position;</span><br><span class="line">                    <span class="keyword">const</span> lineDistances = [<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, l = positionAttribute.count; i &lt; l; i++) &#123;</span><br><span class="line">                        _start$<span class="number">1.</span>fromBufferAttribute(positionAttribute, i - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                        _end$<span class="number">1.</span>fromBufferAttribute(positionAttribute, i);</span><br><span class="line"></span><br><span class="line">                        lineDistances[i] = lineDistances[i - <span class="number">1</span>];</span><br><span class="line">                        lineDistances[i] += _start$<span class="number">1.</span>distanceTo(_end$<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    geometry.setAttribute(<span class="string">&#x27;lineDistance&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(lineDistances, <span class="number">1</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (geometry.isGeometry) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">raycast</span>(<span class="params">raycaster, intersects</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> geometry = <span class="built_in">this</span>.geometry;</span><br><span class="line">            <span class="keyword">const</span> matrixWorld = <span class="built_in">this</span>.matrixWorld;</span><br><span class="line">            <span class="keyword">const</span> threshold = raycaster.params.Line.threshold;</span><br><span class="line">            <span class="keyword">const</span> drawRange = geometry.drawRange; <span class="comment">// Checking boundingSphere distance to ray</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (geometry.boundingSphere === <span class="literal">null</span>) geometry.computeBoundingSphere();</span><br><span class="line"></span><br><span class="line">            _sphere$<span class="number">1.</span>copy(geometry.boundingSphere);</span><br><span class="line"></span><br><span class="line">            _sphere$<span class="number">1.</span>applyMatrix4(matrixWorld);</span><br><span class="line"></span><br><span class="line">            _sphere$<span class="number">1.</span>radius += threshold;</span><br><span class="line">            <span class="keyword">if</span> (raycaster.ray.intersectsSphere(_sphere$<span class="number">1</span>) === <span class="literal">false</span>) <span class="keyword">return</span>; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            _inverseMatrix$<span class="number">1.</span>copy(matrixWorld).invert();</span><br><span class="line"></span><br><span class="line">            _ray$<span class="number">1.</span>copy(raycaster.ray).applyMatrix4(_inverseMatrix$<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> localThreshold = threshold / ((<span class="built_in">this</span>.scale.x + <span class="built_in">this</span>.scale.y + <span class="built_in">this</span>.scale.z) / <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">const</span> localThresholdSq = localThreshold * localThreshold;</span><br><span class="line">            <span class="keyword">const</span> vStart = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> vEnd = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> interSegment = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> interRay = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> step = <span class="built_in">this</span>.isLineSegments ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (geometry.isBufferGeometry) &#123;</span><br><span class="line">                <span class="keyword">const</span> index = geometry.index;</span><br><span class="line">                <span class="keyword">const</span> attributes = geometry.attributes;</span><br><span class="line">                <span class="keyword">const</span> positionAttribute = attributes.position;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (index !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> start = <span class="built_in">Math</span>.max(<span class="number">0</span>, drawRange.start);</span><br><span class="line">                    <span class="keyword">const</span> end = <span class="built_in">Math</span>.min(index.count, drawRange.start + drawRange.count);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = start, l = end - <span class="number">1</span>; i &lt; l; i += step) &#123;</span><br><span class="line">                        <span class="keyword">const</span> a = index.getX(i);</span><br><span class="line">                        <span class="keyword">const</span> b = index.getX(i + <span class="number">1</span>);</span><br><span class="line">                        vStart.fromBufferAttribute(positionAttribute, a);</span><br><span class="line">                        vEnd.fromBufferAttribute(positionAttribute, b);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">const</span> distSq = _ray$<span class="number">1.</span>distanceSqToSegment(vStart, vEnd, interRay, interSegment);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (distSq &gt; localThresholdSq) <span class="keyword">continue</span>;</span><br><span class="line">                        interRay.applyMatrix4(<span class="built_in">this</span>.matrixWorld); <span class="comment">//Move back to world space for distance calculation</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">const</span> distance = raycaster.ray.origin.distanceTo(interRay);</span><br><span class="line">                        <span class="keyword">if</span> (distance &lt; raycaster.near || distance &gt; raycaster.far) <span class="keyword">continue</span>;</span><br><span class="line">                        intersects.push(&#123;</span><br><span class="line">                            <span class="attr">distance</span>: distance,</span><br><span class="line">                            <span class="comment">// What do we want? intersection point on the ray or on the segment??</span></span><br><span class="line">                            <span class="comment">// point: raycaster.ray.at( distance ),</span></span><br><span class="line">                            <span class="attr">point</span>: interSegment.clone().applyMatrix4(<span class="built_in">this</span>.matrixWorld),</span><br><span class="line">                            <span class="attr">index</span>: i,</span><br><span class="line">                            <span class="attr">face</span>: <span class="literal">null</span>,</span><br><span class="line">                            <span class="attr">faceIndex</span>: <span class="literal">null</span>,</span><br><span class="line">                            <span class="attr">object</span>: <span class="built_in">this</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> start = <span class="built_in">Math</span>.max(<span class="number">0</span>, drawRange.start);</span><br><span class="line">                    <span class="keyword">const</span> end = <span class="built_in">Math</span>.min(positionAttribute.count, drawRange.start + drawRange.count);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = start, l = end - <span class="number">1</span>; i &lt; l; i += step) &#123;</span><br><span class="line">                        vStart.fromBufferAttribute(positionAttribute, i);</span><br><span class="line">                        vEnd.fromBufferAttribute(positionAttribute, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">const</span> distSq = _ray$<span class="number">1.</span>distanceSqToSegment(vStart, vEnd, interRay, interSegment);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (distSq &gt; localThresholdSq) <span class="keyword">continue</span>;</span><br><span class="line">                        interRay.applyMatrix4(<span class="built_in">this</span>.matrixWorld); <span class="comment">//Move back to world space for distance calculation</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">const</span> distance = raycaster.ray.origin.distanceTo(interRay);</span><br><span class="line">                        <span class="keyword">if</span> (distance &lt; raycaster.near || distance &gt; raycaster.far) <span class="keyword">continue</span>;</span><br><span class="line">                        intersects.push(&#123;</span><br><span class="line">                            <span class="attr">distance</span>: distance,</span><br><span class="line">                            <span class="comment">// What do we want? intersection point on the ray or on the segment??</span></span><br><span class="line">                            <span class="comment">// point: raycaster.ray.at( distance ),</span></span><br><span class="line">                            <span class="attr">point</span>: interSegment.clone().applyMatrix4(<span class="built_in">this</span>.matrixWorld),</span><br><span class="line">                            <span class="attr">index</span>: i,</span><br><span class="line">                            <span class="attr">face</span>: <span class="literal">null</span>,</span><br><span class="line">                            <span class="attr">faceIndex</span>: <span class="literal">null</span>,</span><br><span class="line">                            <span class="attr">object</span>: <span class="built_in">this</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (geometry.isGeometry) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">updateMorphTargets</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> geometry = <span class="built_in">this</span>.geometry;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (geometry.isBufferGeometry) &#123;</span><br><span class="line">                <span class="keyword">const</span> morphAttributes = geometry.morphAttributes;</span><br><span class="line">                <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(morphAttributes);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (keys.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> morphAttribute = morphAttributes[keys[<span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (morphAttribute !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.morphTargetInfluences = [];</span><br><span class="line">                        <span class="built_in">this</span>.morphTargetDictionary = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> m = <span class="number">0</span>, ml = morphAttribute.length; m &lt; ml; m++) &#123;</span><br><span class="line">                            <span class="keyword">const</span> name = morphAttribute[m].name || <span class="built_in">String</span>(m);</span><br><span class="line">                            <span class="built_in">this</span>.morphTargetInfluences.push(<span class="number">0</span>);</span><br><span class="line">                            <span class="built_in">this</span>.morphTargetDictionary[name] = m;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> morphTargets = geometry.morphTargets;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (morphTargets !== <span class="literal">undefined</span> &amp;&amp; morphTargets.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Line.prototype.isLine = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _start = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _end = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LineSegments</span> <span class="keyword">extends</span> <span class="title">Line</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">geometry, material</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(geometry, material);</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;LineSegments&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">computeLineDistances</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> geometry = <span class="built_in">this</span>.geometry;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (geometry.isBufferGeometry) &#123;</span><br><span class="line">                <span class="comment">// we assume non-indexed geometry</span></span><br><span class="line">                <span class="keyword">if</span> (geometry.index === <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> positionAttribute = geometry.attributes.position;</span><br><span class="line">                    <span class="keyword">const</span> lineDistances = [];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = positionAttribute.count; i &lt; l; i += <span class="number">2</span>) &#123;</span><br><span class="line">                        _start.fromBufferAttribute(positionAttribute, i);</span><br><span class="line"></span><br><span class="line">                        _end.fromBufferAttribute(positionAttribute, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                        lineDistances[i] = i === <span class="number">0</span> ? <span class="number">0</span> : lineDistances[i - <span class="number">1</span>];</span><br><span class="line">                        lineDistances[i + <span class="number">1</span>] = lineDistances[i] + _start.distanceTo(_end);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    geometry.setAttribute(<span class="string">&#x27;lineDistance&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(lineDistances, <span class="number">1</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (geometry.isGeometry) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LineSegments.prototype.isLineSegments = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LineLoop</span> <span class="keyword">extends</span> <span class="title">Line</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">geometry, material</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(geometry, material);</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;LineLoop&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LineLoop.prototype.isLineLoop = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PointsMaterial</span> <span class="keyword">extends</span> <span class="title">Material</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameters</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;PointsMaterial&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.color = <span class="keyword">new</span> Color(<span class="number">0xffffff</span>);</span><br><span class="line">            <span class="built_in">this</span>.map = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.alphaMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.size = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.sizeAttenuation = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.setValues(parameters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.color.copy(source.color);</span><br><span class="line">            <span class="built_in">this</span>.map = source.map;</span><br><span class="line">            <span class="built_in">this</span>.alphaMap = source.alphaMap;</span><br><span class="line">            <span class="built_in">this</span>.size = source.size;</span><br><span class="line">            <span class="built_in">this</span>.sizeAttenuation = source.sizeAttenuation;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PointsMaterial.prototype.isPointsMaterial = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _inverseMatrix = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Matrix4();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _ray = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Ray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _sphere = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Sphere();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _position$<span class="number">2</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Points</span> <span class="keyword">extends</span> <span class="title">Object3D</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">geometry = <span class="keyword">new</span> BufferGeometry(), material = <span class="keyword">new</span> PointsMaterial()</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;Points&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.geometry = geometry;</span><br><span class="line">            <span class="built_in">this</span>.material = material;</span><br><span class="line">            <span class="built_in">this</span>.updateMorphTargets();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.material = source.material;</span><br><span class="line">            <span class="built_in">this</span>.geometry = source.geometry;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">raycast</span>(<span class="params">raycaster, intersects</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> geometry = <span class="built_in">this</span>.geometry;</span><br><span class="line">            <span class="keyword">const</span> matrixWorld = <span class="built_in">this</span>.matrixWorld;</span><br><span class="line">            <span class="keyword">const</span> threshold = raycaster.params.Points.threshold;</span><br><span class="line">            <span class="keyword">const</span> drawRange = geometry.drawRange; <span class="comment">// Checking boundingSphere distance to ray</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (geometry.boundingSphere === <span class="literal">null</span>) geometry.computeBoundingSphere();</span><br><span class="line"></span><br><span class="line">            _sphere.copy(geometry.boundingSphere);</span><br><span class="line"></span><br><span class="line">            _sphere.applyMatrix4(matrixWorld);</span><br><span class="line"></span><br><span class="line">            _sphere.radius += threshold;</span><br><span class="line">            <span class="keyword">if</span> (raycaster.ray.intersectsSphere(_sphere) === <span class="literal">false</span>) <span class="keyword">return</span>; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            _inverseMatrix.copy(matrixWorld).invert();</span><br><span class="line"></span><br><span class="line">            _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> localThreshold = threshold / ((<span class="built_in">this</span>.scale.x + <span class="built_in">this</span>.scale.y + <span class="built_in">this</span>.scale.z) / <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">const</span> localThresholdSq = localThreshold * localThreshold;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (geometry.isBufferGeometry) &#123;</span><br><span class="line">                <span class="keyword">const</span> index = geometry.index;</span><br><span class="line">                <span class="keyword">const</span> attributes = geometry.attributes;</span><br><span class="line">                <span class="keyword">const</span> positionAttribute = attributes.position;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (index !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> start = <span class="built_in">Math</span>.max(<span class="number">0</span>, drawRange.start);</span><br><span class="line">                    <span class="keyword">const</span> end = <span class="built_in">Math</span>.min(index.count, drawRange.start + drawRange.count);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = start, il = end; i &lt; il; i++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> a = index.getX(i);</span><br><span class="line"></span><br><span class="line">                        _position$<span class="number">2.</span>fromBufferAttribute(positionAttribute, a);</span><br><span class="line"></span><br><span class="line">                        testPoint(_position$<span class="number">2</span>, a, localThresholdSq, matrixWorld, raycaster, intersects, <span class="built_in">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> start = <span class="built_in">Math</span>.max(<span class="number">0</span>, drawRange.start);</span><br><span class="line">                    <span class="keyword">const</span> end = <span class="built_in">Math</span>.min(positionAttribute.count, drawRange.start + drawRange.count);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = start, l = end; i &lt; l; i++) &#123;</span><br><span class="line">                        _position$<span class="number">2.</span>fromBufferAttribute(positionAttribute, i);</span><br><span class="line"></span><br><span class="line">                        testPoint(_position$<span class="number">2</span>, i, localThresholdSq, matrixWorld, raycaster, intersects, <span class="built_in">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">updateMorphTargets</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> geometry = <span class="built_in">this</span>.geometry;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (geometry.isBufferGeometry) &#123;</span><br><span class="line">                <span class="keyword">const</span> morphAttributes = geometry.morphAttributes;</span><br><span class="line">                <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(morphAttributes);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (keys.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> morphAttribute = morphAttributes[keys[<span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (morphAttribute !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.morphTargetInfluences = [];</span><br><span class="line">                        <span class="built_in">this</span>.morphTargetDictionary = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> m = <span class="number">0</span>, ml = morphAttribute.length; m &lt; ml; m++) &#123;</span><br><span class="line">                            <span class="keyword">const</span> name = morphAttribute[m].name || <span class="built_in">String</span>(m);</span><br><span class="line">                            <span class="built_in">this</span>.morphTargetInfluences.push(<span class="number">0</span>);</span><br><span class="line">                            <span class="built_in">this</span>.morphTargetDictionary[name] = m;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> morphTargets = geometry.morphTargets;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (morphTargets !== <span class="literal">undefined</span> &amp;&amp; morphTargets.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Points.prototype.isPoints = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">testPoint</span>(<span class="params">point, index, localThresholdSq, matrixWorld, raycaster, intersects, object</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> rayPointDistanceSq = _ray.distanceSqToPoint(point);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rayPointDistanceSq &lt; localThresholdSq) &#123;</span><br><span class="line">            <span class="keyword">const</span> intersectPoint = <span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">            _ray.closestPointToPoint(point, intersectPoint);</span><br><span class="line"></span><br><span class="line">            intersectPoint.applyMatrix4(matrixWorld);</span><br><span class="line">            <span class="keyword">const</span> distance = raycaster.ray.origin.distanceTo(intersectPoint);</span><br><span class="line">            <span class="keyword">if</span> (distance &lt; raycaster.near || distance &gt; raycaster.far) <span class="keyword">return</span>;</span><br><span class="line">            intersects.push(&#123;</span><br><span class="line">                <span class="attr">distance</span>: distance,</span><br><span class="line">                <span class="attr">distanceToRay</span>: <span class="built_in">Math</span>.sqrt(rayPointDistanceSq),</span><br><span class="line">                <span class="attr">point</span>: intersectPoint,</span><br><span class="line">                <span class="attr">index</span>: index,</span><br><span class="line">                <span class="attr">face</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">object</span>: object</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">VideoTexture</span> <span class="keyword">extends</span> <span class="title">Texture</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);</span><br><span class="line">            <span class="built_in">this</span>.minFilter = minFilter !== <span class="literal">undefined</span> ? minFilter : LinearFilter;</span><br><span class="line">            <span class="built_in">this</span>.magFilter = magFilter !== <span class="literal">undefined</span> ? magFilter : LinearFilter;</span><br><span class="line">            <span class="built_in">this</span>.generateMipmaps = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">const</span> scope = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">updateVideo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                scope.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">                video.requestVideoFrameCallback(updateVideo);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;requestVideoFrameCallback&#x27;</span> <span class="keyword">in</span> video) &#123;</span><br><span class="line">                video.requestVideoFrameCallback(updateVideo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor(<span class="built_in">this</span>.image).copy(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> video = <span class="built_in">this</span>.image;</span><br><span class="line">            <span class="keyword">const</span> hasVideoFrameCallback = (<span class="string">&#x27;requestVideoFrameCallback&#x27;</span> <span class="keyword">in</span> video);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hasVideoFrameCallback === <span class="literal">false</span> &amp;&amp; video.readyState &gt;= video.HAVE_CURRENT_DATA) &#123;</span><br><span class="line">                <span class="built_in">this</span>.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VideoTexture.prototype.isVideoTexture = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FramebufferTexture</span> <span class="keyword">extends</span> <span class="title">Texture</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">width, height, format</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(&#123;</span><br><span class="line">                width,</span><br><span class="line">                height</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">this</span>.format = format;</span><br><span class="line">            <span class="built_in">this</span>.magFilter = NearestFilter;</span><br><span class="line">            <span class="built_in">this</span>.minFilter = NearestFilter;</span><br><span class="line">            <span class="built_in">this</span>.generateMipmaps = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FramebufferTexture.prototype.isFramebufferTexture = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CompressedTexture</span> <span class="keyword">extends</span> <span class="title">Texture</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="literal">null</span>, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);</span><br><span class="line">            <span class="built_in">this</span>.image = &#123;</span><br><span class="line">                <span class="attr">width</span>: width,</span><br><span class="line">                <span class="attr">height</span>: height</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">this</span>.mipmaps = mipmaps; <span class="comment">// no flipping for cube textures</span></span><br><span class="line">            <span class="comment">// (also flipping doesn&#x27;t work for compressed textures )</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.flipY = <span class="literal">false</span>; <span class="comment">// can&#x27;t generate mipmaps for compressed textures</span></span><br><span class="line">            <span class="comment">// mips must be embedded in DDS files</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.generateMipmaps = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CompressedTexture.prototype.isCompressedTexture = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CanvasTexture</span> <span class="keyword">extends</span> <span class="title">Texture</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);</span><br><span class="line">            <span class="built_in">this</span>.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CanvasTexture.prototype.isCanvasTexture = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Extensible curve object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Some common of curve methods:</span></span><br><span class="line"><span class="comment">     * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )</span></span><br><span class="line"><span class="comment">     * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )</span></span><br><span class="line"><span class="comment">     * .getPoints(), .getSpacedPoints()</span></span><br><span class="line"><span class="comment">     * .getLength()</span></span><br><span class="line"><span class="comment">     * .updateArcLengths()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This following curves inherit from THREE.Curve:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -- 2D curves --</span></span><br><span class="line"><span class="comment">     * THREE.ArcCurve</span></span><br><span class="line"><span class="comment">     * THREE.CubicBezierCurve</span></span><br><span class="line"><span class="comment">     * THREE.EllipseCurve</span></span><br><span class="line"><span class="comment">     * THREE.LineCurve</span></span><br><span class="line"><span class="comment">     * THREE.QuadraticBezierCurve</span></span><br><span class="line"><span class="comment">     * THREE.SplineCurve</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -- 3D curves --</span></span><br><span class="line"><span class="comment">     * THREE.CatmullRomCurve3</span></span><br><span class="line"><span class="comment">     * THREE.CubicBezierCurve3</span></span><br><span class="line"><span class="comment">     * THREE.LineCurve3</span></span><br><span class="line"><span class="comment">     * THREE.QuadraticBezierCurve3</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A series of curves can be represented as a THREE.CurvePath.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Curve</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;Curve&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.arcLengthDivisions = <span class="number">200</span>;</span><br><span class="line">        &#125; <span class="comment">// Virtual base class method to overwrite and implement in subclasses</span></span><br><span class="line">        <span class="comment">//	- t [0 .. 1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getPoint</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Curve: .getPoint() not implemented.&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="comment">// Get point at relative position in curve according to arc length</span></span><br><span class="line">        <span class="comment">// - u [0 .. 1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getPointAt</span>(<span class="params">u, optionalTarget</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> t = <span class="built_in">this</span>.getUtoTmapping(u);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.getPoint(t, optionalTarget);</span><br><span class="line">        &#125; <span class="comment">// Get sequence of points using getPoint( t )</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getPoints</span>(<span class="params">divisions = <span class="number">5</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> points = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> d = <span class="number">0</span>; d &lt;= divisions; d++) &#123;</span><br><span class="line">                points.push(<span class="built_in">this</span>.getPoint(d / divisions));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> points;</span><br><span class="line">        &#125; <span class="comment">// Get sequence of points using getPointAt( u )</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getSpacedPoints</span>(<span class="params">divisions = <span class="number">5</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> points = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> d = <span class="number">0</span>; d &lt;= divisions; d++) &#123;</span><br><span class="line">                points.push(<span class="built_in">this</span>.getPointAt(d / divisions));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> points;</span><br><span class="line">        &#125; <span class="comment">// Get total curve arc length</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getLength</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> lengths = <span class="built_in">this</span>.getLengths();</span><br><span class="line">            <span class="keyword">return</span> lengths[lengths.length - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="comment">// Get list of cumulative segment lengths</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getLengths</span>(<span class="params">divisions = <span class="built_in">this</span>.arcLengthDivisions</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.cacheArcLengths &amp;&amp; <span class="built_in">this</span>.cacheArcLengths.length === divisions + <span class="number">1</span> &amp;&amp; !<span class="built_in">this</span>.needsUpdate) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.cacheArcLengths;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.needsUpdate = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">const</span> cache = [];</span><br><span class="line">            <span class="keyword">let</span> current,</span><br><span class="line">                last = <span class="built_in">this</span>.getPoint(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">            cache.push(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> p = <span class="number">1</span>; p &lt;= divisions; p++) &#123;</span><br><span class="line">                current = <span class="built_in">this</span>.getPoint(p / divisions);</span><br><span class="line">                sum += current.distanceTo(last);</span><br><span class="line">                cache.push(sum);</span><br><span class="line">                last = current;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.cacheArcLengths = cache;</span><br><span class="line">            <span class="keyword">return</span> cache; <span class="comment">// &#123; sums: cache, sum: sum &#125;; Sum is in the last element.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">updateArcLengths</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.getLengths();</span><br><span class="line">        &#125; <span class="comment">// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getUtoTmapping</span>(<span class="params">u, distance</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> arcLengths = <span class="built_in">this</span>.getLengths();</span><br><span class="line">            <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> il = arcLengths.length;</span><br><span class="line">            <span class="keyword">let</span> targetArcLength; <span class="comment">// The targeted u distance value to get</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (distance) &#123;</span><br><span class="line">                targetArcLength = distance;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                targetArcLength = u * arcLengths[il - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="comment">// binary search for the index with largest value smaller than target u distance</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> low = <span class="number">0</span>,</span><br><span class="line">                high = il - <span class="number">1</span>,</span><br><span class="line">                comparison;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">                i = <span class="built_in">Math</span>.floor(low + (high - low) / <span class="number">2</span>); <span class="comment">// less likely to overflow, though probably not issue here, JS doesn&#x27;t really have integers, all numbers are floats</span></span><br><span class="line"></span><br><span class="line">                comparison = arcLengths[i] - targetArcLength;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (comparison &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    low = i + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparison &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    high = i - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    high = i;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// DONE</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i = high;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (arcLengths[i] === targetArcLength) &#123;</span><br><span class="line">                <span class="keyword">return</span> i / (il - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="comment">// we could get finer grain at lengths, or use simple interpolation between two points</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> lengthBefore = arcLengths[i];</span><br><span class="line">            <span class="keyword">const</span> lengthAfter = arcLengths[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">const</span> segmentLength = lengthAfter - lengthBefore; <span class="comment">// determine where we are between the &#x27;before&#x27; and &#x27;after&#x27; points</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> segmentFraction = (targetArcLength - lengthBefore) / segmentLength; <span class="comment">// add that fractional amount to t</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> t = (i + segmentFraction) / (il - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="comment">// Returns a unit vector tangent at t</span></span><br><span class="line">        <span class="comment">// In case any sub curve does not implement its tangent derivation,</span></span><br><span class="line">        <span class="comment">// 2 points a small delta apart will be used to find its gradient</span></span><br><span class="line">        <span class="comment">// which seems to give a reasonable approximation</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getTangent</span>(<span class="params">t, optionalTarget</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> delta = <span class="number">0.0001</span>;</span><br><span class="line">            <span class="keyword">let</span> t1 = t - delta;</span><br><span class="line">            <span class="keyword">let</span> t2 = t + delta; <span class="comment">// Capping in case of danger</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t1 &lt; <span class="number">0</span>) t1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (t2 &gt; <span class="number">1</span>) t2 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">const</span> pt1 = <span class="built_in">this</span>.getPoint(t1);</span><br><span class="line">            <span class="keyword">const</span> pt2 = <span class="built_in">this</span>.getPoint(t2);</span><br><span class="line">            <span class="keyword">const</span> tangent = optionalTarget || (pt1.isVector2 ? <span class="keyword">new</span> Vector2() : <span class="keyword">new</span> Vector3());</span><br><span class="line">            tangent.copy(pt2).sub(pt1).normalize();</span><br><span class="line">            <span class="keyword">return</span> tangent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getTangentAt</span>(<span class="params">u, optionalTarget</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> t = <span class="built_in">this</span>.getUtoTmapping(u);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.getTangent(t, optionalTarget);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">computeFrenetFrames</span>(<span class="params">segments, closed</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf</span></span><br><span class="line">            <span class="keyword">const</span> normal = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> tangents = [];</span><br><span class="line">            <span class="keyword">const</span> normals = [];</span><br><span class="line">            <span class="keyword">const</span> binormals = [];</span><br><span class="line">            <span class="keyword">const</span> vec = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> mat = <span class="keyword">new</span> Matrix4(); <span class="comment">// compute the tangent vectors for each segment on the curve</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= segments; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> u = i / segments;</span><br><span class="line">                tangents[i] = <span class="built_in">this</span>.getTangentAt(u, <span class="keyword">new</span> Vector3());</span><br><span class="line">            &#125; <span class="comment">// select an initial normal vector perpendicular to the first tangent vector,</span></span><br><span class="line">            <span class="comment">// and in the direction of the minimum tangent xyz component</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            normals[<span class="number">0</span>] = <span class="keyword">new</span> Vector3();</span><br><span class="line">            binormals[<span class="number">0</span>] = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">let</span> min = <span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line">            <span class="keyword">const</span> tx = <span class="built_in">Math</span>.abs(tangents[<span class="number">0</span>].x);</span><br><span class="line">            <span class="keyword">const</span> ty = <span class="built_in">Math</span>.abs(tangents[<span class="number">0</span>].y);</span><br><span class="line">            <span class="keyword">const</span> tz = <span class="built_in">Math</span>.abs(tangents[<span class="number">0</span>].z);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tx &lt;= min) &#123;</span><br><span class="line">                min = tx;</span><br><span class="line">                normal.set(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ty &lt;= min) &#123;</span><br><span class="line">                min = ty;</span><br><span class="line">                normal.set(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tz &lt;= min) &#123;</span><br><span class="line">                normal.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            vec.crossVectors(tangents[<span class="number">0</span>], normal).normalize();</span><br><span class="line">            normals[<span class="number">0</span>].crossVectors(tangents[<span class="number">0</span>], vec);</span><br><span class="line">            binormals[<span class="number">0</span>].crossVectors(tangents[<span class="number">0</span>], normals[<span class="number">0</span>]); <span class="comment">// compute the slowly-varying normal and binormal vectors for each segment on the curve</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= segments; i++) &#123;</span><br><span class="line">                normals[i] = normals[i - <span class="number">1</span>].clone();</span><br><span class="line">                binormals[i] = binormals[i - <span class="number">1</span>].clone();</span><br><span class="line">                vec.crossVectors(tangents[i - <span class="number">1</span>], tangents[i]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (vec.length() &gt; <span class="built_in">Number</span>.EPSILON) &#123;</span><br><span class="line">                    vec.normalize();</span><br><span class="line">                    <span class="keyword">const</span> theta = <span class="built_in">Math</span>.acos(clamp(tangents[i - <span class="number">1</span>].dot(tangents[i]), -<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// clamp for floating pt errors</span></span><br><span class="line"></span><br><span class="line">                    normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                binormals[i].crossVectors(tangents[i], normals[i]);</span><br><span class="line">            &#125; <span class="comment">// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (closed === <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> theta = <span class="built_in">Math</span>.acos(clamp(normals[<span class="number">0</span>].dot(normals[segments]), -<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">                theta /= segments;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tangents[<span class="number">0</span>].dot(vec.crossVectors(normals[<span class="number">0</span>], normals[segments])) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    theta = -theta;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= segments; i++) &#123;</span><br><span class="line">                    <span class="comment">// twist a little...</span></span><br><span class="line">                    normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));</span><br><span class="line">                    binormals[i].crossVectors(tangents[i], normals[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">tangents</span>: tangents,</span><br><span class="line">                <span class="attr">normals</span>: normals,</span><br><span class="line">                <span class="attr">binormals</span>: binormals</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor().copy(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.arcLengthDivisions = source.arcLengthDivisions;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = &#123;</span><br><span class="line">                <span class="attr">metadata</span>: &#123;</span><br><span class="line">                    <span class="attr">version</span>: <span class="number">4.5</span>,</span><br><span class="line">                    <span class="attr">type</span>: <span class="string">&#x27;Curve&#x27;</span>,</span><br><span class="line">                    <span class="attr">generator</span>: <span class="string">&#x27;Curve.toJSON&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            data.arcLengthDivisions = <span class="built_in">this</span>.arcLengthDivisions;</span><br><span class="line">            data.type = <span class="built_in">this</span>.type;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromJSON</span>(<span class="params">json</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.arcLengthDivisions = json.arcLengthDivisions;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EllipseCurve</span> <span class="keyword">extends</span> <span class="title">Curve</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">aX = <span class="number">0</span>, aY = <span class="number">0</span>, xRadius = <span class="number">1</span>, yRadius = <span class="number">1</span>, aStartAngle = <span class="number">0</span>, aEndAngle = <span class="built_in">Math</span>.PI * <span class="number">2</span>, aClockwise = <span class="literal">false</span>, aRotation = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;EllipseCurve&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.aX = aX;</span><br><span class="line">            <span class="built_in">this</span>.aY = aY;</span><br><span class="line">            <span class="built_in">this</span>.xRadius = xRadius;</span><br><span class="line">            <span class="built_in">this</span>.yRadius = yRadius;</span><br><span class="line">            <span class="built_in">this</span>.aStartAngle = aStartAngle;</span><br><span class="line">            <span class="built_in">this</span>.aEndAngle = aEndAngle;</span><br><span class="line">            <span class="built_in">this</span>.aClockwise = aClockwise;</span><br><span class="line">            <span class="built_in">this</span>.aRotation = aRotation;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getPoint</span>(<span class="params">t, optionalTarget</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> point = optionalTarget || <span class="keyword">new</span> Vector2();</span><br><span class="line">            <span class="keyword">const</span> twoPi = <span class="built_in">Math</span>.PI * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">let</span> deltaAngle = <span class="built_in">this</span>.aEndAngle - <span class="built_in">this</span>.aStartAngle;</span><br><span class="line">            <span class="keyword">const</span> samePoints = <span class="built_in">Math</span>.abs(deltaAngle) &lt; <span class="built_in">Number</span>.EPSILON; <span class="comment">// ensures that deltaAngle is 0 .. 2 PI</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (deltaAngle &lt; <span class="number">0</span>) deltaAngle += twoPi;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (deltaAngle &gt; twoPi) deltaAngle -= twoPi;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (deltaAngle &lt; <span class="built_in">Number</span>.EPSILON) &#123;</span><br><span class="line">                <span class="keyword">if</span> (samePoints) &#123;</span><br><span class="line">                    deltaAngle = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    deltaAngle = twoPi;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.aClockwise === <span class="literal">true</span> &amp;&amp; !samePoints) &#123;</span><br><span class="line">                <span class="keyword">if</span> (deltaAngle === twoPi) &#123;</span><br><span class="line">                    deltaAngle = -twoPi;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    deltaAngle = deltaAngle - twoPi;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> angle = <span class="built_in">this</span>.aStartAngle + t * deltaAngle;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="built_in">this</span>.aX + <span class="built_in">this</span>.xRadius * <span class="built_in">Math</span>.cos(angle);</span><br><span class="line">            <span class="keyword">let</span> y = <span class="built_in">this</span>.aY + <span class="built_in">this</span>.yRadius * <span class="built_in">Math</span>.sin(angle);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.aRotation !== <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> cos = <span class="built_in">Math</span>.cos(<span class="built_in">this</span>.aRotation);</span><br><span class="line">                <span class="keyword">const</span> sin = <span class="built_in">Math</span>.sin(<span class="built_in">this</span>.aRotation);</span><br><span class="line">                <span class="keyword">const</span> tx = x - <span class="built_in">this</span>.aX;</span><br><span class="line">                <span class="keyword">const</span> ty = y - <span class="built_in">this</span>.aY; <span class="comment">// Rotate the point about the center of the ellipse.</span></span><br><span class="line"></span><br><span class="line">                x = tx * cos - ty * sin + <span class="built_in">this</span>.aX;</span><br><span class="line">                y = tx * sin + ty * cos + <span class="built_in">this</span>.aY;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> point.set(x, y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.aX = source.aX;</span><br><span class="line">            <span class="built_in">this</span>.aY = source.aY;</span><br><span class="line">            <span class="built_in">this</span>.xRadius = source.xRadius;</span><br><span class="line">            <span class="built_in">this</span>.yRadius = source.yRadius;</span><br><span class="line">            <span class="built_in">this</span>.aStartAngle = source.aStartAngle;</span><br><span class="line">            <span class="built_in">this</span>.aEndAngle = source.aEndAngle;</span><br><span class="line">            <span class="built_in">this</span>.aClockwise = source.aClockwise;</span><br><span class="line">            <span class="built_in">this</span>.aRotation = source.aRotation;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON();</span><br><span class="line">            data.aX = <span class="built_in">this</span>.aX;</span><br><span class="line">            data.aY = <span class="built_in">this</span>.aY;</span><br><span class="line">            data.xRadius = <span class="built_in">this</span>.xRadius;</span><br><span class="line">            data.yRadius = <span class="built_in">this</span>.yRadius;</span><br><span class="line">            data.aStartAngle = <span class="built_in">this</span>.aStartAngle;</span><br><span class="line">            data.aEndAngle = <span class="built_in">this</span>.aEndAngle;</span><br><span class="line">            data.aClockwise = <span class="built_in">this</span>.aClockwise;</span><br><span class="line">            data.aRotation = <span class="built_in">this</span>.aRotation;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromJSON</span>(<span class="params">json</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.fromJSON(json);</span><br><span class="line">            <span class="built_in">this</span>.aX = json.aX;</span><br><span class="line">            <span class="built_in">this</span>.aY = json.aY;</span><br><span class="line">            <span class="built_in">this</span>.xRadius = json.xRadius;</span><br><span class="line">            <span class="built_in">this</span>.yRadius = json.yRadius;</span><br><span class="line">            <span class="built_in">this</span>.aStartAngle = json.aStartAngle;</span><br><span class="line">            <span class="built_in">this</span>.aEndAngle = json.aEndAngle;</span><br><span class="line">            <span class="built_in">this</span>.aClockwise = json.aClockwise;</span><br><span class="line">            <span class="built_in">this</span>.aRotation = json.aRotation;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EllipseCurve.prototype.isEllipseCurve = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ArcCurve</span> <span class="keyword">extends</span> <span class="title">EllipseCurve</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;ArcCurve&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArcCurve.prototype.isArcCurve = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Centripetal CatmullRom Curve - which is useful for avoiding</span></span><br><span class="line"><span class="comment">     * cusps and self-intersections in non-uniform catmull rom curves.</span></span><br><span class="line"><span class="comment">     * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * curve.type accepts centripetal(default), chordal and catmullrom</span></span><br><span class="line"><span class="comment">     * curve.tension is used for catmullrom which defaults to 0.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	Based on an optimized c++ solution in</span></span><br><span class="line"><span class="comment">	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/</span></span><br><span class="line"><span class="comment">	 - http://ideone.com/NoEbVM</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	This CubicPoly class could be used for reusing some variables and calculations,</span></span><br><span class="line"><span class="comment">	but for three.js curve use, it could be possible inlined and flatten into a single function call</span></span><br><span class="line"><span class="comment">	which can be placed in CurveUtils.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">CubicPoly</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> c0 = <span class="number">0</span>,</span><br><span class="line">            c1 = <span class="number">0</span>,</span><br><span class="line">            c2 = <span class="number">0</span>,</span><br><span class="line">            c3 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Compute coefficients for a cubic polynomial</span></span><br><span class="line"><span class="comment">		 *	 p(s) = c0 + c1*s + c2*s^2 + c3*s^3</span></span><br><span class="line"><span class="comment">		 * such that</span></span><br><span class="line"><span class="comment">		 *	 p(0) = x0, p(1) = x1</span></span><br><span class="line"><span class="comment">		 *	and</span></span><br><span class="line"><span class="comment">		 *	 p&#x27;(0) = t0, p&#x27;(1) = t1.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">x0, x1, t0, t1</span>) </span>&#123;</span><br><span class="line">            c0 = x0;</span><br><span class="line">            c1 = t0;</span><br><span class="line">            c2 = -<span class="number">3</span> * x0 + <span class="number">3</span> * x1 - <span class="number">2</span> * t0 - t1;</span><br><span class="line">            c3 = <span class="number">2</span> * x0 - <span class="number">2</span> * x1 + t0 + t1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">initCatmullRom</span>: <span class="function"><span class="keyword">function</span> (<span class="params">x0, x1, x2, x3, tension</span>) </span>&#123;</span><br><span class="line">                init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">initNonuniformCatmullRom</span>: <span class="function"><span class="keyword">function</span> (<span class="params">x0, x1, x2, x3, dt0, dt1, dt2</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// compute tangents when parameterized in [t1,t2]</span></span><br><span class="line">                <span class="keyword">let</span> t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;</span><br><span class="line">                <span class="keyword">let</span> t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2; <span class="comment">// rescale tangents for parametrization in [0,1]</span></span><br><span class="line"></span><br><span class="line">                t1 *= dt1;</span><br><span class="line">                t2 *= dt1;</span><br><span class="line">                init(x1, x2, t1, t2);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">calc</span>: <span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> t2 = t * t;</span><br><span class="line">                <span class="keyword">const</span> t3 = t2 * t;</span><br><span class="line">                <span class="keyword">return</span> c0 + c1 * t + c2 * t2 + c3 * t3;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tmp = <span class="keyword">new</span> Vector3();</span><br><span class="line">    <span class="keyword">const</span> px = <span class="keyword">new</span> CubicPoly(),</span><br><span class="line">        py = <span class="keyword">new</span> CubicPoly(),</span><br><span class="line">        pz = <span class="keyword">new</span> CubicPoly();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CatmullRomCurve3</span> <span class="keyword">extends</span> <span class="title">Curve</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">points = [], closed = <span class="literal">false</span>, curveType = <span class="string">&#x27;centripetal&#x27;</span>, tension = <span class="number">0.5</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;CatmullRomCurve3&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.points = points;</span><br><span class="line">            <span class="built_in">this</span>.closed = closed;</span><br><span class="line">            <span class="built_in">this</span>.curveType = curveType;</span><br><span class="line">            <span class="built_in">this</span>.tension = tension;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getPoint</span>(<span class="params">t, optionalTarget = <span class="keyword">new</span> Vector3()</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> point = optionalTarget;</span><br><span class="line">            <span class="keyword">const</span> points = <span class="built_in">this</span>.points;</span><br><span class="line">            <span class="keyword">const</span> l = points.length;</span><br><span class="line">            <span class="keyword">const</span> p = (l - (<span class="built_in">this</span>.closed ? <span class="number">0</span> : <span class="number">1</span>)) * t;</span><br><span class="line">            <span class="keyword">let</span> intPoint = <span class="built_in">Math</span>.floor(p);</span><br><span class="line">            <span class="keyword">let</span> weight = p - intPoint;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.closed) &#123;</span><br><span class="line">                intPoint += intPoint &gt; <span class="number">0</span> ? <span class="number">0</span> : (<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.abs(intPoint) / l) + <span class="number">1</span>) * l;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (weight === <span class="number">0</span> &amp;&amp; intPoint === l - <span class="number">1</span>) &#123;</span><br><span class="line">                intPoint = l - <span class="number">2</span>;</span><br><span class="line">                weight = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> p0, p3; <span class="comment">// 4 points (p1 &amp; p2 defined below)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.closed || intPoint &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                p0 = points[(intPoint - <span class="number">1</span>) % l];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// extrapolate first point</span></span><br><span class="line">                tmp.subVectors(points[<span class="number">0</span>], points[<span class="number">1</span>]).add(points[<span class="number">0</span>]);</span><br><span class="line">                p0 = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> p1 = points[intPoint % l];</span><br><span class="line">            <span class="keyword">const</span> p2 = points[(intPoint + <span class="number">1</span>) % l];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.closed || intPoint + <span class="number">2</span> &lt; l) &#123;</span><br><span class="line">                p3 = points[(intPoint + <span class="number">2</span>) % l];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// extrapolate last point</span></span><br><span class="line">                tmp.subVectors(points[l - <span class="number">1</span>], points[l - <span class="number">2</span>]).add(points[l - <span class="number">1</span>]);</span><br><span class="line">                p3 = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.curveType === <span class="string">&#x27;centripetal&#x27;</span> || <span class="built_in">this</span>.curveType === <span class="string">&#x27;chordal&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// init Centripetal / Chordal Catmull-Rom</span></span><br><span class="line">                <span class="keyword">const</span> pow = <span class="built_in">this</span>.curveType === <span class="string">&#x27;chordal&#x27;</span> ? <span class="number">0.5</span> : <span class="number">0.25</span>;</span><br><span class="line">                <span class="keyword">let</span> dt0 = <span class="built_in">Math</span>.pow(p0.distanceToSquared(p1), pow);</span><br><span class="line">                <span class="keyword">let</span> dt1 = <span class="built_in">Math</span>.pow(p1.distanceToSquared(p2), pow);</span><br><span class="line">                <span class="keyword">let</span> dt2 = <span class="built_in">Math</span>.pow(p2.distanceToSquared(p3), pow); <span class="comment">// safety check for repeated points</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dt1 &lt; <span class="number">1e-4</span>) dt1 = <span class="number">1.0</span>;</span><br><span class="line">                <span class="keyword">if</span> (dt0 &lt; <span class="number">1e-4</span>) dt0 = dt1;</span><br><span class="line">                <span class="keyword">if</span> (dt2 &lt; <span class="number">1e-4</span>) dt2 = dt1;</span><br><span class="line">                px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);</span><br><span class="line">                py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);</span><br><span class="line">                pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.curveType === <span class="string">&#x27;catmullrom&#x27;</span>) &#123;</span><br><span class="line">                px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, <span class="built_in">this</span>.tension);</span><br><span class="line">                py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, <span class="built_in">this</span>.tension);</span><br><span class="line">                pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, <span class="built_in">this</span>.tension);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            point.set(px.calc(weight), py.calc(weight), pz.calc(weight));</span><br><span class="line">            <span class="keyword">return</span> point;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.points = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = source.points.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> point = source.points[i];</span><br><span class="line">                <span class="built_in">this</span>.points.push(point.clone());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.closed = source.closed;</span><br><span class="line">            <span class="built_in">this</span>.curveType = source.curveType;</span><br><span class="line">            <span class="built_in">this</span>.tension = source.tension;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON();</span><br><span class="line">            data.points = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">this</span>.points.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> point = <span class="built_in">this</span>.points[i];</span><br><span class="line">                data.points.push(point.toArray());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            data.closed = <span class="built_in">this</span>.closed;</span><br><span class="line">            data.curveType = <span class="built_in">this</span>.curveType;</span><br><span class="line">            data.tension = <span class="built_in">this</span>.tension;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromJSON</span>(<span class="params">json</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.fromJSON(json);</span><br><span class="line">            <span class="built_in">this</span>.points = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = json.points.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> point = json.points[i];</span><br><span class="line">                <span class="built_in">this</span>.points.push(<span class="keyword">new</span> Vector3().fromArray(point));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.closed = json.closed;</span><br><span class="line">            <span class="built_in">this</span>.curveType = json.curveType;</span><br><span class="line">            <span class="built_in">this</span>.tension = json.tension;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CatmullRomCurve3.prototype.isCatmullRomCurve3 = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bezier Curves formulas obtained from</span></span><br><span class="line"><span class="comment">     * https://en.wikipedia.org/wiki/B%C3%A9zier_curve</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">CatmullRom</span>(<span class="params">t, p0, p1, p2, p3</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> v0 = (p2 - p0) * <span class="number">0.5</span>;</span><br><span class="line">        <span class="keyword">const</span> v1 = (p3 - p1) * <span class="number">0.5</span>;</span><br><span class="line">        <span class="keyword">const</span> t2 = t * t;</span><br><span class="line">        <span class="keyword">const</span> t3 = t * t2;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> * p1 - <span class="number">2</span> * p2 + v0 + v1) * t3 + (-<span class="number">3</span> * p1 + <span class="number">3</span> * p2 - <span class="number">2</span> * v0 - v1) * t2 + v0 * t + p1;</span><br><span class="line">    &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">QuadraticBezierP0</span>(<span class="params">t, p</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> k = <span class="number">1</span> - t;</span><br><span class="line">        <span class="keyword">return</span> k * k * p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">QuadraticBezierP1</span>(<span class="params">t, p</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * (<span class="number">1</span> - t) * t * p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">QuadraticBezierP2</span>(<span class="params">t, p</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t * t * p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">QuadraticBezier</span>(<span class="params">t, p0, p1, p2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);</span><br><span class="line">    &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">CubicBezierP0</span>(<span class="params">t, p</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> k = <span class="number">1</span> - t;</span><br><span class="line">        <span class="keyword">return</span> k * k * k * p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">CubicBezierP1</span>(<span class="params">t, p</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> k = <span class="number">1</span> - t;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> * k * k * t * p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">CubicBezierP2</span>(<span class="params">t, p</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> * (<span class="number">1</span> - t) * t * t * p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">CubicBezierP3</span>(<span class="params">t, p</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t * t * t * p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">CubicBezier</span>(<span class="params">t, p0, p1, p2, p3</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CubicBezierCurve</span> <span class="keyword">extends</span> <span class="title">Curve</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">v0 = <span class="keyword">new</span> Vector2(), v1 = <span class="keyword">new</span> Vector2(), v2 = <span class="keyword">new</span> Vector2(), v3 = <span class="keyword">new</span> Vector2()</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;CubicBezierCurve&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.v0 = v0;</span><br><span class="line">            <span class="built_in">this</span>.v1 = v1;</span><br><span class="line">            <span class="built_in">this</span>.v2 = v2;</span><br><span class="line">            <span class="built_in">this</span>.v3 = v3;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getPoint</span>(<span class="params">t, optionalTarget = <span class="keyword">new</span> Vector2()</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> point = optionalTarget;</span><br><span class="line">            <span class="keyword">const</span> v0 = <span class="built_in">this</span>.v0,</span><br><span class="line">                v1 = <span class="built_in">this</span>.v1,</span><br><span class="line">                v2 = <span class="built_in">this</span>.v2,</span><br><span class="line">                v3 = <span class="built_in">this</span>.v3;</span><br><span class="line">            point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));</span><br><span class="line">            <span class="keyword">return</span> point;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.v0.copy(source.v0);</span><br><span class="line">            <span class="built_in">this</span>.v1.copy(source.v1);</span><br><span class="line">            <span class="built_in">this</span>.v2.copy(source.v2);</span><br><span class="line">            <span class="built_in">this</span>.v3.copy(source.v3);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON();</span><br><span class="line">            data.v0 = <span class="built_in">this</span>.v0.toArray();</span><br><span class="line">            data.v1 = <span class="built_in">this</span>.v1.toArray();</span><br><span class="line">            data.v2 = <span class="built_in">this</span>.v2.toArray();</span><br><span class="line">            data.v3 = <span class="built_in">this</span>.v3.toArray();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromJSON</span>(<span class="params">json</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.fromJSON(json);</span><br><span class="line">            <span class="built_in">this</span>.v0.fromArray(json.v0);</span><br><span class="line">            <span class="built_in">this</span>.v1.fromArray(json.v1);</span><br><span class="line">            <span class="built_in">this</span>.v2.fromArray(json.v2);</span><br><span class="line">            <span class="built_in">this</span>.v3.fromArray(json.v3);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CubicBezierCurve.prototype.isCubicBezierCurve = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CubicBezierCurve3</span> <span class="keyword">extends</span> <span class="title">Curve</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">v0 = <span class="keyword">new</span> Vector3(), v1 = <span class="keyword">new</span> Vector3(), v2 = <span class="keyword">new</span> Vector3(), v3 = <span class="keyword">new</span> Vector3()</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;CubicBezierCurve3&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.v0 = v0;</span><br><span class="line">            <span class="built_in">this</span>.v1 = v1;</span><br><span class="line">            <span class="built_in">this</span>.v2 = v2;</span><br><span class="line">            <span class="built_in">this</span>.v3 = v3;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getPoint</span>(<span class="params">t, optionalTarget = <span class="keyword">new</span> Vector3()</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> point = optionalTarget;</span><br><span class="line">            <span class="keyword">const</span> v0 = <span class="built_in">this</span>.v0,</span><br><span class="line">                v1 = <span class="built_in">this</span>.v1,</span><br><span class="line">                v2 = <span class="built_in">this</span>.v2,</span><br><span class="line">                v3 = <span class="built_in">this</span>.v3;</span><br><span class="line">            point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));</span><br><span class="line">            <span class="keyword">return</span> point;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.v0.copy(source.v0);</span><br><span class="line">            <span class="built_in">this</span>.v1.copy(source.v1);</span><br><span class="line">            <span class="built_in">this</span>.v2.copy(source.v2);</span><br><span class="line">            <span class="built_in">this</span>.v3.copy(source.v3);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON();</span><br><span class="line">            data.v0 = <span class="built_in">this</span>.v0.toArray();</span><br><span class="line">            data.v1 = <span class="built_in">this</span>.v1.toArray();</span><br><span class="line">            data.v2 = <span class="built_in">this</span>.v2.toArray();</span><br><span class="line">            data.v3 = <span class="built_in">this</span>.v3.toArray();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromJSON</span>(<span class="params">json</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.fromJSON(json);</span><br><span class="line">            <span class="built_in">this</span>.v0.fromArray(json.v0);</span><br><span class="line">            <span class="built_in">this</span>.v1.fromArray(json.v1);</span><br><span class="line">            <span class="built_in">this</span>.v2.fromArray(json.v2);</span><br><span class="line">            <span class="built_in">this</span>.v3.fromArray(json.v3);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CubicBezierCurve3.prototype.isCubicBezierCurve3 = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LineCurve</span> <span class="keyword">extends</span> <span class="title">Curve</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">v1 = <span class="keyword">new</span> Vector2(), v2 = <span class="keyword">new</span> Vector2()</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;LineCurve&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.v1 = v1;</span><br><span class="line">            <span class="built_in">this</span>.v2 = v2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getPoint</span>(<span class="params">t, optionalTarget = <span class="keyword">new</span> Vector2()</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> point = optionalTarget;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t === <span class="number">1</span>) &#123;</span><br><span class="line">                point.copy(<span class="built_in">this</span>.v2);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                point.copy(<span class="built_in">this</span>.v2).sub(<span class="built_in">this</span>.v1);</span><br><span class="line">                point.multiplyScalar(t).add(<span class="built_in">this</span>.v1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> point;</span><br><span class="line">        &#125; <span class="comment">// Line curve is linear, so we can overwrite default getPointAt</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getPointAt</span>(<span class="params">u, optionalTarget</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.getPoint(u, optionalTarget);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getTangent</span>(<span class="params">t, optionalTarget</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> tangent = optionalTarget || <span class="keyword">new</span> Vector2();</span><br><span class="line">            tangent.copy(<span class="built_in">this</span>.v2).sub(<span class="built_in">this</span>.v1).normalize();</span><br><span class="line">            <span class="keyword">return</span> tangent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.v1.copy(source.v1);</span><br><span class="line">            <span class="built_in">this</span>.v2.copy(source.v2);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON();</span><br><span class="line">            data.v1 = <span class="built_in">this</span>.v1.toArray();</span><br><span class="line">            data.v2 = <span class="built_in">this</span>.v2.toArray();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromJSON</span>(<span class="params">json</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.fromJSON(json);</span><br><span class="line">            <span class="built_in">this</span>.v1.fromArray(json.v1);</span><br><span class="line">            <span class="built_in">this</span>.v2.fromArray(json.v2);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LineCurve.prototype.isLineCurve = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LineCurve3</span> <span class="keyword">extends</span> <span class="title">Curve</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">v1 = <span class="keyword">new</span> Vector3(), v2 = <span class="keyword">new</span> Vector3()</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;LineCurve3&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.isLineCurve3 = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.v1 = v1;</span><br><span class="line">            <span class="built_in">this</span>.v2 = v2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getPoint</span>(<span class="params">t, optionalTarget = <span class="keyword">new</span> Vector3()</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> point = optionalTarget;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t === <span class="number">1</span>) &#123;</span><br><span class="line">                point.copy(<span class="built_in">this</span>.v2);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                point.copy(<span class="built_in">this</span>.v2).sub(<span class="built_in">this</span>.v1);</span><br><span class="line">                point.multiplyScalar(t).add(<span class="built_in">this</span>.v1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> point;</span><br><span class="line">        &#125; <span class="comment">// Line curve is linear, so we can overwrite default getPointAt</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getPointAt</span>(<span class="params">u, optionalTarget</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.getPoint(u, optionalTarget);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.v1.copy(source.v1);</span><br><span class="line">            <span class="built_in">this</span>.v2.copy(source.v2);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON();</span><br><span class="line">            data.v1 = <span class="built_in">this</span>.v1.toArray();</span><br><span class="line">            data.v2 = <span class="built_in">this</span>.v2.toArray();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromJSON</span>(<span class="params">json</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.fromJSON(json);</span><br><span class="line">            <span class="built_in">this</span>.v1.fromArray(json.v1);</span><br><span class="line">            <span class="built_in">this</span>.v2.fromArray(json.v2);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">QuadraticBezierCurve</span> <span class="keyword">extends</span> <span class="title">Curve</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">v0 = <span class="keyword">new</span> Vector2(), v1 = <span class="keyword">new</span> Vector2(), v2 = <span class="keyword">new</span> Vector2()</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;QuadraticBezierCurve&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.v0 = v0;</span><br><span class="line">            <span class="built_in">this</span>.v1 = v1;</span><br><span class="line">            <span class="built_in">this</span>.v2 = v2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getPoint</span>(<span class="params">t, optionalTarget = <span class="keyword">new</span> Vector2()</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> point = optionalTarget;</span><br><span class="line">            <span class="keyword">const</span> v0 = <span class="built_in">this</span>.v0,</span><br><span class="line">                v1 = <span class="built_in">this</span>.v1,</span><br><span class="line">                v2 = <span class="built_in">this</span>.v2;</span><br><span class="line">            point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));</span><br><span class="line">            <span class="keyword">return</span> point;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.v0.copy(source.v0);</span><br><span class="line">            <span class="built_in">this</span>.v1.copy(source.v1);</span><br><span class="line">            <span class="built_in">this</span>.v2.copy(source.v2);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON();</span><br><span class="line">            data.v0 = <span class="built_in">this</span>.v0.toArray();</span><br><span class="line">            data.v1 = <span class="built_in">this</span>.v1.toArray();</span><br><span class="line">            data.v2 = <span class="built_in">this</span>.v2.toArray();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromJSON</span>(<span class="params">json</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.fromJSON(json);</span><br><span class="line">            <span class="built_in">this</span>.v0.fromArray(json.v0);</span><br><span class="line">            <span class="built_in">this</span>.v1.fromArray(json.v1);</span><br><span class="line">            <span class="built_in">this</span>.v2.fromArray(json.v2);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QuadraticBezierCurve.prototype.isQuadraticBezierCurve = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">QuadraticBezierCurve3</span> <span class="keyword">extends</span> <span class="title">Curve</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">v0 = <span class="keyword">new</span> Vector3(), v1 = <span class="keyword">new</span> Vector3(), v2 = <span class="keyword">new</span> Vector3()</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;QuadraticBezierCurve3&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.v0 = v0;</span><br><span class="line">            <span class="built_in">this</span>.v1 = v1;</span><br><span class="line">            <span class="built_in">this</span>.v2 = v2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getPoint</span>(<span class="params">t, optionalTarget = <span class="keyword">new</span> Vector3()</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> point = optionalTarget;</span><br><span class="line">            <span class="keyword">const</span> v0 = <span class="built_in">this</span>.v0,</span><br><span class="line">                v1 = <span class="built_in">this</span>.v1,</span><br><span class="line">                v2 = <span class="built_in">this</span>.v2;</span><br><span class="line">            point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));</span><br><span class="line">            <span class="keyword">return</span> point;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.v0.copy(source.v0);</span><br><span class="line">            <span class="built_in">this</span>.v1.copy(source.v1);</span><br><span class="line">            <span class="built_in">this</span>.v2.copy(source.v2);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON();</span><br><span class="line">            data.v0 = <span class="built_in">this</span>.v0.toArray();</span><br><span class="line">            data.v1 = <span class="built_in">this</span>.v1.toArray();</span><br><span class="line">            data.v2 = <span class="built_in">this</span>.v2.toArray();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromJSON</span>(<span class="params">json</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.fromJSON(json);</span><br><span class="line">            <span class="built_in">this</span>.v0.fromArray(json.v0);</span><br><span class="line">            <span class="built_in">this</span>.v1.fromArray(json.v1);</span><br><span class="line">            <span class="built_in">this</span>.v2.fromArray(json.v2);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SplineCurve</span> <span class="keyword">extends</span> <span class="title">Curve</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">points = []</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;SplineCurve&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.points = points;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getPoint</span>(<span class="params">t, optionalTarget = <span class="keyword">new</span> Vector2()</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> point = optionalTarget;</span><br><span class="line">            <span class="keyword">const</span> points = <span class="built_in">this</span>.points;</span><br><span class="line">            <span class="keyword">const</span> p = (points.length - <span class="number">1</span>) * t;</span><br><span class="line">            <span class="keyword">const</span> intPoint = <span class="built_in">Math</span>.floor(p);</span><br><span class="line">            <span class="keyword">const</span> weight = p - intPoint;</span><br><span class="line">            <span class="keyword">const</span> p0 = points[intPoint === <span class="number">0</span> ? intPoint : intPoint - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">const</span> p1 = points[intPoint];</span><br><span class="line">            <span class="keyword">const</span> p2 = points[intPoint &gt; points.length - <span class="number">2</span> ? points.length - <span class="number">1</span> : intPoint + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">const</span> p3 = points[intPoint &gt; points.length - <span class="number">3</span> ? points.length - <span class="number">1</span> : intPoint + <span class="number">2</span>];</span><br><span class="line">            point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));</span><br><span class="line">            <span class="keyword">return</span> point;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.points = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = source.points.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> point = source.points[i];</span><br><span class="line">                <span class="built_in">this</span>.points.push(point.clone());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON();</span><br><span class="line">            data.points = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">this</span>.points.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> point = <span class="built_in">this</span>.points[i];</span><br><span class="line">                data.points.push(point.toArray());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromJSON</span>(<span class="params">json</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.fromJSON(json);</span><br><span class="line">            <span class="built_in">this</span>.points = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = json.points.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> point = json.points[i];</span><br><span class="line">                <span class="built_in">this</span>.points.push(<span class="keyword">new</span> Vector2().fromArray(point));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SplineCurve.prototype.isSplineCurve = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> Curves = <span class="comment">/*#__PURE__*/</span><span class="built_in">Object</span>.freeze(&#123;</span><br><span class="line">        <span class="attr">__proto__</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">ArcCurve</span>: ArcCurve,</span><br><span class="line">        <span class="attr">CatmullRomCurve3</span>: CatmullRomCurve3,</span><br><span class="line">        <span class="attr">CubicBezierCurve</span>: CubicBezierCurve,</span><br><span class="line">        <span class="attr">CubicBezierCurve3</span>: CubicBezierCurve3,</span><br><span class="line">        <span class="attr">EllipseCurve</span>: EllipseCurve,</span><br><span class="line">        <span class="attr">LineCurve</span>: LineCurve,</span><br><span class="line">        <span class="attr">LineCurve3</span>: LineCurve3,</span><br><span class="line">        <span class="attr">QuadraticBezierCurve</span>: QuadraticBezierCurve,</span><br><span class="line">        <span class="attr">QuadraticBezierCurve3</span>: QuadraticBezierCurve3,</span><br><span class="line">        <span class="attr">SplineCurve</span>: SplineCurve</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">     *	Curved Path - a curve path is simply a array of connected</span></span><br><span class="line"><span class="comment">     *	curves, but retains the api of a curve</span></span><br><span class="line"><span class="comment">     **************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CurvePath</span> <span class="keyword">extends</span> <span class="title">Curve</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;CurvePath&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.curves = [];</span><br><span class="line">            <span class="built_in">this</span>.autoClose = <span class="literal">false</span>; <span class="comment">// Automatically closes the path</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params">curve</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.curves.push(curve);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">closePath</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// Add a line curve if start and end of lines are not connected</span></span><br><span class="line">            <span class="keyword">const</span> startPoint = <span class="built_in">this</span>.curves[<span class="number">0</span>].getPoint(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">const</span> endPoint = <span class="built_in">this</span>.curves[<span class="built_in">this</span>.curves.length - <span class="number">1</span>].getPoint(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!startPoint.equals(endPoint)) &#123;</span><br><span class="line">                <span class="built_in">this</span>.curves.push(<span class="keyword">new</span> LineCurve(endPoint, startPoint));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// To get accurate point with reference to</span></span><br><span class="line">        <span class="comment">// entire path distance at time t,</span></span><br><span class="line">        <span class="comment">// following has to be done:</span></span><br><span class="line">        <span class="comment">// 1. Length of each sub path have to be known</span></span><br><span class="line">        <span class="comment">// 2. Locate and identify type of curve</span></span><br><span class="line">        <span class="comment">// 3. Get t for the curve</span></span><br><span class="line">        <span class="comment">// 4. Return curve.getPointAt(t&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getPoint</span>(<span class="params">t, optionalTarget</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> d = t * <span class="built_in">this</span>.getLength();</span><br><span class="line">            <span class="keyword">const</span> curveLengths = <span class="built_in">this</span>.getCurveLengths();</span><br><span class="line">            <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// To think about boundaries points.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (i &lt; curveLengths.length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curveLengths[i] &gt;= d) &#123;</span><br><span class="line">                    <span class="keyword">const</span> diff = curveLengths[i] - d;</span><br><span class="line">                    <span class="keyword">const</span> curve = <span class="built_in">this</span>.curves[i];</span><br><span class="line">                    <span class="keyword">const</span> segmentLength = curve.getLength();</span><br><span class="line">                    <span class="keyword">const</span> u = segmentLength === <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span> - diff / segmentLength;</span><br><span class="line">                    <span class="keyword">return</span> curve.getPointAt(u, optionalTarget);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// loop where sum != 0, sum &gt; d , sum+1 &lt;d</span></span><br><span class="line">        &#125; <span class="comment">// We cannot use the default THREE.Curve getPoint() with getLength() because in</span></span><br><span class="line">        <span class="comment">// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath</span></span><br><span class="line">        <span class="comment">// getPoint() depends on getLength</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getLength</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> lens = <span class="built_in">this</span>.getCurveLengths();</span><br><span class="line">            <span class="keyword">return</span> lens[lens.length - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="comment">// cacheLengths must be recalculated.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">updateArcLengths</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.cacheLengths = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.getCurveLengths();</span><br><span class="line">        &#125; <span class="comment">// Compute lengths and cache them</span></span><br><span class="line">        <span class="comment">// We cannot overwrite getLengths() because UtoT mapping uses it.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getCurveLengths</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// We use cache values if curves and cache array are same length</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.cacheLengths &amp;&amp; <span class="built_in">this</span>.cacheLengths.length === <span class="built_in">this</span>.curves.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.cacheLengths;</span><br><span class="line">            &#125; <span class="comment">// Get length of sub-curve</span></span><br><span class="line">            <span class="comment">// Push sums into cached array</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> lengths = [];</span><br><span class="line">            <span class="keyword">let</span> sums = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">this</span>.curves.length; i &lt; l; i++) &#123;</span><br><span class="line">                sums += <span class="built_in">this</span>.curves[i].getLength();</span><br><span class="line">                lengths.push(sums);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.cacheLengths = lengths;</span><br><span class="line">            <span class="keyword">return</span> lengths;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getSpacedPoints</span>(<span class="params">divisions = <span class="number">40</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> points = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= divisions; i++) &#123;</span><br><span class="line">                points.push(<span class="built_in">this</span>.getPoint(i / divisions));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.autoClose) &#123;</span><br><span class="line">                points.push(points[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> points;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getPoints</span>(<span class="params">divisions = <span class="number">12</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> points = [];</span><br><span class="line">            <span class="keyword">let</span> last;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, curves = <span class="built_in">this</span>.curves; i &lt; curves.length; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> curve = curves[i];</span><br><span class="line">                <span class="keyword">const</span> resolution = curve.isEllipseCurve ? divisions * <span class="number">2</span> : curve.isLineCurve || curve.isLineCurve3 ? <span class="number">1</span> : curve.isSplineCurve ? divisions * curve.points.length : divisions;</span><br><span class="line">                <span class="keyword">const</span> pts = curve.getPoints(resolution);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; pts.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> point = pts[j];</span><br><span class="line">                    <span class="keyword">if</span> (last &amp;&amp; last.equals(point)) <span class="keyword">continue</span>; <span class="comment">// ensures no consecutive points are duplicates</span></span><br><span class="line"></span><br><span class="line">                    points.push(point);</span><br><span class="line">                    last = point;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.autoClose &amp;&amp; points.length &gt; <span class="number">1</span> &amp;&amp; !points[points.length - <span class="number">1</span>].equals(points[<span class="number">0</span>])) &#123;</span><br><span class="line">                points.push(points[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> points;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.curves = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = source.curves.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> curve = source.curves[i];</span><br><span class="line">                <span class="built_in">this</span>.curves.push(curve.clone());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.autoClose = source.autoClose;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON();</span><br><span class="line">            data.autoClose = <span class="built_in">this</span>.autoClose;</span><br><span class="line">            data.curves = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">this</span>.curves.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> curve = <span class="built_in">this</span>.curves[i];</span><br><span class="line">                data.curves.push(curve.toJSON());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromJSON</span>(<span class="params">json</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.fromJSON(json);</span><br><span class="line">            <span class="built_in">this</span>.autoClose = json.autoClose;</span><br><span class="line">            <span class="built_in">this</span>.curves = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = json.curves.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> curve = json.curves[i];</span><br><span class="line">                <span class="built_in">this</span>.curves.push(<span class="keyword">new</span> Curves[curve.type]().fromJSON(curve));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Path</span> <span class="keyword">extends</span> <span class="title">CurvePath</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">points</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;Path&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.currentPoint = <span class="keyword">new</span> Vector2();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (points) &#123;</span><br><span class="line">                <span class="built_in">this</span>.setFromPoints(points);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromPoints</span>(<span class="params">points</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.moveTo(points[<span class="number">0</span>].x, points[<span class="number">0</span>].y);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, l = points.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.lineTo(points[i].x, points[i].y);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">moveTo</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.currentPoint.set(x, y); <span class="comment">// TODO consider referencing vectors instead of copying?</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">lineTo</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> curve = <span class="keyword">new</span> LineCurve(<span class="built_in">this</span>.currentPoint.clone(), <span class="keyword">new</span> Vector2(x, y));</span><br><span class="line">            <span class="built_in">this</span>.curves.push(curve);</span><br><span class="line">            <span class="built_in">this</span>.currentPoint.set(x, y);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">quadraticCurveTo</span>(<span class="params">aCPx, aCPy, aX, aY</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> curve = <span class="keyword">new</span> QuadraticBezierCurve(<span class="built_in">this</span>.currentPoint.clone(), <span class="keyword">new</span> Vector2(aCPx, aCPy), <span class="keyword">new</span> Vector2(aX, aY));</span><br><span class="line">            <span class="built_in">this</span>.curves.push(curve);</span><br><span class="line">            <span class="built_in">this</span>.currentPoint.set(aX, aY);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">bezierCurveTo</span>(<span class="params">aCP1x, aCP1y, aCP2x, aCP2y, aX, aY</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> curve = <span class="keyword">new</span> CubicBezierCurve(<span class="built_in">this</span>.currentPoint.clone(), <span class="keyword">new</span> Vector2(aCP1x, aCP1y), <span class="keyword">new</span> Vector2(aCP2x, aCP2y), <span class="keyword">new</span> Vector2(aX, aY));</span><br><span class="line">            <span class="built_in">this</span>.curves.push(curve);</span><br><span class="line">            <span class="built_in">this</span>.currentPoint.set(aX, aY);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">splineThru</span>(<span class="params">pts</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="comment">/*Array of Vector*/</span></span></span></span><br><span class="line"><span class="params"><span class="function">        </span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> npts = [<span class="built_in">this</span>.currentPoint.clone()].concat(pts);</span><br><span class="line">            <span class="keyword">const</span> curve = <span class="keyword">new</span> SplineCurve(npts);</span><br><span class="line">            <span class="built_in">this</span>.curves.push(curve);</span><br><span class="line">            <span class="built_in">this</span>.currentPoint.copy(pts[pts.length - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">arc</span>(<span class="params">aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> x0 = <span class="built_in">this</span>.currentPoint.x;</span><br><span class="line">            <span class="keyword">const</span> y0 = <span class="built_in">this</span>.currentPoint.y;</span><br><span class="line">            <span class="built_in">this</span>.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">absarc</span>(<span class="params">aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">ellipse</span>(<span class="params">aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> x0 = <span class="built_in">this</span>.currentPoint.x;</span><br><span class="line">            <span class="keyword">const</span> y0 = <span class="built_in">this</span>.currentPoint.y;</span><br><span class="line">            <span class="built_in">this</span>.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">absellipse</span>(<span class="params">aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> curve = <span class="keyword">new</span> EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.curves.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// if a previous curve is present, attempt to join</span></span><br><span class="line">                <span class="keyword">const</span> firstPoint = curve.getPoint(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!firstPoint.equals(<span class="built_in">this</span>.currentPoint)) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.lineTo(firstPoint.x, firstPoint.y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.curves.push(curve);</span><br><span class="line">            <span class="keyword">const</span> lastPoint = curve.getPoint(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.currentPoint.copy(lastPoint);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.currentPoint.copy(source.currentPoint);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON();</span><br><span class="line">            data.currentPoint = <span class="built_in">this</span>.currentPoint.toArray();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromJSON</span>(<span class="params">json</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.fromJSON(json);</span><br><span class="line">            <span class="built_in">this</span>.currentPoint.fromArray(json.currentPoint);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LatheGeometry</span> <span class="keyword">extends</span> <span class="title">BufferGeometry</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">points = [<span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">0.5</span>), <span class="keyword">new</span> Vector2(<span class="number">0.5</span>, <span class="number">0</span>), <span class="keyword">new</span> Vector2(<span class="number">0</span>, -<span class="number">0.5</span>)], segments = <span class="number">12</span>, phiStart = <span class="number">0</span>, phiLength = <span class="built_in">Math</span>.PI * <span class="number">2</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;LatheGeometry&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.parameters = &#123;</span><br><span class="line">                <span class="attr">points</span>: points,</span><br><span class="line">                <span class="attr">segments</span>: segments,</span><br><span class="line">                <span class="attr">phiStart</span>: phiStart,</span><br><span class="line">                <span class="attr">phiLength</span>: phiLength</span><br><span class="line">            &#125;;</span><br><span class="line">            segments = <span class="built_in">Math</span>.floor(segments); <span class="comment">// clamp phiLength so it&#x27;s in range of [ 0, 2PI ]</span></span><br><span class="line"></span><br><span class="line">            phiLength = clamp(phiLength, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>); <span class="comment">// buffers</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> indices = [];</span><br><span class="line">            <span class="keyword">const</span> vertices = [];</span><br><span class="line">            <span class="keyword">const</span> uvs = [];</span><br><span class="line">            <span class="keyword">const</span> initNormals = [];</span><br><span class="line">            <span class="keyword">const</span> normals = []; <span class="comment">// helper variables</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> inverseSegments = <span class="number">1.0</span> / segments;</span><br><span class="line">            <span class="keyword">const</span> vertex = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> uv = <span class="keyword">new</span> Vector2();</span><br><span class="line">            <span class="keyword">const</span> normal = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> curNormal = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> prevNormal = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">let</span> dx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> dy = <span class="number">0</span>; <span class="comment">// pre-compute normals for initial &quot;meridian&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= points.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (j) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                        <span class="comment">// special handling for 1st vertex on path</span></span><br><span class="line">                        dx = points[j + <span class="number">1</span>].x - points[j].x;</span><br><span class="line">                        dy = points[j + <span class="number">1</span>].y - points[j].y;</span><br><span class="line">                        normal.x = dy * <span class="number">1.0</span>;</span><br><span class="line">                        normal.y = -dx;</span><br><span class="line">                        normal.z = dy * <span class="number">0.0</span>;</span><br><span class="line">                        prevNormal.copy(normal);</span><br><span class="line">                        normal.normalize();</span><br><span class="line">                        initNormals.push(normal.x, normal.y, normal.z);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> points.length - <span class="number">1</span>:</span><br><span class="line">                        <span class="comment">// special handling for last Vertex on path</span></span><br><span class="line">                        initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="comment">// default handling for all vertices in between</span></span><br><span class="line">                        dx = points[j + <span class="number">1</span>].x - points[j].x;</span><br><span class="line">                        dy = points[j + <span class="number">1</span>].y - points[j].y;</span><br><span class="line">                        normal.x = dy * <span class="number">1.0</span>;</span><br><span class="line">                        normal.y = -dx;</span><br><span class="line">                        normal.z = dy * <span class="number">0.0</span>;</span><br><span class="line">                        curNormal.copy(normal);</span><br><span class="line">                        normal.x += prevNormal.x;</span><br><span class="line">                        normal.y += prevNormal.y;</span><br><span class="line">                        normal.z += prevNormal.z;</span><br><span class="line">                        normal.normalize();</span><br><span class="line">                        initNormals.push(normal.x, normal.y, normal.z);</span><br><span class="line">                        prevNormal.copy(curNormal);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// generate vertices, uvs and normals</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= segments; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> phi = phiStart + i * inverseSegments * phiLength;</span><br><span class="line">                <span class="keyword">const</span> sin = <span class="built_in">Math</span>.sin(phi);</span><br><span class="line">                <span class="keyword">const</span> cos = <span class="built_in">Math</span>.cos(phi);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= points.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    <span class="comment">// vertex</span></span><br><span class="line">                    vertex.x = points[j].x * sin;</span><br><span class="line">                    vertex.y = points[j].y;</span><br><span class="line">                    vertex.z = points[j].x * cos;</span><br><span class="line">                    vertices.push(vertex.x, vertex.y, vertex.z); <span class="comment">// uv</span></span><br><span class="line"></span><br><span class="line">                    uv.x = i / segments;</span><br><span class="line">                    uv.y = j / (points.length - <span class="number">1</span>);</span><br><span class="line">                    uvs.push(uv.x, uv.y); <span class="comment">// normal</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> x = initNormals[<span class="number">3</span> * j + <span class="number">0</span>] * sin;</span><br><span class="line">                    <span class="keyword">const</span> y = initNormals[<span class="number">3</span> * j + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">const</span> z = initNormals[<span class="number">3</span> * j + <span class="number">0</span>] * cos;</span><br><span class="line">                    normals.push(x, y, z);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// indices</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; segments; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; points.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> base = j + i * points.length;</span><br><span class="line">                    <span class="keyword">const</span> a = base;</span><br><span class="line">                    <span class="keyword">const</span> b = base + points.length;</span><br><span class="line">                    <span class="keyword">const</span> c = base + points.length + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">const</span> d = base + <span class="number">1</span>; <span class="comment">// faces</span></span><br><span class="line"></span><br><span class="line">                    indices.push(a, b, d);</span><br><span class="line">                    indices.push(c, d, b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// build geometry</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setIndex(indices);</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(vertices, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;uv&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(uvs, <span class="number">2</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;normal&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(normals, <span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">fromJSON</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CapsuleGeometry</span> <span class="keyword">extends</span> <span class="title">LatheGeometry</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">radius = <span class="number">1</span>, length = <span class="number">1</span>, capSegments = <span class="number">4</span>, radialSegments = <span class="number">8</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> path = <span class="keyword">new</span> Path();</span><br><span class="line">            path.absarc(<span class="number">0</span>, -length / <span class="number">2</span>, radius, <span class="built_in">Math</span>.PI * <span class="number">1.5</span>, <span class="number">0</span>);</span><br><span class="line">            path.absarc(<span class="number">0</span>, length / <span class="number">2</span>, radius, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">0.5</span>);</span><br><span class="line">            <span class="built_in">super</span>(path.getPoints(capSegments), radialSegments);</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;CapsuleGeometry&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.parameters = &#123;</span><br><span class="line">                <span class="attr">radius</span>: radius,</span><br><span class="line">                <span class="attr">height</span>: length,</span><br><span class="line">                <span class="attr">capSegments</span>: capSegments,</span><br><span class="line">                <span class="attr">radialSegments</span>: radialSegments</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">fromJSON</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CapsuleGeometry(data.radius, data.length, data.capSegments, data.radialSegments);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CircleGeometry</span> <span class="keyword">extends</span> <span class="title">BufferGeometry</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">radius = <span class="number">1</span>, segments = <span class="number">8</span>, thetaStart = <span class="number">0</span>, thetaLength = <span class="built_in">Math</span>.PI * <span class="number">2</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;CircleGeometry&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.parameters = &#123;</span><br><span class="line">                <span class="attr">radius</span>: radius,</span><br><span class="line">                <span class="attr">segments</span>: segments,</span><br><span class="line">                <span class="attr">thetaStart</span>: thetaStart,</span><br><span class="line">                <span class="attr">thetaLength</span>: thetaLength</span><br><span class="line">            &#125;;</span><br><span class="line">            segments = <span class="built_in">Math</span>.max(<span class="number">3</span>, segments); <span class="comment">// buffers</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> indices = [];</span><br><span class="line">            <span class="keyword">const</span> vertices = [];</span><br><span class="line">            <span class="keyword">const</span> normals = [];</span><br><span class="line">            <span class="keyword">const</span> uvs = []; <span class="comment">// helper variables</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> vertex = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> uv = <span class="keyword">new</span> Vector2(); <span class="comment">// center point</span></span><br><span class="line"></span><br><span class="line">            vertices.push(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            normals.push(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            uvs.push(<span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> s = <span class="number">0</span>, i = <span class="number">3</span>; s &lt;= segments; s++, i += <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> segment = thetaStart + s / segments * thetaLength; <span class="comment">// vertex</span></span><br><span class="line"></span><br><span class="line">                vertex.x = radius * <span class="built_in">Math</span>.cos(segment);</span><br><span class="line">                vertex.y = radius * <span class="built_in">Math</span>.sin(segment);</span><br><span class="line">                vertices.push(vertex.x, vertex.y, vertex.z); <span class="comment">// normal</span></span><br><span class="line"></span><br><span class="line">                normals.push(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// uvs</span></span><br><span class="line"></span><br><span class="line">                uv.x = (vertices[i] / radius + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                uv.y = (vertices[i + <span class="number">1</span>] / radius + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                uvs.push(uv.x, uv.y);</span><br><span class="line">            &#125; <span class="comment">// indices</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= segments; i++) &#123;</span><br><span class="line">                indices.push(i, i + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="comment">// build geometry</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setIndex(indices);</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(vertices, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;normal&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(normals, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;uv&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(uvs, <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">fromJSON</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CylinderGeometry</span> <span class="keyword">extends</span> <span class="title">BufferGeometry</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">radiusTop = <span class="number">1</span>, radiusBottom = <span class="number">1</span>, height = <span class="number">1</span>, radialSegments = <span class="number">8</span>, heightSegments = <span class="number">1</span>, openEnded = <span class="literal">false</span>, thetaStart = <span class="number">0</span>, thetaLength = <span class="built_in">Math</span>.PI * <span class="number">2</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;CylinderGeometry&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.parameters = &#123;</span><br><span class="line">                <span class="attr">radiusTop</span>: radiusTop,</span><br><span class="line">                <span class="attr">radiusBottom</span>: radiusBottom,</span><br><span class="line">                <span class="attr">height</span>: height,</span><br><span class="line">                <span class="attr">radialSegments</span>: radialSegments,</span><br><span class="line">                <span class="attr">heightSegments</span>: heightSegments,</span><br><span class="line">                <span class="attr">openEnded</span>: openEnded,</span><br><span class="line">                <span class="attr">thetaStart</span>: thetaStart,</span><br><span class="line">                <span class="attr">thetaLength</span>: thetaLength</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">const</span> scope = <span class="built_in">this</span>;</span><br><span class="line">            radialSegments = <span class="built_in">Math</span>.floor(radialSegments);</span><br><span class="line">            heightSegments = <span class="built_in">Math</span>.floor(heightSegments); <span class="comment">// buffers</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> indices = [];</span><br><span class="line">            <span class="keyword">const</span> vertices = [];</span><br><span class="line">            <span class="keyword">const</span> normals = [];</span><br><span class="line">            <span class="keyword">const</span> uvs = []; <span class="comment">// helper variables</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> indexArray = [];</span><br><span class="line">            <span class="keyword">const</span> halfHeight = height / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">let</span> groupStart = <span class="number">0</span>; <span class="comment">// generate geometry</span></span><br><span class="line"></span><br><span class="line">            generateTorso();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (openEnded === <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (radiusTop &gt; <span class="number">0</span>) generateCap(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (radiusBottom &gt; <span class="number">0</span>) generateCap(<span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="comment">// build geometry</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setIndex(indices);</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(vertices, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;normal&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(normals, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;uv&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(uvs, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">generateTorso</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> normal = <span class="keyword">new</span> Vector3();</span><br><span class="line">                <span class="keyword">const</span> vertex = <span class="keyword">new</span> Vector3();</span><br><span class="line">                <span class="keyword">let</span> groupCount = <span class="number">0</span>; <span class="comment">// this will be used to calculate the normal</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> slope = (radiusBottom - radiusTop) / height; <span class="comment">// generate vertices, normals and uvs</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">0</span>; y &lt;= heightSegments; y++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> indexRow = [];</span><br><span class="line">                    <span class="keyword">const</span> v = y / heightSegments; <span class="comment">// calculate the radius of the current row</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> radius = v * (radiusBottom - radiusTop) + radiusTop;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt;= radialSegments; x++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> u = x / radialSegments;</span><br><span class="line">                        <span class="keyword">const</span> theta = u * thetaLength + thetaStart;</span><br><span class="line">                        <span class="keyword">const</span> sinTheta = <span class="built_in">Math</span>.sin(theta);</span><br><span class="line">                        <span class="keyword">const</span> cosTheta = <span class="built_in">Math</span>.cos(theta); <span class="comment">// vertex</span></span><br><span class="line"></span><br><span class="line">                        vertex.x = radius * sinTheta;</span><br><span class="line">                        vertex.y = -v * height + halfHeight;</span><br><span class="line">                        vertex.z = radius * cosTheta;</span><br><span class="line">                        vertices.push(vertex.x, vertex.y, vertex.z); <span class="comment">// normal</span></span><br><span class="line"></span><br><span class="line">                        normal.set(sinTheta, slope, cosTheta).normalize();</span><br><span class="line">                        normals.push(normal.x, normal.y, normal.z); <span class="comment">// uv</span></span><br><span class="line"></span><br><span class="line">                        uvs.push(u, <span class="number">1</span> - v); <span class="comment">// save index of vertex in respective row</span></span><br><span class="line"></span><br><span class="line">                        indexRow.push(index++);</span><br><span class="line">                    &#125; <span class="comment">// now save vertices of the row in our index array</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    indexArray.push(indexRow);</span><br><span class="line">                &#125; <span class="comment">// generate indices</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; radialSegments; x++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">0</span>; y &lt; heightSegments; y++) &#123;</span><br><span class="line">                        <span class="comment">// we use the index array to access the correct indices</span></span><br><span class="line">                        <span class="keyword">const</span> a = indexArray[y][x];</span><br><span class="line">                        <span class="keyword">const</span> b = indexArray[y + <span class="number">1</span>][x];</span><br><span class="line">                        <span class="keyword">const</span> c = indexArray[y + <span class="number">1</span>][x + <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">const</span> d = indexArray[y][x + <span class="number">1</span>]; <span class="comment">// faces</span></span><br><span class="line"></span><br><span class="line">                        indices.push(a, b, d);</span><br><span class="line">                        indices.push(b, c, d); <span class="comment">// update group counter</span></span><br><span class="line"></span><br><span class="line">                        groupCount += <span class="number">6</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="comment">// add a group to the geometry. this will ensure multi material support</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                scope.addGroup(groupStart, groupCount, <span class="number">0</span>); <span class="comment">// calculate new start value for groups</span></span><br><span class="line"></span><br><span class="line">                groupStart += groupCount;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">generateCap</span>(<span class="params">top</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// save the index of the first center vertex</span></span><br><span class="line">                <span class="keyword">const</span> centerIndexStart = index;</span><br><span class="line">                <span class="keyword">const</span> uv = <span class="keyword">new</span> Vector2();</span><br><span class="line">                <span class="keyword">const</span> vertex = <span class="keyword">new</span> Vector3();</span><br><span class="line">                <span class="keyword">let</span> groupCount = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">const</span> radius = top === <span class="literal">true</span> ? radiusTop : radiusBottom;</span><br><span class="line">                <span class="keyword">const</span> sign = top === <span class="literal">true</span> ? <span class="number">1</span> : -<span class="number">1</span>; <span class="comment">// first we generate the center vertex data of the cap.</span></span><br><span class="line">                <span class="comment">// because the geometry needs one set of uvs per face,</span></span><br><span class="line">                <span class="comment">// we must generate a center vertex per face/segment</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">1</span>; x &lt;= radialSegments; x++) &#123;</span><br><span class="line">                    <span class="comment">// vertex</span></span><br><span class="line">                    vertices.push(<span class="number">0</span>, halfHeight * sign, <span class="number">0</span>); <span class="comment">// normal</span></span><br><span class="line"></span><br><span class="line">                    normals.push(<span class="number">0</span>, sign, <span class="number">0</span>); <span class="comment">// uv</span></span><br><span class="line"></span><br><span class="line">                    uvs.push(<span class="number">0.5</span>, <span class="number">0.5</span>); <span class="comment">// increase index</span></span><br><span class="line"></span><br><span class="line">                    index++;</span><br><span class="line">                &#125; <span class="comment">// save the index of the last center vertex</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> centerIndexEnd = index; <span class="comment">// now we generate the surrounding vertices, normals and uvs</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt;= radialSegments; x++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> u = x / radialSegments;</span><br><span class="line">                    <span class="keyword">const</span> theta = u * thetaLength + thetaStart;</span><br><span class="line">                    <span class="keyword">const</span> cosTheta = <span class="built_in">Math</span>.cos(theta);</span><br><span class="line">                    <span class="keyword">const</span> sinTheta = <span class="built_in">Math</span>.sin(theta); <span class="comment">// vertex</span></span><br><span class="line"></span><br><span class="line">                    vertex.x = radius * sinTheta;</span><br><span class="line">                    vertex.y = halfHeight * sign;</span><br><span class="line">                    vertex.z = radius * cosTheta;</span><br><span class="line">                    vertices.push(vertex.x, vertex.y, vertex.z); <span class="comment">// normal</span></span><br><span class="line"></span><br><span class="line">                    normals.push(<span class="number">0</span>, sign, <span class="number">0</span>); <span class="comment">// uv</span></span><br><span class="line"></span><br><span class="line">                    uv.x = cosTheta * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">                    uv.y = sinTheta * <span class="number">0.5</span> * sign + <span class="number">0.5</span>;</span><br><span class="line">                    uvs.push(uv.x, uv.y); <span class="comment">// increase index</span></span><br><span class="line"></span><br><span class="line">                    index++;</span><br><span class="line">                &#125; <span class="comment">// generate indices</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; radialSegments; x++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> c = centerIndexStart + x;</span><br><span class="line">                    <span class="keyword">const</span> i = centerIndexEnd + x;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (top === <span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="comment">// face top</span></span><br><span class="line">                        indices.push(i, i + <span class="number">1</span>, c);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// face bottom</span></span><br><span class="line">                        indices.push(i + <span class="number">1</span>, i, c);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    groupCount += <span class="number">3</span>;</span><br><span class="line">                &#125; <span class="comment">// add a group to the geometry. this will ensure multi material support</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                scope.addGroup(groupStart, groupCount, top === <span class="literal">true</span> ? <span class="number">1</span> : <span class="number">2</span>); <span class="comment">// calculate new start value for groups</span></span><br><span class="line"></span><br><span class="line">                groupStart += groupCount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">fromJSON</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ConeGeometry</span> <span class="keyword">extends</span> <span class="title">CylinderGeometry</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">radius = <span class="number">1</span>, height = <span class="number">1</span>, radialSegments = <span class="number">8</span>, heightSegments = <span class="number">1</span>, openEnded = <span class="literal">false</span>, thetaStart = <span class="number">0</span>, thetaLength = <span class="built_in">Math</span>.PI * <span class="number">2</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="number">0</span>, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;ConeGeometry&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.parameters = &#123;</span><br><span class="line">                <span class="attr">radius</span>: radius,</span><br><span class="line">                <span class="attr">height</span>: height,</span><br><span class="line">                <span class="attr">radialSegments</span>: radialSegments,</span><br><span class="line">                <span class="attr">heightSegments</span>: heightSegments,</span><br><span class="line">                <span class="attr">openEnded</span>: openEnded,</span><br><span class="line">                <span class="attr">thetaStart</span>: thetaStart,</span><br><span class="line">                <span class="attr">thetaLength</span>: thetaLength</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">fromJSON</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PolyhedronGeometry</span> <span class="keyword">extends</span> <span class="title">BufferGeometry</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">vertices = [], indices = [], radius = <span class="number">1</span>, detail = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;PolyhedronGeometry&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.parameters = &#123;</span><br><span class="line">                <span class="attr">vertices</span>: vertices,</span><br><span class="line">                <span class="attr">indices</span>: indices,</span><br><span class="line">                <span class="attr">radius</span>: radius,</span><br><span class="line">                <span class="attr">detail</span>: detail</span><br><span class="line">            &#125;; <span class="comment">// default buffer data</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> vertexBuffer = [];</span><br><span class="line">            <span class="keyword">const</span> uvBuffer = []; <span class="comment">// the subdivision creates the vertex buffer data</span></span><br><span class="line"></span><br><span class="line">            subdivide(detail); <span class="comment">// all vertices should lie on a conceptual sphere with a given radius</span></span><br><span class="line"></span><br><span class="line">            applyRadius(radius); <span class="comment">// finally, create the uv data</span></span><br><span class="line"></span><br><span class="line">            generateUVs(); <span class="comment">// build non-indexed geometry</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(vertexBuffer, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;normal&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(vertexBuffer.slice(), <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;uv&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(uvBuffer, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (detail === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.computeVertexNormals(); <span class="comment">// flat normals</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.normalizeNormals(); <span class="comment">// smooth normals</span></span><br><span class="line">            &#125; <span class="comment">// helper functions</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">subdivide</span>(<span class="params">detail</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> a = <span class="keyword">new</span> Vector3();</span><br><span class="line">                <span class="keyword">const</span> b = <span class="keyword">new</span> Vector3();</span><br><span class="line">                <span class="keyword">const</span> c = <span class="keyword">new</span> Vector3(); <span class="comment">// iterate over all faces and apply a subdivison with the given detail value</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; indices.length; i += <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="comment">// get the vertices of the face</span></span><br><span class="line">                    getVertexByIndex(indices[i + <span class="number">0</span>], a);</span><br><span class="line">                    getVertexByIndex(indices[i + <span class="number">1</span>], b);</span><br><span class="line">                    getVertexByIndex(indices[i + <span class="number">2</span>], c); <span class="comment">// perform subdivision</span></span><br><span class="line"></span><br><span class="line">                    subdivideFace(a, b, c, detail);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">subdivideFace</span>(<span class="params">a, b, c, detail</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> cols = detail + <span class="number">1</span>; <span class="comment">// we use this multidimensional array as a data structure for creating the subdivision</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> v = []; <span class="comment">// construct all of the vertices for this subdivision</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= cols; i++) &#123;</span><br><span class="line">                    v[i] = [];</span><br><span class="line">                    <span class="keyword">const</span> aj = a.clone().lerp(c, i / cols);</span><br><span class="line">                    <span class="keyword">const</span> bj = b.clone().lerp(c, i / cols);</span><br><span class="line">                    <span class="keyword">const</span> rows = cols - i;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= rows; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (j === <span class="number">0</span> &amp;&amp; i === cols) &#123;</span><br><span class="line">                            v[i][j] = aj;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            v[i][j] = aj.clone().lerp(bj, j / rows);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="comment">// construct all of the faces</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cols; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * (cols - i) - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> k = <span class="built_in">Math</span>.floor(j / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (j % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">                            pushVertex(v[i][k + <span class="number">1</span>]);</span><br><span class="line">                            pushVertex(v[i + <span class="number">1</span>][k]);</span><br><span class="line">                            pushVertex(v[i][k]);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            pushVertex(v[i][k + <span class="number">1</span>]);</span><br><span class="line">                            pushVertex(v[i + <span class="number">1</span>][k + <span class="number">1</span>]);</span><br><span class="line">                            pushVertex(v[i + <span class="number">1</span>][k]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">applyRadius</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> vertex = <span class="keyword">new</span> Vector3(); <span class="comment">// iterate over the entire buffer and apply the radius to each vertex</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vertexBuffer.length; i += <span class="number">3</span>) &#123;</span><br><span class="line">                    vertex.x = vertexBuffer[i + <span class="number">0</span>];</span><br><span class="line">                    vertex.y = vertexBuffer[i + <span class="number">1</span>];</span><br><span class="line">                    vertex.z = vertexBuffer[i + <span class="number">2</span>];</span><br><span class="line">                    vertex.normalize().multiplyScalar(radius);</span><br><span class="line">                    vertexBuffer[i + <span class="number">0</span>] = vertex.x;</span><br><span class="line">                    vertexBuffer[i + <span class="number">1</span>] = vertex.y;</span><br><span class="line">                    vertexBuffer[i + <span class="number">2</span>] = vertex.z;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">generateUVs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> vertex = <span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vertexBuffer.length; i += <span class="number">3</span>) &#123;</span><br><span class="line">                    vertex.x = vertexBuffer[i + <span class="number">0</span>];</span><br><span class="line">                    vertex.y = vertexBuffer[i + <span class="number">1</span>];</span><br><span class="line">                    vertex.z = vertexBuffer[i + <span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">const</span> u = azimuth(vertex) / <span class="number">2</span> / <span class="built_in">Math</span>.PI + <span class="number">0.5</span>;</span><br><span class="line">                    <span class="keyword">const</span> v = inclination(vertex) / <span class="built_in">Math</span>.PI + <span class="number">0.5</span>;</span><br><span class="line">                    uvBuffer.push(u, <span class="number">1</span> - v);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                correctUVs();</span><br><span class="line">                correctSeam();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">correctSeam</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// handle case when face straddles the seam, see #3269</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; uvBuffer.length; i += <span class="number">6</span>) &#123;</span><br><span class="line">                    <span class="comment">// uv data of a single face</span></span><br><span class="line">                    <span class="keyword">const</span> x0 = uvBuffer[i + <span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">const</span> x1 = uvBuffer[i + <span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">const</span> x2 = uvBuffer[i + <span class="number">4</span>];</span><br><span class="line">                    <span class="keyword">const</span> max = <span class="built_in">Math</span>.max(x0, x1, x2);</span><br><span class="line">                    <span class="keyword">const</span> min = <span class="built_in">Math</span>.min(x0, x1, x2); <span class="comment">// 0.9 is somewhat arbitrary</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (max &gt; <span class="number">0.9</span> &amp;&amp; min &lt; <span class="number">0.1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (x0 &lt; <span class="number">0.2</span>) uvBuffer[i + <span class="number">0</span>] += <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (x1 &lt; <span class="number">0.2</span>) uvBuffer[i + <span class="number">2</span>] += <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (x2 &lt; <span class="number">0.2</span>) uvBuffer[i + <span class="number">4</span>] += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">pushVertex</span>(<span class="params">vertex</span>) </span>&#123;</span><br><span class="line">                vertexBuffer.push(vertex.x, vertex.y, vertex.z);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">getVertexByIndex</span>(<span class="params">index, vertex</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> stride = index * <span class="number">3</span>;</span><br><span class="line">                vertex.x = vertices[stride + <span class="number">0</span>];</span><br><span class="line">                vertex.y = vertices[stride + <span class="number">1</span>];</span><br><span class="line">                vertex.z = vertices[stride + <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">correctUVs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> a = <span class="keyword">new</span> Vector3();</span><br><span class="line">                <span class="keyword">const</span> b = <span class="keyword">new</span> Vector3();</span><br><span class="line">                <span class="keyword">const</span> c = <span class="keyword">new</span> Vector3();</span><br><span class="line">                <span class="keyword">const</span> centroid = <span class="keyword">new</span> Vector3();</span><br><span class="line">                <span class="keyword">const</span> uvA = <span class="keyword">new</span> Vector2();</span><br><span class="line">                <span class="keyword">const</span> uvB = <span class="keyword">new</span> Vector2();</span><br><span class="line">                <span class="keyword">const</span> uvC = <span class="keyword">new</span> Vector2();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; vertexBuffer.length; i += <span class="number">9</span>, j += <span class="number">6</span>) &#123;</span><br><span class="line">                    a.set(vertexBuffer[i + <span class="number">0</span>], vertexBuffer[i + <span class="number">1</span>], vertexBuffer[i + <span class="number">2</span>]);</span><br><span class="line">                    b.set(vertexBuffer[i + <span class="number">3</span>], vertexBuffer[i + <span class="number">4</span>], vertexBuffer[i + <span class="number">5</span>]);</span><br><span class="line">                    c.set(vertexBuffer[i + <span class="number">6</span>], vertexBuffer[i + <span class="number">7</span>], vertexBuffer[i + <span class="number">8</span>]);</span><br><span class="line">                    uvA.set(uvBuffer[j + <span class="number">0</span>], uvBuffer[j + <span class="number">1</span>]);</span><br><span class="line">                    uvB.set(uvBuffer[j + <span class="number">2</span>], uvBuffer[j + <span class="number">3</span>]);</span><br><span class="line">                    uvC.set(uvBuffer[j + <span class="number">4</span>], uvBuffer[j + <span class="number">5</span>]);</span><br><span class="line">                    centroid.copy(a).add(b).add(c).divideScalar(<span class="number">3</span>);</span><br><span class="line">                    <span class="keyword">const</span> azi = azimuth(centroid);</span><br><span class="line">                    correctUV(uvA, j + <span class="number">0</span>, a, azi);</span><br><span class="line">                    correctUV(uvB, j + <span class="number">2</span>, b, azi);</span><br><span class="line">                    correctUV(uvC, j + <span class="number">4</span>, c, azi);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">correctUV</span>(<span class="params">uv, stride, vector, azimuth</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (azimuth &lt; <span class="number">0</span> &amp;&amp; uv.x === <span class="number">1</span>) &#123;</span><br><span class="line">                    uvBuffer[stride] = uv.x - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (vector.x === <span class="number">0</span> &amp;&amp; vector.z === <span class="number">0</span>) &#123;</span><br><span class="line">                    uvBuffer[stride] = azimuth / <span class="number">2</span> / <span class="built_in">Math</span>.PI + <span class="number">0.5</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// Angle around the Y axis, counter-clockwise when looking from above.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">azimuth</span>(<span class="params">vector</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Math</span>.atan2(vector.z, -vector.x);</span><br><span class="line">            &#125; <span class="comment">// Angle above the XZ plane.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">inclination</span>(<span class="params">vector</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Math</span>.atan2(-vector.y, <span class="built_in">Math</span>.sqrt(vector.x * vector.x + vector.z * vector.z));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">fromJSON</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DodecahedronGeometry</span> <span class="keyword">extends</span> <span class="title">PolyhedronGeometry</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">radius = <span class="number">1</span>, detail = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> t = (<span class="number">1</span> + <span class="built_in">Math</span>.sqrt(<span class="number">5</span>)) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">const</span> r = <span class="number">1</span> / t;</span><br><span class="line">            <span class="keyword">const</span> vertices = [<span class="comment">// (±1, ±1, ±1)</span></span><br><span class="line">                -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="comment">// (0, ±1/φ, ±φ)</span></span><br><span class="line">                <span class="number">0</span>, -r, -t, <span class="number">0</span>, -r, t, <span class="number">0</span>, r, -t, <span class="number">0</span>, r, t, <span class="comment">// (±1/φ, ±φ, 0)</span></span><br><span class="line">                -r, -t, <span class="number">0</span>, -r, t, <span class="number">0</span>, r, -t, <span class="number">0</span>, r, t, <span class="number">0</span>, <span class="comment">// (±φ, 0, ±1/φ)</span></span><br><span class="line">                -t, <span class="number">0</span>, -r, t, <span class="number">0</span>, -r, -t, <span class="number">0</span>, r, t, <span class="number">0</span>, r];</span><br><span class="line">            <span class="keyword">const</span> indices = [<span class="number">3</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">7</span>, <span class="number">19</span>, <span class="number">17</span>, <span class="number">7</span>, <span class="number">17</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">17</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">16</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">18</span>, <span class="number">0</span>, <span class="number">18</span>, <span class="number">16</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">6</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">2</span>, <span class="number">18</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">13</span>, <span class="number">18</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">18</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">19</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">7</span>, <span class="number">19</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">14</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">4</span>, <span class="number">17</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>];</span><br><span class="line">            <span class="built_in">super</span>(vertices, indices, radius, detail);</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;DodecahedronGeometry&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.parameters = &#123;</span><br><span class="line">                <span class="attr">radius</span>: radius,</span><br><span class="line">                <span class="attr">detail</span>: detail</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">fromJSON</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DodecahedronGeometry(data.radius, data.detail);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _v0 = <span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _v1$<span class="number">1</span> = <span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _normal = <span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _triangle = <span class="keyword">new</span> Triangle();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EdgesGeometry</span> <span class="keyword">extends</span> <span class="title">BufferGeometry</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">geometry = <span class="literal">null</span>, thresholdAngle = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;EdgesGeometry&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.parameters = &#123;</span><br><span class="line">                <span class="attr">geometry</span>: geometry,</span><br><span class="line">                <span class="attr">thresholdAngle</span>: thresholdAngle</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (geometry !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> precisionPoints = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">const</span> precision = <span class="built_in">Math</span>.pow(<span class="number">10</span>, precisionPoints);</span><br><span class="line">                <span class="keyword">const</span> thresholdDot = <span class="built_in">Math</span>.cos(DEG2RAD * thresholdAngle);</span><br><span class="line">                <span class="keyword">const</span> indexAttr = geometry.getIndex();</span><br><span class="line">                <span class="keyword">const</span> positionAttr = geometry.getAttribute(<span class="string">&#x27;position&#x27;</span>);</span><br><span class="line">                <span class="keyword">const</span> indexCount = indexAttr ? indexAttr.count : positionAttr.count;</span><br><span class="line">                <span class="keyword">const</span> indexArr = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">                <span class="keyword">const</span> vertKeys = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">                <span class="keyword">const</span> hashes = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">const</span> edgeData = &#123;&#125;;</span><br><span class="line">                <span class="keyword">const</span> vertices = [];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; indexCount; i += <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (indexAttr) &#123;</span><br><span class="line">                        indexArr[<span class="number">0</span>] = indexAttr.getX(i);</span><br><span class="line">                        indexArr[<span class="number">1</span>] = indexAttr.getX(i + <span class="number">1</span>);</span><br><span class="line">                        indexArr[<span class="number">2</span>] = indexAttr.getX(i + <span class="number">2</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        indexArr[<span class="number">0</span>] = i;</span><br><span class="line">                        indexArr[<span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line">                        indexArr[<span class="number">2</span>] = i + <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> &#123;</span><br><span class="line">                        a,</span><br><span class="line">                        b,</span><br><span class="line">                        c</span><br><span class="line">                    &#125; = _triangle;</span><br><span class="line">                    a.fromBufferAttribute(positionAttr, indexArr[<span class="number">0</span>]);</span><br><span class="line">                    b.fromBufferAttribute(positionAttr, indexArr[<span class="number">1</span>]);</span><br><span class="line">                    c.fromBufferAttribute(positionAttr, indexArr[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">                    _triangle.getNormal(_normal); <span class="comment">// create hashes for the edge from the vertices</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    hashes[<span class="number">0</span>] = <span class="string">`<span class="subst">$&#123;<span class="built_in">Math</span>.round(a.x * precision)&#125;</span>,<span class="subst">$&#123;<span class="built_in">Math</span>.round(a.y * precision)&#125;</span>,<span class="subst">$&#123;<span class="built_in">Math</span>.round(a.z * precision)&#125;</span>`</span>;</span><br><span class="line">                    hashes[<span class="number">1</span>] = <span class="string">`<span class="subst">$&#123;<span class="built_in">Math</span>.round(b.x * precision)&#125;</span>,<span class="subst">$&#123;<span class="built_in">Math</span>.round(b.y * precision)&#125;</span>,<span class="subst">$&#123;<span class="built_in">Math</span>.round(b.z * precision)&#125;</span>`</span>;</span><br><span class="line">                    hashes[<span class="number">2</span>] = <span class="string">`<span class="subst">$&#123;<span class="built_in">Math</span>.round(c.x * precision)&#125;</span>,<span class="subst">$&#123;<span class="built_in">Math</span>.round(c.y * precision)&#125;</span>,<span class="subst">$&#123;<span class="built_in">Math</span>.round(c.z * precision)&#125;</span>`</span>; <span class="comment">// skip degenerate triangles</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (hashes[<span class="number">0</span>] === hashes[<span class="number">1</span>] || hashes[<span class="number">1</span>] === hashes[<span class="number">2</span>] || hashes[<span class="number">2</span>] === hashes[<span class="number">0</span>]) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="comment">// iterate over every edge</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                        <span class="comment">// get the first and next vertex making up the edge</span></span><br><span class="line">                        <span class="keyword">const</span> jNext = (j + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">const</span> vecHash0 = hashes[j];</span><br><span class="line">                        <span class="keyword">const</span> vecHash1 = hashes[jNext];</span><br><span class="line">                        <span class="keyword">const</span> v0 = _triangle[vertKeys[j]];</span><br><span class="line">                        <span class="keyword">const</span> v1 = _triangle[vertKeys[jNext]];</span><br><span class="line">                        <span class="keyword">const</span> hash = <span class="string">`<span class="subst">$&#123;vecHash0&#125;</span>_<span class="subst">$&#123;vecHash1&#125;</span>`</span>;</span><br><span class="line">                        <span class="keyword">const</span> reverseHash = <span class="string">`<span class="subst">$&#123;vecHash1&#125;</span>_<span class="subst">$&#123;vecHash0&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (reverseHash <span class="keyword">in</span> edgeData &amp;&amp; edgeData[reverseHash]) &#123;</span><br><span class="line">                            <span class="comment">// if we found a sibling edge add it into the vertex array if</span></span><br><span class="line">                            <span class="comment">// it meets the angle threshold and delete the edge from the map.</span></span><br><span class="line">                            <span class="keyword">if</span> (_normal.dot(edgeData[reverseHash].normal) &lt;= thresholdDot) &#123;</span><br><span class="line">                                vertices.push(v0.x, v0.y, v0.z);</span><br><span class="line">                                vertices.push(v1.x, v1.y, v1.z);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            edgeData[reverseHash] = <span class="literal">null</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(hash <span class="keyword">in</span> edgeData)) &#123;</span><br><span class="line">                            <span class="comment">// if we&#x27;ve already got an edge here then skip adding a new one</span></span><br><span class="line">                            edgeData[hash] = &#123;</span><br><span class="line">                                <span class="attr">index0</span>: indexArr[j],</span><br><span class="line">                                <span class="attr">index1</span>: indexArr[jNext],</span><br><span class="line">                                <span class="attr">normal</span>: _normal.clone()</span><br><span class="line">                            &#125;;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="comment">// iterate over all remaining, unmatched edges and add them to the vertex array</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> edgeData) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (edgeData[key]) &#123;</span><br><span class="line">                        <span class="keyword">const</span> &#123;</span><br><span class="line">                            index0,</span><br><span class="line">                            index1</span><br><span class="line">                        &#125; = edgeData[key];</span><br><span class="line"></span><br><span class="line">                        _v0.fromBufferAttribute(positionAttr, index0);</span><br><span class="line"></span><br><span class="line">                        _v1$<span class="number">1.</span>fromBufferAttribute(positionAttr, index1);</span><br><span class="line"></span><br><span class="line">                        vertices.push(_v0.x, _v0.y, _v0.z);</span><br><span class="line">                        vertices.push(_v1$<span class="number">1.</span>x, _v1$<span class="number">1.</span>y, _v1$<span class="number">1.</span>z);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(vertices, <span class="number">3</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> <span class="keyword">extends</span> <span class="title">Path</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">points</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(points);</span><br><span class="line">            <span class="built_in">this</span>.uuid = generateUUID();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;Shape&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.holes = [];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getPointsHoles</span>(<span class="params">divisions</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> holesPts = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">this</span>.holes.length; i &lt; l; i++) &#123;</span><br><span class="line">                holesPts[i] = <span class="built_in">this</span>.holes[i].getPoints(divisions);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> holesPts;</span><br><span class="line">        &#125; <span class="comment">// get points of shape and holes (keypoints based on segments parameter)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">extractPoints</span>(<span class="params">divisions</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">shape</span>: <span class="built_in">this</span>.getPoints(divisions),</span><br><span class="line">                <span class="attr">holes</span>: <span class="built_in">this</span>.getPointsHoles(divisions)</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.holes = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = source.holes.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> hole = source.holes[i];</span><br><span class="line">                <span class="built_in">this</span>.holes.push(hole.clone());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON();</span><br><span class="line">            data.uuid = <span class="built_in">this</span>.uuid;</span><br><span class="line">            data.holes = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">this</span>.holes.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> hole = <span class="built_in">this</span>.holes[i];</span><br><span class="line">                data.holes.push(hole.toJSON());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromJSON</span>(<span class="params">json</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.fromJSON(json);</span><br><span class="line">            <span class="built_in">this</span>.uuid = json.uuid;</span><br><span class="line">            <span class="built_in">this</span>.holes = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = json.holes.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> hole = json.holes[i];</span><br><span class="line">                <span class="built_in">this</span>.holes.push(<span class="keyword">new</span> Path().fromJSON(hole));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Port from https://github.com/mapbox/earcut (v2.2.2)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> Earcut = &#123;</span><br><span class="line">        <span class="attr">triangulate</span>: <span class="function"><span class="keyword">function</span> (<span class="params">data, holeIndices, dim = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> hasHoles = holeIndices &amp;&amp; holeIndices.length;</span><br><span class="line">            <span class="keyword">const</span> outerLen = hasHoles ? holeIndices[<span class="number">0</span>] * dim : data.length;</span><br><span class="line">            <span class="keyword">let</span> outerNode = linkedList(data, <span class="number">0</span>, outerLen, dim, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">const</span> triangles = [];</span><br><span class="line">            <span class="keyword">if</span> (!outerNode || outerNode.next === outerNode.prev) <span class="keyword">return</span> triangles;</span><br><span class="line">            <span class="keyword">let</span> minX, minY, maxX, maxY, x, y, invSize;</span><br><span class="line">            <span class="keyword">if</span> (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); <span class="comment">// if the shape is not too simple, we&#x27;ll use z-order curve hash later; calculate polygon bbox</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (data.length &gt; <span class="number">80</span> * dim) &#123;</span><br><span class="line">                minX = maxX = data[<span class="number">0</span>];</span><br><span class="line">                minY = maxY = data[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = dim; i &lt; outerLen; i += dim) &#123;</span><br><span class="line">                    x = data[i];</span><br><span class="line">                    y = data[i + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; minX) minX = x;</span><br><span class="line">                    <span class="keyword">if</span> (y &lt; minY) minY = y;</span><br><span class="line">                    <span class="keyword">if</span> (x &gt; maxX) maxX = x;</span><br><span class="line">                    <span class="keyword">if</span> (y &gt; maxY) maxY = y;</span><br><span class="line">                &#125; <span class="comment">// minX, minY and invSize are later used to transform coords into integers for z-order calculation</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                invSize = <span class="built_in">Math</span>.max(maxX - minX, maxY - minY);</span><br><span class="line">                invSize = invSize !== <span class="number">0</span> ? <span class="number">1</span> / invSize : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            earcutLinked(outerNode, triangles, dim, minX, minY, invSize);</span><br><span class="line">            <span class="keyword">return</span> triangles;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;; <span class="comment">// create a circular doubly linked list from polygon points in the specified winding order</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">linkedList</span>(<span class="params">data, start, end, dim, clockwise</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> i, last;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clockwise === signedArea(data, start, end, dim) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = start; i &lt; end; i += dim) last = insertNode(i, data[i], data[i + <span class="number">1</span>], last);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = end - dim; i &gt;= start; i -= dim) last = insertNode(i, data[i], data[i + <span class="number">1</span>], last);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (last &amp;&amp; equals(last, last.next)) &#123;</span><br><span class="line">            removeNode(last);</span><br><span class="line">            last = last.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125; <span class="comment">// eliminate colinear or duplicate points</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">filterPoints</span>(<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!start) <span class="keyword">return</span> start;</span><br><span class="line">        <span class="keyword">if</span> (!end) end = start;</span><br><span class="line">        <span class="keyword">let</span> p = start,</span><br><span class="line">            again;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            again = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!p.steiner &amp;&amp; (equals(p, p.next) || area(p.prev, p, p.next) === <span class="number">0</span>)) &#123;</span><br><span class="line">                removeNode(p);</span><br><span class="line">                p = end = p.prev;</span><br><span class="line">                <span class="keyword">if</span> (p === p.next) <span class="keyword">break</span>;</span><br><span class="line">                again = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (again || p !== end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125; <span class="comment">// main ear slicing loop which triangulates a polygon (given as a linked list)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">earcutLinked</span>(<span class="params">ear, triangles, dim, minX, minY, invSize, pass</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ear) <span class="keyword">return</span>; <span class="comment">// interlink polygon nodes in z-order</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pass &amp;&amp; invSize) indexCurve(ear, minX, minY, invSize);</span><br><span class="line">        <span class="keyword">let</span> stop = ear,</span><br><span class="line">            prev,</span><br><span class="line">            next; <span class="comment">// iterate through ears, slicing them one by one</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (ear.prev !== ear.next) &#123;</span><br><span class="line">            prev = ear.prev;</span><br><span class="line">            next = ear.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) &#123;</span><br><span class="line">                <span class="comment">// cut off the triangle</span></span><br><span class="line">                triangles.push(prev.i / dim);</span><br><span class="line">                triangles.push(ear.i / dim);</span><br><span class="line">                triangles.push(next.i / dim);</span><br><span class="line">                removeNode(ear); <span class="comment">// skipping the next vertex leads to less sliver triangles</span></span><br><span class="line"></span><br><span class="line">                ear = next.next;</span><br><span class="line">                stop = next.next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ear = next; <span class="comment">// if we looped through the whole remaining polygon and can&#x27;t find any more ears</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ear === stop) &#123;</span><br><span class="line">                <span class="comment">// try filtering points and slicing again</span></span><br><span class="line">                <span class="keyword">if</span> (!pass) &#123;</span><br><span class="line">                    earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, <span class="number">1</span>); <span class="comment">// if this didn&#x27;t work, try curing all small self-intersections locally</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pass === <span class="number">1</span>) &#123;</span><br><span class="line">                    ear = cureLocalIntersections(filterPoints(ear), triangles, dim);</span><br><span class="line">                    earcutLinked(ear, triangles, dim, minX, minY, invSize, <span class="number">2</span>); <span class="comment">// as a last resort, try splitting the remaining polygon into two</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pass === <span class="number">2</span>) &#123;</span><br><span class="line">                    splitEarcut(ear, triangles, dim, minX, minY, invSize);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// check whether a polygon node forms a valid ear with adjacent nodes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isEar</span>(<span class="params">ear</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> a = ear.prev,</span><br><span class="line">            b = ear,</span><br><span class="line">            c = ear.next;</span><br><span class="line">        <span class="keyword">if</span> (area(a, b, c) &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// reflex, can&#x27;t be an ear</span></span><br><span class="line">        <span class="comment">// now make sure we don&#x27;t have other points inside the potential ear</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> p = ear.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p !== ear.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &amp;&amp; area(p.prev, p, p.next) &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isEarHashed</span>(<span class="params">ear, minX, minY, invSize</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> a = ear.prev,</span><br><span class="line">            b = ear,</span><br><span class="line">            c = ear.next;</span><br><span class="line">        <span class="keyword">if</span> (area(a, b, c) &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// reflex, can&#x27;t be an ear</span></span><br><span class="line">        <span class="comment">// triangle bbox; min &amp; max are calculated like this for speed</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> minTX = a.x &lt; b.x ? a.x &lt; c.x ? a.x : c.x : b.x &lt; c.x ? b.x : c.x,</span><br><span class="line">            minTY = a.y &lt; b.y ? a.y &lt; c.y ? a.y : c.y : b.y &lt; c.y ? b.y : c.y,</span><br><span class="line">            maxTX = a.x &gt; b.x ? a.x &gt; c.x ? a.x : c.x : b.x &gt; c.x ? b.x : c.x,</span><br><span class="line">            maxTY = a.y &gt; b.y ? a.y &gt; c.y ? a.y : c.y : b.y &gt; c.y ? b.y : c.y; <span class="comment">// z-order range for the current triangle bbox;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> minZ = zOrder(minTX, minTY, minX, minY, invSize),</span><br><span class="line">            maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);</span><br><span class="line">        <span class="keyword">let</span> p = ear.prevZ,</span><br><span class="line">            n = ear.nextZ; <span class="comment">// look for points inside the triangle in both directions</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; p.z &gt;= minZ &amp;&amp; n &amp;&amp; n.z &lt;= maxZ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p !== ear.prev &amp;&amp; p !== ear.next &amp;&amp; pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &amp;&amp; area(p.prev, p, p.next) &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p.prevZ;</span><br><span class="line">            <span class="keyword">if</span> (n !== ear.prev &amp;&amp; n !== ear.next &amp;&amp; pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &amp;&amp; area(n.prev, n, n.next) &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            n = n.nextZ;</span><br><span class="line">        &#125; <span class="comment">// look for remaining points in decreasing z-order</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; p.z &gt;= minZ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p !== ear.prev &amp;&amp; p !== ear.next &amp;&amp; pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &amp;&amp; area(p.prev, p, p.next) &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p.prevZ;</span><br><span class="line">        &#125; <span class="comment">// look for remaining points in increasing z-order</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n &amp;&amp; n.z &lt;= maxZ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n !== ear.prev &amp;&amp; n !== ear.next &amp;&amp; pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &amp;&amp; area(n.prev, n, n.next) &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            n = n.nextZ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="comment">// go through all polygon nodes and cure small local self-intersections</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cureLocalIntersections</span>(<span class="params">start, triangles, dim</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> p = start;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> a = p.prev,</span><br><span class="line">                b = p.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!equals(a, b) &amp;&amp; intersects(a, p, p.next, b) &amp;&amp; locallyInside(a, b) &amp;&amp; locallyInside(b, a)) &#123;</span><br><span class="line">                triangles.push(a.i / dim);</span><br><span class="line">                triangles.push(p.i / dim);</span><br><span class="line">                triangles.push(b.i / dim); <span class="comment">// remove two nodes involved</span></span><br><span class="line"></span><br><span class="line">                removeNode(p);</span><br><span class="line">                removeNode(p.next);</span><br><span class="line">                p = start = b;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (p !== start);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filterPoints(p);</span><br><span class="line">    &#125; <span class="comment">// try splitting polygon into two and triangulate them independently</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">splitEarcut</span>(<span class="params">start, triangles, dim, minX, minY, invSize</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// look for a valid diagonal that divides the polygon into two</span></span><br><span class="line">        <span class="keyword">let</span> a = start;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> b = a.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (b !== a.prev) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a.i !== b.i &amp;&amp; isValidDiagonal(a, b)) &#123;</span><br><span class="line">                    <span class="comment">// split the polygon in two by the diagonal</span></span><br><span class="line">                    <span class="keyword">let</span> c = splitPolygon(a, b); <span class="comment">// filter colinear points around the cuts</span></span><br><span class="line"></span><br><span class="line">                    a = filterPoints(a, a.next);</span><br><span class="line">                    c = filterPoints(c, c.next); <span class="comment">// run earcut on each half</span></span><br><span class="line"></span><br><span class="line">                    earcutLinked(a, triangles, dim, minX, minY, invSize);</span><br><span class="line">                    earcutLinked(c, triangles, dim, minX, minY, invSize);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                b = b.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            a = a.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (a !== start);</span><br><span class="line">    &#125; <span class="comment">// link every hole into the outer loop, producing a single-ring polygon without holes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">eliminateHoles</span>(<span class="params">data, holeIndices, outerNode, dim</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> queue = [];</span><br><span class="line">        <span class="keyword">let</span> i, len, start, end, list;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, len = holeIndices.length; i &lt; len; i++) &#123;</span><br><span class="line">            start = holeIndices[i] * dim;</span><br><span class="line">            end = i &lt; len - <span class="number">1</span> ? holeIndices[i + <span class="number">1</span>] * dim : data.length;</span><br><span class="line">            list = linkedList(data, start, end, dim, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (list === list.next) list.steiner = <span class="literal">true</span>;</span><br><span class="line">            queue.push(getLeftmost(list));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue.sort(compareX); <span class="comment">// process holes from left to right</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; queue.length; i++) &#123;</span><br><span class="line">            eliminateHole(queue[i], outerNode);</span><br><span class="line">            outerNode = filterPoints(outerNode, outerNode.next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> outerNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">compareX</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x - b.x;</span><br><span class="line">    &#125; <span class="comment">// find a bridge between vertices that connects hole with an outer ring and link it</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">eliminateHole</span>(<span class="params">hole, outerNode</span>) </span>&#123;</span><br><span class="line">        outerNode = findHoleBridge(hole, outerNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (outerNode) &#123;</span><br><span class="line">            <span class="keyword">const</span> b = splitPolygon(outerNode, hole); <span class="comment">// filter collinear points around the cuts</span></span><br><span class="line"></span><br><span class="line">            filterPoints(outerNode, outerNode.next);</span><br><span class="line">            filterPoints(b, b.next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// David Eberly&#x27;s algorithm for finding a bridge between hole and outer polygon</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">findHoleBridge</span>(<span class="params">hole, outerNode</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> p = outerNode;</span><br><span class="line">        <span class="keyword">const</span> hx = hole.x;</span><br><span class="line">        <span class="keyword">const</span> hy = hole.y;</span><br><span class="line">        <span class="keyword">let</span> qx = -<span class="literal">Infinity</span>,</span><br><span class="line">            m; <span class="comment">// find a segment intersected by a ray from the hole&#x27;s leftmost point to the left;</span></span><br><span class="line">        <span class="comment">// segment&#x27;s endpoint with lesser x will be potential connection point</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (hy &lt;= p.y &amp;&amp; hy &gt;= p.next.y &amp;&amp; p.next.y !== p.y) &#123;</span><br><span class="line">                <span class="keyword">const</span> x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (x &lt;= hx &amp;&amp; x &gt; qx) &#123;</span><br><span class="line">                    qx = x;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (x === hx) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hy === p.y) <span class="keyword">return</span> p;</span><br><span class="line">                        <span class="keyword">if</span> (hy === p.next.y) <span class="keyword">return</span> p.next;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    m = p.x &lt; p.next.x ? p : p.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (p !== outerNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (hx === qx) <span class="keyword">return</span> m; <span class="comment">// hole touches outer segment; pick leftmost endpoint</span></span><br><span class="line">        <span class="comment">// look for points inside the triangle of hole point, segment intersection and endpoint;</span></span><br><span class="line">        <span class="comment">// if there are no points found, we have a valid connection;</span></span><br><span class="line">        <span class="comment">// otherwise choose the point of the minimum angle with the ray as connection point</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> stop = m,</span><br><span class="line">            mx = m.x,</span><br><span class="line">            my = m.y;</span><br><span class="line">        <span class="keyword">let</span> tanMin = <span class="literal">Infinity</span>,</span><br><span class="line">            tan;</span><br><span class="line">        p = m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (hx &gt;= p.x &amp;&amp; p.x &gt;= mx &amp;&amp; hx !== p.x &amp;&amp; pointInTriangle(hy &lt; my ? hx : qx, hy, mx, my, hy &lt; my ? qx : hx, hy, p.x, p.y)) &#123;</span><br><span class="line">                tan = <span class="built_in">Math</span>.abs(hy - p.y) / (hx - p.x); <span class="comment">// tangential</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (locallyInside(p, hole) &amp;&amp; (tan &lt; tanMin || tan === tanMin &amp;&amp; (p.x &gt; m.x || p.x === m.x &amp;&amp; sectorContainsSector(m, p)))) &#123;</span><br><span class="line">                    m = p;</span><br><span class="line">                    tanMin = tan;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (p !== stop);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125; <span class="comment">// whether sector in vertex m contains sector in vertex p in the same coordinates</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sectorContainsSector</span>(<span class="params">m, p</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> area(m.prev, m, p.prev) &lt; <span class="number">0</span> &amp;&amp; area(p.next, m, m.next) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="comment">// interlink polygon nodes in z-order</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">indexCurve</span>(<span class="params">start, minX, minY, invSize</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> p = start;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.z === <span class="literal">null</span>) p.z = zOrder(p.x, p.y, minX, minY, invSize);</span><br><span class="line">            p.prevZ = p.prev;</span><br><span class="line">            p.nextZ = p.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (p !== start);</span><br><span class="line"></span><br><span class="line">        p.prevZ.nextZ = <span class="literal">null</span>;</span><br><span class="line">        p.prevZ = <span class="literal">null</span>;</span><br><span class="line">        sortLinked(p);</span><br><span class="line">    &#125; <span class="comment">// Simon Tatham&#x27;s linked list merge sort algorithm</span></span><br><span class="line">    <span class="comment">// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sortLinked</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> i,</span><br><span class="line">            p,</span><br><span class="line">            q,</span><br><span class="line">            e,</span><br><span class="line">            tail,</span><br><span class="line">            numMerges,</span><br><span class="line">            pSize,</span><br><span class="line">            qSize,</span><br><span class="line">            inSize = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            p = list;</span><br><span class="line">            list = <span class="literal">null</span>;</span><br><span class="line">            tail = <span class="literal">null</span>;</span><br><span class="line">            numMerges = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (p) &#123;</span><br><span class="line">                numMerges++;</span><br><span class="line">                q = p;</span><br><span class="line">                pSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; inSize; i++) &#123;</span><br><span class="line">                    pSize++;</span><br><span class="line">                    q = q.nextZ;</span><br><span class="line">                    <span class="keyword">if</span> (!q) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                qSize = inSize;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (pSize &gt; <span class="number">0</span> || qSize &gt; <span class="number">0</span> &amp;&amp; q) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pSize !== <span class="number">0</span> &amp;&amp; (qSize === <span class="number">0</span> || !q || p.z &lt;= q.z)) &#123;</span><br><span class="line">                        e = p;</span><br><span class="line">                        p = p.nextZ;</span><br><span class="line">                        pSize--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        e = q;</span><br><span class="line">                        q = q.nextZ;</span><br><span class="line">                        qSize--;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (tail) tail.nextZ = e;<span class="keyword">else</span> list = e;</span><br><span class="line">                    e.prevZ = tail;</span><br><span class="line">                    tail = e;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                p = q;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tail.nextZ = <span class="literal">null</span>;</span><br><span class="line">            inSize *= <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (numMerges &gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125; <span class="comment">// z-order of a point given coords and inverse of the longer side of data bbox</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">zOrder</span>(<span class="params">x, y, minX, minY, invSize</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// coords are transformed into non-negative 15-bit integer range</span></span><br><span class="line">        x = <span class="number">32767</span> * (x - minX) * invSize;</span><br><span class="line">        y = <span class="number">32767</span> * (y - minY) * invSize;</span><br><span class="line">        x = (x | x &lt;&lt; <span class="number">8</span>) &amp; <span class="number">0x00FF00FF</span>;</span><br><span class="line">        x = (x | x &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0x0F0F0F0F</span>;</span><br><span class="line">        x = (x | x &lt;&lt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>;</span><br><span class="line">        x = (x | x &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>;</span><br><span class="line">        y = (y | y &lt;&lt; <span class="number">8</span>) &amp; <span class="number">0x00FF00FF</span>;</span><br><span class="line">        y = (y | y &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0x0F0F0F0F</span>;</span><br><span class="line">        y = (y | y &lt;&lt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>;</span><br><span class="line">        y = (y | y &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>;</span><br><span class="line">        <span class="keyword">return</span> x | y &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="comment">// find the leftmost node of a polygon ring</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getLeftmost</span>(<span class="params">start</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> p = start,</span><br><span class="line">            leftmost = start;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.x &lt; leftmost.x || p.x === leftmost.x &amp;&amp; p.y &lt; leftmost.y) leftmost = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (p !== start);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftmost;</span><br><span class="line">    &#125; <span class="comment">// check if a point lies within a convex triangle</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pointInTriangle</span>(<span class="params">ax, ay, bx, by, cx, cy, px, py</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (cx - px) * (ay - py) - (ax - px) * (cy - py) &gt;= <span class="number">0</span> &amp;&amp; (ax - px) * (by - py) - (bx - px) * (ay - py) &gt;= <span class="number">0</span> &amp;&amp; (bx - px) * (cy - py) - (cx - px) * (by - py) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="comment">// check if a diagonal between two polygon nodes is valid (lies in polygon interior)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isValidDiagonal</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.next.i !== b.i &amp;&amp; a.prev.i !== b.i &amp;&amp; !intersectsPolygon(a, b) &amp;&amp; ( <span class="comment">// doesn&#x27;t intersect other edges</span></span><br><span class="line">            locallyInside(a, b) &amp;&amp; locallyInside(b, a) &amp;&amp; middleInside(a, b) &amp;&amp; ( <span class="comment">// locally visible</span></span><br><span class="line">                area(a.prev, a, b.prev) || area(a, b.prev, b)) || <span class="comment">// does not create opposite-facing sectors</span></span><br><span class="line">            equals(a, b) &amp;&amp; area(a.prev, a, a.next) &gt; <span class="number">0</span> &amp;&amp; area(b.prev, b, b.next) &gt; <span class="number">0</span>); <span class="comment">// special zero-length case</span></span><br><span class="line">    &#125; <span class="comment">// signed area of a triangle</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">p, q, r</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);</span><br><span class="line">    &#125; <span class="comment">// check if two points are equal</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">equals</span>(<span class="params">p1, p2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.x === p2.x &amp;&amp; p1.y === p2.y;</span><br><span class="line">    &#125; <span class="comment">// check if two segments intersect</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">intersects</span>(<span class="params">p1, q1, p2, q2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> o1 = sign(area(p1, q1, p2));</span><br><span class="line">        <span class="keyword">const</span> o2 = sign(area(p1, q1, q2));</span><br><span class="line">        <span class="keyword">const</span> o3 = sign(area(p2, q2, p1));</span><br><span class="line">        <span class="keyword">const</span> o4 = sign(area(p2, q2, q1));</span><br><span class="line">        <span class="keyword">if</span> (o1 !== o2 &amp;&amp; o3 !== o4) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// general case</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (o1 === <span class="number">0</span> &amp;&amp; onSegment(p1, p2, q1)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// p1, q1 and p2 are collinear and p2 lies on p1q1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (o2 === <span class="number">0</span> &amp;&amp; onSegment(p1, q2, q1)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// p1, q1 and q2 are collinear and q2 lies on p1q1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (o3 === <span class="number">0</span> &amp;&amp; onSegment(p2, p1, q2)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// p2, q2 and p1 are collinear and p1 lies on p2q2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (o4 === <span class="number">0</span> &amp;&amp; onSegment(p2, q1, q2)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// p2, q2 and q1 are collinear and q1 lies on p2q2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="comment">// for collinear points p, q, r, check if point q lies on segment pr</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onSegment</span>(<span class="params">p, q, r</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.x &lt;= <span class="built_in">Math</span>.max(p.x, r.x) &amp;&amp; q.x &gt;= <span class="built_in">Math</span>.min(p.x, r.x) &amp;&amp; q.y &lt;= <span class="built_in">Math</span>.max(p.y, r.y) &amp;&amp; q.y &gt;= <span class="built_in">Math</span>.min(p.y, r.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sign</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num &gt; <span class="number">0</span> ? <span class="number">1</span> : num &lt; <span class="number">0</span> ? -<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="comment">// check if a polygon diagonal intersects any polygon segments</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">intersectsPolygon</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> p = a;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.i !== a.i &amp;&amp; p.next.i !== a.i &amp;&amp; p.i !== b.i &amp;&amp; p.next.i !== b.i &amp;&amp; intersects(p, p.next, a, b)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (p !== a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="comment">// check if a polygon diagonal is locally inside the polygon</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">locallyInside</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> area(a.prev, a, a.next) &lt; <span class="number">0</span> ? area(a, b, a.next) &gt;= <span class="number">0</span> &amp;&amp; area(a, a.prev, b) &gt;= <span class="number">0</span> : area(a, b, a.prev) &lt; <span class="number">0</span> || area(a, a.next, b) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="comment">// check if the middle point of a polygon diagonal is inside the polygon</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">middleInside</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> p = a,</span><br><span class="line">            inside = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">const</span> px = (a.x + b.x) / <span class="number">2</span>,</span><br><span class="line">            py = (a.y + b.y) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.y &gt; py !== p.next.y &gt; py &amp;&amp; p.next.y !== p.y &amp;&amp; px &lt; (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (p !== a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inside;</span><br><span class="line">    &#125; <span class="comment">// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;</span></span><br><span class="line">    <span class="comment">// if one belongs to the outer ring and another to a hole, it merges it into a single ring</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">splitPolygon</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> a2 = <span class="keyword">new</span> Node(a.i, a.x, a.y),</span><br><span class="line">            b2 = <span class="keyword">new</span> Node(b.i, b.x, b.y),</span><br><span class="line">            an = a.next,</span><br><span class="line">            bp = b.prev;</span><br><span class="line">        a.next = b;</span><br><span class="line">        b.prev = a;</span><br><span class="line">        a2.next = an;</span><br><span class="line">        an.prev = a2;</span><br><span class="line">        b2.next = a2;</span><br><span class="line">        a2.prev = b2;</span><br><span class="line">        bp.next = b2;</span><br><span class="line">        b2.prev = bp;</span><br><span class="line">        <span class="keyword">return</span> b2;</span><br><span class="line">    &#125; <span class="comment">// create a node and optionally link it with previous one (in a circular doubly linked list)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">insertNode</span>(<span class="params">i, x, y, last</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> p = <span class="keyword">new</span> Node(i, x, y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!last) &#123;</span><br><span class="line">            p.prev = p;</span><br><span class="line">            p.next = p;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p.next = last.next;</span><br><span class="line">            p.prev = last;</span><br><span class="line">            last.next.prev = p;</span><br><span class="line">            last.next = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeNode</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">        p.next.prev = p.prev;</span><br><span class="line">        p.prev.next = p.next;</span><br><span class="line">        <span class="keyword">if</span> (p.prevZ) p.prevZ.nextZ = p.nextZ;</span><br><span class="line">        <span class="keyword">if</span> (p.nextZ) p.nextZ.prevZ = p.prevZ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">i, x, y</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// vertex index in coordinates array</span></span><br><span class="line">        <span class="built_in">this</span>.i = i; <span class="comment">// vertex coordinates</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y; <span class="comment">// previous and next vertex nodes in a polygon ring</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>; <span class="comment">// z-order curve value</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.z = <span class="literal">null</span>; <span class="comment">// previous and next nodes in z-order</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.prevZ = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.nextZ = <span class="literal">null</span>; <span class="comment">// indicates whether this is a steiner point</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.steiner = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">signedArea</span>(<span class="params">data, start, end, dim</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = start, j = end - dim; i &lt; end; i += dim) &#123;</span><br><span class="line">            sum += (data[j] - data[i]) * (data[i + <span class="number">1</span>] + data[j + <span class="number">1</span>]);</span><br><span class="line">            j = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ShapeUtils</span> </span>&#123;</span><br><span class="line">        <span class="comment">// calculate area of the contour polygon</span></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">area</span>(<span class="params">contour</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> n = contour.length;</span><br><span class="line">            <span class="keyword">let</span> a = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> p = n - <span class="number">1</span>, q = <span class="number">0</span>; q &lt; n; p = q++) &#123;</span><br><span class="line">                a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> a * <span class="number">0.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">isClockWise</span>(<span class="params">pts</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ShapeUtils.area(pts) &lt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">triangulateShape</span>(<span class="params">contour, holes</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> vertices = []; <span class="comment">// flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> holeIndices = []; <span class="comment">// array of hole indices</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> faces = []; <span class="comment">// final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]</span></span><br><span class="line"></span><br><span class="line">            removeDupEndPts(contour);</span><br><span class="line">            addContour(vertices, contour); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> holeIndex = contour.length;</span><br><span class="line">            holes.forEach(removeDupEndPts);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; holes.length; i++) &#123;</span><br><span class="line">                holeIndices.push(holeIndex);</span><br><span class="line">                holeIndex += holes[i].length;</span><br><span class="line">                addContour(vertices, holes[i]);</span><br><span class="line">            &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> triangles = Earcut.triangulate(vertices, holeIndices); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; triangles.length; i += <span class="number">3</span>) &#123;</span><br><span class="line">                faces.push(triangles.slice(i, i + <span class="number">3</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> faces;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeDupEndPts</span>(<span class="params">points</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> l = points.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l &gt; <span class="number">2</span> &amp;&amp; points[l - <span class="number">1</span>].equals(points[<span class="number">0</span>])) &#123;</span><br><span class="line">            points.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addContour</span>(<span class="params">vertices, contour</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; contour.length; i++) &#123;</span><br><span class="line">            vertices.push(contour[i].x);</span><br><span class="line">            vertices.push(contour[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates extruded geometry from a path shape.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * parameters = &#123;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *	curveSegments: &lt;int&gt;, // number of points on the curves</span></span><br><span class="line"><span class="comment">     *	steps: &lt;int&gt;, // number of points for z-side extrusions / used for subdividing segments of extrude spline too</span></span><br><span class="line"><span class="comment">     *	depth: &lt;float&gt;, // Depth to extrude the shape</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *	bevelEnabled: &lt;bool&gt;, // turn on bevel</span></span><br><span class="line"><span class="comment">     *	bevelThickness: &lt;float&gt;, // how deep into the original shape bevel goes</span></span><br><span class="line"><span class="comment">     *	bevelSize: &lt;float&gt;, // how far from shape outline (including bevelOffset) is bevel</span></span><br><span class="line"><span class="comment">     *	bevelOffset: &lt;float&gt;, // how far from shape outline does bevel start</span></span><br><span class="line"><span class="comment">     *	bevelSegments: &lt;int&gt;, // number of bevel layers</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *	extrudePath: &lt;THREE.Curve&gt; // curve to extrude shape along</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *	UVGenerator: &lt;Object&gt; // object that provides UV generator functions</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ExtrudeGeometry</span> <span class="keyword">extends</span> <span class="title">BufferGeometry</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">shapes = <span class="keyword">new</span> Shape([<span class="keyword">new</span> Vector2(<span class="number">0.5</span>, <span class="number">0.5</span>), <span class="keyword">new</span> Vector2(-<span class="number">0.5</span>, <span class="number">0.5</span>), <span class="keyword">new</span> Vector2(-<span class="number">0.5</span>, -<span class="number">0.5</span>), <span class="keyword">new</span> Vector2(<span class="number">0.5</span>, -<span class="number">0.5</span>)]), options = &#123;&#125;</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;ExtrudeGeometry&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.parameters = &#123;</span><br><span class="line">                <span class="attr">shapes</span>: shapes,</span><br><span class="line">                <span class="attr">options</span>: options</span><br><span class="line">            &#125;;</span><br><span class="line">            shapes = <span class="built_in">Array</span>.isArray(shapes) ? shapes : [shapes];</span><br><span class="line">            <span class="keyword">const</span> scope = <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">const</span> verticesArray = [];</span><br><span class="line">            <span class="keyword">const</span> uvArray = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = shapes.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> shape = shapes[i];</span><br><span class="line">                addShape(shape);</span><br><span class="line">            &#125; <span class="comment">// build geometry</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(verticesArray, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;uv&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(uvArray, <span class="number">2</span>));</span><br><span class="line">            <span class="built_in">this</span>.computeVertexNormals(); <span class="comment">// functions</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">addShape</span>(<span class="params">shape</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> placeholder = []; <span class="comment">// options</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> curveSegments = options.curveSegments !== <span class="literal">undefined</span> ? options.curveSegments : <span class="number">12</span>;</span><br><span class="line">                <span class="keyword">const</span> steps = options.steps !== <span class="literal">undefined</span> ? options.steps : <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">let</span> depth = options.depth !== <span class="literal">undefined</span> ? options.depth : <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">let</span> bevelEnabled = options.bevelEnabled !== <span class="literal">undefined</span> ? options.bevelEnabled : <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">let</span> bevelThickness = options.bevelThickness !== <span class="literal">undefined</span> ? options.bevelThickness : <span class="number">0.2</span>;</span><br><span class="line">                <span class="keyword">let</span> bevelSize = options.bevelSize !== <span class="literal">undefined</span> ? options.bevelSize : bevelThickness - <span class="number">0.1</span>;</span><br><span class="line">                <span class="keyword">let</span> bevelOffset = options.bevelOffset !== <span class="literal">undefined</span> ? options.bevelOffset : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">let</span> bevelSegments = options.bevelSegments !== <span class="literal">undefined</span> ? options.bevelSegments : <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">const</span> extrudePath = options.extrudePath;</span><br><span class="line">                <span class="keyword">const</span> uvgen = options.UVGenerator !== <span class="literal">undefined</span> ? options.UVGenerator : WorldUVGenerator; <span class="comment">// deprecated options</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (options.amount !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.ExtrudeBufferGeometry: amount has been renamed to depth.&#x27;</span>);</span><br><span class="line">                    depth = options.amount;</span><br><span class="line">                &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> extrudePts,</span><br><span class="line">                    extrudeByPath = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">let</span> splineTube, binormal, normal, position2;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (extrudePath) &#123;</span><br><span class="line">                    extrudePts = extrudePath.getSpacedPoints(steps);</span><br><span class="line">                    extrudeByPath = <span class="literal">true</span>;</span><br><span class="line">                    bevelEnabled = <span class="literal">false</span>; <span class="comment">// bevels not supported for path extrusion</span></span><br><span class="line">                    <span class="comment">// SETUP TNB variables</span></span><br><span class="line">                    <span class="comment">// TODO1 - have a .isClosed in spline?</span></span><br><span class="line"></span><br><span class="line">                    splineTube = extrudePath.computeFrenetFrames(steps, <span class="literal">false</span>); <span class="comment">// console.log(splineTube, &#x27;splineTube&#x27;, splineTube.normals.length, &#x27;steps&#x27;, steps, &#x27;extrudePts&#x27;, extrudePts.length);</span></span><br><span class="line"></span><br><span class="line">                    binormal = <span class="keyword">new</span> Vector3();</span><br><span class="line">                    normal = <span class="keyword">new</span> Vector3();</span><br><span class="line">                    position2 = <span class="keyword">new</span> Vector3();</span><br><span class="line">                &#125; <span class="comment">// Safeguards if bevels are not enabled</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!bevelEnabled) &#123;</span><br><span class="line">                    bevelSegments = <span class="number">0</span>;</span><br><span class="line">                    bevelThickness = <span class="number">0</span>;</span><br><span class="line">                    bevelSize = <span class="number">0</span>;</span><br><span class="line">                    bevelOffset = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="comment">// Variables initialization</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> shapePoints = shape.extractPoints(curveSegments);</span><br><span class="line">                <span class="keyword">let</span> vertices = shapePoints.shape;</span><br><span class="line">                <span class="keyword">const</span> holes = shapePoints.holes;</span><br><span class="line">                <span class="keyword">const</span> reverse = !ShapeUtils.isClockWise(vertices);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reverse) &#123;</span><br><span class="line">                    vertices = vertices.reverse(); <span class="comment">// Maybe we should also check if holes are in the opposite direction, just to be safe ...</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> h = <span class="number">0</span>, hl = holes.length; h &lt; hl; h++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> ahole = holes[h];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (ShapeUtils.isClockWise(ahole)) &#123;</span><br><span class="line">                            holes[h] = ahole.reverse();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> faces = ShapeUtils.triangulateShape(vertices, holes);</span><br><span class="line">                <span class="comment">/* Vertices */</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> contour = vertices; <span class="comment">// vertices has all points but contour has only points of circumference</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> h = <span class="number">0</span>, hl = holes.length; h &lt; hl; h++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> ahole = holes[h];</span><br><span class="line">                    vertices = vertices.concat(ahole);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">scalePt2</span>(<span class="params">pt, vec, size</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!vec) <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.ExtrudeGeometry: vec does not exist&#x27;</span>);</span><br><span class="line">                    <span class="keyword">return</span> vec.clone().multiplyScalar(size).add(pt);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> vlen = vertices.length,</span><br><span class="line">                    flen = faces.length; <span class="comment">// Find directions for point movement</span></span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">getBevelVec</span>(<span class="params">inPt, inPrev, inNext</span>) </span>&#123;</span><br><span class="line">                    <span class="comment">// computes for inPt the corresponding point inPt&#x27; on a new contour</span></span><br><span class="line">                    <span class="comment">//	 shifted by 1 unit (length of normalized vector) to the left</span></span><br><span class="line">                    <span class="comment">// if we walk along contour clockwise, this new contour is outside the old one</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// inPt&#x27; is the intersection of the two lines parallel to the two</span></span><br><span class="line">                    <span class="comment">//	adjacent edges of inPt at a distance of 1 unit on the left side.</span></span><br><span class="line">                    <span class="keyword">let</span> v_trans_x, v_trans_y, shrink_by; <span class="comment">// resulting translation vector for inPt</span></span><br><span class="line">                    <span class="comment">// good reading for geometry algorithms (here: line-line intersection)</span></span><br><span class="line">                    <span class="comment">// http://geomalgorithms.com/a05-_intersect-1.html</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> v_prev_x = inPt.x - inPrev.x,</span><br><span class="line">                        v_prev_y = inPt.y - inPrev.y;</span><br><span class="line">                    <span class="keyword">const</span> v_next_x = inNext.x - inPt.x,</span><br><span class="line">                        v_next_y = inNext.y - inPt.y;</span><br><span class="line">                    <span class="keyword">const</span> v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; <span class="comment">// check for collinear edges</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(collinear0) &gt; <span class="built_in">Number</span>.EPSILON) &#123;</span><br><span class="line">                        <span class="comment">// not collinear</span></span><br><span class="line">                        <span class="comment">// length of vectors for normalizing</span></span><br><span class="line">                        <span class="keyword">const</span> v_prev_len = <span class="built_in">Math</span>.sqrt(v_prev_lensq);</span><br><span class="line">                        <span class="keyword">const</span> v_next_len = <span class="built_in">Math</span>.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); <span class="comment">// shift adjacent points by unit vectors to the left</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">const</span> ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;</span><br><span class="line">                        <span class="keyword">const</span> ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;</span><br><span class="line">                        <span class="keyword">const</span> ptNextShift_x = inNext.x - v_next_y / v_next_len;</span><br><span class="line">                        <span class="keyword">const</span> ptNextShift_y = inNext.y + v_next_x / v_next_len; <span class="comment">// scaling factor for v_prev to intersection point</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">const</span> sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); <span class="comment">// vector from inPt to intersection point</span></span><br><span class="line"></span><br><span class="line">                        v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;</span><br><span class="line">                        v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; <span class="comment">// Don&#x27;t normalize!, otherwise sharp corners become ugly</span></span><br><span class="line">                        <span class="comment">//	but prevent crazy spikes</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">const</span> v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (v_trans_lensq &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> Vector2(v_trans_x, v_trans_y);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            shrink_by = <span class="built_in">Math</span>.sqrt(v_trans_lensq / <span class="number">2</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// handle special case of collinear edges</span></span><br><span class="line">                        <span class="keyword">let</span> direction_eq = <span class="literal">false</span>; <span class="comment">// assumes: opposite</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (v_prev_x &gt; <span class="built_in">Number</span>.EPSILON) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (v_next_x &gt; <span class="built_in">Number</span>.EPSILON) &#123;</span><br><span class="line">                                direction_eq = <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (v_prev_x &lt; -<span class="built_in">Number</span>.EPSILON) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (v_next_x &lt; -<span class="built_in">Number</span>.EPSILON) &#123;</span><br><span class="line">                                    direction_eq = <span class="literal">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (<span class="built_in">Math</span>.sign(v_prev_y) === <span class="built_in">Math</span>.sign(v_next_y)) &#123;</span><br><span class="line">                                    direction_eq = <span class="literal">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (direction_eq) &#123;</span><br><span class="line">                            <span class="comment">// console.log(&quot;Warning: lines are a straight sequence&quot;);</span></span><br><span class="line">                            v_trans_x = -v_prev_y;</span><br><span class="line">                            v_trans_y = v_prev_x;</span><br><span class="line">                            shrink_by = <span class="built_in">Math</span>.sqrt(v_prev_lensq);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// console.log(&quot;Warning: lines are a straight spike&quot;);</span></span><br><span class="line">                            v_trans_x = v_prev_x;</span><br><span class="line">                            v_trans_y = v_prev_y;</span><br><span class="line">                            shrink_by = <span class="built_in">Math</span>.sqrt(v_prev_lensq / <span class="number">2</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> contourMovements = [];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = contour.length, j = il - <span class="number">1</span>, k = i + <span class="number">1</span>; i &lt; il; i++, j++, k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j === il) j = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (k === il) k = <span class="number">0</span>; <span class="comment">//	(j)---(i)---(k)</span></span><br><span class="line">                    <span class="comment">// console.log(&#x27;i,j,k&#x27;, i, j , k)</span></span><br><span class="line"></span><br><span class="line">                    contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> holesMovements = [];</span><br><span class="line">                <span class="keyword">let</span> oneHoleMovements,</span><br><span class="line">                    verticesMovements = contourMovements.concat();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> h = <span class="number">0</span>, hl = holes.length; h &lt; hl; h++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> ahole = holes[h];</span><br><span class="line">                    oneHoleMovements = [];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = ahole.length, j = il - <span class="number">1</span>, k = i + <span class="number">1</span>; i &lt; il; i++, j++, k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (j === il) j = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (k === il) k = <span class="number">0</span>; <span class="comment">//	(j)---(i)---(k)</span></span><br><span class="line"></span><br><span class="line">                        oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    holesMovements.push(oneHoleMovements);</span><br><span class="line">                    verticesMovements = verticesMovements.concat(oneHoleMovements);</span><br><span class="line">                &#125; <span class="comment">// Loop bevelSegments, 1 for the front, 1 for the back</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> b = <span class="number">0</span>; b &lt; bevelSegments; b++) &#123;</span><br><span class="line">                    <span class="comment">//for ( b = bevelSegments; b &gt; 0; b -- ) &#123;</span></span><br><span class="line">                    <span class="keyword">const</span> t = b / bevelSegments;</span><br><span class="line">                    <span class="keyword">const</span> z = bevelThickness * <span class="built_in">Math</span>.cos(t * <span class="built_in">Math</span>.PI / <span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">const</span> bs = bevelSize * <span class="built_in">Math</span>.sin(t * <span class="built_in">Math</span>.PI / <span class="number">2</span>) + bevelOffset; <span class="comment">// contract shape</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = contour.length; i &lt; il; i++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> vert = scalePt2(contour[i], contourMovements[i], bs);</span><br><span class="line">                        v(vert.x, vert.y, -z);</span><br><span class="line">                    &#125; <span class="comment">// expand holes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> h = <span class="number">0</span>, hl = holes.length; h &lt; hl; h++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> ahole = holes[h];</span><br><span class="line">                        oneHoleMovements = holesMovements[h];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = ahole.length; i &lt; il; i++) &#123;</span><br><span class="line">                            <span class="keyword">const</span> vert = scalePt2(ahole[i], oneHoleMovements[i], bs);</span><br><span class="line">                            v(vert.x, vert.y, -z);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> bs = bevelSize + bevelOffset; <span class="comment">// Back facing vertices</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!extrudeByPath) &#123;</span><br><span class="line">                        v(vert.x, vert.y, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );</span></span><br><span class="line">                        normal.copy(splineTube.normals[<span class="number">0</span>]).multiplyScalar(vert.x);</span><br><span class="line">                        binormal.copy(splineTube.binormals[<span class="number">0</span>]).multiplyScalar(vert.y);</span><br><span class="line">                        position2.copy(extrudePts[<span class="number">0</span>]).add(normal).add(binormal);</span><br><span class="line">                        v(position2.x, position2.y, position2.z);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="comment">// Add stepped vertices...</span></span><br><span class="line">                <span class="comment">// Including front facing vertices</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> s = <span class="number">1</span>; s &lt;= steps; s++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!extrudeByPath) &#123;</span><br><span class="line">                            v(vert.x, vert.y, depth / steps * s);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );</span></span><br><span class="line">                            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);</span><br><span class="line">                            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);</span><br><span class="line">                            position2.copy(extrudePts[s]).add(normal).add(binormal);</span><br><span class="line">                            v(position2.x, position2.y, position2.z);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="comment">// Add bevel segments planes</span></span><br><span class="line">                <span class="comment">//for ( b = 1; b &lt;= bevelSegments; b ++ ) &#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> b = bevelSegments - <span class="number">1</span>; b &gt;= <span class="number">0</span>; b--) &#123;</span><br><span class="line">                    <span class="keyword">const</span> t = b / bevelSegments;</span><br><span class="line">                    <span class="keyword">const</span> z = bevelThickness * <span class="built_in">Math</span>.cos(t * <span class="built_in">Math</span>.PI / <span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">const</span> bs = bevelSize * <span class="built_in">Math</span>.sin(t * <span class="built_in">Math</span>.PI / <span class="number">2</span>) + bevelOffset; <span class="comment">// contract shape</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = contour.length; i &lt; il; i++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> vert = scalePt2(contour[i], contourMovements[i], bs);</span><br><span class="line">                        v(vert.x, vert.y, depth + z);</span><br><span class="line">                    &#125; <span class="comment">// expand holes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> h = <span class="number">0</span>, hl = holes.length; h &lt; hl; h++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> ahole = holes[h];</span><br><span class="line">                        oneHoleMovements = holesMovements[h];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = ahole.length; i &lt; il; i++) &#123;</span><br><span class="line">                            <span class="keyword">const</span> vert = scalePt2(ahole[i], oneHoleMovements[i], bs);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (!extrudeByPath) &#123;</span><br><span class="line">                                v(vert.x, vert.y, depth + z);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                v(vert.x, vert.y + extrudePts[steps - <span class="number">1</span>].y, extrudePts[steps - <span class="number">1</span>].x + z);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* Faces */</span></span><br><span class="line">                <span class="comment">// Top and bottom faces</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                buildLidFaces(); <span class="comment">// Sides faces</span></span><br><span class="line"></span><br><span class="line">                buildSideFaces(); <span class="comment">/////	Internal functions</span></span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">buildLidFaces</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">const</span> start = verticesArray.length / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (bevelEnabled) &#123;</span><br><span class="line">                        <span class="keyword">let</span> layer = <span class="number">0</span>; <span class="comment">// steps + 1</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">let</span> offset = vlen * layer; <span class="comment">// Bottom faces</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; flen; i++) &#123;</span><br><span class="line">                            <span class="keyword">const</span> face = faces[i];</span><br><span class="line">                            f3(face[<span class="number">2</span>] + offset, face[<span class="number">1</span>] + offset, face[<span class="number">0</span>] + offset);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        layer = steps + bevelSegments * <span class="number">2</span>;</span><br><span class="line">                        offset = vlen * layer; <span class="comment">// Top faces</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; flen; i++) &#123;</span><br><span class="line">                            <span class="keyword">const</span> face = faces[i];</span><br><span class="line">                            f3(face[<span class="number">0</span>] + offset, face[<span class="number">1</span>] + offset, face[<span class="number">2</span>] + offset);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Bottom faces</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; flen; i++) &#123;</span><br><span class="line">                            <span class="keyword">const</span> face = faces[i];</span><br><span class="line">                            f3(face[<span class="number">2</span>], face[<span class="number">1</span>], face[<span class="number">0</span>]);</span><br><span class="line">                        &#125; <span class="comment">// Top faces</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; flen; i++) &#123;</span><br><span class="line">                            <span class="keyword">const</span> face = faces[i];</span><br><span class="line">                            f3(face[<span class="number">0</span>] + vlen * steps, face[<span class="number">1</span>] + vlen * steps, face[<span class="number">2</span>] + vlen * steps);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    scope.addGroup(start, verticesArray.length / <span class="number">3</span> - start, <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="comment">// Create faces for the z-sides of the shape</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">buildSideFaces</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">const</span> start = verticesArray.length / <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">let</span> layeroffset = <span class="number">0</span>;</span><br><span class="line">                    sidewalls(contour, layeroffset);</span><br><span class="line">                    layeroffset += contour.length;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> h = <span class="number">0</span>, hl = holes.length; h &lt; hl; h++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> ahole = holes[h];</span><br><span class="line">                        sidewalls(ahole, layeroffset); <span class="comment">//, true</span></span><br><span class="line"></span><br><span class="line">                        layeroffset += ahole.length;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    scope.addGroup(start, verticesArray.length / <span class="number">3</span> - start, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">sidewalls</span>(<span class="params">contour, layeroffset</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">let</span> i = contour.length;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">const</span> j = i;</span><br><span class="line">                        <span class="keyword">let</span> k = i - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (k &lt; <span class="number">0</span>) k = contour.length - <span class="number">1</span>; <span class="comment">//console.log(&#x27;b&#x27;, i,j, i-1, k,vertices.length);</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> s = <span class="number">0</span>, sl = steps + bevelSegments * <span class="number">2</span>; s &lt; sl; s++) &#123;</span><br><span class="line">                            <span class="keyword">const</span> slen1 = vlen * s;</span><br><span class="line">                            <span class="keyword">const</span> slen2 = vlen * (s + <span class="number">1</span>);</span><br><span class="line">                            <span class="keyword">const</span> a = layeroffset + j + slen1,</span><br><span class="line">                                b = layeroffset + k + slen1,</span><br><span class="line">                                c = layeroffset + k + slen2,</span><br><span class="line">                                d = layeroffset + j + slen2;</span><br><span class="line">                            f4(a, b, c, d);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">v</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">                    placeholder.push(x);</span><br><span class="line">                    placeholder.push(y);</span><br><span class="line">                    placeholder.push(z);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">                    addVertex(a);</span><br><span class="line">                    addVertex(b);</span><br><span class="line">                    addVertex(c);</span><br><span class="line">                    <span class="keyword">const</span> nextIndex = verticesArray.length / <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">const</span> uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - <span class="number">3</span>, nextIndex - <span class="number">2</span>, nextIndex - <span class="number">1</span>);</span><br><span class="line">                    addUV(uvs[<span class="number">0</span>]);</span><br><span class="line">                    addUV(uvs[<span class="number">1</span>]);</span><br><span class="line">                    addUV(uvs[<span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">f4</span>(<span class="params">a, b, c, d</span>) </span>&#123;</span><br><span class="line">                    addVertex(a);</span><br><span class="line">                    addVertex(b);</span><br><span class="line">                    addVertex(d);</span><br><span class="line">                    addVertex(b);</span><br><span class="line">                    addVertex(c);</span><br><span class="line">                    addVertex(d);</span><br><span class="line">                    <span class="keyword">const</span> nextIndex = verticesArray.length / <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">const</span> uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - <span class="number">6</span>, nextIndex - <span class="number">3</span>, nextIndex - <span class="number">2</span>, nextIndex - <span class="number">1</span>);</span><br><span class="line">                    addUV(uvs[<span class="number">0</span>]);</span><br><span class="line">                    addUV(uvs[<span class="number">1</span>]);</span><br><span class="line">                    addUV(uvs[<span class="number">3</span>]);</span><br><span class="line">                    addUV(uvs[<span class="number">1</span>]);</span><br><span class="line">                    addUV(uvs[<span class="number">2</span>]);</span><br><span class="line">                    addUV(uvs[<span class="number">3</span>]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">addVertex</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">                    verticesArray.push(placeholder[index * <span class="number">3</span> + <span class="number">0</span>]);</span><br><span class="line">                    verticesArray.push(placeholder[index * <span class="number">3</span> + <span class="number">1</span>]);</span><br><span class="line">                    verticesArray.push(placeholder[index * <span class="number">3</span> + <span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">addUV</span>(<span class="params">vector2</span>) </span>&#123;</span><br><span class="line">                    uvArray.push(vector2.x);</span><br><span class="line">                    uvArray.push(vector2.y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON();</span><br><span class="line">            <span class="keyword">const</span> shapes = <span class="built_in">this</span>.parameters.shapes;</span><br><span class="line">            <span class="keyword">const</span> options = <span class="built_in">this</span>.parameters.options;</span><br><span class="line">            <span class="keyword">return</span> toJSON$<span class="number">1</span>(shapes, options, data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">fromJSON</span>(<span class="params">data, shapes</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> geometryShapes = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, jl = data.shapes.length; j &lt; jl; j++) &#123;</span><br><span class="line">                <span class="keyword">const</span> shape = shapes[data.shapes[j]];</span><br><span class="line">                geometryShapes.push(shape);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> extrudePath = data.options.extrudePath;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (extrudePath !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                data.options.extrudePath = <span class="keyword">new</span> Curves[extrudePath.type]().fromJSON(extrudePath);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ExtrudeGeometry(geometryShapes, data.options);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> WorldUVGenerator = &#123;</span><br><span class="line">        <span class="attr">generateTopUV</span>: <span class="function"><span class="keyword">function</span> (<span class="params">geometry, vertices, indexA, indexB, indexC</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> a_x = vertices[indexA * <span class="number">3</span>];</span><br><span class="line">            <span class="keyword">const</span> a_y = vertices[indexA * <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">const</span> b_x = vertices[indexB * <span class="number">3</span>];</span><br><span class="line">            <span class="keyword">const</span> b_y = vertices[indexB * <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">const</span> c_x = vertices[indexC * <span class="number">3</span>];</span><br><span class="line">            <span class="keyword">const</span> c_y = vertices[indexC * <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">new</span> Vector2(a_x, a_y), <span class="keyword">new</span> Vector2(b_x, b_y), <span class="keyword">new</span> Vector2(c_x, c_y)];</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">generateSideWallUV</span>: <span class="function"><span class="keyword">function</span> (<span class="params">geometry, vertices, indexA, indexB, indexC, indexD</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> a_x = vertices[indexA * <span class="number">3</span>];</span><br><span class="line">            <span class="keyword">const</span> a_y = vertices[indexA * <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">const</span> a_z = vertices[indexA * <span class="number">3</span> + <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">const</span> b_x = vertices[indexB * <span class="number">3</span>];</span><br><span class="line">            <span class="keyword">const</span> b_y = vertices[indexB * <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">const</span> b_z = vertices[indexB * <span class="number">3</span> + <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">const</span> c_x = vertices[indexC * <span class="number">3</span>];</span><br><span class="line">            <span class="keyword">const</span> c_y = vertices[indexC * <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">const</span> c_z = vertices[indexC * <span class="number">3</span> + <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">const</span> d_x = vertices[indexD * <span class="number">3</span>];</span><br><span class="line">            <span class="keyword">const</span> d_y = vertices[indexD * <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">const</span> d_z = vertices[indexD * <span class="number">3</span> + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(a_y - b_y) &lt; <span class="built_in">Math</span>.abs(a_x - b_x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> [<span class="keyword">new</span> Vector2(a_x, <span class="number">1</span> - a_z), <span class="keyword">new</span> Vector2(b_x, <span class="number">1</span> - b_z), <span class="keyword">new</span> Vector2(c_x, <span class="number">1</span> - c_z), <span class="keyword">new</span> Vector2(d_x, <span class="number">1</span> - d_z)];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> [<span class="keyword">new</span> Vector2(a_y, <span class="number">1</span> - a_z), <span class="keyword">new</span> Vector2(b_y, <span class="number">1</span> - b_z), <span class="keyword">new</span> Vector2(c_y, <span class="number">1</span> - c_z), <span class="keyword">new</span> Vector2(d_y, <span class="number">1</span> - d_z)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">toJSON$1</span>(<span class="params">shapes, options, data</span>) </span>&#123;</span><br><span class="line">        data.shapes = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(shapes)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = shapes.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> shape = shapes[i];</span><br><span class="line">                data.shapes.push(shape.uuid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data.shapes.push(shapes.uuid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (options.extrudePath !== <span class="literal">undefined</span>) data.options.extrudePath = options.extrudePath.toJSON();</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">IcosahedronGeometry</span> <span class="keyword">extends</span> <span class="title">PolyhedronGeometry</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">radius = <span class="number">1</span>, detail = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> t = (<span class="number">1</span> + <span class="built_in">Math</span>.sqrt(<span class="number">5</span>)) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">const</span> vertices = [-<span class="number">1</span>, t, <span class="number">0</span>, <span class="number">1</span>, t, <span class="number">0</span>, -<span class="number">1</span>, -t, <span class="number">0</span>, <span class="number">1</span>, -t, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, t, <span class="number">0</span>, <span class="number">1</span>, t, <span class="number">0</span>, -<span class="number">1</span>, -t, <span class="number">0</span>, <span class="number">1</span>, -t, t, <span class="number">0</span>, -<span class="number">1</span>, t, <span class="number">0</span>, <span class="number">1</span>, -t, <span class="number">0</span>, -<span class="number">1</span>, -t, <span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">const</span> indices = [<span class="number">0</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">super</span>(vertices, indices, radius, detail);</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;IcosahedronGeometry&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.parameters = &#123;</span><br><span class="line">                <span class="attr">radius</span>: radius,</span><br><span class="line">                <span class="attr">detail</span>: detail</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">fromJSON</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> IcosahedronGeometry(data.radius, data.detail);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OctahedronGeometry</span> <span class="keyword">extends</span> <span class="title">PolyhedronGeometry</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">radius = <span class="number">1</span>, detail = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> vertices = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">const</span> indices = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>];</span><br><span class="line">            <span class="built_in">super</span>(vertices, indices, radius, detail);</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;OctahedronGeometry&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.parameters = &#123;</span><br><span class="line">                <span class="attr">radius</span>: radius,</span><br><span class="line">                <span class="attr">detail</span>: detail</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">fromJSON</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> OctahedronGeometry(data.radius, data.detail);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RingGeometry</span> <span class="keyword">extends</span> <span class="title">BufferGeometry</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">innerRadius = <span class="number">0.5</span>, outerRadius = <span class="number">1</span>, thetaSegments = <span class="number">8</span>, phiSegments = <span class="number">1</span>, thetaStart = <span class="number">0</span>, thetaLength = <span class="built_in">Math</span>.PI * <span class="number">2</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;RingGeometry&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.parameters = &#123;</span><br><span class="line">                <span class="attr">innerRadius</span>: innerRadius,</span><br><span class="line">                <span class="attr">outerRadius</span>: outerRadius,</span><br><span class="line">                <span class="attr">thetaSegments</span>: thetaSegments,</span><br><span class="line">                <span class="attr">phiSegments</span>: phiSegments,</span><br><span class="line">                <span class="attr">thetaStart</span>: thetaStart,</span><br><span class="line">                <span class="attr">thetaLength</span>: thetaLength</span><br><span class="line">            &#125;;</span><br><span class="line">            thetaSegments = <span class="built_in">Math</span>.max(<span class="number">3</span>, thetaSegments);</span><br><span class="line">            phiSegments = <span class="built_in">Math</span>.max(<span class="number">1</span>, phiSegments); <span class="comment">// buffers</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> indices = [];</span><br><span class="line">            <span class="keyword">const</span> vertices = [];</span><br><span class="line">            <span class="keyword">const</span> normals = [];</span><br><span class="line">            <span class="keyword">const</span> uvs = []; <span class="comment">// some helper variables</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> radius = innerRadius;</span><br><span class="line">            <span class="keyword">const</span> radiusStep = (outerRadius - innerRadius) / phiSegments;</span><br><span class="line">            <span class="keyword">const</span> vertex = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> uv = <span class="keyword">new</span> Vector2(); <span class="comment">// generate vertices, normals and uvs</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= phiSegments; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= thetaSegments; i++) &#123;</span><br><span class="line">                    <span class="comment">// values are generate from the inside of the ring to the outside</span></span><br><span class="line">                    <span class="keyword">const</span> segment = thetaStart + i / thetaSegments * thetaLength; <span class="comment">// vertex</span></span><br><span class="line"></span><br><span class="line">                    vertex.x = radius * <span class="built_in">Math</span>.cos(segment);</span><br><span class="line">                    vertex.y = radius * <span class="built_in">Math</span>.sin(segment);</span><br><span class="line">                    vertices.push(vertex.x, vertex.y, vertex.z); <span class="comment">// normal</span></span><br><span class="line"></span><br><span class="line">                    normals.push(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// uv</span></span><br><span class="line"></span><br><span class="line">                    uv.x = (vertex.x / outerRadius + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                    uv.y = (vertex.y / outerRadius + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                    uvs.push(uv.x, uv.y);</span><br><span class="line">                &#125; <span class="comment">// increase the radius for next row of vertices</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                radius += radiusStep;</span><br><span class="line">            &#125; <span class="comment">// indices</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; phiSegments; j++) &#123;</span><br><span class="line">                <span class="keyword">const</span> thetaSegmentLevel = j * (thetaSegments + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; thetaSegments; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> segment = i + thetaSegmentLevel;</span><br><span class="line">                    <span class="keyword">const</span> a = segment;</span><br><span class="line">                    <span class="keyword">const</span> b = segment + thetaSegments + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">const</span> c = segment + thetaSegments + <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">const</span> d = segment + <span class="number">1</span>; <span class="comment">// faces</span></span><br><span class="line"></span><br><span class="line">                    indices.push(a, b, d);</span><br><span class="line">                    indices.push(b, c, d);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// build geometry</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setIndex(indices);</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(vertices, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;normal&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(normals, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;uv&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(uvs, <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">fromJSON</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ShapeGeometry</span> <span class="keyword">extends</span> <span class="title">BufferGeometry</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">shapes = <span class="keyword">new</span> Shape([<span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">0.5</span>), <span class="keyword">new</span> Vector2(-<span class="number">0.5</span>, -<span class="number">0.5</span>), <span class="keyword">new</span> Vector2(<span class="number">0.5</span>, -<span class="number">0.5</span>)]), curveSegments = <span class="number">12</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;ShapeGeometry&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.parameters = &#123;</span><br><span class="line">                <span class="attr">shapes</span>: shapes,</span><br><span class="line">                <span class="attr">curveSegments</span>: curveSegments</span><br><span class="line">            &#125;; <span class="comment">// buffers</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> indices = [];</span><br><span class="line">            <span class="keyword">const</span> vertices = [];</span><br><span class="line">            <span class="keyword">const</span> normals = [];</span><br><span class="line">            <span class="keyword">const</span> uvs = []; <span class="comment">// helper variables</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> groupStart = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> groupCount = <span class="number">0</span>; <span class="comment">// allow single and array values for &quot;shapes&quot; parameter</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(shapes) === <span class="literal">false</span>) &#123;</span><br><span class="line">                addShape(shapes);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; shapes.length; i++) &#123;</span><br><span class="line">                    addShape(shapes[i]);</span><br><span class="line">                    <span class="built_in">this</span>.addGroup(groupStart, groupCount, i); <span class="comment">// enables MultiMaterial support</span></span><br><span class="line"></span><br><span class="line">                    groupStart += groupCount;</span><br><span class="line">                    groupCount = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// build geometry</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setIndex(indices);</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(vertices, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;normal&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(normals, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;uv&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(uvs, <span class="number">2</span>)); <span class="comment">// helper functions</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">addShape</span>(<span class="params">shape</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> indexOffset = vertices.length / <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">const</span> points = shape.extractPoints(curveSegments);</span><br><span class="line">                <span class="keyword">let</span> shapeVertices = points.shape;</span><br><span class="line">                <span class="keyword">const</span> shapeHoles = points.holes; <span class="comment">// check direction of vertices</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ShapeUtils.isClockWise(shapeVertices) === <span class="literal">false</span>) &#123;</span><br><span class="line">                    shapeVertices = shapeVertices.reverse();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = shapeHoles.length; i &lt; l; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> shapeHole = shapeHoles[i];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (ShapeUtils.isClockWise(shapeHole) === <span class="literal">true</span>) &#123;</span><br><span class="line">                        shapeHoles[i] = shapeHole.reverse();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); <span class="comment">// join vertices of inner and outer paths to a single array</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = shapeHoles.length; i &lt; l; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> shapeHole = shapeHoles[i];</span><br><span class="line">                    shapeVertices = shapeVertices.concat(shapeHole);</span><br><span class="line">                &#125; <span class="comment">// vertices, normals, uvs</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = shapeVertices.length; i &lt; l; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> vertex = shapeVertices[i];</span><br><span class="line">                    vertices.push(vertex.x, vertex.y, <span class="number">0</span>);</span><br><span class="line">                    normals.push(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                    uvs.push(vertex.x, vertex.y); <span class="comment">// world uvs</span></span><br><span class="line">                &#125; <span class="comment">// incides</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = faces.length; i &lt; l; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> face = faces[i];</span><br><span class="line">                    <span class="keyword">const</span> a = face[<span class="number">0</span>] + indexOffset;</span><br><span class="line">                    <span class="keyword">const</span> b = face[<span class="number">1</span>] + indexOffset;</span><br><span class="line">                    <span class="keyword">const</span> c = face[<span class="number">2</span>] + indexOffset;</span><br><span class="line">                    indices.push(a, b, c);</span><br><span class="line">                    groupCount += <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON();</span><br><span class="line">            <span class="keyword">const</span> shapes = <span class="built_in">this</span>.parameters.shapes;</span><br><span class="line">            <span class="keyword">return</span> toJSON(shapes, data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">fromJSON</span>(<span class="params">data, shapes</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> geometryShapes = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, jl = data.shapes.length; j &lt; jl; j++) &#123;</span><br><span class="line">                <span class="keyword">const</span> shape = shapes[data.shapes[j]];</span><br><span class="line">                geometryShapes.push(shape);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ShapeGeometry(geometryShapes, data.curveSegments);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">toJSON</span>(<span class="params">shapes, data</span>) </span>&#123;</span><br><span class="line">        data.shapes = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(shapes)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = shapes.length; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> shape = shapes[i];</span><br><span class="line">                data.shapes.push(shape.uuid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data.shapes.push(shapes.uuid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SphereGeometry</span> <span class="keyword">extends</span> <span class="title">BufferGeometry</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">radius = <span class="number">1</span>, widthSegments = <span class="number">32</span>, heightSegments = <span class="number">16</span>, phiStart = <span class="number">0</span>, phiLength = <span class="built_in">Math</span>.PI * <span class="number">2</span>, thetaStart = <span class="number">0</span>, thetaLength = <span class="built_in">Math</span>.PI</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;SphereGeometry&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.parameters = &#123;</span><br><span class="line">                <span class="attr">radius</span>: radius,</span><br><span class="line">                <span class="attr">widthSegments</span>: widthSegments,</span><br><span class="line">                <span class="attr">heightSegments</span>: heightSegments,</span><br><span class="line">                <span class="attr">phiStart</span>: phiStart,</span><br><span class="line">                <span class="attr">phiLength</span>: phiLength,</span><br><span class="line">                <span class="attr">thetaStart</span>: thetaStart,</span><br><span class="line">                <span class="attr">thetaLength</span>: thetaLength</span><br><span class="line">            &#125;;</span><br><span class="line">            widthSegments = <span class="built_in">Math</span>.max(<span class="number">3</span>, <span class="built_in">Math</span>.floor(widthSegments));</span><br><span class="line">            heightSegments = <span class="built_in">Math</span>.max(<span class="number">2</span>, <span class="built_in">Math</span>.floor(heightSegments));</span><br><span class="line">            <span class="keyword">const</span> thetaEnd = <span class="built_in">Math</span>.min(thetaStart + thetaLength, <span class="built_in">Math</span>.PI);</span><br><span class="line">            <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> grid = [];</span><br><span class="line">            <span class="keyword">const</span> vertex = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> normal = <span class="keyword">new</span> Vector3(); <span class="comment">// buffers</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> indices = [];</span><br><span class="line">            <span class="keyword">const</span> vertices = [];</span><br><span class="line">            <span class="keyword">const</span> normals = [];</span><br><span class="line">            <span class="keyword">const</span> uvs = []; <span class="comment">// generate vertices, normals and uvs</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> iy = <span class="number">0</span>; iy &lt;= heightSegments; iy++) &#123;</span><br><span class="line">                <span class="keyword">const</span> verticesRow = [];</span><br><span class="line">                <span class="keyword">const</span> v = iy / heightSegments; <span class="comment">// special case for the poles</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> uOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (iy == <span class="number">0</span> &amp;&amp; thetaStart == <span class="number">0</span>) &#123;</span><br><span class="line">                    uOffset = <span class="number">0.5</span> / widthSegments;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iy == heightSegments &amp;&amp; thetaEnd == <span class="built_in">Math</span>.PI) &#123;</span><br><span class="line">                    uOffset = -<span class="number">0.5</span> / widthSegments;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> ix = <span class="number">0</span>; ix &lt;= widthSegments; ix++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> u = ix / widthSegments; <span class="comment">// vertex</span></span><br><span class="line"></span><br><span class="line">                    vertex.x = -radius * <span class="built_in">Math</span>.cos(phiStart + u * phiLength) * <span class="built_in">Math</span>.sin(thetaStart + v * thetaLength);</span><br><span class="line">                    vertex.y = radius * <span class="built_in">Math</span>.cos(thetaStart + v * thetaLength);</span><br><span class="line">                    vertex.z = radius * <span class="built_in">Math</span>.sin(phiStart + u * phiLength) * <span class="built_in">Math</span>.sin(thetaStart + v * thetaLength);</span><br><span class="line">                    vertices.push(vertex.x, vertex.y, vertex.z); <span class="comment">// normal</span></span><br><span class="line"></span><br><span class="line">                    normal.copy(vertex).normalize();</span><br><span class="line">                    normals.push(normal.x, normal.y, normal.z); <span class="comment">// uv</span></span><br><span class="line"></span><br><span class="line">                    uvs.push(u + uOffset, <span class="number">1</span> - v);</span><br><span class="line">                    verticesRow.push(index++);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                grid.push(verticesRow);</span><br><span class="line">            &#125; <span class="comment">// indices</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> iy = <span class="number">0</span>; iy &lt; heightSegments; iy++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> ix = <span class="number">0</span>; ix &lt; widthSegments; ix++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> a = grid[iy][ix + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">const</span> b = grid[iy][ix];</span><br><span class="line">                    <span class="keyword">const</span> c = grid[iy + <span class="number">1</span>][ix];</span><br><span class="line">                    <span class="keyword">const</span> d = grid[iy + <span class="number">1</span>][ix + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (iy !== <span class="number">0</span> || thetaStart &gt; <span class="number">0</span>) indices.push(a, b, d);</span><br><span class="line">                    <span class="keyword">if</span> (iy !== heightSegments - <span class="number">1</span> || thetaEnd &lt; <span class="built_in">Math</span>.PI) indices.push(b, c, d);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// build geometry</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setIndex(indices);</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(vertices, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;normal&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(normals, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;uv&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(uvs, <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">fromJSON</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TetrahedronGeometry</span> <span class="keyword">extends</span> <span class="title">PolyhedronGeometry</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">radius = <span class="number">1</span>, detail = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> vertices = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">const</span> indices = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">super</span>(vertices, indices, radius, detail);</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;TetrahedronGeometry&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.parameters = &#123;</span><br><span class="line">                <span class="attr">radius</span>: radius,</span><br><span class="line">                <span class="attr">detail</span>: detail</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">fromJSON</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TetrahedronGeometry(data.radius, data.detail);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TorusGeometry</span> <span class="keyword">extends</span> <span class="title">BufferGeometry</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">radius = <span class="number">1</span>, tube = <span class="number">0.4</span>, radialSegments = <span class="number">8</span>, tubularSegments = <span class="number">6</span>, arc = <span class="built_in">Math</span>.PI * <span class="number">2</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;TorusGeometry&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.parameters = &#123;</span><br><span class="line">                <span class="attr">radius</span>: radius,</span><br><span class="line">                <span class="attr">tube</span>: tube,</span><br><span class="line">                <span class="attr">radialSegments</span>: radialSegments,</span><br><span class="line">                <span class="attr">tubularSegments</span>: tubularSegments,</span><br><span class="line">                <span class="attr">arc</span>: arc</span><br><span class="line">            &#125;;</span><br><span class="line">            radialSegments = <span class="built_in">Math</span>.floor(radialSegments);</span><br><span class="line">            tubularSegments = <span class="built_in">Math</span>.floor(tubularSegments); <span class="comment">// buffers</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> indices = [];</span><br><span class="line">            <span class="keyword">const</span> vertices = [];</span><br><span class="line">            <span class="keyword">const</span> normals = [];</span><br><span class="line">            <span class="keyword">const</span> uvs = []; <span class="comment">// helper variables</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> center = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> vertex = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> normal = <span class="keyword">new</span> Vector3(); <span class="comment">// generate vertices, normals and uvs</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= radialSegments; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= tubularSegments; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> u = i / tubularSegments * arc;</span><br><span class="line">                    <span class="keyword">const</span> v = j / radialSegments * <span class="built_in">Math</span>.PI * <span class="number">2</span>; <span class="comment">// vertex</span></span><br><span class="line"></span><br><span class="line">                    vertex.x = (radius + tube * <span class="built_in">Math</span>.cos(v)) * <span class="built_in">Math</span>.cos(u);</span><br><span class="line">                    vertex.y = (radius + tube * <span class="built_in">Math</span>.cos(v)) * <span class="built_in">Math</span>.sin(u);</span><br><span class="line">                    vertex.z = tube * <span class="built_in">Math</span>.sin(v);</span><br><span class="line">                    vertices.push(vertex.x, vertex.y, vertex.z); <span class="comment">// normal</span></span><br><span class="line"></span><br><span class="line">                    center.x = radius * <span class="built_in">Math</span>.cos(u);</span><br><span class="line">                    center.y = radius * <span class="built_in">Math</span>.sin(u);</span><br><span class="line">                    normal.subVectors(vertex, center).normalize();</span><br><span class="line">                    normals.push(normal.x, normal.y, normal.z); <span class="comment">// uv</span></span><br><span class="line"></span><br><span class="line">                    uvs.push(i / tubularSegments);</span><br><span class="line">                    uvs.push(j / radialSegments);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// generate indices</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= radialSegments; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= tubularSegments; i++) &#123;</span><br><span class="line">                    <span class="comment">// indices</span></span><br><span class="line">                    <span class="keyword">const</span> a = (tubularSegments + <span class="number">1</span>) * j + i - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">const</span> b = (tubularSegments + <span class="number">1</span>) * (j - <span class="number">1</span>) + i - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">const</span> c = (tubularSegments + <span class="number">1</span>) * (j - <span class="number">1</span>) + i;</span><br><span class="line">                    <span class="keyword">const</span> d = (tubularSegments + <span class="number">1</span>) * j + i; <span class="comment">// faces</span></span><br><span class="line"></span><br><span class="line">                    indices.push(a, b, d);</span><br><span class="line">                    indices.push(b, c, d);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// build geometry</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setIndex(indices);</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(vertices, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;normal&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(normals, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;uv&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(uvs, <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">fromJSON</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TorusKnotGeometry</span> <span class="keyword">extends</span> <span class="title">BufferGeometry</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">radius = <span class="number">1</span>, tube = <span class="number">0.4</span>, tubularSegments = <span class="number">64</span>, radialSegments = <span class="number">8</span>, p = <span class="number">2</span>, q = <span class="number">3</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;TorusKnotGeometry&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.parameters = &#123;</span><br><span class="line">                <span class="attr">radius</span>: radius,</span><br><span class="line">                <span class="attr">tube</span>: tube,</span><br><span class="line">                <span class="attr">tubularSegments</span>: tubularSegments,</span><br><span class="line">                <span class="attr">radialSegments</span>: radialSegments,</span><br><span class="line">                <span class="attr">p</span>: p,</span><br><span class="line">                <span class="attr">q</span>: q</span><br><span class="line">            &#125;;</span><br><span class="line">            tubularSegments = <span class="built_in">Math</span>.floor(tubularSegments);</span><br><span class="line">            radialSegments = <span class="built_in">Math</span>.floor(radialSegments); <span class="comment">// buffers</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> indices = [];</span><br><span class="line">            <span class="keyword">const</span> vertices = [];</span><br><span class="line">            <span class="keyword">const</span> normals = [];</span><br><span class="line">            <span class="keyword">const</span> uvs = []; <span class="comment">// helper variables</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> vertex = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> normal = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> P1 = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> P2 = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> B = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> T = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> N = <span class="keyword">new</span> Vector3(); <span class="comment">// generate vertices, normals and uvs</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= tubularSegments; ++i) &#123;</span><br><span class="line">                <span class="comment">// the radian &quot;u&quot; is used to calculate the position on the torus curve of the current tubular segment</span></span><br><span class="line">                <span class="keyword">const</span> u = i / tubularSegments * p * <span class="built_in">Math</span>.PI * <span class="number">2</span>; <span class="comment">// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.</span></span><br><span class="line">                <span class="comment">// these points are used to create a special &quot;coordinate space&quot;, which is necessary to calculate the correct vertex positions</span></span><br><span class="line"></span><br><span class="line">                calculatePositionOnCurve(u, p, q, radius, P1);</span><br><span class="line">                calculatePositionOnCurve(u + <span class="number">0.01</span>, p, q, radius, P2); <span class="comment">// calculate orthonormal basis</span></span><br><span class="line"></span><br><span class="line">                T.subVectors(P2, P1);</span><br><span class="line">                N.addVectors(P2, P1);</span><br><span class="line">                B.crossVectors(T, N);</span><br><span class="line">                N.crossVectors(B, T); <span class="comment">// normalize B, N. T can be ignored, we don&#x27;t use it</span></span><br><span class="line"></span><br><span class="line">                B.normalize();</span><br><span class="line">                N.normalize();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= radialSegments; ++j) &#123;</span><br><span class="line">                    <span class="comment">// now calculate the vertices. they are nothing more than an extrusion of the torus curve.</span></span><br><span class="line">                    <span class="comment">// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.</span></span><br><span class="line">                    <span class="keyword">const</span> v = j / radialSegments * <span class="built_in">Math</span>.PI * <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">const</span> cx = -tube * <span class="built_in">Math</span>.cos(v);</span><br><span class="line">                    <span class="keyword">const</span> cy = tube * <span class="built_in">Math</span>.sin(v); <span class="comment">// now calculate the final vertex position.</span></span><br><span class="line">                    <span class="comment">// first we orient the extrusion with our basis vectors, then we add it to the current position on the curve</span></span><br><span class="line"></span><br><span class="line">                    vertex.x = P1.x + (cx * N.x + cy * B.x);</span><br><span class="line">                    vertex.y = P1.y + (cx * N.y + cy * B.y);</span><br><span class="line">                    vertex.z = P1.z + (cx * N.z + cy * B.z);</span><br><span class="line">                    vertices.push(vertex.x, vertex.y, vertex.z); <span class="comment">// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)</span></span><br><span class="line"></span><br><span class="line">                    normal.subVectors(vertex, P1).normalize();</span><br><span class="line">                    normals.push(normal.x, normal.y, normal.z); <span class="comment">// uv</span></span><br><span class="line"></span><br><span class="line">                    uvs.push(i / tubularSegments);</span><br><span class="line">                    uvs.push(j / radialSegments);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// generate indices</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= tubularSegments; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= radialSegments; i++) &#123;</span><br><span class="line">                    <span class="comment">// indices</span></span><br><span class="line">                    <span class="keyword">const</span> a = (radialSegments + <span class="number">1</span>) * (j - <span class="number">1</span>) + (i - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">const</span> b = (radialSegments + <span class="number">1</span>) * j + (i - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">const</span> c = (radialSegments + <span class="number">1</span>) * j + i;</span><br><span class="line">                    <span class="keyword">const</span> d = (radialSegments + <span class="number">1</span>) * (j - <span class="number">1</span>) + i; <span class="comment">// faces</span></span><br><span class="line"></span><br><span class="line">                    indices.push(a, b, d);</span><br><span class="line">                    indices.push(b, c, d);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// build geometry</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setIndex(indices);</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(vertices, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;normal&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(normals, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;uv&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(uvs, <span class="number">2</span>)); <span class="comment">// this function calculates the current position on the torus curve</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">calculatePositionOnCurve</span>(<span class="params">u, p, q, radius, position</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> cu = <span class="built_in">Math</span>.cos(u);</span><br><span class="line">                <span class="keyword">const</span> su = <span class="built_in">Math</span>.sin(u);</span><br><span class="line">                <span class="keyword">const</span> quOverP = q / p * u;</span><br><span class="line">                <span class="keyword">const</span> cs = <span class="built_in">Math</span>.cos(quOverP);</span><br><span class="line">                position.x = radius * (<span class="number">2</span> + cs) * <span class="number">0.5</span> * cu;</span><br><span class="line">                position.y = radius * (<span class="number">2</span> + cs) * su * <span class="number">0.5</span>;</span><br><span class="line">                position.z = radius * <span class="built_in">Math</span>.sin(quOverP) * <span class="number">0.5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">fromJSON</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TubeGeometry</span> <span class="keyword">extends</span> <span class="title">BufferGeometry</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">path = <span class="keyword">new</span> QuadraticBezierCurve3(<span class="keyword">new</span> Vector3(-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>), <span class="keyword">new</span> Vector3(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>)), tubularSegments = <span class="number">64</span>, radius = <span class="number">1</span>, radialSegments = <span class="number">8</span>, closed = <span class="literal">false</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;TubeGeometry&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.parameters = &#123;</span><br><span class="line">                <span class="attr">path</span>: path,</span><br><span class="line">                <span class="attr">tubularSegments</span>: tubularSegments,</span><br><span class="line">                <span class="attr">radius</span>: radius,</span><br><span class="line">                <span class="attr">radialSegments</span>: radialSegments,</span><br><span class="line">                <span class="attr">closed</span>: closed</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">const</span> frames = path.computeFrenetFrames(tubularSegments, closed); <span class="comment">// expose internals</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.tangents = frames.tangents;</span><br><span class="line">            <span class="built_in">this</span>.normals = frames.normals;</span><br><span class="line">            <span class="built_in">this</span>.binormals = frames.binormals; <span class="comment">// helper variables</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> vertex = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> normal = <span class="keyword">new</span> Vector3();</span><br><span class="line">            <span class="keyword">const</span> uv = <span class="keyword">new</span> Vector2();</span><br><span class="line">            <span class="keyword">let</span> P = <span class="keyword">new</span> Vector3(); <span class="comment">// buffer</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> vertices = [];</span><br><span class="line">            <span class="keyword">const</span> normals = [];</span><br><span class="line">            <span class="keyword">const</span> uvs = [];</span><br><span class="line">            <span class="keyword">const</span> indices = []; <span class="comment">// create buffer data</span></span><br><span class="line"></span><br><span class="line">            generateBufferData(); <span class="comment">// build geometry</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setIndex(indices);</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(vertices, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;normal&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(normals, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;uv&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(uvs, <span class="number">2</span>)); <span class="comment">// functions</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">generateBufferData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tubularSegments; i++) &#123;</span><br><span class="line">                    generateSegment(i);</span><br><span class="line">                &#125; <span class="comment">// if the geometry is not closed, generate the last row of vertices and normals</span></span><br><span class="line">                <span class="comment">// at the regular position on the given path</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                generateSegment(closed === <span class="literal">false</span> ? tubularSegments : <span class="number">0</span>); <span class="comment">// uvs are generated in a separate function.</span></span><br><span class="line">                <span class="comment">// this makes it easy compute correct values for closed geometries</span></span><br><span class="line"></span><br><span class="line">                generateUVs(); <span class="comment">// finally create faces</span></span><br><span class="line"></span><br><span class="line">                generateIndices();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">generateSegment</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// we use getPointAt to sample evenly distributed points from the given path</span></span><br><span class="line">                P = path.getPointAt(i / tubularSegments, P); <span class="comment">// retrieve corresponding normal and binormal</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> N = frames.normals[i];</span><br><span class="line">                <span class="keyword">const</span> B = frames.binormals[i]; <span class="comment">// generate normals and vertices for the current segment</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= radialSegments; j++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> v = j / radialSegments * <span class="built_in">Math</span>.PI * <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">const</span> sin = <span class="built_in">Math</span>.sin(v);</span><br><span class="line">                    <span class="keyword">const</span> cos = -<span class="built_in">Math</span>.cos(v); <span class="comment">// normal</span></span><br><span class="line"></span><br><span class="line">                    normal.x = cos * N.x + sin * B.x;</span><br><span class="line">                    normal.y = cos * N.y + sin * B.y;</span><br><span class="line">                    normal.z = cos * N.z + sin * B.z;</span><br><span class="line">                    normal.normalize();</span><br><span class="line">                    normals.push(normal.x, normal.y, normal.z); <span class="comment">// vertex</span></span><br><span class="line"></span><br><span class="line">                    vertex.x = P.x + radius * normal.x;</span><br><span class="line">                    vertex.y = P.y + radius * normal.y;</span><br><span class="line">                    vertex.z = P.z + radius * normal.z;</span><br><span class="line">                    vertices.push(vertex.x, vertex.y, vertex.z);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">generateIndices</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= tubularSegments; j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= radialSegments; i++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> a = (radialSegments + <span class="number">1</span>) * (j - <span class="number">1</span>) + (i - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">const</span> b = (radialSegments + <span class="number">1</span>) * j + (i - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">const</span> c = (radialSegments + <span class="number">1</span>) * j + i;</span><br><span class="line">                        <span class="keyword">const</span> d = (radialSegments + <span class="number">1</span>) * (j - <span class="number">1</span>) + i; <span class="comment">// faces</span></span><br><span class="line"></span><br><span class="line">                        indices.push(a, b, d);</span><br><span class="line">                        indices.push(b, c, d);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">generateUVs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= tubularSegments; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= radialSegments; j++) &#123;</span><br><span class="line">                        uv.x = i / tubularSegments;</span><br><span class="line">                        uv.y = j / radialSegments;</span><br><span class="line">                        uvs.push(uv.x, uv.y);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON();</span><br><span class="line">            data.path = <span class="built_in">this</span>.parameters.path.toJSON();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">fromJSON</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// This only works for built-in curves (e.g. CatmullRomCurve3).</span></span><br><span class="line">            <span class="comment">// User defined curves or instances of CurvePath will not be deserialized.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TubeGeometry(<span class="keyword">new</span> Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WireframeGeometry</span> <span class="keyword">extends</span> <span class="title">BufferGeometry</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">geometry = <span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;WireframeGeometry&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.parameters = &#123;</span><br><span class="line">                <span class="attr">geometry</span>: geometry</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (geometry !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// buffer</span></span><br><span class="line">                <span class="keyword">const</span> vertices = [];</span><br><span class="line">                <span class="keyword">const</span> edges = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// helper variables</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> start = <span class="keyword">new</span> Vector3();</span><br><span class="line">                <span class="keyword">const</span> end = <span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (geometry.index !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// indexed BufferGeometry</span></span><br><span class="line">                    <span class="keyword">const</span> position = geometry.attributes.position;</span><br><span class="line">                    <span class="keyword">const</span> indices = geometry.index;</span><br><span class="line">                    <span class="keyword">let</span> groups = geometry.groups;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (groups.length === <span class="number">0</span>) &#123;</span><br><span class="line">                        groups = [&#123;</span><br><span class="line">                            <span class="attr">start</span>: <span class="number">0</span>,</span><br><span class="line">                            <span class="attr">count</span>: indices.count,</span><br><span class="line">                            <span class="attr">materialIndex</span>: <span class="number">0</span></span><br><span class="line">                        &#125;];</span><br><span class="line">                    &#125; <span class="comment">// create a data structure that contains all edges without duplicates</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> o = <span class="number">0</span>, ol = groups.length; o &lt; ol; ++o) &#123;</span><br><span class="line">                        <span class="keyword">const</span> group = groups[o];</span><br><span class="line">                        <span class="keyword">const</span> groupStart = group.start;</span><br><span class="line">                        <span class="keyword">const</span> groupCount = group.count;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> i = groupStart, l = groupStart + groupCount; i &lt; l; i += <span class="number">3</span>) &#123;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                                <span class="keyword">const</span> index1 = indices.getX(i + j);</span><br><span class="line">                                <span class="keyword">const</span> index2 = indices.getX(i + (j + <span class="number">1</span>) % <span class="number">3</span>);</span><br><span class="line">                                start.fromBufferAttribute(position, index1);</span><br><span class="line">                                end.fromBufferAttribute(position, index2);</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (isUniqueEdge(start, end, edges) === <span class="literal">true</span>) &#123;</span><br><span class="line">                                    vertices.push(start.x, start.y, start.z);</span><br><span class="line">                                    vertices.push(end.x, end.y, end.z);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// non-indexed BufferGeometry</span></span><br><span class="line">                    <span class="keyword">const</span> position = geometry.attributes.position;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = position.count / <span class="number">3</span>; i &lt; l; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                            <span class="comment">// three edges per triangle, an edge is represented as (index1, index2)</span></span><br><span class="line">                            <span class="comment">// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)</span></span><br><span class="line">                            <span class="keyword">const</span> index1 = <span class="number">3</span> * i + j;</span><br><span class="line">                            <span class="keyword">const</span> index2 = <span class="number">3</span> * i + (j + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">                            start.fromBufferAttribute(position, index1);</span><br><span class="line">                            end.fromBufferAttribute(position, index2);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (isUniqueEdge(start, end, edges) === <span class="literal">true</span>) &#123;</span><br><span class="line">                                vertices.push(start.x, start.y, start.z);</span><br><span class="line">                                vertices.push(end.x, end.y, end.z);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="comment">// build geometry</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(vertices, <span class="number">3</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isUniqueEdge</span>(<span class="params">start, end, edges</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> hash1 = <span class="string">`<span class="subst">$&#123;start.x&#125;</span>,<span class="subst">$&#123;start.y&#125;</span>,<span class="subst">$&#123;start.z&#125;</span>-<span class="subst">$&#123;end.x&#125;</span>,<span class="subst">$&#123;end.y&#125;</span>,<span class="subst">$&#123;end.z&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">const</span> hash2 = <span class="string">`<span class="subst">$&#123;end.x&#125;</span>,<span class="subst">$&#123;end.y&#125;</span>,<span class="subst">$&#123;end.z&#125;</span>-<span class="subst">$&#123;start.x&#125;</span>,<span class="subst">$&#123;start.y&#125;</span>,<span class="subst">$&#123;start.z&#125;</span>`</span>; <span class="comment">// coincident edge</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (edges.has(hash1) === <span class="literal">true</span> || edges.has(hash2) === <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            edges.add(hash1);</span><br><span class="line">            edges.add(hash2);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> Geometries = <span class="comment">/*#__PURE__*/</span><span class="built_in">Object</span>.freeze(&#123;</span><br><span class="line">        <span class="attr">__proto__</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">BoxGeometry</span>: BoxGeometry,</span><br><span class="line">        <span class="attr">BoxBufferGeometry</span>: BoxGeometry,</span><br><span class="line">        <span class="attr">CapsuleGeometry</span>: CapsuleGeometry,</span><br><span class="line">        <span class="attr">CapsuleBufferGeometry</span>: CapsuleGeometry,</span><br><span class="line">        <span class="attr">CircleGeometry</span>: CircleGeometry,</span><br><span class="line">        <span class="attr">CircleBufferGeometry</span>: CircleGeometry,</span><br><span class="line">        <span class="attr">ConeGeometry</span>: ConeGeometry,</span><br><span class="line">        <span class="attr">ConeBufferGeometry</span>: ConeGeometry,</span><br><span class="line">        <span class="attr">CylinderGeometry</span>: CylinderGeometry,</span><br><span class="line">        <span class="attr">CylinderBufferGeometry</span>: CylinderGeometry,</span><br><span class="line">        <span class="attr">DodecahedronGeometry</span>: DodecahedronGeometry,</span><br><span class="line">        <span class="attr">DodecahedronBufferGeometry</span>: DodecahedronGeometry,</span><br><span class="line">        <span class="attr">EdgesGeometry</span>: EdgesGeometry,</span><br><span class="line">        <span class="attr">ExtrudeGeometry</span>: ExtrudeGeometry,</span><br><span class="line">        <span class="attr">ExtrudeBufferGeometry</span>: ExtrudeGeometry,</span><br><span class="line">        <span class="attr">IcosahedronGeometry</span>: IcosahedronGeometry,</span><br><span class="line">        <span class="attr">IcosahedronBufferGeometry</span>: IcosahedronGeometry,</span><br><span class="line">        <span class="attr">LatheGeometry</span>: LatheGeometry,</span><br><span class="line">        <span class="attr">LatheBufferGeometry</span>: LatheGeometry,</span><br><span class="line">        <span class="attr">OctahedronGeometry</span>: OctahedronGeometry,</span><br><span class="line">        <span class="attr">OctahedronBufferGeometry</span>: OctahedronGeometry,</span><br><span class="line">        <span class="attr">PlaneGeometry</span>: PlaneGeometry,</span><br><span class="line">        <span class="attr">PlaneBufferGeometry</span>: PlaneGeometry,</span><br><span class="line">        <span class="attr">PolyhedronGeometry</span>: PolyhedronGeometry,</span><br><span class="line">        <span class="attr">PolyhedronBufferGeometry</span>: PolyhedronGeometry,</span><br><span class="line">        <span class="attr">RingGeometry</span>: RingGeometry,</span><br><span class="line">        <span class="attr">RingBufferGeometry</span>: RingGeometry,</span><br><span class="line">        <span class="attr">ShapeGeometry</span>: ShapeGeometry,</span><br><span class="line">        <span class="attr">ShapeBufferGeometry</span>: ShapeGeometry,</span><br><span class="line">        <span class="attr">SphereGeometry</span>: SphereGeometry,</span><br><span class="line">        <span class="attr">SphereBufferGeometry</span>: SphereGeometry,</span><br><span class="line">        <span class="attr">TetrahedronGeometry</span>: TetrahedronGeometry,</span><br><span class="line">        <span class="attr">TetrahedronBufferGeometry</span>: TetrahedronGeometry,</span><br><span class="line">        <span class="attr">TorusGeometry</span>: TorusGeometry,</span><br><span class="line">        <span class="attr">TorusBufferGeometry</span>: TorusGeometry,</span><br><span class="line">        <span class="attr">TorusKnotGeometry</span>: TorusKnotGeometry,</span><br><span class="line">        <span class="attr">TorusKnotBufferGeometry</span>: TorusKnotGeometry,</span><br><span class="line">        <span class="attr">TubeGeometry</span>: TubeGeometry,</span><br><span class="line">        <span class="attr">TubeBufferGeometry</span>: TubeGeometry,</span><br><span class="line">        <span class="attr">WireframeGeometry</span>: WireframeGeometry</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ShadowMaterial</span> <span class="keyword">extends</span> <span class="title">Material</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameters</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;ShadowMaterial&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.color = <span class="keyword">new</span> Color(<span class="number">0x000000</span>);</span><br><span class="line">            <span class="built_in">this</span>.transparent = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.setValues(parameters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.color.copy(source.color);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ShadowMaterial.prototype.isShadowMaterial = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RawShaderMaterial</span> <span class="keyword">extends</span> <span class="title">ShaderMaterial</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameters</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(parameters);</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;RawShaderMaterial&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RawShaderMaterial.prototype.isRawShaderMaterial = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MeshStandardMaterial</span> <span class="keyword">extends</span> <span class="title">Material</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameters</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.defines = &#123;</span><br><span class="line">                <span class="string">&#x27;STANDARD&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;MeshStandardMaterial&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.color = <span class="keyword">new</span> Color(<span class="number">0xffffff</span>); <span class="comment">// diffuse</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.roughness = <span class="number">1.0</span>;</span><br><span class="line">            <span class="built_in">this</span>.metalness = <span class="number">0.0</span>;</span><br><span class="line">            <span class="built_in">this</span>.map = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.lightMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.lightMapIntensity = <span class="number">1.0</span>;</span><br><span class="line">            <span class="built_in">this</span>.aoMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.aoMapIntensity = <span class="number">1.0</span>;</span><br><span class="line">            <span class="built_in">this</span>.emissive = <span class="keyword">new</span> Color(<span class="number">0x000000</span>);</span><br><span class="line">            <span class="built_in">this</span>.emissiveIntensity = <span class="number">1.0</span>;</span><br><span class="line">            <span class="built_in">this</span>.emissiveMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.bumpMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.bumpScale = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.normalMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.normalMapType = TangentSpaceNormalMap;</span><br><span class="line">            <span class="built_in">this</span>.normalScale = <span class="keyword">new</span> Vector2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.displacementMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.displacementScale = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.displacementBias = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.roughnessMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.metalnessMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.alphaMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.envMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.envMapIntensity = <span class="number">1.0</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframe = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinewidth = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinecap = <span class="string">&#x27;round&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinejoin = <span class="string">&#x27;round&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.flatShading = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.setValues(parameters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.defines = &#123;</span><br><span class="line">                <span class="string">&#x27;STANDARD&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">this</span>.color.copy(source.color);</span><br><span class="line">            <span class="built_in">this</span>.roughness = source.roughness;</span><br><span class="line">            <span class="built_in">this</span>.metalness = source.metalness;</span><br><span class="line">            <span class="built_in">this</span>.map = source.map;</span><br><span class="line">            <span class="built_in">this</span>.lightMap = source.lightMap;</span><br><span class="line">            <span class="built_in">this</span>.lightMapIntensity = source.lightMapIntensity;</span><br><span class="line">            <span class="built_in">this</span>.aoMap = source.aoMap;</span><br><span class="line">            <span class="built_in">this</span>.aoMapIntensity = source.aoMapIntensity;</span><br><span class="line">            <span class="built_in">this</span>.emissive.copy(source.emissive);</span><br><span class="line">            <span class="built_in">this</span>.emissiveMap = source.emissiveMap;</span><br><span class="line">            <span class="built_in">this</span>.emissiveIntensity = source.emissiveIntensity;</span><br><span class="line">            <span class="built_in">this</span>.bumpMap = source.bumpMap;</span><br><span class="line">            <span class="built_in">this</span>.bumpScale = source.bumpScale;</span><br><span class="line">            <span class="built_in">this</span>.normalMap = source.normalMap;</span><br><span class="line">            <span class="built_in">this</span>.normalMapType = source.normalMapType;</span><br><span class="line">            <span class="built_in">this</span>.normalScale.copy(source.normalScale);</span><br><span class="line">            <span class="built_in">this</span>.displacementMap = source.displacementMap;</span><br><span class="line">            <span class="built_in">this</span>.displacementScale = source.displacementScale;</span><br><span class="line">            <span class="built_in">this</span>.displacementBias = source.displacementBias;</span><br><span class="line">            <span class="built_in">this</span>.roughnessMap = source.roughnessMap;</span><br><span class="line">            <span class="built_in">this</span>.metalnessMap = source.metalnessMap;</span><br><span class="line">            <span class="built_in">this</span>.alphaMap = source.alphaMap;</span><br><span class="line">            <span class="built_in">this</span>.envMap = source.envMap;</span><br><span class="line">            <span class="built_in">this</span>.envMapIntensity = source.envMapIntensity;</span><br><span class="line">            <span class="built_in">this</span>.wireframe = source.wireframe;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinewidth = source.wireframeLinewidth;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinecap = source.wireframeLinecap;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinejoin = source.wireframeLinejoin;</span><br><span class="line">            <span class="built_in">this</span>.flatShading = source.flatShading;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MeshStandardMaterial.prototype.isMeshStandardMaterial = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MeshPhysicalMaterial</span> <span class="keyword">extends</span> <span class="title">MeshStandardMaterial</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameters</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.defines = &#123;</span><br><span class="line">                <span class="string">&#x27;STANDARD&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;PHYSICAL&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;MeshPhysicalMaterial&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.clearcoatMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.clearcoatRoughness = <span class="number">0.0</span>;</span><br><span class="line">            <span class="built_in">this</span>.clearcoatRoughnessMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.clearcoatNormalScale = <span class="keyword">new</span> Vector2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.clearcoatNormalMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.ior = <span class="number">1.5</span>;</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, <span class="string">&#x27;reflectivity&#x27;</span>, &#123;</span><br><span class="line">                <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> clamp(<span class="number">2.5</span> * (<span class="built_in">this</span>.ior - <span class="number">1</span>) / (<span class="built_in">this</span>.ior + <span class="number">1</span>), <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">reflectivity</span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.ior = (<span class="number">1</span> + <span class="number">0.4</span> * reflectivity) / (<span class="number">1</span> - <span class="number">0.4</span> * reflectivity);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">this</span>.sheenColor = <span class="keyword">new</span> Color(<span class="number">0x000000</span>);</span><br><span class="line">            <span class="built_in">this</span>.sheenColorMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.sheenRoughness = <span class="number">1.0</span>;</span><br><span class="line">            <span class="built_in">this</span>.sheenRoughnessMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.transmissionMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.thickness = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.thicknessMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.attenuationDistance = <span class="number">0.0</span>;</span><br><span class="line">            <span class="built_in">this</span>.attenuationColor = <span class="keyword">new</span> Color(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.specularIntensity = <span class="number">1.0</span>;</span><br><span class="line">            <span class="built_in">this</span>.specularIntensityMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.specularColor = <span class="keyword">new</span> Color(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.specularColorMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>._sheen = <span class="number">0.0</span>;</span><br><span class="line">            <span class="built_in">this</span>._clearcoat = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>._transmission = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.setValues(parameters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">sheen</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._sheen;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">sheen</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._sheen &gt; <span class="number">0</span> !== value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.version++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._sheen = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">clearcoat</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._clearcoat;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">clearcoat</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._clearcoat &gt; <span class="number">0</span> !== value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.version++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._clearcoat = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">transmission</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._transmission;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">transmission</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._transmission &gt; <span class="number">0</span> !== value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.version++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._transmission = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.defines = &#123;</span><br><span class="line">                <span class="string">&#x27;STANDARD&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;PHYSICAL&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">this</span>.clearcoat = source.clearcoat;</span><br><span class="line">            <span class="built_in">this</span>.clearcoatMap = source.clearcoatMap;</span><br><span class="line">            <span class="built_in">this</span>.clearcoatRoughness = source.clearcoatRoughness;</span><br><span class="line">            <span class="built_in">this</span>.clearcoatRoughnessMap = source.clearcoatRoughnessMap;</span><br><span class="line">            <span class="built_in">this</span>.clearcoatNormalMap = source.clearcoatNormalMap;</span><br><span class="line">            <span class="built_in">this</span>.clearcoatNormalScale.copy(source.clearcoatNormalScale);</span><br><span class="line">            <span class="built_in">this</span>.ior = source.ior;</span><br><span class="line">            <span class="built_in">this</span>.sheen = source.sheen;</span><br><span class="line">            <span class="built_in">this</span>.sheenColor.copy(source.sheenColor);</span><br><span class="line">            <span class="built_in">this</span>.sheenColorMap = source.sheenColorMap;</span><br><span class="line">            <span class="built_in">this</span>.sheenRoughness = source.sheenRoughness;</span><br><span class="line">            <span class="built_in">this</span>.sheenRoughnessMap = source.sheenRoughnessMap;</span><br><span class="line">            <span class="built_in">this</span>.transmission = source.transmission;</span><br><span class="line">            <span class="built_in">this</span>.transmissionMap = source.transmissionMap;</span><br><span class="line">            <span class="built_in">this</span>.thickness = source.thickness;</span><br><span class="line">            <span class="built_in">this</span>.thicknessMap = source.thicknessMap;</span><br><span class="line">            <span class="built_in">this</span>.attenuationDistance = source.attenuationDistance;</span><br><span class="line">            <span class="built_in">this</span>.attenuationColor.copy(source.attenuationColor);</span><br><span class="line">            <span class="built_in">this</span>.specularIntensity = source.specularIntensity;</span><br><span class="line">            <span class="built_in">this</span>.specularIntensityMap = source.specularIntensityMap;</span><br><span class="line">            <span class="built_in">this</span>.specularColor.copy(source.specularColor);</span><br><span class="line">            <span class="built_in">this</span>.specularColorMap = source.specularColorMap;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MeshPhongMaterial</span> <span class="keyword">extends</span> <span class="title">Material</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameters</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;MeshPhongMaterial&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.color = <span class="keyword">new</span> Color(<span class="number">0xffffff</span>); <span class="comment">// diffuse</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.specular = <span class="keyword">new</span> Color(<span class="number">0x111111</span>);</span><br><span class="line">            <span class="built_in">this</span>.shininess = <span class="number">30</span>;</span><br><span class="line">            <span class="built_in">this</span>.map = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.lightMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.lightMapIntensity = <span class="number">1.0</span>;</span><br><span class="line">            <span class="built_in">this</span>.aoMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.aoMapIntensity = <span class="number">1.0</span>;</span><br><span class="line">            <span class="built_in">this</span>.emissive = <span class="keyword">new</span> Color(<span class="number">0x000000</span>);</span><br><span class="line">            <span class="built_in">this</span>.emissiveIntensity = <span class="number">1.0</span>;</span><br><span class="line">            <span class="built_in">this</span>.emissiveMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.bumpMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.bumpScale = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.normalMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.normalMapType = TangentSpaceNormalMap;</span><br><span class="line">            <span class="built_in">this</span>.normalScale = <span class="keyword">new</span> Vector2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.displacementMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.displacementScale = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.displacementBias = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.specularMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.alphaMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.envMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.combine = MultiplyOperation;</span><br><span class="line">            <span class="built_in">this</span>.reflectivity = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.refractionRatio = <span class="number">0.98</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframe = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinewidth = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinecap = <span class="string">&#x27;round&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinejoin = <span class="string">&#x27;round&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.flatShading = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.setValues(parameters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.color.copy(source.color);</span><br><span class="line">            <span class="built_in">this</span>.specular.copy(source.specular);</span><br><span class="line">            <span class="built_in">this</span>.shininess = source.shininess;</span><br><span class="line">            <span class="built_in">this</span>.map = source.map;</span><br><span class="line">            <span class="built_in">this</span>.lightMap = source.lightMap;</span><br><span class="line">            <span class="built_in">this</span>.lightMapIntensity = source.lightMapIntensity;</span><br><span class="line">            <span class="built_in">this</span>.aoMap = source.aoMap;</span><br><span class="line">            <span class="built_in">this</span>.aoMapIntensity = source.aoMapIntensity;</span><br><span class="line">            <span class="built_in">this</span>.emissive.copy(source.emissive);</span><br><span class="line">            <span class="built_in">this</span>.emissiveMap = source.emissiveMap;</span><br><span class="line">            <span class="built_in">this</span>.emissiveIntensity = source.emissiveIntensity;</span><br><span class="line">            <span class="built_in">this</span>.bumpMap = source.bumpMap;</span><br><span class="line">            <span class="built_in">this</span>.bumpScale = source.bumpScale;</span><br><span class="line">            <span class="built_in">this</span>.normalMap = source.normalMap;</span><br><span class="line">            <span class="built_in">this</span>.normalMapType = source.normalMapType;</span><br><span class="line">            <span class="built_in">this</span>.normalScale.copy(source.normalScale);</span><br><span class="line">            <span class="built_in">this</span>.displacementMap = source.displacementMap;</span><br><span class="line">            <span class="built_in">this</span>.displacementScale = source.displacementScale;</span><br><span class="line">            <span class="built_in">this</span>.displacementBias = source.displacementBias;</span><br><span class="line">            <span class="built_in">this</span>.specularMap = source.specularMap;</span><br><span class="line">            <span class="built_in">this</span>.alphaMap = source.alphaMap;</span><br><span class="line">            <span class="built_in">this</span>.envMap = source.envMap;</span><br><span class="line">            <span class="built_in">this</span>.combine = source.combine;</span><br><span class="line">            <span class="built_in">this</span>.reflectivity = source.reflectivity;</span><br><span class="line">            <span class="built_in">this</span>.refractionRatio = source.refractionRatio;</span><br><span class="line">            <span class="built_in">this</span>.wireframe = source.wireframe;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinewidth = source.wireframeLinewidth;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinecap = source.wireframeLinecap;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinejoin = source.wireframeLinejoin;</span><br><span class="line">            <span class="built_in">this</span>.flatShading = source.flatShading;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MeshPhongMaterial.prototype.isMeshPhongMaterial = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MeshToonMaterial</span> <span class="keyword">extends</span> <span class="title">Material</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameters</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.defines = &#123;</span><br><span class="line">                <span class="string">&#x27;TOON&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;MeshToonMaterial&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.color = <span class="keyword">new</span> Color(<span class="number">0xffffff</span>);</span><br><span class="line">            <span class="built_in">this</span>.map = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.gradientMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.lightMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.lightMapIntensity = <span class="number">1.0</span>;</span><br><span class="line">            <span class="built_in">this</span>.aoMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.aoMapIntensity = <span class="number">1.0</span>;</span><br><span class="line">            <span class="built_in">this</span>.emissive = <span class="keyword">new</span> Color(<span class="number">0x000000</span>);</span><br><span class="line">            <span class="built_in">this</span>.emissiveIntensity = <span class="number">1.0</span>;</span><br><span class="line">            <span class="built_in">this</span>.emissiveMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.bumpMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.bumpScale = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.normalMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.normalMapType = TangentSpaceNormalMap;</span><br><span class="line">            <span class="built_in">this</span>.normalScale = <span class="keyword">new</span> Vector2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.displacementMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.displacementScale = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.displacementBias = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.alphaMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframe = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinewidth = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinecap = <span class="string">&#x27;round&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinejoin = <span class="string">&#x27;round&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.setValues(parameters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.color.copy(source.color);</span><br><span class="line">            <span class="built_in">this</span>.map = source.map;</span><br><span class="line">            <span class="built_in">this</span>.gradientMap = source.gradientMap;</span><br><span class="line">            <span class="built_in">this</span>.lightMap = source.lightMap;</span><br><span class="line">            <span class="built_in">this</span>.lightMapIntensity = source.lightMapIntensity;</span><br><span class="line">            <span class="built_in">this</span>.aoMap = source.aoMap;</span><br><span class="line">            <span class="built_in">this</span>.aoMapIntensity = source.aoMapIntensity;</span><br><span class="line">            <span class="built_in">this</span>.emissive.copy(source.emissive);</span><br><span class="line">            <span class="built_in">this</span>.emissiveMap = source.emissiveMap;</span><br><span class="line">            <span class="built_in">this</span>.emissiveIntensity = source.emissiveIntensity;</span><br><span class="line">            <span class="built_in">this</span>.bumpMap = source.bumpMap;</span><br><span class="line">            <span class="built_in">this</span>.bumpScale = source.bumpScale;</span><br><span class="line">            <span class="built_in">this</span>.normalMap = source.normalMap;</span><br><span class="line">            <span class="built_in">this</span>.normalMapType = source.normalMapType;</span><br><span class="line">            <span class="built_in">this</span>.normalScale.copy(source.normalScale);</span><br><span class="line">            <span class="built_in">this</span>.displacementMap = source.displacementMap;</span><br><span class="line">            <span class="built_in">this</span>.displacementScale = source.displacementScale;</span><br><span class="line">            <span class="built_in">this</span>.displacementBias = source.displacementBias;</span><br><span class="line">            <span class="built_in">this</span>.alphaMap = source.alphaMap;</span><br><span class="line">            <span class="built_in">this</span>.wireframe = source.wireframe;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinewidth = source.wireframeLinewidth;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinecap = source.wireframeLinecap;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinejoin = source.wireframeLinejoin;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MeshToonMaterial.prototype.isMeshToonMaterial = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MeshNormalMaterial</span> <span class="keyword">extends</span> <span class="title">Material</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameters</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;MeshNormalMaterial&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.bumpMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.bumpScale = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.normalMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.normalMapType = TangentSpaceNormalMap;</span><br><span class="line">            <span class="built_in">this</span>.normalScale = <span class="keyword">new</span> Vector2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.displacementMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.displacementScale = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.displacementBias = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframe = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinewidth = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.fog = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.flatShading = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.setValues(parameters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.bumpMap = source.bumpMap;</span><br><span class="line">            <span class="built_in">this</span>.bumpScale = source.bumpScale;</span><br><span class="line">            <span class="built_in">this</span>.normalMap = source.normalMap;</span><br><span class="line">            <span class="built_in">this</span>.normalMapType = source.normalMapType;</span><br><span class="line">            <span class="built_in">this</span>.normalScale.copy(source.normalScale);</span><br><span class="line">            <span class="built_in">this</span>.displacementMap = source.displacementMap;</span><br><span class="line">            <span class="built_in">this</span>.displacementScale = source.displacementScale;</span><br><span class="line">            <span class="built_in">this</span>.displacementBias = source.displacementBias;</span><br><span class="line">            <span class="built_in">this</span>.wireframe = source.wireframe;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinewidth = source.wireframeLinewidth;</span><br><span class="line">            <span class="built_in">this</span>.flatShading = source.flatShading;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MeshNormalMaterial.prototype.isMeshNormalMaterial = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MeshLambertMaterial</span> <span class="keyword">extends</span> <span class="title">Material</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameters</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;MeshLambertMaterial&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.color = <span class="keyword">new</span> Color(<span class="number">0xffffff</span>); <span class="comment">// diffuse</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.map = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.lightMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.lightMapIntensity = <span class="number">1.0</span>;</span><br><span class="line">            <span class="built_in">this</span>.aoMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.aoMapIntensity = <span class="number">1.0</span>;</span><br><span class="line">            <span class="built_in">this</span>.emissive = <span class="keyword">new</span> Color(<span class="number">0x000000</span>);</span><br><span class="line">            <span class="built_in">this</span>.emissiveIntensity = <span class="number">1.0</span>;</span><br><span class="line">            <span class="built_in">this</span>.emissiveMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.specularMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.alphaMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.envMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.combine = MultiplyOperation;</span><br><span class="line">            <span class="built_in">this</span>.reflectivity = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.refractionRatio = <span class="number">0.98</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframe = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinewidth = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinecap = <span class="string">&#x27;round&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinejoin = <span class="string">&#x27;round&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.setValues(parameters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.color.copy(source.color);</span><br><span class="line">            <span class="built_in">this</span>.map = source.map;</span><br><span class="line">            <span class="built_in">this</span>.lightMap = source.lightMap;</span><br><span class="line">            <span class="built_in">this</span>.lightMapIntensity = source.lightMapIntensity;</span><br><span class="line">            <span class="built_in">this</span>.aoMap = source.aoMap;</span><br><span class="line">            <span class="built_in">this</span>.aoMapIntensity = source.aoMapIntensity;</span><br><span class="line">            <span class="built_in">this</span>.emissive.copy(source.emissive);</span><br><span class="line">            <span class="built_in">this</span>.emissiveMap = source.emissiveMap;</span><br><span class="line">            <span class="built_in">this</span>.emissiveIntensity = source.emissiveIntensity;</span><br><span class="line">            <span class="built_in">this</span>.specularMap = source.specularMap;</span><br><span class="line">            <span class="built_in">this</span>.alphaMap = source.alphaMap;</span><br><span class="line">            <span class="built_in">this</span>.envMap = source.envMap;</span><br><span class="line">            <span class="built_in">this</span>.combine = source.combine;</span><br><span class="line">            <span class="built_in">this</span>.reflectivity = source.reflectivity;</span><br><span class="line">            <span class="built_in">this</span>.refractionRatio = source.refractionRatio;</span><br><span class="line">            <span class="built_in">this</span>.wireframe = source.wireframe;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinewidth = source.wireframeLinewidth;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinecap = source.wireframeLinecap;</span><br><span class="line">            <span class="built_in">this</span>.wireframeLinejoin = source.wireframeLinejoin;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MeshLambertMaterial.prototype.isMeshLambertMaterial = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MeshMatcapMaterial</span> <span class="keyword">extends</span> <span class="title">Material</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameters</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.defines = &#123;</span><br><span class="line">                <span class="string">&#x27;MATCAP&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;MeshMatcapMaterial&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.color = <span class="keyword">new</span> Color(<span class="number">0xffffff</span>); <span class="comment">// diffuse</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.matcap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.map = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.bumpMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.bumpScale = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.normalMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.normalMapType = TangentSpaceNormalMap;</span><br><span class="line">            <span class="built_in">this</span>.normalScale = <span class="keyword">new</span> Vector2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.displacementMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.displacementScale = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.displacementBias = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.alphaMap = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.flatShading = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.setValues(parameters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.defines = &#123;</span><br><span class="line">                <span class="string">&#x27;MATCAP&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">this</span>.color.copy(source.color);</span><br><span class="line">            <span class="built_in">this</span>.matcap = source.matcap;</span><br><span class="line">            <span class="built_in">this</span>.map = source.map;</span><br><span class="line">            <span class="built_in">this</span>.bumpMap = source.bumpMap;</span><br><span class="line">            <span class="built_in">this</span>.bumpScale = source.bumpScale;</span><br><span class="line">            <span class="built_in">this</span>.normalMap = source.normalMap;</span><br><span class="line">            <span class="built_in">this</span>.normalMapType = source.normalMapType;</span><br><span class="line">            <span class="built_in">this</span>.normalScale.copy(source.normalScale);</span><br><span class="line">            <span class="built_in">this</span>.displacementMap = source.displacementMap;</span><br><span class="line">            <span class="built_in">this</span>.displacementScale = source.displacementScale;</span><br><span class="line">            <span class="built_in">this</span>.displacementBias = source.displacementBias;</span><br><span class="line">            <span class="built_in">this</span>.alphaMap = source.alphaMap;</span><br><span class="line">            <span class="built_in">this</span>.flatShading = source.flatShading;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MeshMatcapMaterial.prototype.isMeshMatcapMaterial = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LineDashedMaterial</span> <span class="keyword">extends</span> <span class="title">LineBasicMaterial</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameters</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;LineDashedMaterial&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.scale = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.dashSize = <span class="number">3</span>;</span><br><span class="line">            <span class="built_in">this</span>.gapSize = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.setValues(parameters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.scale = source.scale;</span><br><span class="line">            <span class="built_in">this</span>.dashSize = source.dashSize;</span><br><span class="line">            <span class="built_in">this</span>.gapSize = source.gapSize;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LineDashedMaterial.prototype.isLineDashedMaterial = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> materialLib = &#123;</span><br><span class="line">        ShadowMaterial,</span><br><span class="line">        SpriteMaterial,</span><br><span class="line">        RawShaderMaterial,</span><br><span class="line">        ShaderMaterial,</span><br><span class="line">        PointsMaterial,</span><br><span class="line">        MeshPhysicalMaterial,</span><br><span class="line">        MeshStandardMaterial,</span><br><span class="line">        MeshPhongMaterial,</span><br><span class="line">        MeshToonMaterial,</span><br><span class="line">        MeshNormalMaterial,</span><br><span class="line">        MeshLambertMaterial,</span><br><span class="line">        MeshDepthMaterial,</span><br><span class="line">        MeshDistanceMaterial,</span><br><span class="line">        MeshBasicMaterial,</span><br><span class="line">        MeshMatcapMaterial,</span><br><span class="line">        LineDashedMaterial,</span><br><span class="line">        LineBasicMaterial,</span><br><span class="line">        Material</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Material.fromType = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> materialLib[type]();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> AnimationUtils = &#123;</span><br><span class="line">        <span class="comment">// same as Array.prototype.slice, but also works on typed arrays</span></span><br><span class="line">        <span class="attr">arraySlice</span>: <span class="function"><span class="keyword">function</span> (<span class="params">array, <span class="keyword">from</span>, to</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (AnimationUtils.isTypedArray(array)) &#123;</span><br><span class="line">                <span class="comment">// in ios9 array.subarray(from, undefined) will return empty array</span></span><br><span class="line">                <span class="comment">// but array.subarray(from) or array.subarray(from, len) is correct</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> array.constructor(array.subarray(<span class="keyword">from</span>, to !== <span class="literal">undefined</span> ? to : array.length));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> array.slice(<span class="keyword">from</span>, to);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// converts an array to a specific type</span></span><br><span class="line">        <span class="attr">convertArray</span>: <span class="function"><span class="keyword">function</span> (<span class="params">array, type, forceClone</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!array || <span class="comment">// let &#x27;undefined&#x27; and &#x27;null&#x27; pass</span></span><br><span class="line">                !forceClone &amp;&amp; array.constructor === type) <span class="keyword">return</span> array;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> type.BYTES_PER_ELEMENT === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> type(array); <span class="comment">// create typed array</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(array); <span class="comment">// create Array</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">isTypedArray</span>: <span class="function"><span class="keyword">function</span> (<span class="params">object</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ArrayBuffer</span>.isView(object) &amp;&amp; !(object <span class="keyword">instanceof</span> <span class="built_in">DataView</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// returns an array by which times and values can be sorted</span></span><br><span class="line">        <span class="attr">getKeyframeOrder</span>: <span class="function"><span class="keyword">function</span> (<span class="params">times</span>) </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">compareTime</span>(<span class="params">i, j</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> times[i] - times[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> n = times.length;</span><br><span class="line">            <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i !== n; ++i) result[i] = i;</span><br><span class="line"></span><br><span class="line">            result.sort(compareTime);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// uses the array previously returned by &#x27;getKeyframeOrder&#x27; to sort data</span></span><br><span class="line">        <span class="attr">sortedArray</span>: <span class="function"><span class="keyword">function</span> (<span class="params">values, stride, order</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> nValues = values.length;</span><br><span class="line">            <span class="keyword">const</span> result = <span class="keyword">new</span> values.constructor(nValues);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, dstOffset = <span class="number">0</span>; dstOffset !== nValues; ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> srcOffset = order[i] * stride;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j !== stride; ++j) &#123;</span><br><span class="line">                    result[dstOffset++] = values[srcOffset + j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// function for parsing AOS keyframe formats</span></span><br><span class="line">        <span class="attr">flattenJSON</span>: <span class="function"><span class="keyword">function</span> (<span class="params">jsonKeys, times, values, valuePropertyName</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> i = <span class="number">1</span>,</span><br><span class="line">                key = jsonKeys[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (key !== <span class="literal">undefined</span> &amp;&amp; key[valuePropertyName] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                key = jsonKeys[i++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (key === <span class="literal">undefined</span>) <span class="keyword">return</span>; <span class="comment">// no data</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> value = key[valuePropertyName];</span><br><span class="line">            <span class="keyword">if</span> (value === <span class="literal">undefined</span>) <span class="keyword">return</span>; <span class="comment">// no data</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    value = key[valuePropertyName];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (value !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        times.push(key.time);</span><br><span class="line">                        values.push.apply(values, value); <span class="comment">// push all elements</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    key = jsonKeys[i++];</span><br><span class="line">                &#125; <span class="keyword">while</span> (key !== <span class="literal">undefined</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.toArray !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="comment">// ...assume THREE.Math-ish</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    value = key[valuePropertyName];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (value !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        times.push(key.time);</span><br><span class="line">                        value.toArray(values, values.length);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    key = jsonKeys[i++];</span><br><span class="line">                &#125; <span class="keyword">while</span> (key !== <span class="literal">undefined</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// otherwise push as-is</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    value = key[valuePropertyName];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (value !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        times.push(key.time);</span><br><span class="line">                        values.push(value);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    key = jsonKeys[i++];</span><br><span class="line">                &#125; <span class="keyword">while</span> (key !== <span class="literal">undefined</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">subclip</span>: <span class="function"><span class="keyword">function</span> (<span class="params">sourceClip, name, startFrame, endFrame, fps = <span class="number">30</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> clip = sourceClip.clone();</span><br><span class="line">            clip.name = name;</span><br><span class="line">            <span class="keyword">const</span> tracks = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; clip.tracks.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> track = clip.tracks[i];</span><br><span class="line">                <span class="keyword">const</span> valueSize = track.getValueSize();</span><br><span class="line">                <span class="keyword">const</span> times = [];</span><br><span class="line">                <span class="keyword">const</span> values = [];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; track.times.length; ++j) &#123;</span><br><span class="line">                    <span class="keyword">const</span> frame = track.times[j] * fps;</span><br><span class="line">                    <span class="keyword">if</span> (frame &lt; startFrame || frame &gt;= endFrame) <span class="keyword">continue</span>;</span><br><span class="line">                    times.push(track.times[j]);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; valueSize; ++k) &#123;</span><br><span class="line">                        values.push(track.values[j * valueSize + k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (times.length === <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                track.times = AnimationUtils.convertArray(times, track.times.constructor);</span><br><span class="line">                track.values = AnimationUtils.convertArray(values, track.values.constructor);</span><br><span class="line">                tracks.push(track);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clip.tracks = tracks; <span class="comment">// find minimum .times value across all tracks in the trimmed clip</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> minStartTime = <span class="literal">Infinity</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; clip.tracks.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minStartTime &gt; clip.tracks[i].times[<span class="number">0</span>]) &#123;</span><br><span class="line">                    minStartTime = clip.tracks[i].times[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// shift all tracks such that clip begins at t=0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; clip.tracks.length; ++i) &#123;</span><br><span class="line">                clip.tracks[i].shift(-<span class="number">1</span> * minStartTime);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clip.resetDuration();</span><br><span class="line">            <span class="keyword">return</span> clip;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">makeClipAdditive</span>: <span class="function"><span class="keyword">function</span> (<span class="params">targetClip, referenceFrame = <span class="number">0</span>, referenceClip = targetClip, fps = <span class="number">30</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (fps &lt;= <span class="number">0</span>) fps = <span class="number">30</span>;</span><br><span class="line">            <span class="keyword">const</span> numTracks = referenceClip.tracks.length;</span><br><span class="line">            <span class="keyword">const</span> referenceTime = referenceFrame / fps; <span class="comment">// Make each track&#x27;s values relative to the values at the reference frame</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numTracks; ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> referenceTrack = referenceClip.tracks[i];</span><br><span class="line">                <span class="keyword">const</span> referenceTrackType = referenceTrack.ValueTypeName; <span class="comment">// Skip this track if it&#x27;s non-numeric</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (referenceTrackType === <span class="string">&#x27;bool&#x27;</span> || referenceTrackType === <span class="string">&#x27;string&#x27;</span>) <span class="keyword">continue</span>; <span class="comment">// Find the track in the target clip whose name and type matches the reference track</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> targetTrack = targetClip.tracks.find(<span class="function"><span class="keyword">function</span> (<span class="params">track</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> track.name === referenceTrack.name &amp;&amp; track.ValueTypeName === referenceTrackType;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">if</span> (targetTrack === <span class="literal">undefined</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">let</span> referenceOffset = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">const</span> referenceValueSize = referenceTrack.getValueSize();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) &#123;</span><br><span class="line">                    referenceOffset = referenceValueSize / <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> targetOffset = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">const</span> targetValueSize = targetTrack.getValueSize();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) &#123;</span><br><span class="line">                    targetOffset = targetValueSize / <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> lastIndex = referenceTrack.times.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">let</span> referenceValue; <span class="comment">// Find the value to subtract out of the track</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (referenceTime &lt;= referenceTrack.times[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="comment">// Reference frame is earlier than the first keyframe, so just use the first keyframe</span></span><br><span class="line">                    <span class="keyword">const</span> startIndex = referenceOffset;</span><br><span class="line">                    <span class="keyword">const</span> endIndex = referenceValueSize - referenceOffset;</span><br><span class="line">                    referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (referenceTime &gt;= referenceTrack.times[lastIndex]) &#123;</span><br><span class="line">                    <span class="comment">// Reference frame is after the last keyframe, so just use the last keyframe</span></span><br><span class="line">                    <span class="keyword">const</span> startIndex = lastIndex * referenceValueSize + referenceOffset;</span><br><span class="line">                    <span class="keyword">const</span> endIndex = startIndex + referenceValueSize - referenceOffset;</span><br><span class="line">                    referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Interpolate to the reference value</span></span><br><span class="line">                    <span class="keyword">const</span> interpolant = referenceTrack.createInterpolant();</span><br><span class="line">                    <span class="keyword">const</span> startIndex = referenceOffset;</span><br><span class="line">                    <span class="keyword">const</span> endIndex = referenceValueSize - referenceOffset;</span><br><span class="line">                    interpolant.evaluate(referenceTime);</span><br><span class="line">                    referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);</span><br><span class="line">                &#125; <span class="comment">// Conjugate the quaternion</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (referenceTrackType === <span class="string">&#x27;quaternion&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> referenceQuat = <span class="keyword">new</span> Quaternion().fromArray(referenceValue).normalize().conjugate();</span><br><span class="line">                    referenceQuat.toArray(referenceValue);</span><br><span class="line">                &#125; <span class="comment">// Subtract the reference value from all of the track values</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> numTimes = targetTrack.times.length;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; numTimes; ++j) &#123;</span><br><span class="line">                    <span class="keyword">const</span> valueStart = j * targetValueSize + targetOffset;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (referenceTrackType === <span class="string">&#x27;quaternion&#x27;</span>) &#123;</span><br><span class="line">                        <span class="comment">// Multiply the conjugate for quaternion track types</span></span><br><span class="line">                        Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, <span class="number">0</span>, targetTrack.values, valueStart);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">const</span> valueEnd = targetValueSize - targetOffset * <span class="number">2</span>; <span class="comment">// Subtract each value for all other numeric track types</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; valueEnd; ++k) &#123;</span><br><span class="line">                            targetTrack.values[valueStart + k] -= referenceValue[k];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            targetClip.blendMode = AdditiveAnimationBlendMode;</span><br><span class="line">            <span class="keyword">return</span> targetClip;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Abstract base class of interpolants over parametric samples.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The parameter domain is one dimensional, typically the time or a path</span></span><br><span class="line"><span class="comment">     * along a curve defined by the data.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The sample values can have any dimensionality and derived classes may</span></span><br><span class="line"><span class="comment">     * apply special interpretations to the data.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This class provides the interval seek in a Template Method, deferring</span></span><br><span class="line"><span class="comment">     * the actual interpolation to derived classes.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Time complexity is O(1) for linear access crossing at most two points</span></span><br><span class="line"><span class="comment">     * and O(log N) for random access, where N is the number of positions.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * References:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 		http://www.oodesign.com/template-method-pattern.html</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Interpolant</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameterPositions, sampleValues, sampleSize, resultBuffer</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.parameterPositions = parameterPositions;</span><br><span class="line">            <span class="built_in">this</span>._cachedIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.resultBuffer = resultBuffer !== <span class="literal">undefined</span> ? resultBuffer : <span class="keyword">new</span> sampleValues.constructor(sampleSize);</span><br><span class="line">            <span class="built_in">this</span>.sampleValues = sampleValues;</span><br><span class="line">            <span class="built_in">this</span>.valueSize = sampleSize;</span><br><span class="line">            <span class="built_in">this</span>.settings = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.DefaultSettings_ = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">evaluate</span>(<span class="params">t</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> pp = <span class="built_in">this</span>.parameterPositions;</span><br><span class="line">            <span class="keyword">let</span> i1 = <span class="built_in">this</span>._cachedIndex,</span><br><span class="line">                t1 = pp[i1],</span><br><span class="line">                t0 = pp[i1 - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            validate_interval: &#123;</span><br><span class="line">                <span class="attr">seek</span>: &#123;</span><br><span class="line">                    <span class="keyword">let</span> right;</span><br><span class="line"></span><br><span class="line">                    linear_scan: &#123;</span><br><span class="line">                        <span class="comment">//- See http://jsperf.com/comparison-to-undefined/3</span></span><br><span class="line">                        <span class="comment">//- slower code:</span></span><br><span class="line">                        <span class="comment">//-</span></span><br><span class="line">                        <span class="comment">//- 				if ( t &gt;= t1 || t1 === undefined ) &#123;</span></span><br><span class="line">                        <span class="attr">forward_scan</span>: <span class="keyword">if</span> (!(t &lt; t1)) &#123;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">let</span> giveUpAt = i1 + <span class="number">2</span>;;) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (t1 === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (t &lt; t0) <span class="keyword">break</span> forward_scan; <span class="comment">// after end</span></span><br><span class="line"></span><br><span class="line">                                    i1 = pp.length;</span><br><span class="line">                                    <span class="built_in">this</span>._cachedIndex = i1;</span><br><span class="line">                                    <span class="keyword">return</span> <span class="built_in">this</span>.afterEnd_(i1 - <span class="number">1</span>, t, t0);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (i1 === giveUpAt) <span class="keyword">break</span>; <span class="comment">// this loop</span></span><br><span class="line"></span><br><span class="line">                                t0 = t1;</span><br><span class="line">                                t1 = pp[++i1];</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (t &lt; t1) &#123;</span><br><span class="line">                                    <span class="comment">// we have arrived at the sought interval</span></span><br><span class="line">                                    <span class="keyword">break</span> seek;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="comment">// prepare binary search on the right side of the index</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            right = pp.length;</span><br><span class="line">                            <span class="keyword">break</span> linear_scan;</span><br><span class="line">                        &#125; <span class="comment">//- slower code:</span></span><br><span class="line">                        <span class="comment">//-					if ( t &lt; t0 || t0 === undefined ) &#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!(t &gt;= t0)) &#123;</span><br><span class="line">                            <span class="comment">// looping?</span></span><br><span class="line">                            <span class="keyword">const</span> t1global = pp[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (t &lt; t1global) &#123;</span><br><span class="line">                                i1 = <span class="number">2</span>; <span class="comment">// + 1, using the scan for the details</span></span><br><span class="line"></span><br><span class="line">                                t0 = t1global;</span><br><span class="line">                            &#125; <span class="comment">// linear reverse scan</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">let</span> giveUpAt = i1 - <span class="number">2</span>;;) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (t0 === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                                    <span class="comment">// before start</span></span><br><span class="line">                                    <span class="built_in">this</span>._cachedIndex = <span class="number">0</span>;</span><br><span class="line">                                    <span class="keyword">return</span> <span class="built_in">this</span>.beforeStart_(<span class="number">0</span>, t, t1);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (i1 === giveUpAt) <span class="keyword">break</span>; <span class="comment">// this loop</span></span><br><span class="line"></span><br><span class="line">                                t1 = t0;</span><br><span class="line">                                t0 = pp[--i1 - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (t &gt;= t0) &#123;</span><br><span class="line">                                    <span class="comment">// we have arrived at the sought interval</span></span><br><span class="line">                                    <span class="keyword">break</span> seek;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="comment">// prepare binary search on the left side of the index</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            right = i1;</span><br><span class="line">                            i1 = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">break</span> linear_scan;</span><br><span class="line">                        &#125; <span class="comment">// the interval is valid</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span> validate_interval;</span><br><span class="line">                    &#125; <span class="comment">// linear scan</span></span><br><span class="line">                    <span class="comment">// binary search</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (i1 &lt; right) &#123;</span><br><span class="line">                        <span class="keyword">const</span> mid = i1 + right &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (t &lt; pp[mid]) &#123;</span><br><span class="line">                            right = mid;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            i1 = mid + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    t1 = pp[i1];</span><br><span class="line">                    t0 = pp[i1 - <span class="number">1</span>]; <span class="comment">// check boundary cases, again</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (t0 === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>._cachedIndex = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">this</span>.beforeStart_(<span class="number">0</span>, t, t1);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (t1 === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        i1 = pp.length;</span><br><span class="line">                        <span class="built_in">this</span>._cachedIndex = i1;</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">this</span>.afterEnd_(i1 - <span class="number">1</span>, t0, t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="comment">// seek</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>._cachedIndex = i1;</span><br><span class="line">                <span class="built_in">this</span>.intervalChanged_(i1, t0, t1);</span><br><span class="line">            &#125; <span class="comment">// validate_interval</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.interpolate_(i1, t0, t, t1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getSettings_</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.settings || <span class="built_in">this</span>.DefaultSettings_;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copySampleValue_</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// copies a sample value to the result buffer</span></span><br><span class="line">            <span class="keyword">const</span> result = <span class="built_in">this</span>.resultBuffer,</span><br><span class="line">                values = <span class="built_in">this</span>.sampleValues,</span><br><span class="line">                stride = <span class="built_in">this</span>.valueSize,</span><br><span class="line">                offset = index * stride;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i !== stride; ++i) &#123;</span><br><span class="line">                result[i] = values[offset + i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="comment">// Template methods for derived classes:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">interpolate_</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;call to abstract method&#x27;</span>); <span class="comment">// implementations shall return this.resultBuffer</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intervalChanged_</span>(<span class="params"></span>)</span> &#123;<span class="comment">// empty</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">// ALIAS DEFINITIONS</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;</span><br><span class="line">    Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fast and simple cubic spline interpolant.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * It was derived from a Hermitian construction setting the first derivative</span></span><br><span class="line"><span class="comment">     * at each sample position to the linear slope between neighboring positions</span></span><br><span class="line"><span class="comment">     * over their parameter interval.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CubicInterpolant</span> <span class="keyword">extends</span> <span class="title">Interpolant</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameterPositions, sampleValues, sampleSize, resultBuffer</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(parameterPositions, sampleValues, sampleSize, resultBuffer);</span><br><span class="line">            <span class="built_in">this</span>._weightPrev = -<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>._offsetPrev = -<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>._weightNext = -<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>._offsetNext = -<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.DefaultSettings_ = &#123;</span><br><span class="line">                <span class="attr">endingStart</span>: ZeroCurvatureEnding,</span><br><span class="line">                <span class="attr">endingEnd</span>: ZeroCurvatureEnding</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intervalChanged_</span>(<span class="params">i1, t0, t1</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> pp = <span class="built_in">this</span>.parameterPositions;</span><br><span class="line">            <span class="keyword">let</span> iPrev = i1 - <span class="number">2</span>,</span><br><span class="line">                iNext = i1 + <span class="number">1</span>,</span><br><span class="line">                tPrev = pp[iPrev],</span><br><span class="line">                tNext = pp[iNext];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tPrev === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (<span class="built_in">this</span>.getSettings_().endingStart) &#123;</span><br><span class="line">                    <span class="keyword">case</span> ZeroSlopeEnding:</span><br><span class="line">                        <span class="comment">// f&#x27;(t0) = 0</span></span><br><span class="line">                        iPrev = i1;</span><br><span class="line">                        tPrev = <span class="number">2</span> * t0 - t1;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> WrapAroundEnding:</span><br><span class="line">                        <span class="comment">// use the other end of the curve</span></span><br><span class="line">                        iPrev = pp.length - <span class="number">2</span>;</span><br><span class="line">                        tPrev = t0 + pp[iPrev] - pp[iPrev + <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="comment">// ZeroCurvatureEnding</span></span><br><span class="line">                        <span class="comment">// f&#x27;&#x27;(t0) = 0 a.k.a. Natural Spline</span></span><br><span class="line">                        iPrev = i1;</span><br><span class="line">                        tPrev = t1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tNext === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (<span class="built_in">this</span>.getSettings_().endingEnd) &#123;</span><br><span class="line">                    <span class="keyword">case</span> ZeroSlopeEnding:</span><br><span class="line">                        <span class="comment">// f&#x27;(tN) = 0</span></span><br><span class="line">                        iNext = i1;</span><br><span class="line">                        tNext = <span class="number">2</span> * t1 - t0;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> WrapAroundEnding:</span><br><span class="line">                        <span class="comment">// use the other end of the curve</span></span><br><span class="line">                        iNext = <span class="number">1</span>;</span><br><span class="line">                        tNext = t1 + pp[<span class="number">1</span>] - pp[<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="comment">// ZeroCurvatureEnding</span></span><br><span class="line">                        <span class="comment">// f&#x27;&#x27;(tN) = 0, a.k.a. Natural Spline</span></span><br><span class="line">                        iNext = i1 - <span class="number">1</span>;</span><br><span class="line">                        tNext = t0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> halfDt = (t1 - t0) * <span class="number">0.5</span>,</span><br><span class="line">                stride = <span class="built_in">this</span>.valueSize;</span><br><span class="line">            <span class="built_in">this</span>._weightPrev = halfDt / (t0 - tPrev);</span><br><span class="line">            <span class="built_in">this</span>._weightNext = halfDt / (tNext - t1);</span><br><span class="line">            <span class="built_in">this</span>._offsetPrev = iPrev * stride;</span><br><span class="line">            <span class="built_in">this</span>._offsetNext = iNext * stride;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">interpolate_</span>(<span class="params">i1, t0, t, t1</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = <span class="built_in">this</span>.resultBuffer,</span><br><span class="line">                values = <span class="built_in">this</span>.sampleValues,</span><br><span class="line">                stride = <span class="built_in">this</span>.valueSize,</span><br><span class="line">                o1 = i1 * stride,</span><br><span class="line">                o0 = o1 - stride,</span><br><span class="line">                oP = <span class="built_in">this</span>._offsetPrev,</span><br><span class="line">                oN = <span class="built_in">this</span>._offsetNext,</span><br><span class="line">                wP = <span class="built_in">this</span>._weightPrev,</span><br><span class="line">                wN = <span class="built_in">this</span>._weightNext,</span><br><span class="line">                p = (t - t0) / (t1 - t0),</span><br><span class="line">                pp = p * p,</span><br><span class="line">                ppp = pp * p; <span class="comment">// evaluate polynomials</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> sP = -wP * ppp + <span class="number">2</span> * wP * pp - wP * p;</span><br><span class="line">            <span class="keyword">const</span> s0 = (<span class="number">1</span> + wP) * ppp + (-<span class="number">1.5</span> - <span class="number">2</span> * wP) * pp + (-<span class="number">0.5</span> + wP) * p + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">const</span> s1 = (-<span class="number">1</span> - wN) * ppp + (<span class="number">1.5</span> + wN) * pp + <span class="number">0.5</span> * p;</span><br><span class="line">            <span class="keyword">const</span> sN = wN * ppp - wN * pp; <span class="comment">// combine data linearly</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i !== stride; ++i) &#123;</span><br><span class="line">                result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LinearInterpolant</span> <span class="keyword">extends</span> <span class="title">Interpolant</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameterPositions, sampleValues, sampleSize, resultBuffer</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(parameterPositions, sampleValues, sampleSize, resultBuffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">interpolate_</span>(<span class="params">i1, t0, t, t1</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = <span class="built_in">this</span>.resultBuffer,</span><br><span class="line">                values = <span class="built_in">this</span>.sampleValues,</span><br><span class="line">                stride = <span class="built_in">this</span>.valueSize,</span><br><span class="line">                offset1 = i1 * stride,</span><br><span class="line">                offset0 = offset1 - stride,</span><br><span class="line">                weight1 = (t - t0) / (t1 - t0),</span><br><span class="line">                weight0 = <span class="number">1</span> - weight1;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i !== stride; ++i) &#123;</span><br><span class="line">                result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Interpolant that evaluates to the sample value at the position preceding</span></span><br><span class="line"><span class="comment">     * the parameter.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DiscreteInterpolant</span> <span class="keyword">extends</span> <span class="title">Interpolant</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameterPositions, sampleValues, sampleSize, resultBuffer</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(parameterPositions, sampleValues, sampleSize, resultBuffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">interpolate_</span>(<span class="params">i1</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="comment">/*, t0, t, t1 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">        </span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.copySampleValue_(i1 - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">KeyframeTrack</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">name, times, values, interpolation</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (name === <span class="literal">undefined</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;THREE.KeyframeTrack: track name is undefined&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (times === <span class="literal">undefined</span> || times.length === <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;THREE.KeyframeTrack: no keyframes in track named &#x27;</span> + name);</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.times = AnimationUtils.convertArray(times, <span class="built_in">this</span>.TimeBufferType);</span><br><span class="line">            <span class="built_in">this</span>.values = AnimationUtils.convertArray(values, <span class="built_in">this</span>.ValueBufferType);</span><br><span class="line">            <span class="built_in">this</span>.setInterpolation(interpolation || <span class="built_in">this</span>.DefaultInterpolation);</span><br><span class="line">        &#125; <span class="comment">// Serialization (in static context, because of constructor invocation</span></span><br><span class="line">        <span class="comment">// and automatic invocation of .toJSON):</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">toJSON</span>(<span class="params">track</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> trackType = track.constructor;</span><br><span class="line">            <span class="keyword">let</span> json; <span class="comment">// derived classes can define a static toJSON method</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (trackType.toJSON !== <span class="built_in">this</span>.toJSON) &#123;</span><br><span class="line">                json = trackType.toJSON(track);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// by default, we assume the data can be serialized as-is</span></span><br><span class="line">                json = &#123;</span><br><span class="line">                    <span class="string">&#x27;name&#x27;</span>: track.name,</span><br><span class="line">                    <span class="string">&#x27;times&#x27;</span>: AnimationUtils.convertArray(track.times, <span class="built_in">Array</span>),</span><br><span class="line">                    <span class="string">&#x27;values&#x27;</span>: AnimationUtils.convertArray(track.values, <span class="built_in">Array</span>)</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">const</span> interpolation = track.getInterpolation();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (interpolation !== track.DefaultInterpolation) &#123;</span><br><span class="line">                    json.interpolation = interpolation;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            json.type = track.ValueTypeName; <span class="comment">// mandatory</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> json;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">InterpolantFactoryMethodDiscrete</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DiscreteInterpolant(<span class="built_in">this</span>.times, <span class="built_in">this</span>.values, <span class="built_in">this</span>.getValueSize(), result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">InterpolantFactoryMethodLinear</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LinearInterpolant(<span class="built_in">this</span>.times, <span class="built_in">this</span>.values, <span class="built_in">this</span>.getValueSize(), result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">InterpolantFactoryMethodSmooth</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CubicInterpolant(<span class="built_in">this</span>.times, <span class="built_in">this</span>.values, <span class="built_in">this</span>.getValueSize(), result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setInterpolation</span>(<span class="params">interpolation</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> factoryMethod;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (interpolation) &#123;</span><br><span class="line">                <span class="keyword">case</span> InterpolateDiscrete:</span><br><span class="line">                    factoryMethod = <span class="built_in">this</span>.InterpolantFactoryMethodDiscrete;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> InterpolateLinear:</span><br><span class="line">                    factoryMethod = <span class="built_in">this</span>.InterpolantFactoryMethodLinear;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> InterpolateSmooth:</span><br><span class="line">                    factoryMethod = <span class="built_in">this</span>.InterpolantFactoryMethodSmooth;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (factoryMethod === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> message = <span class="string">&#x27;unsupported interpolation for &#x27;</span> + <span class="built_in">this</span>.ValueTypeName + <span class="string">&#x27; keyframe track named &#x27;</span> + <span class="built_in">this</span>.name;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.createInterpolant === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="comment">// fall back to default, unless the default itself is messed up</span></span><br><span class="line">                    <span class="keyword">if</span> (interpolation !== <span class="built_in">this</span>.DefaultInterpolation) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.setInterpolation(<span class="built_in">this</span>.DefaultInterpolation);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message); <span class="comment">// fatal, in this case</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.KeyframeTrack:&#x27;</span>, message);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.createInterpolant = factoryMethod;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getInterpolation</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">this</span>.createInterpolant) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="built_in">this</span>.InterpolantFactoryMethodDiscrete:</span><br><span class="line">                    <span class="keyword">return</span> InterpolateDiscrete;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="built_in">this</span>.InterpolantFactoryMethodLinear:</span><br><span class="line">                    <span class="keyword">return</span> InterpolateLinear;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="built_in">this</span>.InterpolantFactoryMethodSmooth:</span><br><span class="line">                    <span class="keyword">return</span> InterpolateSmooth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getValueSize</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.values.length / <span class="built_in">this</span>.times.length;</span><br><span class="line">        &#125; <span class="comment">// move all keyframes either forwards or backwards in time</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">shift</span>(<span class="params">timeOffset</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeOffset !== <span class="number">0.0</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> times = <span class="built_in">this</span>.times;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = times.length; i !== n; ++i) &#123;</span><br><span class="line">                    times[i] += timeOffset;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125; <span class="comment">// scale all keyframe times by a factor (useful for frame &lt;-&gt; seconds conversions)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">scale</span>(<span class="params">timeScale</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeScale !== <span class="number">1.0</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> times = <span class="built_in">this</span>.times;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = times.length; i !== n; ++i) &#123;</span><br><span class="line">                    times[i] *= timeScale;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125; <span class="comment">// removes keyframes before and after animation without changing any values within the range [startTime, endTime].</span></span><br><span class="line">        <span class="comment">// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">trim</span>(<span class="params">startTime, endTime</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> times = <span class="built_in">this</span>.times,</span><br><span class="line">                nKeys = times.length;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">from</span> = <span class="number">0</span>,</span><br><span class="line">                to = nKeys - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">from</span> !== nKeys &amp;&amp; times[<span class="keyword">from</span>] &lt; startTime) &#123;</span><br><span class="line">                ++<span class="keyword">from</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (to !== -<span class="number">1</span> &amp;&amp; times[to] &gt; endTime) &#123;</span><br><span class="line">                --to;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++to; <span class="comment">// inclusive -&gt; exclusive bound</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">from</span> !== <span class="number">0</span> || to !== nKeys) &#123;</span><br><span class="line">                <span class="comment">// empty tracks are forbidden, so keep at least one keyframe</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">from</span> &gt;= to) &#123;</span><br><span class="line">                    to = <span class="built_in">Math</span>.max(to, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">from</span> = to - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> stride = <span class="built_in">this</span>.getValueSize();</span><br><span class="line">                <span class="built_in">this</span>.times = AnimationUtils.arraySlice(times, <span class="keyword">from</span>, to);</span><br><span class="line">                <span class="built_in">this</span>.values = AnimationUtils.arraySlice(<span class="built_in">this</span>.values, <span class="keyword">from</span> * stride, to * stride);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125; <span class="comment">// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">validate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">const</span> valueSize = <span class="built_in">this</span>.getValueSize();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (valueSize - <span class="built_in">Math</span>.floor(valueSize) !== <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.KeyframeTrack: Invalid value size in track.&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> times = <span class="built_in">this</span>.times,</span><br><span class="line">                values = <span class="built_in">this</span>.values,</span><br><span class="line">                nKeys = times.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nKeys === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.KeyframeTrack: Track is empty.&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> prevTime = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i !== nKeys; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> currTime = times[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> currTime === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="built_in">isNaN</span>(currTime)) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.KeyframeTrack: Time is not a valid number.&#x27;</span>, <span class="built_in">this</span>, i, currTime);</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (prevTime !== <span class="literal">null</span> &amp;&amp; prevTime &gt; currTime) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.KeyframeTrack: Out of order keys.&#x27;</span>, <span class="built_in">this</span>, i, currTime, prevTime);</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                prevTime = currTime;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (values !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (AnimationUtils.isTypedArray(values)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = values.length; i !== n; ++i) &#123;</span><br><span class="line">                        <span class="keyword">const</span> value = values[i];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">isNaN</span>(value)) &#123;</span><br><span class="line">                            <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.KeyframeTrack: Value is not a valid number.&#x27;</span>, <span class="built_in">this</span>, i, value);</span><br><span class="line">                            valid = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> valid;</span><br><span class="line">        &#125; <span class="comment">// removes equivalent sequential keys as common in morph target sequences</span></span><br><span class="line">        <span class="comment">// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --&gt; (0,0,1,1,0,0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">optimize</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// times or values may be shared with other tracks, so overwriting is unsafe</span></span><br><span class="line">            <span class="keyword">const</span> times = AnimationUtils.arraySlice(<span class="built_in">this</span>.times),</span><br><span class="line">                values = AnimationUtils.arraySlice(<span class="built_in">this</span>.values),</span><br><span class="line">                stride = <span class="built_in">this</span>.getValueSize(),</span><br><span class="line">                smoothInterpolation = <span class="built_in">this</span>.getInterpolation() === InterpolateSmooth,</span><br><span class="line">                lastIndex = times.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">let</span> writeIndex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; lastIndex; ++i) &#123;</span><br><span class="line">                <span class="keyword">let</span> keep = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">const</span> time = times[i];</span><br><span class="line">                <span class="keyword">const</span> timeNext = times[i + <span class="number">1</span>]; <span class="comment">// remove adjacent keyframes scheduled at the same time</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (time !== timeNext &amp;&amp; (i !== <span class="number">1</span> || time !== times[<span class="number">0</span>])) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!smoothInterpolation) &#123;</span><br><span class="line">                        <span class="comment">// remove unnecessary keyframes same as their neighbors</span></span><br><span class="line">                        <span class="keyword">const</span> offset = i * stride,</span><br><span class="line">                            offsetP = offset - stride,</span><br><span class="line">                            offsetN = offset + stride;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j !== stride; ++j) &#123;</span><br><span class="line">                            <span class="keyword">const</span> value = values[offset + j];</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (value !== values[offsetP + j] || value !== values[offsetN + j]) &#123;</span><br><span class="line">                                keep = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        keep = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="comment">// in-place compaction</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (keep) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i !== writeIndex) &#123;</span><br><span class="line">                        times[writeIndex] = times[i];</span><br><span class="line">                        <span class="keyword">const</span> readOffset = i * stride,</span><br><span class="line">                            writeOffset = writeIndex * stride;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j !== stride; ++j) &#123;</span><br><span class="line">                            values[writeOffset + j] = values[readOffset + j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ++writeIndex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// flush last keyframe (compaction looks ahead)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (lastIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                times[writeIndex] = times[lastIndex];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = <span class="number">0</span>; j !== stride; ++j) &#123;</span><br><span class="line">                    values[writeOffset + j] = values[readOffset + j];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ++writeIndex;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (writeIndex !== times.length) &#123;</span><br><span class="line">                <span class="built_in">this</span>.times = AnimationUtils.arraySlice(times, <span class="number">0</span>, writeIndex);</span><br><span class="line">                <span class="built_in">this</span>.values = AnimationUtils.arraySlice(values, <span class="number">0</span>, writeIndex * stride);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.times = times;</span><br><span class="line">                <span class="built_in">this</span>.values = values;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> times = AnimationUtils.arraySlice(<span class="built_in">this</span>.times, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">const</span> values = AnimationUtils.arraySlice(<span class="built_in">this</span>.values, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">const</span> TypedKeyframeTrack = <span class="built_in">this</span>.constructor;</span><br><span class="line">            <span class="keyword">const</span> track = <span class="keyword">new</span> TypedKeyframeTrack(<span class="built_in">this</span>.name, times, values); <span class="comment">// Interpolant argument to constructor is not saved, so copy the factory method directly.</span></span><br><span class="line"></span><br><span class="line">            track.createInterpolant = <span class="built_in">this</span>.createInterpolant;</span><br><span class="line">            <span class="keyword">return</span> track;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KeyframeTrack.prototype.TimeBufferType = <span class="built_in">Float32Array</span>;</span><br><span class="line">    KeyframeTrack.prototype.ValueBufferType = <span class="built_in">Float32Array</span>;</span><br><span class="line">    KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A Track of Boolean keyframe values.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BooleanKeyframeTrack</span> <span class="keyword">extends</span> <span class="title">KeyframeTrack</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    BooleanKeyframeTrack.prototype.ValueTypeName = <span class="string">&#x27;bool&#x27;</span>;</span><br><span class="line">    BooleanKeyframeTrack.prototype.ValueBufferType = <span class="built_in">Array</span>;</span><br><span class="line">    BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;</span><br><span class="line">    BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = <span class="literal">undefined</span>;</span><br><span class="line">    BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = <span class="literal">undefined</span>; <span class="comment">// Note: Actually this track could have a optimized / compressed</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A Track of keyframe values that represent color.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ColorKeyframeTrack</span> <span class="keyword">extends</span> <span class="title">KeyframeTrack</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    ColorKeyframeTrack.prototype.ValueTypeName = <span class="string">&#x27;color&#x27;</span>; <span class="comment">// ValueBufferType is inherited</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A Track of numeric keyframe values.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NumberKeyframeTrack</span> <span class="keyword">extends</span> <span class="title">KeyframeTrack</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    NumberKeyframeTrack.prototype.ValueTypeName = <span class="string">&#x27;number&#x27;</span>; <span class="comment">// ValueBufferType is inherited</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spherical linear unit quaternion interpolant.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">QuaternionLinearInterpolant</span> <span class="keyword">extends</span> <span class="title">Interpolant</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameterPositions, sampleValues, sampleSize, resultBuffer</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(parameterPositions, sampleValues, sampleSize, resultBuffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">interpolate_</span>(<span class="params">i1, t0, t, t1</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = <span class="built_in">this</span>.resultBuffer,</span><br><span class="line">                values = <span class="built_in">this</span>.sampleValues,</span><br><span class="line">                stride = <span class="built_in">this</span>.valueSize,</span><br><span class="line">                alpha = (t - t0) / (t1 - t0);</span><br><span class="line">            <span class="keyword">let</span> offset = i1 * stride;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> end = offset + stride; offset !== end; offset += <span class="number">4</span>) &#123;</span><br><span class="line">                Quaternion.slerpFlat(result, <span class="number">0</span>, values, offset - stride, values, offset, alpha);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A Track of quaternion keyframe values.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">QuaternionKeyframeTrack</span> <span class="keyword">extends</span> <span class="title">KeyframeTrack</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">InterpolantFactoryMethodLinear</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> QuaternionLinearInterpolant(<span class="built_in">this</span>.times, <span class="built_in">this</span>.values, <span class="built_in">this</span>.getValueSize(), result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QuaternionKeyframeTrack.prototype.ValueTypeName = <span class="string">&#x27;quaternion&#x27;</span>; <span class="comment">// ValueBufferType is inherited</span></span><br><span class="line"></span><br><span class="line">    QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;</span><br><span class="line">    QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A Track that interpolates Strings</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">StringKeyframeTrack</span> <span class="keyword">extends</span> <span class="title">KeyframeTrack</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    StringKeyframeTrack.prototype.ValueTypeName = <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">    StringKeyframeTrack.prototype.ValueBufferType = <span class="built_in">Array</span>;</span><br><span class="line">    StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;</span><br><span class="line">    StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = <span class="literal">undefined</span>;</span><br><span class="line">    StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A Track of vectored keyframe values.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">VectorKeyframeTrack</span> <span class="keyword">extends</span> <span class="title">KeyframeTrack</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    VectorKeyframeTrack.prototype.ValueTypeName = <span class="string">&#x27;vector&#x27;</span>; <span class="comment">// ValueBufferType is inherited</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AnimationClip</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">name, duration = -<span class="number">1</span>, tracks, blendMode = NormalAnimationBlendMode</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.tracks = tracks;</span><br><span class="line">            <span class="built_in">this</span>.duration = duration;</span><br><span class="line">            <span class="built_in">this</span>.blendMode = blendMode;</span><br><span class="line">            <span class="built_in">this</span>.uuid = generateUUID(); <span class="comment">// this means it should figure out its duration by scanning the tracks</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.duration &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.resetDuration();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">parse</span>(<span class="params">json</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> tracks = [],</span><br><span class="line">                jsonTracks = json.tracks,</span><br><span class="line">                frameTime = <span class="number">1.0</span> / (json.fps || <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = jsonTracks.length; i !== n; ++i) &#123;</span><br><span class="line">                tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> clip = <span class="keyword">new</span> <span class="built_in">this</span>(json.name, json.duration, tracks, json.blendMode);</span><br><span class="line">            clip.uuid = json.uuid;</span><br><span class="line">            <span class="keyword">return</span> clip;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">toJSON</span>(<span class="params">clip</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> tracks = [],</span><br><span class="line">                clipTracks = clip.tracks;</span><br><span class="line">            <span class="keyword">const</span> json = &#123;</span><br><span class="line">                <span class="string">&#x27;name&#x27;</span>: clip.name,</span><br><span class="line">                <span class="string">&#x27;duration&#x27;</span>: clip.duration,</span><br><span class="line">                <span class="string">&#x27;tracks&#x27;</span>: tracks,</span><br><span class="line">                <span class="string">&#x27;uuid&#x27;</span>: clip.uuid,</span><br><span class="line">                <span class="string">&#x27;blendMode&#x27;</span>: clip.blendMode</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = clipTracks.length; i !== n; ++i) &#123;</span><br><span class="line">                tracks.push(KeyframeTrack.toJSON(clipTracks[i]));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> json;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">CreateFromMorphTargetSequence</span>(<span class="params">name, morphTargetSequence, fps, noLoop</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> numMorphTargets = morphTargetSequence.length;</span><br><span class="line">            <span class="keyword">const</span> tracks = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numMorphTargets; i++) &#123;</span><br><span class="line">                <span class="keyword">let</span> times = [];</span><br><span class="line">                <span class="keyword">let</span> values = [];</span><br><span class="line">                times.push((i + numMorphTargets - <span class="number">1</span>) % numMorphTargets, i, (i + <span class="number">1</span>) % numMorphTargets);</span><br><span class="line">                values.push(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">const</span> order = AnimationUtils.getKeyframeOrder(times);</span><br><span class="line">                times = AnimationUtils.sortedArray(times, <span class="number">1</span>, order);</span><br><span class="line">                values = AnimationUtils.sortedArray(values, <span class="number">1</span>, order); <span class="comment">// if there is a key at the first frame, duplicate it as the</span></span><br><span class="line">                <span class="comment">// last frame as well for perfect loop.</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!noLoop &amp;&amp; times[<span class="number">0</span>] === <span class="number">0</span>) &#123;</span><br><span class="line">                    times.push(numMorphTargets);</span><br><span class="line">                    values.push(values[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                tracks.push(<span class="keyword">new</span> NumberKeyframeTrack(<span class="string">&#x27;.morphTargetInfluences[&#x27;</span> + morphTargetSequence[i].name + <span class="string">&#x27;]&#x27;</span>, times, values).scale(<span class="number">1.0</span> / fps));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>(name, -<span class="number">1</span>, tracks);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">findByName</span>(<span class="params">objectOrClipArray, name</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> clipArray = objectOrClipArray;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(objectOrClipArray)) &#123;</span><br><span class="line">                <span class="keyword">const</span> o = objectOrClipArray;</span><br><span class="line">                clipArray = o.geometry &amp;&amp; o.geometry.animations || o.animations;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; clipArray.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (clipArray[i].name === name) &#123;</span><br><span class="line">                    <span class="keyword">return</span> clipArray[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">CreateClipsFromMorphTargetSequences</span>(<span class="params">morphTargets, fps, noLoop</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> animationToMorphTargets = &#123;&#125;; <span class="comment">// tested with https://regex101.com/ on trick sequences</span></span><br><span class="line">            <span class="comment">// such flamingo_flyA_003, flamingo_run1_003, crdeath0059</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> pattern = <span class="regexp">/^([\w-]*?)([\d]+)$/</span>; <span class="comment">// sort morph target names into animation groups based</span></span><br><span class="line">            <span class="comment">// patterns like Walk_001, Walk_002, Run_001, Run_002</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = morphTargets.length; i &lt; il; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> morphTarget = morphTargets[i];</span><br><span class="line">                <span class="keyword">const</span> parts = morphTarget.name.match(pattern);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (parts &amp;&amp; parts.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> name = parts[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">let</span> animationMorphTargets = animationToMorphTargets[name];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!animationMorphTargets) &#123;</span><br><span class="line">                        animationToMorphTargets[name] = animationMorphTargets = [];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    animationMorphTargets.push(morphTarget);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> clips = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> animationToMorphTargets) &#123;</span><br><span class="line">                clips.push(<span class="built_in">this</span>.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> clips;</span><br><span class="line">        &#125; <span class="comment">// parse the animation.hierarchy format</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">parseAnimation</span>(<span class="params">animation, bones</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!animation) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.AnimationClip: No animation in JSONLoader data.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> addNonemptyTrack = <span class="function"><span class="keyword">function</span> (<span class="params">trackType, trackName, animationKeys, propertyName, destTracks</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// only return track if there are actually keys.</span></span><br><span class="line">                <span class="keyword">if</span> (animationKeys.length !== <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> times = [];</span><br><span class="line">                    <span class="keyword">const</span> values = [];</span><br><span class="line">                    AnimationUtils.flattenJSON(animationKeys, times, values, propertyName); <span class="comment">// empty keys are filtered out, so check again</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (times.length !== <span class="number">0</span>) &#123;</span><br><span class="line">                        destTracks.push(<span class="keyword">new</span> trackType(trackName, times, values));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> tracks = [];</span><br><span class="line">            <span class="keyword">const</span> clipName = animation.name || <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line">            <span class="keyword">const</span> fps = animation.fps || <span class="number">30</span>;</span><br><span class="line">            <span class="keyword">const</span> blendMode = animation.blendMode; <span class="comment">// automatic length determination in AnimationClip.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> duration = animation.length || -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">const</span> hierarchyTracks = animation.hierarchy || [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> h = <span class="number">0</span>; h &lt; hierarchyTracks.length; h++) &#123;</span><br><span class="line">                <span class="keyword">const</span> animationKeys = hierarchyTracks[h].keys; <span class="comment">// skip empty tracks</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!animationKeys || animationKeys.length === <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// process morph targets</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (animationKeys[<span class="number">0</span>].morphTargets) &#123;</span><br><span class="line">                    <span class="comment">// figure out all morph targets used in this track</span></span><br><span class="line">                    <span class="keyword">const</span> morphTargetNames = &#123;&#125;;</span><br><span class="line">                    <span class="keyword">let</span> k;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; animationKeys.length; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (animationKeys[k].morphTargets) &#123;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">let</span> m = <span class="number">0</span>; m &lt; animationKeys[k].morphTargets.length; m++) &#123;</span><br><span class="line">                                morphTargetNames[animationKeys[k].morphTargets[m]] = -<span class="number">1</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="comment">// create a track for each morph target with all zero</span></span><br><span class="line">                    <span class="comment">// morphTargetInfluences except for the keys in which</span></span><br><span class="line">                    <span class="comment">// the morphTarget is named.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">const</span> morphTargetName <span class="keyword">in</span> morphTargetNames) &#123;</span><br><span class="line">                        <span class="keyword">const</span> times = [];</span><br><span class="line">                        <span class="keyword">const</span> values = [];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> m = <span class="number">0</span>; m !== animationKeys[k].morphTargets.length; ++m) &#123;</span><br><span class="line">                            <span class="keyword">const</span> animationKey = animationKeys[k];</span><br><span class="line">                            times.push(animationKey.time);</span><br><span class="line">                            values.push(animationKey.morphTarget === morphTargetName ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        tracks.push(<span class="keyword">new</span> NumberKeyframeTrack(<span class="string">&#x27;.morphTargetInfluence[&#x27;</span> + morphTargetName + <span class="string">&#x27;]&#x27;</span>, times, values));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    duration = morphTargetNames.length * fps;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// ...assume skeletal animation</span></span><br><span class="line">                    <span class="keyword">const</span> boneName = <span class="string">&#x27;.bones[&#x27;</span> + bones[h].name + <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">                    addNonemptyTrack(VectorKeyframeTrack, boneName + <span class="string">&#x27;.position&#x27;</span>, animationKeys, <span class="string">&#x27;pos&#x27;</span>, tracks);</span><br><span class="line">                    addNonemptyTrack(QuaternionKeyframeTrack, boneName + <span class="string">&#x27;.quaternion&#x27;</span>, animationKeys, <span class="string">&#x27;rot&#x27;</span>, tracks);</span><br><span class="line">                    addNonemptyTrack(VectorKeyframeTrack, boneName + <span class="string">&#x27;.scale&#x27;</span>, animationKeys, <span class="string">&#x27;scl&#x27;</span>, tracks);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tracks.length === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> clip = <span class="keyword">new</span> <span class="built_in">this</span>(clipName, duration, tracks, blendMode);</span><br><span class="line">            <span class="keyword">return</span> clip;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">resetDuration</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> tracks = <span class="built_in">this</span>.tracks;</span><br><span class="line">            <span class="keyword">let</span> duration = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = tracks.length; i !== n; ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> track = <span class="built_in">this</span>.tracks[i];</span><br><span class="line">                duration = <span class="built_in">Math</span>.max(duration, track.times[track.times.length - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.duration = duration;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">trim</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.tracks.length; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.tracks[i].trim(<span class="number">0</span>, <span class="built_in">this</span>.duration);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">validate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> valid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.tracks.length; i++) &#123;</span><br><span class="line">                valid = valid &amp;&amp; <span class="built_in">this</span>.tracks[i].validate();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> valid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">optimize</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.tracks.length; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.tracks[i].optimize();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> tracks = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.tracks.length; i++) &#123;</span><br><span class="line">                tracks.push(<span class="built_in">this</span>.tracks[i].clone());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor(<span class="built_in">this</span>.name, <span class="built_in">this</span>.duration, tracks, <span class="built_in">this</span>.blendMode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.constructor.toJSON(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getTrackTypeForValueTypeName</span>(<span class="params">typeName</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (typeName.toLowerCase()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;scalar&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;double&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;float&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;integer&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> NumberKeyframeTrack;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;vector&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;vector2&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;vector3&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;vector4&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> VectorKeyframeTrack;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;color&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> ColorKeyframeTrack;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;quaternion&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> QuaternionKeyframeTrack;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;bool&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;boolean&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> BooleanKeyframeTrack;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> StringKeyframeTrack;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;THREE.KeyframeTrack: Unsupported typeName: &#x27;</span> + typeName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">parseKeyframeTrack</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (json.type === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;THREE.KeyframeTrack: track type undefined, can not parse&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> trackType = getTrackTypeForValueTypeName(json.type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (json.times === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> times = [],</span><br><span class="line">                values = [];</span><br><span class="line">            AnimationUtils.flattenJSON(json.keys, times, values, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">            json.times = times;</span><br><span class="line">            json.values = values;</span><br><span class="line">        &#125; <span class="comment">// derived classes can define a static parse method</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (trackType.parse !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> trackType.parse(json);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// by default, we assume a constructor compatible with the base</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> trackType(json.name, json.times, json.values, json.interpolation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Cache = &#123;</span><br><span class="line">        <span class="attr">enabled</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">files</span>: &#123;&#125;,</span><br><span class="line">        <span class="attr">add</span>: <span class="function"><span class="keyword">function</span> (<span class="params">key, file</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.enabled === <span class="literal">false</span>) <span class="keyword">return</span>; <span class="comment">// console.log( &#x27;THREE.Cache&#x27;, &#x27;Adding key:&#x27;, key );</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.files[key] = file;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.enabled === <span class="literal">false</span>) <span class="keyword">return</span>; <span class="comment">// console.log( &#x27;THREE.Cache&#x27;, &#x27;Checking key:&#x27;, key );</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.files[key];</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">remove</span>: <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>.files[key];</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">clear</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.files = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LoadingManager</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">onLoad, onProgress, onError</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> scope = <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">let</span> isLoading = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">let</span> itemsLoaded = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> itemsTotal = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> urlModifier = <span class="literal">undefined</span>;</span><br><span class="line">            <span class="keyword">const</span> handlers = []; <span class="comment">// Refer to #5689 for the reason why we don&#x27;t set .onStart</span></span><br><span class="line">            <span class="comment">// in the constructor</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.onStart = <span class="literal">undefined</span>;</span><br><span class="line">            <span class="built_in">this</span>.onLoad = onLoad;</span><br><span class="line">            <span class="built_in">this</span>.onProgress = onProgress;</span><br><span class="line">            <span class="built_in">this</span>.onError = onError;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.itemStart = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">                itemsTotal++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isLoading === <span class="literal">false</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (scope.onStart !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        scope.onStart(url, itemsLoaded, itemsTotal);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                isLoading = <span class="literal">true</span>;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.itemEnd = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">                itemsLoaded++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (scope.onProgress !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    scope.onProgress(url, itemsLoaded, itemsTotal);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (itemsLoaded === itemsTotal) &#123;</span><br><span class="line">                    isLoading = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (scope.onLoad !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        scope.onLoad();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.itemError = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (scope.onError !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    scope.onError(url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.resolveURL = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (urlModifier) &#123;</span><br><span class="line">                    <span class="keyword">return</span> urlModifier(url);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> url;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setURLModifier = <span class="function"><span class="keyword">function</span> (<span class="params">transform</span>) </span>&#123;</span><br><span class="line">                urlModifier = transform;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.addHandler = <span class="function"><span class="keyword">function</span> (<span class="params">regex, loader</span>) </span>&#123;</span><br><span class="line">                handlers.push(regex, loader);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.removeHandler = <span class="function"><span class="keyword">function</span> (<span class="params">regex</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> index = handlers.indexOf(regex);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">                    handlers.splice(index, <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.getHandler = <span class="function"><span class="keyword">function</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = handlers.length; i &lt; l; i += <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> regex = handlers[i];</span><br><span class="line">                    <span class="keyword">const</span> loader = handlers[i + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (regex.global) regex.lastIndex = <span class="number">0</span>; <span class="comment">// see #17920</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (regex.test(file)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> loader;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> DefaultLoadingManager = <span class="keyword">new</span> LoadingManager();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Loader</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">manager</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.manager = manager !== <span class="literal">undefined</span> ? manager : DefaultLoadingManager;</span><br><span class="line">            <span class="built_in">this</span>.crossOrigin = <span class="string">&#x27;anonymous&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.withCredentials = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.path = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.resourcePath = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.requestHeader = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">load</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">loadAsync</span>(<span class="params">url, onProgress</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> scope = <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">                scope.load(url, resolve, onProgress, reject);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">parse</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setCrossOrigin</span>(<span class="params">crossOrigin</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.crossOrigin = crossOrigin;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setWithCredentials</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.withCredentials = value;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setPath</span>(<span class="params">path</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.path = path;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setResourcePath</span>(<span class="params">resourcePath</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.resourcePath = resourcePath;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setRequestHeader</span>(<span class="params">requestHeader</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.requestHeader = requestHeader;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> loading = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FileLoader</span> <span class="keyword">extends</span> <span class="title">Loader</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">manager</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(manager);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">load</span>(<span class="params">url, onLoad, onProgress, onError</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (url === <span class="literal">undefined</span>) url = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.path !== <span class="literal">undefined</span>) url = <span class="built_in">this</span>.path + url;</span><br><span class="line">            url = <span class="built_in">this</span>.manager.resolveURL(url);</span><br><span class="line">            <span class="keyword">const</span> cached = Cache.get(url);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cached !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.manager.itemStart(url);</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (onLoad) onLoad(cached);</span><br><span class="line">                    <span class="built_in">this</span>.manager.itemEnd(url);</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> cached;</span><br><span class="line">            &#125; <span class="comment">// Check if request is duplicate</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (loading[url] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                loading[url].push(&#123;</span><br><span class="line">                    <span class="attr">onLoad</span>: onLoad,</span><br><span class="line">                    <span class="attr">onProgress</span>: onProgress,</span><br><span class="line">                    <span class="attr">onError</span>: onError</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="comment">// Initialise array for duplicate requests</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            loading[url] = [];</span><br><span class="line">            loading[url].push(&#123;</span><br><span class="line">                <span class="attr">onLoad</span>: onLoad,</span><br><span class="line">                <span class="attr">onProgress</span>: onProgress,</span><br><span class="line">                <span class="attr">onError</span>: onError</span><br><span class="line">            &#125;); <span class="comment">// create request</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> req = <span class="keyword">new</span> Request(url, &#123;</span><br><span class="line">                <span class="attr">headers</span>: <span class="keyword">new</span> Headers(<span class="built_in">this</span>.requestHeader),</span><br><span class="line">                <span class="attr">credentials</span>: <span class="built_in">this</span>.withCredentials ? <span class="string">&#x27;include&#x27;</span> : <span class="string">&#x27;same-origin&#x27;</span> <span class="comment">// An abort controller could be added within a future PR</span></span><br><span class="line"></span><br><span class="line">            &#125;); <span class="comment">// record states ( avoid data race )</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> mimeType = <span class="built_in">this</span>.mimeType;</span><br><span class="line">            <span class="keyword">const</span> responseType = <span class="built_in">this</span>.responseType; <span class="comment">// start the fetch</span></span><br><span class="line"></span><br><span class="line">            fetch(req).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (response.status === <span class="number">200</span> || response.status === <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// Some browsers return HTTP Status 0 when using non-http protocol</span></span><br><span class="line">                    <span class="comment">// e.g. &#x27;file://&#x27; or &#x27;data://&#x27;. Handle as success.</span></span><br><span class="line">                    <span class="keyword">if</span> (response.status === <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.FileLoader: HTTP Status 0 received.&#x27;</span>);</span><br><span class="line">                    &#125; <span class="comment">// Workaround: Checking if response.body === undefined for Alipay browser #23548</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">typeof</span> ReadableStream === <span class="string">&#x27;undefined&#x27;</span> || response.body === <span class="literal">undefined</span> || response.body.getReader === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> response;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> callbacks = loading[url];</span><br><span class="line">                    <span class="keyword">const</span> reader = response.body.getReader();</span><br><span class="line">                    <span class="keyword">const</span> contentLength = response.headers.get(<span class="string">&#x27;Content-Length&#x27;</span>);</span><br><span class="line">                    <span class="keyword">const</span> total = contentLength ? <span class="built_in">parseInt</span>(contentLength) : <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">const</span> lengthComputable = total !== <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">let</span> loaded = <span class="number">0</span>; <span class="comment">// periodically read data into the new stream tracking while download progress</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> stream = <span class="keyword">new</span> ReadableStream(&#123;</span><br><span class="line">                        <span class="function"><span class="title">start</span>(<span class="params">controller</span>)</span> &#123;</span><br><span class="line">                            readData();</span><br><span class="line"></span><br><span class="line">                            <span class="function"><span class="keyword">function</span> <span class="title">readData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                                reader.read().then(<span class="function">(<span class="params">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                                                        done,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                        value</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                                        controller.close();</span><br><span class="line">                                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        loaded += value.byteLength;</span><br><span class="line">                                        <span class="keyword">const</span> event = <span class="keyword">new</span> ProgressEvent(<span class="string">&#x27;progress&#x27;</span>, &#123;</span><br><span class="line">                                            lengthComputable,</span><br><span class="line">                                            loaded,</span><br><span class="line">                                            total</span><br><span class="line">                                        &#125;);</span><br><span class="line"></span><br><span class="line">                                        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = callbacks.length; i &lt; il; i++) &#123;</span><br><span class="line">                                            <span class="keyword">const</span> callback = callbacks[i];</span><br><span class="line">                                            <span class="keyword">if</span> (callback.onProgress) callback.onProgress(event);</span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                        controller.enqueue(value);</span><br><span class="line">                                        readData();</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Response(stream);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`fetch for &quot;<span class="subst">$&#123;response.url&#125;</span>&quot; responded with <span class="subst">$&#123;response.status&#125;</span>: <span class="subst">$&#123;response.statusText&#125;</span>`</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> (responseType) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;arraybuffer&#x27;</span>:</span><br><span class="line">                        <span class="keyword">return</span> response.arrayBuffer();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;blob&#x27;</span>:</span><br><span class="line">                        <span class="keyword">return</span> response.blob();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;document&#x27;</span>:</span><br><span class="line">                        <span class="keyword">return</span> response.text().then(<span class="function"><span class="params">text</span> =&gt;</span> &#123;</span><br><span class="line">                            <span class="keyword">const</span> parser = <span class="keyword">new</span> DOMParser();</span><br><span class="line">                            <span class="keyword">return</span> parser.parseFromString(text, mimeType);</span><br><span class="line">                        &#125;);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;json&#x27;</span>:</span><br><span class="line">                        <span class="keyword">return</span> response.json();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">if</span> (mimeType === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> response.text();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// sniff encoding</span></span><br><span class="line">                            <span class="keyword">const</span> re = <span class="regexp">/charset=&quot;?([^;&quot;\s]*)&quot;?/i</span>;</span><br><span class="line">                            <span class="keyword">const</span> exec = re.exec(mimeType);</span><br><span class="line">                            <span class="keyword">const</span> label = exec &amp;&amp; exec[<span class="number">1</span>] ? exec[<span class="number">1</span>].toLowerCase() : <span class="literal">undefined</span>;</span><br><span class="line">                            <span class="keyword">const</span> decoder = <span class="keyword">new</span> TextDecoder(label);</span><br><span class="line">                            <span class="keyword">return</span> response.arrayBuffer().then(<span class="function"><span class="params">ab</span> =&gt;</span> decoder.decode(ab));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// Add to cache only on HTTP success, so that we do not cache</span></span><br><span class="line">                <span class="comment">// error response bodies as proper responses to requests.</span></span><br><span class="line">                Cache.add(url, data);</span><br><span class="line">                <span class="keyword">const</span> callbacks = loading[url];</span><br><span class="line">                <span class="keyword">delete</span> loading[url];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = callbacks.length; i &lt; il; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> callback = callbacks[i];</span><br><span class="line">                    <span class="keyword">if</span> (callback.onLoad) callback.onLoad(data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// Abort errors and other errors are handled the same</span></span><br><span class="line">                <span class="keyword">const</span> callbacks = loading[url];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (callbacks === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="comment">// When onLoad was called and url was deleted in `loading`</span></span><br><span class="line">                    <span class="built_in">this</span>.manager.itemError(url);</span><br><span class="line">                    <span class="keyword">throw</span> err;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">delete</span> loading[url];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = callbacks.length; i &lt; il; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> callback = callbacks[i];</span><br><span class="line">                    <span class="keyword">if</span> (callback.onError) callback.onError(err);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.manager.itemError(url);</span><br><span class="line">            &#125;).finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.manager.itemEnd(url);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">this</span>.manager.itemStart(url);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setResponseType</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.responseType = value;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setMimeType</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.mimeType = value;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AnimationLoader</span> <span class="keyword">extends</span> <span class="title">Loader</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">manager</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(manager);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">load</span>(<span class="params">url, onLoad, onProgress, onError</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> scope = <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">const</span> loader = <span class="keyword">new</span> FileLoader(<span class="built_in">this</span>.manager);</span><br><span class="line">            loader.setPath(<span class="built_in">this</span>.path);</span><br><span class="line">            loader.setRequestHeader(<span class="built_in">this</span>.requestHeader);</span><br><span class="line">            loader.setWithCredentials(<span class="built_in">this</span>.withCredentials);</span><br><span class="line">            loader.load(url, <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    onLoad(scope.parse(<span class="built_in">JSON</span>.parse(text)));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (onError) &#123;</span><br><span class="line">                        onError(e);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">console</span>.error(e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    scope.manager.itemError(url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, onProgress, onError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">parse</span>(<span class="params">json</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> animations = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; json.length; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> clip = AnimationClip.parse(json[i]);</span><br><span class="line">                animations.push(clip);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> animations;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Abstract Base class to block based textures loader (dds, pvr, ...)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub classes have to implement the parse() method which will be used in load().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CompressedTextureLoader</span> <span class="keyword">extends</span> <span class="title">Loader</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">manager</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(manager);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">load</span>(<span class="params">url, onLoad, onProgress, onError</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> scope = <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">const</span> images = [];</span><br><span class="line">            <span class="keyword">const</span> texture = <span class="keyword">new</span> CompressedTexture();</span><br><span class="line">            <span class="keyword">const</span> loader = <span class="keyword">new</span> FileLoader(<span class="built_in">this</span>.manager);</span><br><span class="line">            loader.setPath(<span class="built_in">this</span>.path);</span><br><span class="line">            loader.setResponseType(<span class="string">&#x27;arraybuffer&#x27;</span>);</span><br><span class="line">            loader.setRequestHeader(<span class="built_in">this</span>.requestHeader);</span><br><span class="line">            loader.setWithCredentials(scope.withCredentials);</span><br><span class="line">            <span class="keyword">let</span> loaded = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">loadTexture</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">                loader.load(url[i], <span class="function"><span class="keyword">function</span> (<span class="params">buffer</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">const</span> texDatas = scope.parse(buffer, <span class="literal">true</span>);</span><br><span class="line">                    images[i] = &#123;</span><br><span class="line">                        <span class="attr">width</span>: texDatas.width,</span><br><span class="line">                        <span class="attr">height</span>: texDatas.height,</span><br><span class="line">                        <span class="attr">format</span>: texDatas.format,</span><br><span class="line">                        <span class="attr">mipmaps</span>: texDatas.mipmaps</span><br><span class="line">                    &#125;;</span><br><span class="line">                    loaded += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (loaded === <span class="number">6</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (texDatas.mipmapCount === <span class="number">1</span>) texture.minFilter = LinearFilter;</span><br><span class="line">                        texture.image = images;</span><br><span class="line">                        texture.format = texDatas.format;</span><br><span class="line">                        texture.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (onLoad) onLoad(texture);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, onProgress, onError);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(url)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = url.length; i &lt; il; ++i) &#123;</span><br><span class="line">                    loadTexture(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// compressed cubemap texture stored in a single DDS file</span></span><br><span class="line">                loader.load(url, <span class="function"><span class="keyword">function</span> (<span class="params">buffer</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">const</span> texDatas = scope.parse(buffer, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (texDatas.isCubemap) &#123;</span><br><span class="line">                        <span class="keyword">const</span> faces = texDatas.mipmaps.length / texDatas.mipmapCount;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> f = <span class="number">0</span>; f &lt; faces; f++) &#123;</span><br><span class="line">                            images[f] = &#123;</span><br><span class="line">                                <span class="attr">mipmaps</span>: []</span><br><span class="line">                            &#125;;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; texDatas.mipmapCount; i++) &#123;</span><br><span class="line">                                images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);</span><br><span class="line">                                images[f].format = texDatas.format;</span><br><span class="line">                                images[f].width = texDatas.width;</span><br><span class="line">                                images[f].height = texDatas.height;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        texture.image = images;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        texture.image.width = texDatas.width;</span><br><span class="line">                        texture.image.height = texDatas.height;</span><br><span class="line">                        texture.mipmaps = texDatas.mipmaps;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (texDatas.mipmapCount === <span class="number">1</span>) &#123;</span><br><span class="line">                        texture.minFilter = LinearFilter;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    texture.format = texDatas.format;</span><br><span class="line">                    texture.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (onLoad) onLoad(texture);</span><br><span class="line">                &#125;, onProgress, onError);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> texture;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> <span class="keyword">extends</span> <span class="title">Loader</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">manager</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(manager);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">load</span>(<span class="params">url, onLoad, onProgress, onError</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.path !== <span class="literal">undefined</span>) url = <span class="built_in">this</span>.path + url;</span><br><span class="line">            url = <span class="built_in">this</span>.manager.resolveURL(url);</span><br><span class="line">            <span class="keyword">const</span> scope = <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">const</span> cached = Cache.get(url);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cached !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                scope.manager.itemStart(url);</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (onLoad) onLoad(cached);</span><br><span class="line">                    scope.manager.itemEnd(url);</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> cached;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> image = createElementNS(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">onImageLoad</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                removeEventListeners();</span><br><span class="line">                Cache.add(url, <span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">if</span> (onLoad) onLoad(<span class="built_in">this</span>);</span><br><span class="line">                scope.manager.itemEnd(url);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">onImageError</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">                removeEventListeners();</span><br><span class="line">                <span class="keyword">if</span> (onError) onError(event);</span><br><span class="line">                scope.manager.itemError(url);</span><br><span class="line">                scope.manager.itemEnd(url);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">removeEventListeners</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                image.removeEventListener(<span class="string">&#x27;load&#x27;</span>, onImageLoad, <span class="literal">false</span>);</span><br><span class="line">                image.removeEventListener(<span class="string">&#x27;error&#x27;</span>, onImageError, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            image.addEventListener(<span class="string">&#x27;load&#x27;</span>, onImageLoad, <span class="literal">false</span>);</span><br><span class="line">            image.addEventListener(<span class="string">&#x27;error&#x27;</span>, onImageError, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (url.slice(<span class="number">0</span>, <span class="number">5</span>) !== <span class="string">&#x27;data:&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.crossOrigin !== <span class="literal">undefined</span>) image.crossOrigin = <span class="built_in">this</span>.crossOrigin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            scope.manager.itemStart(url);</span><br><span class="line">            image.src = url;</span><br><span class="line">            <span class="keyword">return</span> image;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CubeTextureLoader</span> <span class="keyword">extends</span> <span class="title">Loader</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">manager</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(manager);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">load</span>(<span class="params">urls, onLoad, onProgress, onError</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> texture = <span class="keyword">new</span> CubeTexture();</span><br><span class="line">            <span class="keyword">const</span> loader = <span class="keyword">new</span> ImageLoader(<span class="built_in">this</span>.manager);</span><br><span class="line">            loader.setCrossOrigin(<span class="built_in">this</span>.crossOrigin);</span><br><span class="line">            loader.setPath(<span class="built_in">this</span>.path);</span><br><span class="line">            <span class="keyword">let</span> loaded = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">loadTexture</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">                loader.load(urls[i], <span class="function"><span class="keyword">function</span> (<span class="params">image</span>) </span>&#123;</span><br><span class="line">                    texture.images[i] = image;</span><br><span class="line">                    loaded++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (loaded === <span class="number">6</span>) &#123;</span><br><span class="line">                        texture.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (onLoad) onLoad(texture);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="literal">undefined</span>, onError);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; urls.length; ++i) &#123;</span><br><span class="line">                loadTexture(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> texture;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub classes have to implement the parse() method which will be used in load().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DataTextureLoader</span> <span class="keyword">extends</span> <span class="title">Loader</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">manager</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(manager);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">load</span>(<span class="params">url, onLoad, onProgress, onError</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> scope = <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">const</span> texture = <span class="keyword">new</span> DataTexture();</span><br><span class="line">            <span class="keyword">const</span> loader = <span class="keyword">new</span> FileLoader(<span class="built_in">this</span>.manager);</span><br><span class="line">            loader.setResponseType(<span class="string">&#x27;arraybuffer&#x27;</span>);</span><br><span class="line">            loader.setRequestHeader(<span class="built_in">this</span>.requestHeader);</span><br><span class="line">            loader.setPath(<span class="built_in">this</span>.path);</span><br><span class="line">            loader.setWithCredentials(scope.withCredentials);</span><br><span class="line">            loader.load(url, <span class="function"><span class="keyword">function</span> (<span class="params">buffer</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> texData = scope.parse(buffer);</span><br><span class="line">                <span class="keyword">if</span> (!texData) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (texData.image !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    texture.image = texData.image;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (texData.data !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    texture.image.width = texData.width;</span><br><span class="line">                    texture.image.height = texData.height;</span><br><span class="line">                    texture.image.data = texData.data;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                texture.wrapS = texData.wrapS !== <span class="literal">undefined</span> ? texData.wrapS : ClampToEdgeWrapping;</span><br><span class="line">                texture.wrapT = texData.wrapT !== <span class="literal">undefined</span> ? texData.wrapT : ClampToEdgeWrapping;</span><br><span class="line">                texture.magFilter = texData.magFilter !== <span class="literal">undefined</span> ? texData.magFilter : LinearFilter;</span><br><span class="line">                texture.minFilter = texData.minFilter !== <span class="literal">undefined</span> ? texData.minFilter : LinearFilter;</span><br><span class="line">                texture.anisotropy = texData.anisotropy !== <span class="literal">undefined</span> ? texData.anisotropy : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (texData.encoding !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    texture.encoding = texData.encoding;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (texData.flipY !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    texture.flipY = texData.flipY;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (texData.format !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    texture.format = texData.format;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (texData.type !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    texture.type = texData.type;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (texData.mipmaps !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    texture.mipmaps = texData.mipmaps;</span><br><span class="line">                    texture.minFilter = LinearMipmapLinearFilter; <span class="comment">// presumably...</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (texData.mipmapCount === <span class="number">1</span>) &#123;</span><br><span class="line">                    texture.minFilter = LinearFilter;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (texData.generateMipmaps !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    texture.generateMipmaps = texData.generateMipmaps;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                texture.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (onLoad) onLoad(texture, texData);</span><br><span class="line">            &#125;, onProgress, onError);</span><br><span class="line">            <span class="keyword">return</span> texture;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TextureLoader</span> <span class="keyword">extends</span> <span class="title">Loader</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">manager</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(manager);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">load</span>(<span class="params">url, onLoad, onProgress, onError</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> texture = <span class="keyword">new</span> Texture();</span><br><span class="line">            <span class="keyword">const</span> loader = <span class="keyword">new</span> ImageLoader(<span class="built_in">this</span>.manager);</span><br><span class="line">            loader.setCrossOrigin(<span class="built_in">this</span>.crossOrigin);</span><br><span class="line">            loader.setPath(<span class="built_in">this</span>.path);</span><br><span class="line">            loader.load(url, <span class="function"><span class="keyword">function</span> (<span class="params">image</span>) </span>&#123;</span><br><span class="line">                texture.image = image;</span><br><span class="line">                texture.needsUpdate = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (onLoad !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    onLoad(texture);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, onProgress, onError);</span><br><span class="line">            <span class="keyword">return</span> texture;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Light</span> <span class="keyword">extends</span> <span class="title">Object3D</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">color, intensity = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;Light&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.color = <span class="keyword">new</span> Color(color);</span><br><span class="line">            <span class="built_in">this</span>.intensity = intensity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dispose</span>(<span class="params"></span>)</span> &#123;<span class="comment">// Empty here in base class; some subclasses override.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.color.copy(source.color);</span><br><span class="line">            <span class="built_in">this</span>.intensity = source.intensity;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params">meta</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON(meta);</span><br><span class="line">            data.object.color = <span class="built_in">this</span>.color.getHex();</span><br><span class="line">            data.object.intensity = <span class="built_in">this</span>.intensity;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.groundColor !== <span class="literal">undefined</span>) data.object.groundColor = <span class="built_in">this</span>.groundColor.getHex();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.distance !== <span class="literal">undefined</span>) data.object.distance = <span class="built_in">this</span>.distance;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.angle !== <span class="literal">undefined</span>) data.object.angle = <span class="built_in">this</span>.angle;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.decay !== <span class="literal">undefined</span>) data.object.decay = <span class="built_in">this</span>.decay;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.penumbra !== <span class="literal">undefined</span>) data.object.penumbra = <span class="built_in">this</span>.penumbra;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.shadow !== <span class="literal">undefined</span>) data.object.shadow = <span class="built_in">this</span>.shadow.toJSON();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Light.prototype.isLight = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HemisphereLight</span> <span class="keyword">extends</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">skyColor, groundColor, intensity</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(skyColor, intensity);</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;HemisphereLight&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.position.copy(Object3D.DefaultUp);</span><br><span class="line">            <span class="built_in">this</span>.updateMatrix();</span><br><span class="line">            <span class="built_in">this</span>.groundColor = <span class="keyword">new</span> Color(groundColor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            Light.prototype.copy.call(<span class="built_in">this</span>, source);</span><br><span class="line">            <span class="built_in">this</span>.groundColor.copy(source.groundColor);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HemisphereLight.prototype.isHemisphereLight = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _projScreenMatrix$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Matrix4();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _lightPositionWorld$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _lookTarget$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LightShadow</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">camera</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.camera = camera;</span><br><span class="line">            <span class="built_in">this</span>.bias = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.normalBias = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.radius = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.blurSamples = <span class="number">8</span>;</span><br><span class="line">            <span class="built_in">this</span>.mapSize = <span class="keyword">new</span> Vector2(<span class="number">512</span>, <span class="number">512</span>);</span><br><span class="line">            <span class="built_in">this</span>.map = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.mapPass = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.matrix = <span class="keyword">new</span> Matrix4();</span><br><span class="line">            <span class="built_in">this</span>.autoUpdate = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.needsUpdate = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>._frustum = <span class="keyword">new</span> Frustum();</span><br><span class="line">            <span class="built_in">this</span>._frameExtents = <span class="keyword">new</span> Vector2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>._viewportCount = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>._viewports = [<span class="keyword">new</span> Vector4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>)];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getViewportCount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._viewportCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getFrustum</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._frustum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">updateMatrices</span>(<span class="params">light</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> shadowCamera = <span class="built_in">this</span>.camera;</span><br><span class="line">            <span class="keyword">const</span> shadowMatrix = <span class="built_in">this</span>.matrix;</span><br><span class="line"></span><br><span class="line">            _lightPositionWorld$<span class="number">1.</span>setFromMatrixPosition(light.matrixWorld);</span><br><span class="line"></span><br><span class="line">            shadowCamera.position.copy(_lightPositionWorld$<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            _lookTarget$<span class="number">1.</span>setFromMatrixPosition(light.target.matrixWorld);</span><br><span class="line"></span><br><span class="line">            shadowCamera.lookAt(_lookTarget$<span class="number">1</span>);</span><br><span class="line">            shadowCamera.updateMatrixWorld();</span><br><span class="line"></span><br><span class="line">            _projScreenMatrix$<span class="number">1.</span>multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._frustum.setFromProjectionMatrix(_projScreenMatrix$<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            shadowMatrix.set(<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">            shadowMatrix.multiply(shadowCamera.projectionMatrix);</span><br><span class="line">            shadowMatrix.multiply(shadowCamera.matrixWorldInverse);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getViewport</span>(<span class="params">viewportIndex</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._viewports[viewportIndex];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getFrameExtents</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._frameExtents;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dispose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.map) &#123;</span><br><span class="line">                <span class="built_in">this</span>.map.dispose();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.mapPass) &#123;</span><br><span class="line">                <span class="built_in">this</span>.mapPass.dispose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.camera = source.camera.clone();</span><br><span class="line">            <span class="built_in">this</span>.bias = source.bias;</span><br><span class="line">            <span class="built_in">this</span>.radius = source.radius;</span><br><span class="line">            <span class="built_in">this</span>.mapSize.copy(source.mapSize);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor().copy(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> object = &#123;&#125;;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.bias !== <span class="number">0</span>) object.bias = <span class="built_in">this</span>.bias;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.normalBias !== <span class="number">0</span>) object.normalBias = <span class="built_in">this</span>.normalBias;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.radius !== <span class="number">1</span>) object.radius = <span class="built_in">this</span>.radius;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.mapSize.x !== <span class="number">512</span> || <span class="built_in">this</span>.mapSize.y !== <span class="number">512</span>) object.mapSize = <span class="built_in">this</span>.mapSize.toArray();</span><br><span class="line">            object.camera = <span class="built_in">this</span>.camera.toJSON(<span class="literal">false</span>).object;</span><br><span class="line">            <span class="keyword">delete</span> object.camera.matrix;</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SpotLightShadow</span> <span class="keyword">extends</span> <span class="title">LightShadow</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="keyword">new</span> PerspectiveCamera(<span class="number">50</span>, <span class="number">1</span>, <span class="number">0.5</span>, <span class="number">500</span>));</span><br><span class="line">            <span class="built_in">this</span>.focus = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">updateMatrices</span>(<span class="params">light</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> camera = <span class="built_in">this</span>.camera;</span><br><span class="line">            <span class="keyword">const</span> fov = RAD2DEG * <span class="number">2</span> * light.angle * <span class="built_in">this</span>.focus;</span><br><span class="line">            <span class="keyword">const</span> aspect = <span class="built_in">this</span>.mapSize.width / <span class="built_in">this</span>.mapSize.height;</span><br><span class="line">            <span class="keyword">const</span> far = light.distance || camera.far;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) &#123;</span><br><span class="line">                camera.fov = fov;</span><br><span class="line">                camera.aspect = aspect;</span><br><span class="line">                camera.far = far;</span><br><span class="line">                camera.updateProjectionMatrix();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">super</span>.updateMatrices(light);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.focus = source.focus;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SpotLightShadow.prototype.isSpotLightShadow = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SpotLight</span> <span class="keyword">extends</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">color, intensity, distance = <span class="number">0</span>, angle = <span class="built_in">Math</span>.PI / <span class="number">3</span>, penumbra = <span class="number">0</span>, decay = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(color, intensity);</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;SpotLight&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.position.copy(Object3D.DefaultUp);</span><br><span class="line">            <span class="built_in">this</span>.updateMatrix();</span><br><span class="line">            <span class="built_in">this</span>.target = <span class="keyword">new</span> Object3D();</span><br><span class="line">            <span class="built_in">this</span>.distance = distance;</span><br><span class="line">            <span class="built_in">this</span>.angle = angle;</span><br><span class="line">            <span class="built_in">this</span>.penumbra = penumbra;</span><br><span class="line">            <span class="built_in">this</span>.decay = decay; <span class="comment">// for physically correct lights, should be 2.</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.shadow = <span class="keyword">new</span> SpotLightShadow();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">power</span>() &#123;</span><br><span class="line">            <span class="comment">// compute the light&#x27;s luminous power (in lumens) from its intensity (in candela)</span></span><br><span class="line">            <span class="comment">// by convention for a spotlight, luminous power (lm) = π * luminous intensity (cd)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.intensity * <span class="built_in">Math</span>.PI;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">power</span>(<span class="params">power</span>) &#123;</span><br><span class="line">            <span class="comment">// set the light&#x27;s intensity (in candela) from the desired luminous power (in lumens)</span></span><br><span class="line">            <span class="built_in">this</span>.intensity = power / <span class="built_in">Math</span>.PI;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dispose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.shadow.dispose();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.distance = source.distance;</span><br><span class="line">            <span class="built_in">this</span>.angle = source.angle;</span><br><span class="line">            <span class="built_in">this</span>.penumbra = source.penumbra;</span><br><span class="line">            <span class="built_in">this</span>.decay = source.decay;</span><br><span class="line">            <span class="built_in">this</span>.target = source.target.clone();</span><br><span class="line">            <span class="built_in">this</span>.shadow = source.shadow.clone();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SpotLight.prototype.isSpotLight = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _projScreenMatrix = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Matrix4();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _lightPositionWorld = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _lookTarget = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PointLightShadow</span> <span class="keyword">extends</span> <span class="title">LightShadow</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="keyword">new</span> PerspectiveCamera(<span class="number">90</span>, <span class="number">1</span>, <span class="number">0.5</span>, <span class="number">500</span>));</span><br><span class="line">            <span class="built_in">this</span>._frameExtents = <span class="keyword">new</span> Vector2(<span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">this</span>._viewportCount = <span class="number">6</span>;</span><br><span class="line">            <span class="built_in">this</span>._viewports = [<span class="comment">// These viewports map a cube-map onto a 2D texture with the</span></span><br><span class="line">                <span class="comment">// following orientation:</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">//	xzXZ</span></span><br><span class="line">                <span class="comment">//	 y Y</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// X - Positive x direction</span></span><br><span class="line">                <span class="comment">// x - Negative x direction</span></span><br><span class="line">                <span class="comment">// Y - Positive y direction</span></span><br><span class="line">                <span class="comment">// y - Negative y direction</span></span><br><span class="line">                <span class="comment">// Z - Positive z direction</span></span><br><span class="line">                <span class="comment">// z - Negative z direction</span></span><br><span class="line">                <span class="comment">// positive X</span></span><br><span class="line">                <span class="keyword">new</span> Vector4(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="comment">// negative X</span></span><br><span class="line">                <span class="keyword">new</span> Vector4(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="comment">// positive Z</span></span><br><span class="line">                <span class="keyword">new</span> Vector4(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="comment">// negative Z</span></span><br><span class="line">                <span class="keyword">new</span> Vector4(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="comment">// positive Y</span></span><br><span class="line">                <span class="keyword">new</span> Vector4(<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="comment">// negative Y</span></span><br><span class="line">                <span class="keyword">new</span> Vector4(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>)];</span><br><span class="line">            <span class="built_in">this</span>._cubeDirections = [<span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="keyword">new</span> Vector3(-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>), <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="keyword">new</span> Vector3(<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>)];</span><br><span class="line">            <span class="built_in">this</span>._cubeUps = [<span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>)];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">updateMatrices</span>(<span class="params">light, viewportIndex = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> camera = <span class="built_in">this</span>.camera;</span><br><span class="line">            <span class="keyword">const</span> shadowMatrix = <span class="built_in">this</span>.matrix;</span><br><span class="line">            <span class="keyword">const</span> far = light.distance || camera.far;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (far !== camera.far) &#123;</span><br><span class="line">                camera.far = far;</span><br><span class="line">                camera.updateProjectionMatrix();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);</span><br><span class="line"></span><br><span class="line">            camera.position.copy(_lightPositionWorld);</span><br><span class="line"></span><br><span class="line">            _lookTarget.copy(camera.position);</span><br><span class="line"></span><br><span class="line">            _lookTarget.add(<span class="built_in">this</span>._cubeDirections[viewportIndex]);</span><br><span class="line"></span><br><span class="line">            camera.up.copy(<span class="built_in">this</span>._cubeUps[viewportIndex]);</span><br><span class="line">            camera.lookAt(_lookTarget);</span><br><span class="line">            camera.updateMatrixWorld();</span><br><span class="line">            shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);</span><br><span class="line"></span><br><span class="line">            _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._frustum.setFromProjectionMatrix(_projScreenMatrix);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PointLightShadow.prototype.isPointLightShadow = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PointLight</span> <span class="keyword">extends</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">color, intensity, distance = <span class="number">0</span>, decay = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(color, intensity);</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;PointLight&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.distance = distance;</span><br><span class="line">            <span class="built_in">this</span>.decay = decay; <span class="comment">// for physically correct lights, should be 2.</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.shadow = <span class="keyword">new</span> PointLightShadow();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">power</span>() &#123;</span><br><span class="line">            <span class="comment">// compute the light&#x27;s luminous power (in lumens) from its intensity (in candela)</span></span><br><span class="line">            <span class="comment">// for an isotropic light source, luminous power (lm) = 4 π luminous intensity (cd)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.intensity * <span class="number">4</span> * <span class="built_in">Math</span>.PI;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">power</span>(<span class="params">power</span>) &#123;</span><br><span class="line">            <span class="comment">// set the light&#x27;s intensity (in candela) from the desired luminous power (in lumens)</span></span><br><span class="line">            <span class="built_in">this</span>.intensity = power / (<span class="number">4</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dispose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.shadow.dispose();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.distance = source.distance;</span><br><span class="line">            <span class="built_in">this</span>.decay = source.decay;</span><br><span class="line">            <span class="built_in">this</span>.shadow = source.shadow.clone();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PointLight.prototype.isPointLight = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DirectionalLightShadow</span> <span class="keyword">extends</span> <span class="title">LightShadow</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="keyword">new</span> OrthographicCamera(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, -<span class="number">5</span>, <span class="number">0.5</span>, <span class="number">500</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DirectionalLightShadow.prototype.isDirectionalLightShadow = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DirectionalLight</span> <span class="keyword">extends</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">color, intensity</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(color, intensity);</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;DirectionalLight&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.position.copy(Object3D.DefaultUp);</span><br><span class="line">            <span class="built_in">this</span>.updateMatrix();</span><br><span class="line">            <span class="built_in">this</span>.target = <span class="keyword">new</span> Object3D();</span><br><span class="line">            <span class="built_in">this</span>.shadow = <span class="keyword">new</span> DirectionalLightShadow();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dispose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.shadow.dispose();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.target = source.target.clone();</span><br><span class="line">            <span class="built_in">this</span>.shadow = source.shadow.clone();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DirectionalLight.prototype.isDirectionalLight = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AmbientLight</span> <span class="keyword">extends</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">color, intensity</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(color, intensity);</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;AmbientLight&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AmbientLight.prototype.isAmbientLight = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RectAreaLight</span> <span class="keyword">extends</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">color, intensity, width = <span class="number">10</span>, height = <span class="number">10</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(color, intensity);</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;RectAreaLight&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.width = width;</span><br><span class="line">            <span class="built_in">this</span>.height = height;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="title">power</span>() &#123;</span><br><span class="line">            <span class="comment">// compute the light&#x27;s luminous power (in lumens) from its intensity (in nits)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.intensity * <span class="built_in">this</span>.width * <span class="built_in">this</span>.height * <span class="built_in">Math</span>.PI;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">power</span>(<span class="params">power</span>) &#123;</span><br><span class="line">            <span class="comment">// set the light&#x27;s intensity (in nits) from the desired luminous power (in lumens)</span></span><br><span class="line">            <span class="built_in">this</span>.intensity = power / (<span class="built_in">this</span>.width * <span class="built_in">this</span>.height * <span class="built_in">Math</span>.PI);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.width = source.width;</span><br><span class="line">            <span class="built_in">this</span>.height = source.height;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params">meta</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON(meta);</span><br><span class="line">            data.object.width = <span class="built_in">this</span>.width;</span><br><span class="line">            data.object.height = <span class="built_in">this</span>.height;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RectAreaLight.prototype.isRectAreaLight = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Primary reference:</span></span><br><span class="line"><span class="comment">     *	 https://graphics.stanford.edu/papers/envmap/envmap.pdf</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Secondary reference:</span></span><br><span class="line"><span class="comment">     *	 https://www.ppsloan.org/publications/StupidSH36.pdf</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="comment">// 3-band SH defined by 9 coefficients</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SphericalHarmonics3</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.coefficients = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.coefficients.push(<span class="keyword">new</span> Vector3());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">coefficients</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.coefficients[i].copy(coefficients[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">zero</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.coefficients[i].set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125; <span class="comment">// get the radiance in the direction of the normal</span></span><br><span class="line">        <span class="comment">// target is a Vector3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getAt</span>(<span class="params">normal, target</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// normal is assumed to be unit length</span></span><br><span class="line">            <span class="keyword">const</span> x = normal.x,</span><br><span class="line">                y = normal.y,</span><br><span class="line">                z = normal.z;</span><br><span class="line">            <span class="keyword">const</span> coeff = <span class="built_in">this</span>.coefficients; <span class="comment">// band 0</span></span><br><span class="line"></span><br><span class="line">            target.copy(coeff[<span class="number">0</span>]).multiplyScalar(<span class="number">0.282095</span>); <span class="comment">// band 1</span></span><br><span class="line"></span><br><span class="line">            target.addScaledVector(coeff[<span class="number">1</span>], <span class="number">0.488603</span> * y);</span><br><span class="line">            target.addScaledVector(coeff[<span class="number">2</span>], <span class="number">0.488603</span> * z);</span><br><span class="line">            target.addScaledVector(coeff[<span class="number">3</span>], <span class="number">0.488603</span> * x); <span class="comment">// band 2</span></span><br><span class="line"></span><br><span class="line">            target.addScaledVector(coeff[<span class="number">4</span>], <span class="number">1.092548</span> * (x * y));</span><br><span class="line">            target.addScaledVector(coeff[<span class="number">5</span>], <span class="number">1.092548</span> * (y * z));</span><br><span class="line">            target.addScaledVector(coeff[<span class="number">6</span>], <span class="number">0.315392</span> * (<span class="number">3.0</span> * z * z - <span class="number">1.0</span>));</span><br><span class="line">            target.addScaledVector(coeff[<span class="number">7</span>], <span class="number">1.092548</span> * (x * z));</span><br><span class="line">            target.addScaledVector(coeff[<span class="number">8</span>], <span class="number">0.546274</span> * (x * x - y * y));</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125; <span class="comment">// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal</span></span><br><span class="line">        <span class="comment">// target is a Vector3</span></span><br><span class="line">        <span class="comment">// https://graphics.stanford.edu/papers/envmap/envmap.pdf</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getIrradianceAt</span>(<span class="params">normal, target</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// normal is assumed to be unit length</span></span><br><span class="line">            <span class="keyword">const</span> x = normal.x,</span><br><span class="line">                y = normal.y,</span><br><span class="line">                z = normal.z;</span><br><span class="line">            <span class="keyword">const</span> coeff = <span class="built_in">this</span>.coefficients; <span class="comment">// band 0</span></span><br><span class="line"></span><br><span class="line">            target.copy(coeff[<span class="number">0</span>]).multiplyScalar(<span class="number">0.886227</span>); <span class="comment">// π * 0.282095</span></span><br><span class="line">            <span class="comment">// band 1</span></span><br><span class="line"></span><br><span class="line">            target.addScaledVector(coeff[<span class="number">1</span>], <span class="number">2.0</span> * <span class="number">0.511664</span> * y); <span class="comment">// ( 2 * π / 3 ) * 0.488603</span></span><br><span class="line"></span><br><span class="line">            target.addScaledVector(coeff[<span class="number">2</span>], <span class="number">2.0</span> * <span class="number">0.511664</span> * z);</span><br><span class="line">            target.addScaledVector(coeff[<span class="number">3</span>], <span class="number">2.0</span> * <span class="number">0.511664</span> * x); <span class="comment">// band 2</span></span><br><span class="line"></span><br><span class="line">            target.addScaledVector(coeff[<span class="number">4</span>], <span class="number">2.0</span> * <span class="number">0.429043</span> * x * y); <span class="comment">// ( π / 4 ) * 1.092548</span></span><br><span class="line"></span><br><span class="line">            target.addScaledVector(coeff[<span class="number">5</span>], <span class="number">2.0</span> * <span class="number">0.429043</span> * y * z);</span><br><span class="line">            target.addScaledVector(coeff[<span class="number">6</span>], <span class="number">0.743125</span> * z * z - <span class="number">0.247708</span>); <span class="comment">// ( π / 4 ) * 0.315392 * 3</span></span><br><span class="line"></span><br><span class="line">            target.addScaledVector(coeff[<span class="number">7</span>], <span class="number">2.0</span> * <span class="number">0.429043</span> * x * z);</span><br><span class="line">            target.addScaledVector(coeff[<span class="number">8</span>], <span class="number">0.429043</span> * (x * x - y * y)); <span class="comment">// ( π / 4 ) * 0.546274</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params">sh</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.coefficients[i].add(sh.coefficients[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">addScaledSH</span>(<span class="params">sh, s</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.coefficients[i].addScaledVector(sh.coefficients[i], s);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">scale</span>(<span class="params">s</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.coefficients[i].multiplyScalar(s);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">lerp</span>(<span class="params">sh, alpha</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.coefficients[i].lerp(sh.coefficients[i], alpha);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">equals</span>(<span class="params">sh</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">this</span>.coefficients[i].equals(sh.coefficients[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">sh</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.set(sh.coefficients);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor().copy(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromArray</span>(<span class="params">array, offset = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> coefficients = <span class="built_in">this</span>.coefficients;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                coefficients[i].fromArray(array, offset + i * <span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toArray</span>(<span class="params">array = [], offset = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> coefficients = <span class="built_in">this</span>.coefficients;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                coefficients[i].toArray(array, offset + i * <span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125; <span class="comment">// evaluate the basis functions</span></span><br><span class="line">        <span class="comment">// shBasis is an Array[ 9 ]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">getBasisAt</span>(<span class="params">normal, shBasis</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// normal is assumed to be unit length</span></span><br><span class="line">            <span class="keyword">const</span> x = normal.x,</span><br><span class="line">                y = normal.y,</span><br><span class="line">                z = normal.z; <span class="comment">// band 0</span></span><br><span class="line"></span><br><span class="line">            shBasis[<span class="number">0</span>] = <span class="number">0.282095</span>; <span class="comment">// band 1</span></span><br><span class="line"></span><br><span class="line">            shBasis[<span class="number">1</span>] = <span class="number">0.488603</span> * y;</span><br><span class="line">            shBasis[<span class="number">2</span>] = <span class="number">0.488603</span> * z;</span><br><span class="line">            shBasis[<span class="number">3</span>] = <span class="number">0.488603</span> * x; <span class="comment">// band 2</span></span><br><span class="line"></span><br><span class="line">            shBasis[<span class="number">4</span>] = <span class="number">1.092548</span> * x * y;</span><br><span class="line">            shBasis[<span class="number">5</span>] = <span class="number">1.092548</span> * y * z;</span><br><span class="line">            shBasis[<span class="number">6</span>] = <span class="number">0.315392</span> * (<span class="number">3</span> * z * z - <span class="number">1</span>);</span><br><span class="line">            shBasis[<span class="number">7</span>] = <span class="number">1.092548</span> * x * z;</span><br><span class="line">            shBasis[<span class="number">8</span>] = <span class="number">0.546274</span> * (x * x - y * y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SphericalHarmonics3.prototype.isSphericalHarmonics3 = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LightProbe</span> <span class="keyword">extends</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">sh = <span class="keyword">new</span> SphericalHarmonics3(), intensity = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="literal">undefined</span>, intensity);</span><br><span class="line">            <span class="built_in">this</span>.sh = sh;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.sh.copy(source.sh);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fromJSON</span>(<span class="params">json</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.intensity = json.intensity; <span class="comment">// <span class="doctag">TODO:</span> Move this bit to Light.fromJSON();</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.sh.fromArray(json.sh);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params">meta</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON(meta);</span><br><span class="line">            data.object.sh = <span class="built_in">this</span>.sh.toArray();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LightProbe.prototype.isLightProbe = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MaterialLoader</span> <span class="keyword">extends</span> <span class="title">Loader</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">manager</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(manager);</span><br><span class="line">            <span class="built_in">this</span>.textures = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">load</span>(<span class="params">url, onLoad, onProgress, onError</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> scope = <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">const</span> loader = <span class="keyword">new</span> FileLoader(scope.manager);</span><br><span class="line">            loader.setPath(scope.path);</span><br><span class="line">            loader.setRequestHeader(scope.requestHeader);</span><br><span class="line">            loader.setWithCredentials(scope.withCredentials);</span><br><span class="line">            loader.load(url, <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    onLoad(scope.parse(<span class="built_in">JSON</span>.parse(text)));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (onError) &#123;</span><br><span class="line">                        onError(e);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">console</span>.error(e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    scope.manager.itemError(url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, onProgress, onError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">parse</span>(<span class="params">json</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> textures = <span class="built_in">this</span>.textures;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">getTexture</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (textures[name] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.MaterialLoader: Undefined texture&#x27;</span>, name);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> textures[name];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> material = Material.fromType(json.type);</span><br><span class="line">            <span class="keyword">if</span> (json.uuid !== <span class="literal">undefined</span>) material.uuid = json.uuid;</span><br><span class="line">            <span class="keyword">if</span> (json.name !== <span class="literal">undefined</span>) material.name = json.name;</span><br><span class="line">            <span class="keyword">if</span> (json.color !== <span class="literal">undefined</span> &amp;&amp; material.color !== <span class="literal">undefined</span>) material.color.setHex(json.color);</span><br><span class="line">            <span class="keyword">if</span> (json.roughness !== <span class="literal">undefined</span>) material.roughness = json.roughness;</span><br><span class="line">            <span class="keyword">if</span> (json.metalness !== <span class="literal">undefined</span>) material.metalness = json.metalness;</span><br><span class="line">            <span class="keyword">if</span> (json.sheen !== <span class="literal">undefined</span>) material.sheen = json.sheen;</span><br><span class="line">            <span class="keyword">if</span> (json.sheenColor !== <span class="literal">undefined</span>) material.sheenColor = <span class="keyword">new</span> Color().setHex(json.sheenColor);</span><br><span class="line">            <span class="keyword">if</span> (json.sheenRoughness !== <span class="literal">undefined</span>) material.sheenRoughness = json.sheenRoughness;</span><br><span class="line">            <span class="keyword">if</span> (json.emissive !== <span class="literal">undefined</span> &amp;&amp; material.emissive !== <span class="literal">undefined</span>) material.emissive.setHex(json.emissive);</span><br><span class="line">            <span class="keyword">if</span> (json.specular !== <span class="literal">undefined</span> &amp;&amp; material.specular !== <span class="literal">undefined</span>) material.specular.setHex(json.specular);</span><br><span class="line">            <span class="keyword">if</span> (json.specularIntensity !== <span class="literal">undefined</span>) material.specularIntensity = json.specularIntensity;</span><br><span class="line">            <span class="keyword">if</span> (json.specularColor !== <span class="literal">undefined</span> &amp;&amp; material.specularColor !== <span class="literal">undefined</span>) material.specularColor.setHex(json.specularColor);</span><br><span class="line">            <span class="keyword">if</span> (json.shininess !== <span class="literal">undefined</span>) material.shininess = json.shininess;</span><br><span class="line">            <span class="keyword">if</span> (json.clearcoat !== <span class="literal">undefined</span>) material.clearcoat = json.clearcoat;</span><br><span class="line">            <span class="keyword">if</span> (json.clearcoatRoughness !== <span class="literal">undefined</span>) material.clearcoatRoughness = json.clearcoatRoughness;</span><br><span class="line">            <span class="keyword">if</span> (json.transmission !== <span class="literal">undefined</span>) material.transmission = json.transmission;</span><br><span class="line">            <span class="keyword">if</span> (json.thickness !== <span class="literal">undefined</span>) material.thickness = json.thickness;</span><br><span class="line">            <span class="keyword">if</span> (json.attenuationDistance !== <span class="literal">undefined</span>) material.attenuationDistance = json.attenuationDistance;</span><br><span class="line">            <span class="keyword">if</span> (json.attenuationColor !== <span class="literal">undefined</span> &amp;&amp; material.attenuationColor !== <span class="literal">undefined</span>) material.attenuationColor.setHex(json.attenuationColor);</span><br><span class="line">            <span class="keyword">if</span> (json.fog !== <span class="literal">undefined</span>) material.fog = json.fog;</span><br><span class="line">            <span class="keyword">if</span> (json.flatShading !== <span class="literal">undefined</span>) material.flatShading = json.flatShading;</span><br><span class="line">            <span class="keyword">if</span> (json.blending !== <span class="literal">undefined</span>) material.blending = json.blending;</span><br><span class="line">            <span class="keyword">if</span> (json.combine !== <span class="literal">undefined</span>) material.combine = json.combine;</span><br><span class="line">            <span class="keyword">if</span> (json.side !== <span class="literal">undefined</span>) material.side = json.side;</span><br><span class="line">            <span class="keyword">if</span> (json.shadowSide !== <span class="literal">undefined</span>) material.shadowSide = json.shadowSide;</span><br><span class="line">            <span class="keyword">if</span> (json.opacity !== <span class="literal">undefined</span>) material.opacity = json.opacity;</span><br><span class="line">            <span class="keyword">if</span> (json.transparent !== <span class="literal">undefined</span>) material.transparent = json.transparent;</span><br><span class="line">            <span class="keyword">if</span> (json.alphaTest !== <span class="literal">undefined</span>) material.alphaTest = json.alphaTest;</span><br><span class="line">            <span class="keyword">if</span> (json.depthTest !== <span class="literal">undefined</span>) material.depthTest = json.depthTest;</span><br><span class="line">            <span class="keyword">if</span> (json.depthWrite !== <span class="literal">undefined</span>) material.depthWrite = json.depthWrite;</span><br><span class="line">            <span class="keyword">if</span> (json.colorWrite !== <span class="literal">undefined</span>) material.colorWrite = json.colorWrite;</span><br><span class="line">            <span class="keyword">if</span> (json.stencilWrite !== <span class="literal">undefined</span>) material.stencilWrite = json.stencilWrite;</span><br><span class="line">            <span class="keyword">if</span> (json.stencilWriteMask !== <span class="literal">undefined</span>) material.stencilWriteMask = json.stencilWriteMask;</span><br><span class="line">            <span class="keyword">if</span> (json.stencilFunc !== <span class="literal">undefined</span>) material.stencilFunc = json.stencilFunc;</span><br><span class="line">            <span class="keyword">if</span> (json.stencilRef !== <span class="literal">undefined</span>) material.stencilRef = json.stencilRef;</span><br><span class="line">            <span class="keyword">if</span> (json.stencilFuncMask !== <span class="literal">undefined</span>) material.stencilFuncMask = json.stencilFuncMask;</span><br><span class="line">            <span class="keyword">if</span> (json.stencilFail !== <span class="literal">undefined</span>) material.stencilFail = json.stencilFail;</span><br><span class="line">            <span class="keyword">if</span> (json.stencilZFail !== <span class="literal">undefined</span>) material.stencilZFail = json.stencilZFail;</span><br><span class="line">            <span class="keyword">if</span> (json.stencilZPass !== <span class="literal">undefined</span>) material.stencilZPass = json.stencilZPass;</span><br><span class="line">            <span class="keyword">if</span> (json.wireframe !== <span class="literal">undefined</span>) material.wireframe = json.wireframe;</span><br><span class="line">            <span class="keyword">if</span> (json.wireframeLinewidth !== <span class="literal">undefined</span>) material.wireframeLinewidth = json.wireframeLinewidth;</span><br><span class="line">            <span class="keyword">if</span> (json.wireframeLinecap !== <span class="literal">undefined</span>) material.wireframeLinecap = json.wireframeLinecap;</span><br><span class="line">            <span class="keyword">if</span> (json.wireframeLinejoin !== <span class="literal">undefined</span>) material.wireframeLinejoin = json.wireframeLinejoin;</span><br><span class="line">            <span class="keyword">if</span> (json.rotation !== <span class="literal">undefined</span>) material.rotation = json.rotation;</span><br><span class="line">            <span class="keyword">if</span> (json.linewidth !== <span class="number">1</span>) material.linewidth = json.linewidth;</span><br><span class="line">            <span class="keyword">if</span> (json.dashSize !== <span class="literal">undefined</span>) material.dashSize = json.dashSize;</span><br><span class="line">            <span class="keyword">if</span> (json.gapSize !== <span class="literal">undefined</span>) material.gapSize = json.gapSize;</span><br><span class="line">            <span class="keyword">if</span> (json.scale !== <span class="literal">undefined</span>) material.scale = json.scale;</span><br><span class="line">            <span class="keyword">if</span> (json.polygonOffset !== <span class="literal">undefined</span>) material.polygonOffset = json.polygonOffset;</span><br><span class="line">            <span class="keyword">if</span> (json.polygonOffsetFactor !== <span class="literal">undefined</span>) material.polygonOffsetFactor = json.polygonOffsetFactor;</span><br><span class="line">            <span class="keyword">if</span> (json.polygonOffsetUnits !== <span class="literal">undefined</span>) material.polygonOffsetUnits = json.polygonOffsetUnits;</span><br><span class="line">            <span class="keyword">if</span> (json.dithering !== <span class="literal">undefined</span>) material.dithering = json.dithering;</span><br><span class="line">            <span class="keyword">if</span> (json.alphaToCoverage !== <span class="literal">undefined</span>) material.alphaToCoverage = json.alphaToCoverage;</span><br><span class="line">            <span class="keyword">if</span> (json.premultipliedAlpha !== <span class="literal">undefined</span>) material.premultipliedAlpha = json.premultipliedAlpha;</span><br><span class="line">            <span class="keyword">if</span> (json.visible !== <span class="literal">undefined</span>) material.visible = json.visible;</span><br><span class="line">            <span class="keyword">if</span> (json.toneMapped !== <span class="literal">undefined</span>) material.toneMapped = json.toneMapped;</span><br><span class="line">            <span class="keyword">if</span> (json.userData !== <span class="literal">undefined</span>) material.userData = json.userData;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (json.vertexColors !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> json.vertexColors === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">                    material.vertexColors = json.vertexColors &gt; <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    material.vertexColors = json.vertexColors;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// Shader Material</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (json.uniforms !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> json.uniforms) &#123;</span><br><span class="line">                    <span class="keyword">const</span> uniform = json.uniforms[name];</span><br><span class="line">                    material.uniforms[name] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">switch</span> (uniform.type) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">                            material.uniforms[name].value = getTexture(uniform.value);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">                            material.uniforms[name].value = <span class="keyword">new</span> Color().setHex(uniform.value);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;v2&#x27;</span>:</span><br><span class="line">                            material.uniforms[name].value = <span class="keyword">new</span> Vector2().fromArray(uniform.value);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;v3&#x27;</span>:</span><br><span class="line">                            material.uniforms[name].value = <span class="keyword">new</span> Vector3().fromArray(uniform.value);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;v4&#x27;</span>:</span><br><span class="line">                            material.uniforms[name].value = <span class="keyword">new</span> Vector4().fromArray(uniform.value);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;m3&#x27;</span>:</span><br><span class="line">                            material.uniforms[name].value = <span class="keyword">new</span> Matrix3().fromArray(uniform.value);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;m4&#x27;</span>:</span><br><span class="line">                            material.uniforms[name].value = <span class="keyword">new</span> Matrix4().fromArray(uniform.value);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            material.uniforms[name].value = uniform.value;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (json.defines !== <span class="literal">undefined</span>) material.defines = json.defines;</span><br><span class="line">            <span class="keyword">if</span> (json.vertexShader !== <span class="literal">undefined</span>) material.vertexShader = json.vertexShader;</span><br><span class="line">            <span class="keyword">if</span> (json.fragmentShader !== <span class="literal">undefined</span>) material.fragmentShader = json.fragmentShader;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (json.extensions !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> json.extensions) &#123;</span><br><span class="line">                    material.extensions[key] = json.extensions[key];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// Deprecated</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (json.shading !== <span class="literal">undefined</span>) material.flatShading = json.shading === <span class="number">1</span>; <span class="comment">// THREE.FlatShading</span></span><br><span class="line">            <span class="comment">// for PointsMaterial</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (json.size !== <span class="literal">undefined</span>) material.size = json.size;</span><br><span class="line">            <span class="keyword">if</span> (json.sizeAttenuation !== <span class="literal">undefined</span>) material.sizeAttenuation = json.sizeAttenuation; <span class="comment">// maps</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (json.map !== <span class="literal">undefined</span>) material.map = getTexture(json.map);</span><br><span class="line">            <span class="keyword">if</span> (json.matcap !== <span class="literal">undefined</span>) material.matcap = getTexture(json.matcap);</span><br><span class="line">            <span class="keyword">if</span> (json.alphaMap !== <span class="literal">undefined</span>) material.alphaMap = getTexture(json.alphaMap);</span><br><span class="line">            <span class="keyword">if</span> (json.bumpMap !== <span class="literal">undefined</span>) material.bumpMap = getTexture(json.bumpMap);</span><br><span class="line">            <span class="keyword">if</span> (json.bumpScale !== <span class="literal">undefined</span>) material.bumpScale = json.bumpScale;</span><br><span class="line">            <span class="keyword">if</span> (json.normalMap !== <span class="literal">undefined</span>) material.normalMap = getTexture(json.normalMap);</span><br><span class="line">            <span class="keyword">if</span> (json.normalMapType !== <span class="literal">undefined</span>) material.normalMapType = json.normalMapType;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (json.normalScale !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> normalScale = json.normalScale;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(normalScale) === <span class="literal">false</span>) &#123;</span><br><span class="line">                    <span class="comment">// Blender exporter used to export a scalar. See #7459</span></span><br><span class="line">                    normalScale = [normalScale, normalScale];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                material.normalScale = <span class="keyword">new</span> Vector2().fromArray(normalScale);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (json.displacementMap !== <span class="literal">undefined</span>) material.displacementMap = getTexture(json.displacementMap);</span><br><span class="line">            <span class="keyword">if</span> (json.displacementScale !== <span class="literal">undefined</span>) material.displacementScale = json.displacementScale;</span><br><span class="line">            <span class="keyword">if</span> (json.displacementBias !== <span class="literal">undefined</span>) material.displacementBias = json.displacementBias;</span><br><span class="line">            <span class="keyword">if</span> (json.roughnessMap !== <span class="literal">undefined</span>) material.roughnessMap = getTexture(json.roughnessMap);</span><br><span class="line">            <span class="keyword">if</span> (json.metalnessMap !== <span class="literal">undefined</span>) material.metalnessMap = getTexture(json.metalnessMap);</span><br><span class="line">            <span class="keyword">if</span> (json.emissiveMap !== <span class="literal">undefined</span>) material.emissiveMap = getTexture(json.emissiveMap);</span><br><span class="line">            <span class="keyword">if</span> (json.emissiveIntensity !== <span class="literal">undefined</span>) material.emissiveIntensity = json.emissiveIntensity;</span><br><span class="line">            <span class="keyword">if</span> (json.specularMap !== <span class="literal">undefined</span>) material.specularMap = getTexture(json.specularMap);</span><br><span class="line">            <span class="keyword">if</span> (json.specularIntensityMap !== <span class="literal">undefined</span>) material.specularIntensityMap = getTexture(json.specularIntensityMap);</span><br><span class="line">            <span class="keyword">if</span> (json.specularColorMap !== <span class="literal">undefined</span>) material.specularColorMap = getTexture(json.specularColorMap);</span><br><span class="line">            <span class="keyword">if</span> (json.envMap !== <span class="literal">undefined</span>) material.envMap = getTexture(json.envMap);</span><br><span class="line">            <span class="keyword">if</span> (json.envMapIntensity !== <span class="literal">undefined</span>) material.envMapIntensity = json.envMapIntensity;</span><br><span class="line">            <span class="keyword">if</span> (json.reflectivity !== <span class="literal">undefined</span>) material.reflectivity = json.reflectivity;</span><br><span class="line">            <span class="keyword">if</span> (json.refractionRatio !== <span class="literal">undefined</span>) material.refractionRatio = json.refractionRatio;</span><br><span class="line">            <span class="keyword">if</span> (json.lightMap !== <span class="literal">undefined</span>) material.lightMap = getTexture(json.lightMap);</span><br><span class="line">            <span class="keyword">if</span> (json.lightMapIntensity !== <span class="literal">undefined</span>) material.lightMapIntensity = json.lightMapIntensity;</span><br><span class="line">            <span class="keyword">if</span> (json.aoMap !== <span class="literal">undefined</span>) material.aoMap = getTexture(json.aoMap);</span><br><span class="line">            <span class="keyword">if</span> (json.aoMapIntensity !== <span class="literal">undefined</span>) material.aoMapIntensity = json.aoMapIntensity;</span><br><span class="line">            <span class="keyword">if</span> (json.gradientMap !== <span class="literal">undefined</span>) material.gradientMap = getTexture(json.gradientMap);</span><br><span class="line">            <span class="keyword">if</span> (json.clearcoatMap !== <span class="literal">undefined</span>) material.clearcoatMap = getTexture(json.clearcoatMap);</span><br><span class="line">            <span class="keyword">if</span> (json.clearcoatRoughnessMap !== <span class="literal">undefined</span>) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);</span><br><span class="line">            <span class="keyword">if</span> (json.clearcoatNormalMap !== <span class="literal">undefined</span>) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);</span><br><span class="line">            <span class="keyword">if</span> (json.clearcoatNormalScale !== <span class="literal">undefined</span>) material.clearcoatNormalScale = <span class="keyword">new</span> Vector2().fromArray(json.clearcoatNormalScale);</span><br><span class="line">            <span class="keyword">if</span> (json.transmissionMap !== <span class="literal">undefined</span>) material.transmissionMap = getTexture(json.transmissionMap);</span><br><span class="line">            <span class="keyword">if</span> (json.thicknessMap !== <span class="literal">undefined</span>) material.thicknessMap = getTexture(json.thicknessMap);</span><br><span class="line">            <span class="keyword">if</span> (json.sheenColorMap !== <span class="literal">undefined</span>) material.sheenColorMap = getTexture(json.sheenColorMap);</span><br><span class="line">            <span class="keyword">if</span> (json.sheenRoughnessMap !== <span class="literal">undefined</span>) material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);</span><br><span class="line">            <span class="keyword">return</span> material;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setTextures</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.textures = value;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LoaderUtils</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">decodeText</span>(<span class="params">array</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> TextDecoder !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> TextDecoder().decode(array);</span><br><span class="line">            &#125; <span class="comment">// Avoid the String.fromCharCode.apply(null, array) shortcut, which</span></span><br><span class="line">            <span class="comment">// throws a &quot;maximum call stack size exceeded&quot; error for large arrays.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> s = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = array.length; i &lt; il; i++) &#123;</span><br><span class="line">                <span class="comment">// Implicitly assumes little-endian.</span></span><br><span class="line">                s += <span class="built_in">String</span>.fromCharCode(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// merges multi-byte utf-8 characters.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(<span class="built_in">escape</span>(s));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="comment">// see #16358</span></span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">extractUrlBase</span>(<span class="params">url</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> index = url.lastIndexOf(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (index === -<span class="number">1</span>) <span class="keyword">return</span> <span class="string">&#x27;./&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> url.slice(<span class="number">0</span>, index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">resolveURL</span>(<span class="params">url, path</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// Invalid URL</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> url !== <span class="string">&#x27;string&#x27;</span> || url === <span class="string">&#x27;&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>; <span class="comment">// Host Relative URL</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="regexp">/^https?:\/\//i</span>.test(path) &amp;&amp; <span class="regexp">/^\//</span>.test(url)) &#123;</span><br><span class="line">                path = path.replace(<span class="regexp">/(^https?:\/\/[^\/]+).*/i</span>, <span class="string">&#x27;$1&#x27;</span>);</span><br><span class="line">            &#125; <span class="comment">// Absolute URL http://,https://,//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="regexp">/^(https?:)?\/\//i</span>.test(url)) <span class="keyword">return</span> url; <span class="comment">// Data URI</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="regexp">/^data:.*,.*$/i</span>.test(url)) <span class="keyword">return</span> url; <span class="comment">// Blob URL</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="regexp">/^blob:.*$/i</span>.test(url)) <span class="keyword">return</span> url; <span class="comment">// Relative URL</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> path + url;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InstancedBufferGeometry</span> <span class="keyword">extends</span> <span class="title">BufferGeometry</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;InstancedBufferGeometry&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.instanceCount = <span class="literal">Infinity</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.instanceCount = source.instanceCount;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor().copy(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">super</span>.toJSON(<span class="built_in">this</span>);</span><br><span class="line">            data.instanceCount = <span class="built_in">this</span>.instanceCount;</span><br><span class="line">            data.isInstancedBufferGeometry = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InstancedBufferGeometry.prototype.isInstancedBufferGeometry = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BufferGeometryLoader</span> <span class="keyword">extends</span> <span class="title">Loader</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">manager</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(manager);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">load</span>(<span class="params">url, onLoad, onProgress, onError</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> scope = <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">const</span> loader = <span class="keyword">new</span> FileLoader(scope.manager);</span><br><span class="line">            loader.setPath(scope.path);</span><br><span class="line">            loader.setRequestHeader(scope.requestHeader);</span><br><span class="line">            loader.setWithCredentials(scope.withCredentials);</span><br><span class="line">            loader.load(url, <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    onLoad(scope.parse(<span class="built_in">JSON</span>.parse(text)));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (onError) &#123;</span><br><span class="line">                        onError(e);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">console</span>.error(e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    scope.manager.itemError(url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, onProgress, onError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">parse</span>(<span class="params">json</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> interleavedBufferMap = &#123;&#125;;</span><br><span class="line">            <span class="keyword">const</span> arrayBufferMap = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">getInterleavedBuffer</span>(<span class="params">json, uuid</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (interleavedBufferMap[uuid] !== <span class="literal">undefined</span>) <span class="keyword">return</span> interleavedBufferMap[uuid];</span><br><span class="line">                <span class="keyword">const</span> interleavedBuffers = json.interleavedBuffers;</span><br><span class="line">                <span class="keyword">const</span> interleavedBuffer = interleavedBuffers[uuid];</span><br><span class="line">                <span class="keyword">const</span> buffer = getArrayBuffer(json, interleavedBuffer.buffer);</span><br><span class="line">                <span class="keyword">const</span> array = getTypedArray(interleavedBuffer.type, buffer);</span><br><span class="line">                <span class="keyword">const</span> ib = <span class="keyword">new</span> InterleavedBuffer(array, interleavedBuffer.stride);</span><br><span class="line">                ib.uuid = interleavedBuffer.uuid;</span><br><span class="line">                interleavedBufferMap[uuid] = ib;</span><br><span class="line">                <span class="keyword">return</span> ib;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">getArrayBuffer</span>(<span class="params">json, uuid</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (arrayBufferMap[uuid] !== <span class="literal">undefined</span>) <span class="keyword">return</span> arrayBufferMap[uuid];</span><br><span class="line">                <span class="keyword">const</span> arrayBuffers = json.arrayBuffers;</span><br><span class="line">                <span class="keyword">const</span> arrayBuffer = arrayBuffers[uuid];</span><br><span class="line">                <span class="keyword">const</span> ab = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(arrayBuffer).buffer;</span><br><span class="line">                arrayBufferMap[uuid] = ab;</span><br><span class="line">                <span class="keyword">return</span> ab;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> geometry = json.isInstancedBufferGeometry ? <span class="keyword">new</span> InstancedBufferGeometry() : <span class="keyword">new</span> BufferGeometry();</span><br><span class="line">            <span class="keyword">const</span> index = json.data.index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> typedArray = getTypedArray(index.type, index.array);</span><br><span class="line">                geometry.setIndex(<span class="keyword">new</span> BufferAttribute(typedArray, <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> attributes = json.data.attributes;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> attributes) &#123;</span><br><span class="line">                <span class="keyword">const</span> attribute = attributes[key];</span><br><span class="line">                <span class="keyword">let</span> bufferAttribute;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (attribute.isInterleavedBufferAttribute) &#123;</span><br><span class="line">                    <span class="keyword">const</span> interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);</span><br><span class="line">                    bufferAttribute = <span class="keyword">new</span> InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> typedArray = getTypedArray(attribute.type, attribute.array);</span><br><span class="line">                    <span class="keyword">const</span> bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;</span><br><span class="line">                    bufferAttribute = <span class="keyword">new</span> bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (attribute.name !== <span class="literal">undefined</span>) bufferAttribute.name = attribute.name;</span><br><span class="line">                <span class="keyword">if</span> (attribute.usage !== <span class="literal">undefined</span>) bufferAttribute.setUsage(attribute.usage);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (attribute.updateRange !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    bufferAttribute.updateRange.offset = attribute.updateRange.offset;</span><br><span class="line">                    bufferAttribute.updateRange.count = attribute.updateRange.count;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                geometry.setAttribute(key, bufferAttribute);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> morphAttributes = json.data.morphAttributes;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (morphAttributes) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> morphAttributes) &#123;</span><br><span class="line">                    <span class="keyword">const</span> attributeArray = morphAttributes[key];</span><br><span class="line">                    <span class="keyword">const</span> array = [];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = attributeArray.length; i &lt; il; i++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> attribute = attributeArray[i];</span><br><span class="line">                        <span class="keyword">let</span> bufferAttribute;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (attribute.isInterleavedBufferAttribute) &#123;</span><br><span class="line">                            <span class="keyword">const</span> interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);</span><br><span class="line">                            bufferAttribute = <span class="keyword">new</span> InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">const</span> typedArray = getTypedArray(attribute.type, attribute.array);</span><br><span class="line">                            bufferAttribute = <span class="keyword">new</span> BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (attribute.name !== <span class="literal">undefined</span>) bufferAttribute.name = attribute.name;</span><br><span class="line">                        array.push(bufferAttribute);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    geometry.morphAttributes[key] = array;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> morphTargetsRelative = json.data.morphTargetsRelative;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (morphTargetsRelative) &#123;</span><br><span class="line">                geometry.morphTargetsRelative = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> groups = json.data.groups || json.data.drawcalls || json.data.offsets;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (groups !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = groups.length; i !== n; ++i) &#123;</span><br><span class="line">                    <span class="keyword">const</span> group = groups[i];</span><br><span class="line">                    geometry.addGroup(group.start, group.count, group.materialIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> boundingSphere = json.data.boundingSphere;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (boundingSphere !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> center = <span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (boundingSphere.center !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    center.fromArray(boundingSphere.center);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                geometry.boundingSphere = <span class="keyword">new</span> Sphere(center, boundingSphere.radius);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (json.name) geometry.name = json.name;</span><br><span class="line">            <span class="keyword">if</span> (json.userData) geometry.userData = json.userData;</span><br><span class="line">            <span class="keyword">return</span> geometry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ObjectLoader</span> <span class="keyword">extends</span> <span class="title">Loader</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">manager</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(manager);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">load</span>(<span class="params">url, onLoad, onProgress, onError</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> scope = <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">const</span> path = <span class="built_in">this</span>.path === <span class="string">&#x27;&#x27;</span> ? LoaderUtils.extractUrlBase(url) : <span class="built_in">this</span>.path;</span><br><span class="line">            <span class="built_in">this</span>.resourcePath = <span class="built_in">this</span>.resourcePath || path;</span><br><span class="line">            <span class="keyword">const</span> loader = <span class="keyword">new</span> FileLoader(<span class="built_in">this</span>.manager);</span><br><span class="line">            loader.setPath(<span class="built_in">this</span>.path);</span><br><span class="line">            loader.setRequestHeader(<span class="built_in">this</span>.requestHeader);</span><br><span class="line">            loader.setWithCredentials(<span class="built_in">this</span>.withCredentials);</span><br><span class="line">            loader.load(url, <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">let</span> json = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    json = <span class="built_in">JSON</span>.parse(text);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (onError !== <span class="literal">undefined</span>) onError(error);</span><br><span class="line">                    <span class="built_in">console</span>.error(<span class="string">&#x27;THREE:ObjectLoader: Can\&#x27;t parse &#x27;</span> + url + <span class="string">&#x27;.&#x27;</span>, error.message);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> metadata = json.metadata;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (metadata === <span class="literal">undefined</span> || metadata.type === <span class="literal">undefined</span> || metadata.type.toLowerCase() === <span class="string">&#x27;geometry&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.ObjectLoader: Can\&#x27;t load &#x27;</span> + url);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                scope.parse(json, onLoad);</span><br><span class="line">            &#125;, onProgress, onError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="title">loadAsync</span>(<span class="params">url, onProgress</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> scope = <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">const</span> path = <span class="built_in">this</span>.path === <span class="string">&#x27;&#x27;</span> ? LoaderUtils.extractUrlBase(url) : <span class="built_in">this</span>.path;</span><br><span class="line">            <span class="built_in">this</span>.resourcePath = <span class="built_in">this</span>.resourcePath || path;</span><br><span class="line">            <span class="keyword">const</span> loader = <span class="keyword">new</span> FileLoader(<span class="built_in">this</span>.manager);</span><br><span class="line">            loader.setPath(<span class="built_in">this</span>.path);</span><br><span class="line">            loader.setRequestHeader(<span class="built_in">this</span>.requestHeader);</span><br><span class="line">            loader.setWithCredentials(<span class="built_in">this</span>.withCredentials);</span><br><span class="line">            <span class="keyword">const</span> text = <span class="keyword">await</span> loader.loadAsync(url, onProgress);</span><br><span class="line">            <span class="keyword">const</span> json = <span class="built_in">JSON</span>.parse(text);</span><br><span class="line">            <span class="keyword">const</span> metadata = json.metadata;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (metadata === <span class="literal">undefined</span> || metadata.type === <span class="literal">undefined</span> || metadata.type.toLowerCase() === <span class="string">&#x27;geometry&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;THREE.ObjectLoader: Can\&#x27;t load &#x27;</span> + url);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> scope.parseAsync(json);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">parse</span>(<span class="params">json, onLoad</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> animations = <span class="built_in">this</span>.parseAnimations(json.animations);</span><br><span class="line">            <span class="keyword">const</span> shapes = <span class="built_in">this</span>.parseShapes(json.shapes);</span><br><span class="line">            <span class="keyword">const</span> geometries = <span class="built_in">this</span>.parseGeometries(json.geometries, shapes);</span><br><span class="line">            <span class="keyword">const</span> images = <span class="built_in">this</span>.parseImages(json.images, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (onLoad !== <span class="literal">undefined</span>) onLoad(object);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">const</span> textures = <span class="built_in">this</span>.parseTextures(json.textures, images);</span><br><span class="line">            <span class="keyword">const</span> materials = <span class="built_in">this</span>.parseMaterials(json.materials, textures);</span><br><span class="line">            <span class="keyword">const</span> object = <span class="built_in">this</span>.parseObject(json.object, geometries, materials, textures, animations);</span><br><span class="line">            <span class="keyword">const</span> skeletons = <span class="built_in">this</span>.parseSkeletons(json.skeletons, object);</span><br><span class="line">            <span class="built_in">this</span>.bindSkeletons(object, skeletons); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (onLoad !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> hasImages = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> uuid <span class="keyword">in</span> images) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (images[uuid] <span class="keyword">instanceof</span> HTMLImageElement) &#123;</span><br><span class="line">                        hasImages = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (hasImages === <span class="literal">false</span>) onLoad(object);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="title">parseAsync</span>(<span class="params">json</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> animations = <span class="built_in">this</span>.parseAnimations(json.animations);</span><br><span class="line">            <span class="keyword">const</span> shapes = <span class="built_in">this</span>.parseShapes(json.shapes);</span><br><span class="line">            <span class="keyword">const</span> geometries = <span class="built_in">this</span>.parseGeometries(json.geometries, shapes);</span><br><span class="line">            <span class="keyword">const</span> images = <span class="keyword">await</span> <span class="built_in">this</span>.parseImagesAsync(json.images);</span><br><span class="line">            <span class="keyword">const</span> textures = <span class="built_in">this</span>.parseTextures(json.textures, images);</span><br><span class="line">            <span class="keyword">const</span> materials = <span class="built_in">this</span>.parseMaterials(json.materials, textures);</span><br><span class="line">            <span class="keyword">const</span> object = <span class="built_in">this</span>.parseObject(json.object, geometries, materials, textures, animations);</span><br><span class="line">            <span class="keyword">const</span> skeletons = <span class="built_in">this</span>.parseSkeletons(json.skeletons, object);</span><br><span class="line">            <span class="built_in">this</span>.bindSkeletons(object, skeletons);</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">parseShapes</span>(<span class="params">json</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> shapes = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (json !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = json.length; i &lt; l; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> shape = <span class="keyword">new</span> Shape().fromJSON(json[i]);</span><br><span class="line">                    shapes[shape.uuid] = shape;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> shapes;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">parseSkeletons</span>(<span class="params">json, object</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> skeletons = &#123;&#125;;</span><br><span class="line">            <span class="keyword">const</span> bones = &#123;&#125;; <span class="comment">// generate bone lookup table</span></span><br><span class="line"></span><br><span class="line">            object.traverse(<span class="function"><span class="keyword">function</span> (<span class="params">child</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (child.isBone) bones[child.uuid] = child;</span><br><span class="line">            &#125;); <span class="comment">// create skeletons</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (json !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = json.length; i &lt; l; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> skeleton = <span class="keyword">new</span> Skeleton().fromJSON(json[i], bones);</span><br><span class="line">                    skeletons[skeleton.uuid] = skeleton;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> skeletons;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">parseGeometries</span>(<span class="params">json, shapes</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> geometries = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (json !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> bufferGeometryLoader = <span class="keyword">new</span> BufferGeometryLoader();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = json.length; i &lt; l; i++) &#123;</span><br><span class="line">                    <span class="keyword">let</span> geometry;</span><br><span class="line">                    <span class="keyword">const</span> data = json[i];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">switch</span> (data.type) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;BufferGeometry&#x27;</span>:</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;InstancedBufferGeometry&#x27;</span>:</span><br><span class="line">                            geometry = bufferGeometryLoader.parse(data);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;Geometry&#x27;</span>:</span><br><span class="line">                            <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.ObjectLoader: The legacy Geometry type is no longer supported.&#x27;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">if</span> (data.type <span class="keyword">in</span> Geometries) &#123;</span><br><span class="line">                                geometry = Geometries[data.type].fromJSON(data, shapes);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="built_in">console</span>.warn(<span class="string">`THREE.ObjectLoader: Unsupported geometry type &quot;<span class="subst">$&#123;data.type&#125;</span>&quot;`</span>);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    geometry.uuid = data.uuid;</span><br><span class="line">                    <span class="keyword">if</span> (data.name !== <span class="literal">undefined</span>) geometry.name = data.name;</span><br><span class="line">                    <span class="keyword">if</span> (geometry.isBufferGeometry === <span class="literal">true</span> &amp;&amp; data.userData !== <span class="literal">undefined</span>) geometry.userData = data.userData;</span><br><span class="line">                    geometries[data.uuid] = geometry;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> geometries;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">parseMaterials</span>(<span class="params">json, textures</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> cache = &#123;&#125;; <span class="comment">// MultiMaterial</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> materials = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (json !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> loader = <span class="keyword">new</span> MaterialLoader();</span><br><span class="line">                loader.setTextures(textures);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = json.length; i &lt; l; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> data = json[i];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (data.type === <span class="string">&#x27;MultiMaterial&#x27;</span>) &#123;</span><br><span class="line">                        <span class="comment">// Deprecated</span></span><br><span class="line">                        <span class="keyword">const</span> array = [];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; data.materials.length; j++) &#123;</span><br><span class="line">                            <span class="keyword">const</span> material = data.materials[j];</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (cache[material.uuid] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                                cache[material.uuid] = loader.parse(material);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            array.push(cache[material.uuid]);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        materials[data.uuid] = array;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (cache[data.uuid] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                            cache[data.uuid] = loader.parse(data);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        materials[data.uuid] = cache[data.uuid];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> materials;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">parseAnimations</span>(<span class="params">json</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> animations = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (json !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; json.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> data = json[i];</span><br><span class="line">                    <span class="keyword">const</span> clip = AnimationClip.parse(data);</span><br><span class="line">                    animations[clip.uuid] = clip;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> animations;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">parseImages</span>(<span class="params">json, onLoad</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> scope = <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">const</span> images = &#123;&#125;;</span><br><span class="line">            <span class="keyword">let</span> loader;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">loadImage</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">                scope.manager.itemStart(url);</span><br><span class="line">                <span class="keyword">return</span> loader.load(url, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    scope.manager.itemEnd(url);</span><br><span class="line">                &#125;, <span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    scope.manager.itemError(url);</span><br><span class="line">                    scope.manager.itemEnd(url);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">deserializeImage</span>(<span class="params">image</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> image === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> url = image;</span><br><span class="line">                    <span class="keyword">const</span> path = <span class="regexp">/^(\/\/)|([a-z]+:(\/\/)?)/i</span>.test(url) ? url : scope.resourcePath + url;</span><br><span class="line">                    <span class="keyword">return</span> loadImage(path);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (image.data) &#123;</span><br><span class="line">                        <span class="keyword">return</span> &#123;</span><br><span class="line">                            <span class="attr">data</span>: getTypedArray(image.type, image.data),</span><br><span class="line">                            <span class="attr">width</span>: image.width,</span><br><span class="line">                            <span class="attr">height</span>: image.height</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (json !== <span class="literal">undefined</span> &amp;&amp; json.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> manager = <span class="keyword">new</span> LoadingManager(onLoad);</span><br><span class="line">                loader = <span class="keyword">new</span> ImageLoader(manager);</span><br><span class="line">                loader.setCrossOrigin(<span class="built_in">this</span>.crossOrigin);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = json.length; i &lt; il; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> image = json[i];</span><br><span class="line">                    <span class="keyword">const</span> url = image.url;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(url)) &#123;</span><br><span class="line">                        <span class="comment">// load array of images e.g CubeTexture</span></span><br><span class="line">                        <span class="keyword">const</span> imageArray = [];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, jl = url.length; j &lt; jl; j++) &#123;</span><br><span class="line">                            <span class="keyword">const</span> currentUrl = url[j];</span><br><span class="line">                            <span class="keyword">const</span> deserializedImage = deserializeImage(currentUrl);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (deserializedImage !== <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (deserializedImage <span class="keyword">instanceof</span> HTMLImageElement) &#123;</span><br><span class="line">                                    imageArray.push(deserializedImage);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="comment">// special case: handle array of data textures for cube textures</span></span><br><span class="line">                                    imageArray.push(<span class="keyword">new</span> DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        images[image.uuid] = <span class="keyword">new</span> Source(imageArray);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// load single image</span></span><br><span class="line">                        <span class="keyword">const</span> deserializedImage = deserializeImage(image.url);</span><br><span class="line">                        images[image.uuid] = <span class="keyword">new</span> Source(deserializedImage);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> images;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="title">parseImagesAsync</span>(<span class="params">json</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> scope = <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">const</span> images = &#123;&#125;;</span><br><span class="line">            <span class="keyword">let</span> loader;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">deserializeImage</span>(<span class="params">image</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> image === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> url = image;</span><br><span class="line">                    <span class="keyword">const</span> path = <span class="regexp">/^(\/\/)|([a-z]+:(\/\/)?)/i</span>.test(url) ? url : scope.resourcePath + url;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">await</span> loader.loadAsync(path);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (image.data) &#123;</span><br><span class="line">                        <span class="keyword">return</span> &#123;</span><br><span class="line">                            <span class="attr">data</span>: getTypedArray(image.type, image.data),</span><br><span class="line">                            <span class="attr">width</span>: image.width,</span><br><span class="line">                            <span class="attr">height</span>: image.height</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (json !== <span class="literal">undefined</span> &amp;&amp; json.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                loader = <span class="keyword">new</span> ImageLoader(<span class="built_in">this</span>.manager);</span><br><span class="line">                loader.setCrossOrigin(<span class="built_in">this</span>.crossOrigin);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = json.length; i &lt; il; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> image = json[i];</span><br><span class="line">                    <span class="keyword">const</span> url = image.url;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(url)) &#123;</span><br><span class="line">                        <span class="comment">// load array of images e.g CubeTexture</span></span><br><span class="line">                        <span class="keyword">const</span> imageArray = [];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, jl = url.length; j &lt; jl; j++) &#123;</span><br><span class="line">                            <span class="keyword">const</span> currentUrl = url[j];</span><br><span class="line">                            <span class="keyword">const</span> deserializedImage = <span class="keyword">await</span> deserializeImage(currentUrl);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (deserializedImage !== <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (deserializedImage <span class="keyword">instanceof</span> HTMLImageElement) &#123;</span><br><span class="line">                                    imageArray.push(deserializedImage);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="comment">// special case: handle array of data textures for cube textures</span></span><br><span class="line">                                    imageArray.push(<span class="keyword">new</span> DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        images[image.uuid] = <span class="keyword">new</span> Source(imageArray);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// load single image</span></span><br><span class="line">                        <span class="keyword">const</span> deserializedImage = <span class="keyword">await</span> deserializeImage(image.url);</span><br><span class="line">                        images[image.uuid] = <span class="keyword">new</span> Source(deserializedImage);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> images;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">parseTextures</span>(<span class="params">json, images</span>)</span> &#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">parseConstant</span>(<span class="params">value, type</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span>) <span class="keyword">return</span> value;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.ObjectLoader.parseTexture: Constant should be in numeric form.&#x27;</span>, value);</span><br><span class="line">                <span class="keyword">return</span> type[value];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> textures = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (json !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = json.length; i &lt; l; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> data = json[i];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (data.image === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.ObjectLoader: No &quot;image&quot; specified for&#x27;</span>, data.uuid);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (images[data.image] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.ObjectLoader: Undefined image&#x27;</span>, data.image);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> source = images[data.image];</span><br><span class="line">                    <span class="keyword">const</span> image = source.data;</span><br><span class="line">                    <span class="keyword">let</span> texture;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(image)) &#123;</span><br><span class="line">                        texture = <span class="keyword">new</span> CubeTexture();</span><br><span class="line">                        <span class="keyword">if</span> (image.length === <span class="number">6</span>) texture.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (image &amp;&amp; image.data) &#123;</span><br><span class="line">                            texture = <span class="keyword">new</span> DataTexture();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            texture = <span class="keyword">new</span> Texture();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (image) texture.needsUpdate = <span class="literal">true</span>; <span class="comment">// textures can have undefined image data</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    texture.source = source;</span><br><span class="line">                    texture.uuid = data.uuid;</span><br><span class="line">                    <span class="keyword">if</span> (data.name !== <span class="literal">undefined</span>) texture.name = data.name;</span><br><span class="line">                    <span class="keyword">if</span> (data.mapping !== <span class="literal">undefined</span>) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);</span><br><span class="line">                    <span class="keyword">if</span> (data.offset !== <span class="literal">undefined</span>) texture.offset.fromArray(data.offset);</span><br><span class="line">                    <span class="keyword">if</span> (data.repeat !== <span class="literal">undefined</span>) texture.repeat.fromArray(data.repeat);</span><br><span class="line">                    <span class="keyword">if</span> (data.center !== <span class="literal">undefined</span>) texture.center.fromArray(data.center);</span><br><span class="line">                    <span class="keyword">if</span> (data.rotation !== <span class="literal">undefined</span>) texture.rotation = data.rotation;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (data.wrap !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        texture.wrapS = parseConstant(data.wrap[<span class="number">0</span>], TEXTURE_WRAPPING);</span><br><span class="line">                        texture.wrapT = parseConstant(data.wrap[<span class="number">1</span>], TEXTURE_WRAPPING);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (data.format !== <span class="literal">undefined</span>) texture.format = data.format;</span><br><span class="line">                    <span class="keyword">if</span> (data.type !== <span class="literal">undefined</span>) texture.type = data.type;</span><br><span class="line">                    <span class="keyword">if</span> (data.encoding !== <span class="literal">undefined</span>) texture.encoding = data.encoding;</span><br><span class="line">                    <span class="keyword">if</span> (data.minFilter !== <span class="literal">undefined</span>) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);</span><br><span class="line">                    <span class="keyword">if</span> (data.magFilter !== <span class="literal">undefined</span>) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);</span><br><span class="line">                    <span class="keyword">if</span> (data.anisotropy !== <span class="literal">undefined</span>) texture.anisotropy = data.anisotropy;</span><br><span class="line">                    <span class="keyword">if</span> (data.flipY !== <span class="literal">undefined</span>) texture.flipY = data.flipY;</span><br><span class="line">                    <span class="keyword">if</span> (data.premultiplyAlpha !== <span class="literal">undefined</span>) texture.premultiplyAlpha = data.premultiplyAlpha;</span><br><span class="line">                    <span class="keyword">if</span> (data.unpackAlignment !== <span class="literal">undefined</span>) texture.unpackAlignment = data.unpackAlignment;</span><br><span class="line">                    <span class="keyword">if</span> (data.userData !== <span class="literal">undefined</span>) texture.userData = data.userData;</span><br><span class="line">                    textures[data.uuid] = texture;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> textures;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">parseObject</span>(<span class="params">data, geometries, materials, textures, animations</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> object;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">getGeometry</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (geometries[name] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.ObjectLoader: Undefined geometry&#x27;</span>, name);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> geometries[name];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">getMaterial</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (name === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(name)) &#123;</span><br><span class="line">                    <span class="keyword">const</span> array = [];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = name.length; i &lt; l; i++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> uuid = name[i];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (materials[uuid] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.ObjectLoader: Undefined material&#x27;</span>, uuid);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        array.push(materials[uuid]);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> array;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (materials[name] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.ObjectLoader: Undefined material&#x27;</span>, name);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> materials[name];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">getTexture</span>(<span class="params">uuid</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (textures[uuid] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.ObjectLoader: Undefined texture&#x27;</span>, uuid);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> textures[uuid];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> geometry, material;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (data.type) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;Scene&#x27;</span>:</span><br><span class="line">                    object = <span class="keyword">new</span> Scene();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (data.background !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">Number</span>.isInteger(data.background)) &#123;</span><br><span class="line">                            object.background = <span class="keyword">new</span> Color(data.background);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            object.background = getTexture(data.background);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (data.environment !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        object.environment = getTexture(data.environment);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (data.fog !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (data.fog.type === <span class="string">&#x27;Fog&#x27;</span>) &#123;</span><br><span class="line">                            object.fog = <span class="keyword">new</span> Fog(data.fog.color, data.fog.near, data.fog.far);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.fog.type === <span class="string">&#x27;FogExp2&#x27;</span>) &#123;</span><br><span class="line">                            object.fog = <span class="keyword">new</span> FogExp2(data.fog.color, data.fog.density);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;PerspectiveCamera&#x27;</span>:</span><br><span class="line">                    object = <span class="keyword">new</span> PerspectiveCamera(data.fov, data.aspect, data.near, data.far);</span><br><span class="line">                    <span class="keyword">if</span> (data.focus !== <span class="literal">undefined</span>) object.focus = data.focus;</span><br><span class="line">                    <span class="keyword">if</span> (data.zoom !== <span class="literal">undefined</span>) object.zoom = data.zoom;</span><br><span class="line">                    <span class="keyword">if</span> (data.filmGauge !== <span class="literal">undefined</span>) object.filmGauge = data.filmGauge;</span><br><span class="line">                    <span class="keyword">if</span> (data.filmOffset !== <span class="literal">undefined</span>) object.filmOffset = data.filmOffset;</span><br><span class="line">                    <span class="keyword">if</span> (data.view !== <span class="literal">undefined</span>) object.view = <span class="built_in">Object</span>.assign(&#123;&#125;, data.view);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;OrthographicCamera&#x27;</span>:</span><br><span class="line">                    object = <span class="keyword">new</span> OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);</span><br><span class="line">                    <span class="keyword">if</span> (data.zoom !== <span class="literal">undefined</span>) object.zoom = data.zoom;</span><br><span class="line">                    <span class="keyword">if</span> (data.view !== <span class="literal">undefined</span>) object.view = <span class="built_in">Object</span>.assign(&#123;&#125;, data.view);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;AmbientLight&#x27;</span>:</span><br><span class="line">                    object = <span class="keyword">new</span> AmbientLight(data.color, data.intensity);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;DirectionalLight&#x27;</span>:</span><br><span class="line">                    object = <span class="keyword">new</span> DirectionalLight(data.color, data.intensity);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;PointLight&#x27;</span>:</span><br><span class="line">                    object = <span class="keyword">new</span> PointLight(data.color, data.intensity, data.distance, data.decay);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;RectAreaLight&#x27;</span>:</span><br><span class="line">                    object = <span class="keyword">new</span> RectAreaLight(data.color, data.intensity, data.width, data.height);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;SpotLight&#x27;</span>:</span><br><span class="line">                    object = <span class="keyword">new</span> SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;HemisphereLight&#x27;</span>:</span><br><span class="line">                    object = <span class="keyword">new</span> HemisphereLight(data.color, data.groundColor, data.intensity);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;LightProbe&#x27;</span>:</span><br><span class="line">                    object = <span class="keyword">new</span> LightProbe().fromJSON(data);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;SkinnedMesh&#x27;</span>:</span><br><span class="line">                    geometry = getGeometry(data.geometry);</span><br><span class="line">                    material = getMaterial(data.material);</span><br><span class="line">                    object = <span class="keyword">new</span> SkinnedMesh(geometry, material);</span><br><span class="line">                    <span class="keyword">if</span> (data.bindMode !== <span class="literal">undefined</span>) object.bindMode = data.bindMode;</span><br><span class="line">                    <span class="keyword">if</span> (data.bindMatrix !== <span class="literal">undefined</span>) object.bindMatrix.fromArray(data.bindMatrix);</span><br><span class="line">                    <span class="keyword">if</span> (data.skeleton !== <span class="literal">undefined</span>) object.skeleton = data.skeleton;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;Mesh&#x27;</span>:</span><br><span class="line">                    geometry = getGeometry(data.geometry);</span><br><span class="line">                    material = getMaterial(data.material);</span><br><span class="line">                    object = <span class="keyword">new</span> Mesh(geometry, material);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;InstancedMesh&#x27;</span>:</span><br><span class="line">                    geometry = getGeometry(data.geometry);</span><br><span class="line">                    material = getMaterial(data.material);</span><br><span class="line">                    <span class="keyword">const</span> count = data.count;</span><br><span class="line">                    <span class="keyword">const</span> instanceMatrix = data.instanceMatrix;</span><br><span class="line">                    <span class="keyword">const</span> instanceColor = data.instanceColor;</span><br><span class="line">                    object = <span class="keyword">new</span> InstancedMesh(geometry, material, count);</span><br><span class="line">                    object.instanceMatrix = <span class="keyword">new</span> InstancedBufferAttribute(<span class="keyword">new</span> <span class="built_in">Float32Array</span>(instanceMatrix.array), <span class="number">16</span>);</span><br><span class="line">                    <span class="keyword">if</span> (instanceColor !== <span class="literal">undefined</span>) object.instanceColor = <span class="keyword">new</span> InstancedBufferAttribute(<span class="keyword">new</span> <span class="built_in">Float32Array</span>(instanceColor.array), instanceColor.itemSize);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;LOD&#x27;</span>:</span><br><span class="line">                    object = <span class="keyword">new</span> LOD();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;Line&#x27;</span>:</span><br><span class="line">                    object = <span class="keyword">new</span> Line(getGeometry(data.geometry), getMaterial(data.material));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;LineLoop&#x27;</span>:</span><br><span class="line">                    object = <span class="keyword">new</span> LineLoop(getGeometry(data.geometry), getMaterial(data.material));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;LineSegments&#x27;</span>:</span><br><span class="line">                    object = <span class="keyword">new</span> LineSegments(getGeometry(data.geometry), getMaterial(data.material));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;PointCloud&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;Points&#x27;</span>:</span><br><span class="line">                    object = <span class="keyword">new</span> Points(getGeometry(data.geometry), getMaterial(data.material));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;Sprite&#x27;</span>:</span><br><span class="line">                    object = <span class="keyword">new</span> Sprite(getMaterial(data.material));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;Group&#x27;</span>:</span><br><span class="line">                    object = <span class="keyword">new</span> Group();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;Bone&#x27;</span>:</span><br><span class="line">                    object = <span class="keyword">new</span> Bone();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    object = <span class="keyword">new</span> Object3D();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            object.uuid = data.uuid;</span><br><span class="line">            <span class="keyword">if</span> (data.name !== <span class="literal">undefined</span>) object.name = data.name;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (data.matrix !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                object.matrix.fromArray(data.matrix);</span><br><span class="line">                <span class="keyword">if</span> (data.matrixAutoUpdate !== <span class="literal">undefined</span>) object.matrixAutoUpdate = data.matrixAutoUpdate;</span><br><span class="line">                <span class="keyword">if</span> (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (data.position !== <span class="literal">undefined</span>) object.position.fromArray(data.position);</span><br><span class="line">                <span class="keyword">if</span> (data.rotation !== <span class="literal">undefined</span>) object.rotation.fromArray(data.rotation);</span><br><span class="line">                <span class="keyword">if</span> (data.quaternion !== <span class="literal">undefined</span>) object.quaternion.fromArray(data.quaternion);</span><br><span class="line">                <span class="keyword">if</span> (data.scale !== <span class="literal">undefined</span>) object.scale.fromArray(data.scale);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (data.castShadow !== <span class="literal">undefined</span>) object.castShadow = data.castShadow;</span><br><span class="line">            <span class="keyword">if</span> (data.receiveShadow !== <span class="literal">undefined</span>) object.receiveShadow = data.receiveShadow;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (data.shadow) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data.shadow.bias !== <span class="literal">undefined</span>) object.shadow.bias = data.shadow.bias;</span><br><span class="line">                <span class="keyword">if</span> (data.shadow.normalBias !== <span class="literal">undefined</span>) object.shadow.normalBias = data.shadow.normalBias;</span><br><span class="line">                <span class="keyword">if</span> (data.shadow.radius !== <span class="literal">undefined</span>) object.shadow.radius = data.shadow.radius;</span><br><span class="line">                <span class="keyword">if</span> (data.shadow.mapSize !== <span class="literal">undefined</span>) object.shadow.mapSize.fromArray(data.shadow.mapSize);</span><br><span class="line">                <span class="keyword">if</span> (data.shadow.camera !== <span class="literal">undefined</span>) object.shadow.camera = <span class="built_in">this</span>.parseObject(data.shadow.camera);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (data.visible !== <span class="literal">undefined</span>) object.visible = data.visible;</span><br><span class="line">            <span class="keyword">if</span> (data.frustumCulled !== <span class="literal">undefined</span>) object.frustumCulled = data.frustumCulled;</span><br><span class="line">            <span class="keyword">if</span> (data.renderOrder !== <span class="literal">undefined</span>) object.renderOrder = data.renderOrder;</span><br><span class="line">            <span class="keyword">if</span> (data.userData !== <span class="literal">undefined</span>) object.userData = data.userData;</span><br><span class="line">            <span class="keyword">if</span> (data.layers !== <span class="literal">undefined</span>) object.layers.mask = data.layers;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (data.children !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> children = data.children;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">                    object.add(<span class="built_in">this</span>.parseObject(children[i], geometries, materials, textures, animations));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (data.animations !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> objectAnimations = data.animations;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; objectAnimations.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> uuid = objectAnimations[i];</span><br><span class="line">                    object.animations.push(animations[uuid]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (data.type === <span class="string">&#x27;LOD&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data.autoUpdate !== <span class="literal">undefined</span>) object.autoUpdate = data.autoUpdate;</span><br><span class="line">                <span class="keyword">const</span> levels = data.levels;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> l = <span class="number">0</span>; l &lt; levels.length; l++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> level = levels[l];</span><br><span class="line">                    <span class="keyword">const</span> child = object.getObjectByProperty(<span class="string">&#x27;uuid&#x27;</span>, level.object);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (child !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        object.addLevel(child, level.distance);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">bindSkeletons</span>(<span class="params">object, skeletons</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(skeletons).length === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            object.traverse(<span class="function"><span class="keyword">function</span> (<span class="params">child</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (child.isSkinnedMesh === <span class="literal">true</span> &amp;&amp; child.skeleton !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> skeleton = skeletons[child.skeleton];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (skeleton === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.ObjectLoader: No skeleton found with UUID:&#x27;</span>, child.skeleton);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        child.bind(skeleton, child.bindMatrix);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* DEPRECATED */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setTexturePath</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.setResourcePath(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> TEXTURE_MAPPING = &#123;</span><br><span class="line">        <span class="attr">UVMapping</span>: UVMapping,</span><br><span class="line">        <span class="attr">CubeReflectionMapping</span>: CubeReflectionMapping,</span><br><span class="line">        <span class="attr">CubeRefractionMapping</span>: CubeRefractionMapping,</span><br><span class="line">        <span class="attr">EquirectangularReflectionMapping</span>: EquirectangularReflectionMapping,</span><br><span class="line">        <span class="attr">EquirectangularRefractionMapping</span>: EquirectangularRefractionMapping,</span><br><span class="line">        <span class="attr">CubeUVReflectionMapping</span>: CubeUVReflectionMapping</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> TEXTURE_WRAPPING = &#123;</span><br><span class="line">        <span class="attr">RepeatWrapping</span>: RepeatWrapping,</span><br><span class="line">        <span class="attr">ClampToEdgeWrapping</span>: ClampToEdgeWrapping,</span><br><span class="line">        <span class="attr">MirroredRepeatWrapping</span>: MirroredRepeatWrapping</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> TEXTURE_FILTER = &#123;</span><br><span class="line">        <span class="attr">NearestFilter</span>: NearestFilter,</span><br><span class="line">        <span class="attr">NearestMipmapNearestFilter</span>: NearestMipmapNearestFilter,</span><br><span class="line">        <span class="attr">NearestMipmapLinearFilter</span>: NearestMipmapLinearFilter,</span><br><span class="line">        <span class="attr">LinearFilter</span>: LinearFilter,</span><br><span class="line">        <span class="attr">LinearMipmapNearestFilter</span>: LinearMipmapNearestFilter,</span><br><span class="line">        <span class="attr">LinearMipmapLinearFilter</span>: LinearMipmapLinearFilter</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ImageBitmapLoader</span> <span class="keyword">extends</span> <span class="title">Loader</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">manager</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(manager);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> createImageBitmap === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.ImageBitmapLoader: createImageBitmap() not supported.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> fetch === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.ImageBitmapLoader: fetch() not supported.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.options = &#123;</span><br><span class="line">                <span class="attr">premultiplyAlpha</span>: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setOptions</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.options = options;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">load</span>(<span class="params">url, onLoad, onProgress, onError</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (url === <span class="literal">undefined</span>) url = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.path !== <span class="literal">undefined</span>) url = <span class="built_in">this</span>.path + url;</span><br><span class="line">            url = <span class="built_in">this</span>.manager.resolveURL(url);</span><br><span class="line">            <span class="keyword">const</span> scope = <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">const</span> cached = Cache.get(url);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cached !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                scope.manager.itemStart(url);</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (onLoad) onLoad(cached);</span><br><span class="line">                    scope.manager.itemEnd(url);</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> cached;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> fetchOptions = &#123;&#125;;</span><br><span class="line">            fetchOptions.credentials = <span class="built_in">this</span>.crossOrigin === <span class="string">&#x27;anonymous&#x27;</span> ? <span class="string">&#x27;same-origin&#x27;</span> : <span class="string">&#x27;include&#x27;</span>;</span><br><span class="line">            fetchOptions.headers = <span class="built_in">this</span>.requestHeader;</span><br><span class="line">            fetch(url, fetchOptions).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> res.blob();</span><br><span class="line">            &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">blob</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> createImageBitmap(blob, <span class="built_in">Object</span>.assign(scope.options, &#123;</span><br><span class="line">                    <span class="attr">colorSpaceConversion</span>: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">                &#125;));</span><br><span class="line">            &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">imageBitmap</span>) </span>&#123;</span><br><span class="line">                Cache.add(url, imageBitmap);</span><br><span class="line">                <span class="keyword">if</span> (onLoad) onLoad(imageBitmap);</span><br><span class="line">                scope.manager.itemEnd(url);</span><br><span class="line">            &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (onError) onError(e);</span><br><span class="line">                scope.manager.itemError(url);</span><br><span class="line">                scope.manager.itemEnd(url);</span><br><span class="line">            &#125;);</span><br><span class="line">            scope.manager.itemStart(url);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ImageBitmapLoader.prototype.isImageBitmapLoader = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> _context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> AudioContext = &#123;</span><br><span class="line">        <span class="attr">getContext</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (_context === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                _context = <span class="keyword">new</span> (<span class="built_in">window</span>.AudioContext || <span class="built_in">window</span>.webkitAudioContext)();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> _context;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">setContext</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">            _context = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AudioLoader</span> <span class="keyword">extends</span> <span class="title">Loader</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">manager</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(manager);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">load</span>(<span class="params">url, onLoad, onProgress, onError</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> scope = <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">const</span> loader = <span class="keyword">new</span> FileLoader(<span class="built_in">this</span>.manager);</span><br><span class="line">            loader.setResponseType(<span class="string">&#x27;arraybuffer&#x27;</span>);</span><br><span class="line">            loader.setPath(<span class="built_in">this</span>.path);</span><br><span class="line">            loader.setRequestHeader(<span class="built_in">this</span>.requestHeader);</span><br><span class="line">            loader.setWithCredentials(<span class="built_in">this</span>.withCredentials);</span><br><span class="line">            loader.load(url, <span class="function"><span class="keyword">function</span> (<span class="params">buffer</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Create a copy of the buffer. The `decodeAudioData` method</span></span><br><span class="line">                    <span class="comment">// detaches the buffer when complete, preventing reuse.</span></span><br><span class="line">                    <span class="keyword">const</span> bufferCopy = buffer.slice(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">const</span> context = AudioContext.getContext();</span><br><span class="line">                    context.decodeAudioData(bufferCopy, <span class="function"><span class="keyword">function</span> (<span class="params">audioBuffer</span>) </span>&#123;</span><br><span class="line">                        onLoad(audioBuffer);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (onError) &#123;</span><br><span class="line">                        onError(e);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">console</span>.error(e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    scope.manager.itemError(url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, onProgress, onError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HemisphereLightProbe</span> <span class="keyword">extends</span> <span class="title">LightProbe</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">skyColor, groundColor, intensity = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="literal">undefined</span>, intensity);</span><br><span class="line">            <span class="keyword">const</span> color1 = <span class="keyword">new</span> Color().set(skyColor);</span><br><span class="line">            <span class="keyword">const</span> color2 = <span class="keyword">new</span> Color().set(groundColor);</span><br><span class="line">            <span class="keyword">const</span> sky = <span class="keyword">new</span> Vector3(color1.r, color1.g, color1.b);</span><br><span class="line">            <span class="keyword">const</span> ground = <span class="keyword">new</span> Vector3(color2.r, color2.g, color2.b); <span class="comment">// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> c0 = <span class="built_in">Math</span>.sqrt(<span class="built_in">Math</span>.PI);</span><br><span class="line">            <span class="keyword">const</span> c1 = c0 * <span class="built_in">Math</span>.sqrt(<span class="number">0.75</span>);</span><br><span class="line">            <span class="built_in">this</span>.sh.coefficients[<span class="number">0</span>].copy(sky).add(ground).multiplyScalar(c0);</span><br><span class="line">            <span class="built_in">this</span>.sh.coefficients[<span class="number">1</span>].copy(sky).sub(ground).multiplyScalar(c1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HemisphereLightProbe.prototype.isHemisphereLightProbe = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AmbientLightProbe</span> <span class="keyword">extends</span> <span class="title">LightProbe</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">color, intensity = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="literal">undefined</span>, intensity);</span><br><span class="line">            <span class="keyword">const</span> color1 = <span class="keyword">new</span> Color().set(color); <span class="comment">// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.sh.coefficients[<span class="number">0</span>].set(color1.r, color1.g, color1.b).multiplyScalar(<span class="number">2</span> * <span class="built_in">Math</span>.sqrt(<span class="built_in">Math</span>.PI));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AmbientLightProbe.prototype.isAmbientLightProbe = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _eyeRight = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Matrix4();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _eyeLeft = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Matrix4();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _projectionMatrix = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Matrix4();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">StereoCamera</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;StereoCamera&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.aspect = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.eyeSep = <span class="number">0.064</span>;</span><br><span class="line">            <span class="built_in">this</span>.cameraL = <span class="keyword">new</span> PerspectiveCamera();</span><br><span class="line">            <span class="built_in">this</span>.cameraL.layers.enable(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.cameraL.matrixAutoUpdate = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.cameraR = <span class="keyword">new</span> PerspectiveCamera();</span><br><span class="line">            <span class="built_in">this</span>.cameraR.layers.enable(<span class="number">2</span>);</span><br><span class="line">            <span class="built_in">this</span>.cameraR.matrixAutoUpdate = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>._cache = &#123;</span><br><span class="line">                <span class="attr">focus</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">fov</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">aspect</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">near</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">far</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">zoom</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">eyeSep</span>: <span class="literal">null</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">update</span>(<span class="params">camera</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> cache = <span class="built_in">this</span>._cache;</span><br><span class="line">            <span class="keyword">const</span> needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * <span class="built_in">this</span>.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== <span class="built_in">this</span>.eyeSep;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (needsUpdate) &#123;</span><br><span class="line">                cache.focus = camera.focus;</span><br><span class="line">                cache.fov = camera.fov;</span><br><span class="line">                cache.aspect = camera.aspect * <span class="built_in">this</span>.aspect;</span><br><span class="line">                cache.near = camera.near;</span><br><span class="line">                cache.far = camera.far;</span><br><span class="line">                cache.zoom = camera.zoom;</span><br><span class="line">                cache.eyeSep = <span class="built_in">this</span>.eyeSep; <span class="comment">// Off-axis stereoscopic effect based on</span></span><br><span class="line">                <span class="comment">// http://paulbourke.net/stereographics/stereorender/</span></span><br><span class="line"></span><br><span class="line">                _projectionMatrix.copy(camera.projectionMatrix);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> eyeSepHalf = cache.eyeSep / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">const</span> eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;</span><br><span class="line">                <span class="keyword">const</span> ymax = cache.near * <span class="built_in">Math</span>.tan(DEG2RAD * cache.fov * <span class="number">0.5</span>) / cache.zoom;</span><br><span class="line">                <span class="keyword">let</span> xmin, xmax; <span class="comment">// translate xOffset</span></span><br><span class="line"></span><br><span class="line">                _eyeLeft.elements[<span class="number">12</span>] = -eyeSepHalf;</span><br><span class="line">                _eyeRight.elements[<span class="number">12</span>] = eyeSepHalf; <span class="comment">// for left eye</span></span><br><span class="line"></span><br><span class="line">                xmin = -ymax * cache.aspect + eyeSepOnProjection;</span><br><span class="line">                xmax = ymax * cache.aspect + eyeSepOnProjection;</span><br><span class="line">                _projectionMatrix.elements[<span class="number">0</span>] = <span class="number">2</span> * cache.near / (xmax - xmin);</span><br><span class="line">                _projectionMatrix.elements[<span class="number">8</span>] = (xmax + xmin) / (xmax - xmin);</span><br><span class="line">                <span class="built_in">this</span>.cameraL.projectionMatrix.copy(_projectionMatrix); <span class="comment">// for right eye</span></span><br><span class="line"></span><br><span class="line">                xmin = -ymax * cache.aspect - eyeSepOnProjection;</span><br><span class="line">                xmax = ymax * cache.aspect - eyeSepOnProjection;</span><br><span class="line">                _projectionMatrix.elements[<span class="number">0</span>] = <span class="number">2</span> * cache.near / (xmax - xmin);</span><br><span class="line">                _projectionMatrix.elements[<span class="number">8</span>] = (xmax + xmin) / (xmax - xmin);</span><br><span class="line">                <span class="built_in">this</span>.cameraR.projectionMatrix.copy(_projectionMatrix);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);</span><br><span class="line">            <span class="built_in">this</span>.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Clock</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">autoStart = <span class="literal">true</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.autoStart = autoStart;</span><br><span class="line">            <span class="built_in">this</span>.startTime = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.oldTime = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.elapsedTime = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.running = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.startTime = now();</span><br><span class="line">            <span class="built_in">this</span>.oldTime = <span class="built_in">this</span>.startTime;</span><br><span class="line">            <span class="built_in">this</span>.elapsedTime = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.running = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">stop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.getElapsedTime();</span><br><span class="line">            <span class="built_in">this</span>.running = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.autoStart = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getElapsedTime</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.getDelta();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.elapsedTime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getDelta</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> diff = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.autoStart &amp;&amp; !<span class="built_in">this</span>.running) &#123;</span><br><span class="line">                <span class="built_in">this</span>.start();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.running) &#123;</span><br><span class="line">                <span class="keyword">const</span> newTime = now();</span><br><span class="line">                diff = (newTime - <span class="built_in">this</span>.oldTime) / <span class="number">1000</span>;</span><br><span class="line">                <span class="built_in">this</span>.oldTime = newTime;</span><br><span class="line">                <span class="built_in">this</span>.elapsedTime += diff;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> diff;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">now</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">typeof</span> performance === <span class="string">&#x27;undefined&#x27;</span> ? <span class="built_in">Date</span> : performance).now(); <span class="comment">// see #10732</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _position$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _quaternion$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Quaternion();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _scale$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _orientation$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AudioListener</span> <span class="keyword">extends</span> <span class="title">Object3D</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;AudioListener&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.context = AudioContext.getContext();</span><br><span class="line">            <span class="built_in">this</span>.gain = <span class="built_in">this</span>.context.createGain();</span><br><span class="line">            <span class="built_in">this</span>.gain.connect(<span class="built_in">this</span>.context.destination);</span><br><span class="line">            <span class="built_in">this</span>.filter = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.timeDelta = <span class="number">0</span>; <span class="comment">// private</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._clock = <span class="keyword">new</span> Clock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getInput</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.gain;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">removeFilter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.filter !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.gain.disconnect(<span class="built_in">this</span>.filter);</span><br><span class="line">                <span class="built_in">this</span>.filter.disconnect(<span class="built_in">this</span>.context.destination);</span><br><span class="line">                <span class="built_in">this</span>.gain.connect(<span class="built_in">this</span>.context.destination);</span><br><span class="line">                <span class="built_in">this</span>.filter = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getFilter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.filter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFilter</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.filter !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.gain.disconnect(<span class="built_in">this</span>.filter);</span><br><span class="line">                <span class="built_in">this</span>.filter.disconnect(<span class="built_in">this</span>.context.destination);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.gain.disconnect(<span class="built_in">this</span>.context.destination);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.filter = value;</span><br><span class="line">            <span class="built_in">this</span>.gain.connect(<span class="built_in">this</span>.filter);</span><br><span class="line">            <span class="built_in">this</span>.filter.connect(<span class="built_in">this</span>.context.destination);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getMasterVolume</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.gain.gain.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setMasterVolume</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.gain.gain.setTargetAtTime(value, <span class="built_in">this</span>.context.currentTime, <span class="number">0.01</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">updateMatrixWorld</span>(<span class="params">force</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.updateMatrixWorld(force);</span><br><span class="line">            <span class="keyword">const</span> listener = <span class="built_in">this</span>.context.listener;</span><br><span class="line">            <span class="keyword">const</span> up = <span class="built_in">this</span>.up;</span><br><span class="line">            <span class="built_in">this</span>.timeDelta = <span class="built_in">this</span>._clock.getDelta();</span><br><span class="line">            <span class="built_in">this</span>.matrixWorld.decompose(_position$<span class="number">1</span>, _quaternion$<span class="number">1</span>, _scale$<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            _orientation$<span class="number">1.</span>set(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>).applyQuaternion(_quaternion$<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (listener.positionX) &#123;</span><br><span class="line">                <span class="comment">// code path for Chrome (see #14393)</span></span><br><span class="line">                <span class="keyword">const</span> endTime = <span class="built_in">this</span>.context.currentTime + <span class="built_in">this</span>.timeDelta;</span><br><span class="line">                listener.positionX.linearRampToValueAtTime(_position$<span class="number">1.</span>x, endTime);</span><br><span class="line">                listener.positionY.linearRampToValueAtTime(_position$<span class="number">1.</span>y, endTime);</span><br><span class="line">                listener.positionZ.linearRampToValueAtTime(_position$<span class="number">1.</span>z, endTime);</span><br><span class="line">                listener.forwardX.linearRampToValueAtTime(_orientation$<span class="number">1.</span>x, endTime);</span><br><span class="line">                listener.forwardY.linearRampToValueAtTime(_orientation$<span class="number">1.</span>y, endTime);</span><br><span class="line">                listener.forwardZ.linearRampToValueAtTime(_orientation$<span class="number">1.</span>z, endTime);</span><br><span class="line">                listener.upX.linearRampToValueAtTime(up.x, endTime);</span><br><span class="line">                listener.upY.linearRampToValueAtTime(up.y, endTime);</span><br><span class="line">                listener.upZ.linearRampToValueAtTime(up.z, endTime);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                listener.setPosition(_position$<span class="number">1.</span>x, _position$<span class="number">1.</span>y, _position$<span class="number">1.</span>z);</span><br><span class="line">                listener.setOrientation(_orientation$<span class="number">1.</span>x, _orientation$<span class="number">1.</span>y, _orientation$<span class="number">1.</span>z, up.x, up.y, up.z);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Audio</span> <span class="keyword">extends</span> <span class="title">Object3D</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">listener</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;Audio&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.listener = listener;</span><br><span class="line">            <span class="built_in">this</span>.context = listener.context;</span><br><span class="line">            <span class="built_in">this</span>.gain = <span class="built_in">this</span>.context.createGain();</span><br><span class="line">            <span class="built_in">this</span>.gain.connect(listener.getInput());</span><br><span class="line">            <span class="built_in">this</span>.autoplay = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.buffer = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.detune = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.loop = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.loopStart = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.loopEnd = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.offset = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.duration = <span class="literal">undefined</span>;</span><br><span class="line">            <span class="built_in">this</span>.playbackRate = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.isPlaying = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.hasPlaybackControl = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.source = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.sourceType = <span class="string">&#x27;empty&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>._startedAt = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>._progress = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>._connected = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.filters = [];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getOutput</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.gain;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setNodeSource</span>(<span class="params">audioNode</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.hasPlaybackControl = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.sourceType = <span class="string">&#x27;audioNode&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.source = audioNode;</span><br><span class="line">            <span class="built_in">this</span>.connect();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setMediaElementSource</span>(<span class="params">mediaElement</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.hasPlaybackControl = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.sourceType = <span class="string">&#x27;mediaNode&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.source = <span class="built_in">this</span>.context.createMediaElementSource(mediaElement);</span><br><span class="line">            <span class="built_in">this</span>.connect();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setMediaStreamSource</span>(<span class="params">mediaStream</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.hasPlaybackControl = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.sourceType = <span class="string">&#x27;mediaStreamNode&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.source = <span class="built_in">this</span>.context.createMediaStreamSource(mediaStream);</span><br><span class="line">            <span class="built_in">this</span>.connect();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setBuffer</span>(<span class="params">audioBuffer</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.buffer = audioBuffer;</span><br><span class="line">            <span class="built_in">this</span>.sourceType = <span class="string">&#x27;buffer&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.autoplay) <span class="built_in">this</span>.play();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">play</span>(<span class="params">delay = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isPlaying === <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Audio: Audio is already playing.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.hasPlaybackControl === <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Audio: this Audio has no playback control.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._startedAt = <span class="built_in">this</span>.context.currentTime + delay;</span><br><span class="line">            <span class="keyword">const</span> source = <span class="built_in">this</span>.context.createBufferSource();</span><br><span class="line">            source.buffer = <span class="built_in">this</span>.buffer;</span><br><span class="line">            source.loop = <span class="built_in">this</span>.loop;</span><br><span class="line">            source.loopStart = <span class="built_in">this</span>.loopStart;</span><br><span class="line">            source.loopEnd = <span class="built_in">this</span>.loopEnd;</span><br><span class="line">            source.onended = <span class="built_in">this</span>.onEnded.bind(<span class="built_in">this</span>);</span><br><span class="line">            source.start(<span class="built_in">this</span>._startedAt, <span class="built_in">this</span>._progress + <span class="built_in">this</span>.offset, <span class="built_in">this</span>.duration);</span><br><span class="line">            <span class="built_in">this</span>.isPlaying = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.source = source;</span><br><span class="line">            <span class="built_in">this</span>.setDetune(<span class="built_in">this</span>.detune);</span><br><span class="line">            <span class="built_in">this</span>.setPlaybackRate(<span class="built_in">this</span>.playbackRate);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.connect();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">pause</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.hasPlaybackControl === <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Audio: this Audio has no playback control.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isPlaying === <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// update current progress</span></span><br><span class="line">                <span class="built_in">this</span>._progress += <span class="built_in">Math</span>.max(<span class="built_in">this</span>.context.currentTime - <span class="built_in">this</span>._startedAt, <span class="number">0</span>) * <span class="built_in">this</span>.playbackRate;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.loop === <span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// ensure _progress does not exceed duration with looped audios</span></span><br><span class="line">                    <span class="built_in">this</span>._progress = <span class="built_in">this</span>._progress % (<span class="built_in">this</span>.duration || <span class="built_in">this</span>.buffer.duration);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.source.stop();</span><br><span class="line">                <span class="built_in">this</span>.source.onended = <span class="literal">null</span>;</span><br><span class="line">                <span class="built_in">this</span>.isPlaying = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">stop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.hasPlaybackControl === <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Audio: this Audio has no playback control.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._progress = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.source.stop();</span><br><span class="line">            <span class="built_in">this</span>.source.onended = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.isPlaying = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">connect</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.filters.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.source.connect(<span class="built_in">this</span>.filters[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, l = <span class="built_in">this</span>.filters.length; i &lt; l; i++) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.filters[i - <span class="number">1</span>].connect(<span class="built_in">this</span>.filters[i]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.filters[<span class="built_in">this</span>.filters.length - <span class="number">1</span>].connect(<span class="built_in">this</span>.getOutput());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.source.connect(<span class="built_in">this</span>.getOutput());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._connected = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">disconnect</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.filters.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.source.disconnect(<span class="built_in">this</span>.filters[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, l = <span class="built_in">this</span>.filters.length; i &lt; l; i++) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.filters[i - <span class="number">1</span>].disconnect(<span class="built_in">this</span>.filters[i]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.filters[<span class="built_in">this</span>.filters.length - <span class="number">1</span>].disconnect(<span class="built_in">this</span>.getOutput());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.source.disconnect(<span class="built_in">this</span>.getOutput());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._connected = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getFilters</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.filters;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFilters</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!value) value = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._connected === <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.disconnect();</span><br><span class="line">                <span class="built_in">this</span>.filters = value.slice();</span><br><span class="line">                <span class="built_in">this</span>.connect();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.filters = value.slice();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setDetune</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.detune = value;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.source.detune === <span class="literal">undefined</span>) <span class="keyword">return</span>; <span class="comment">// only set detune when available</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isPlaying === <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.source.detune.setTargetAtTime(<span class="built_in">this</span>.detune, <span class="built_in">this</span>.context.currentTime, <span class="number">0.01</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getDetune</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.detune;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getFilter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.getFilters()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFilter</span>(<span class="params">filter</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.setFilters(filter ? [filter] : []);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setPlaybackRate</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.hasPlaybackControl === <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Audio: this Audio has no playback control.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.playbackRate = value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isPlaying === <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.source.playbackRate.setTargetAtTime(<span class="built_in">this</span>.playbackRate, <span class="built_in">this</span>.context.currentTime, <span class="number">0.01</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getPlaybackRate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.playbackRate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">onEnded</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.isPlaying = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getLoop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.hasPlaybackControl === <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Audio: this Audio has no playback control.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.loop;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setLoop</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.hasPlaybackControl === <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Audio: this Audio has no playback control.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.loop = value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isPlaying === <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.source.loop = <span class="built_in">this</span>.loop;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setLoopStart</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.loopStart = value;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setLoopEnd</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.loopEnd = value;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getVolume</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.gain.gain.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setVolume</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.gain.gain.setTargetAtTime(value, <span class="built_in">this</span>.context.currentTime, <span class="number">0.01</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _position = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _quaternion = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Quaternion();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _scale = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _orientation = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PositionalAudio</span> <span class="keyword">extends</span> <span class="title">Audio</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">listener</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(listener);</span><br><span class="line">            <span class="built_in">this</span>.panner = <span class="built_in">this</span>.context.createPanner();</span><br><span class="line">            <span class="built_in">this</span>.panner.panningModel = <span class="string">&#x27;HRTF&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.panner.connect(<span class="built_in">this</span>.gain);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">disconnect</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.disconnect();</span><br><span class="line">            <span class="built_in">this</span>.panner.disconnect(<span class="built_in">this</span>.gain);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getOutput</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.panner;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getRefDistance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.panner.refDistance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setRefDistance</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.panner.refDistance = value;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getRolloffFactor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.panner.rolloffFactor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setRolloffFactor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.panner.rolloffFactor = value;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getDistanceModel</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.panner.distanceModel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setDistanceModel</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.panner.distanceModel = value;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getMaxDistance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.panner.maxDistance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setMaxDistance</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.panner.maxDistance = value;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setDirectionalCone</span>(<span class="params">coneInnerAngle, coneOuterAngle, coneOuterGain</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.panner.coneInnerAngle = coneInnerAngle;</span><br><span class="line">            <span class="built_in">this</span>.panner.coneOuterAngle = coneOuterAngle;</span><br><span class="line">            <span class="built_in">this</span>.panner.coneOuterGain = coneOuterGain;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">updateMatrixWorld</span>(<span class="params">force</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.updateMatrixWorld(force);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.hasPlaybackControl === <span class="literal">true</span> &amp;&amp; <span class="built_in">this</span>.isPlaying === <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">this</span>.matrixWorld.decompose(_position, _quaternion, _scale);</span><br><span class="line"></span><br><span class="line">            _orientation.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>).applyQuaternion(_quaternion);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> panner = <span class="built_in">this</span>.panner;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (panner.positionX) &#123;</span><br><span class="line">                <span class="comment">// code path for Chrome and Firefox (see #14393)</span></span><br><span class="line">                <span class="keyword">const</span> endTime = <span class="built_in">this</span>.context.currentTime + <span class="built_in">this</span>.listener.timeDelta;</span><br><span class="line">                panner.positionX.linearRampToValueAtTime(_position.x, endTime);</span><br><span class="line">                panner.positionY.linearRampToValueAtTime(_position.y, endTime);</span><br><span class="line">                panner.positionZ.linearRampToValueAtTime(_position.z, endTime);</span><br><span class="line">                panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);</span><br><span class="line">                panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);</span><br><span class="line">                panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                panner.setPosition(_position.x, _position.y, _position.z);</span><br><span class="line">                panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AudioAnalyser</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">audio, fftSize = <span class="number">2048</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.analyser = audio.context.createAnalyser();</span><br><span class="line">            <span class="built_in">this</span>.analyser.fftSize = fftSize;</span><br><span class="line">            <span class="built_in">this</span>.data = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="built_in">this</span>.analyser.frequencyBinCount);</span><br><span class="line">            audio.getOutput().connect(<span class="built_in">this</span>.analyser);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getFrequencyData</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.analyser.getByteFrequencyData(<span class="built_in">this</span>.data);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getAverageFrequency</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> value = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">this</span>.getFrequencyData();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">                value += data[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> value / data.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PropertyMixer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">binding, typeName, valueSize</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.binding = binding;</span><br><span class="line">            <span class="built_in">this</span>.valueSize = valueSize;</span><br><span class="line">            <span class="keyword">let</span> mixFunction, mixFunctionAdditive, setIdentity; <span class="comment">// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// interpolators can use .buffer as their .result</span></span><br><span class="line">            <span class="comment">// the data then goes to &#x27;incoming&#x27;</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// &#x27;accu0&#x27; and &#x27;accu1&#x27; are used frame-interleaved for</span></span><br><span class="line">            <span class="comment">// the cumulative result and are compared to detect</span></span><br><span class="line">            <span class="comment">// changes</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// &#x27;orig&#x27; stores the original state of the property</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// &#x27;add&#x27; is used for additive cumulative results</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// &#x27;work&#x27; is optional and is only present for quaternion types. It is used</span></span><br><span class="line">            <span class="comment">// to store intermediate quaternion multiplication results</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (typeName) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;quaternion&#x27;</span>:</span><br><span class="line">                    mixFunction = <span class="built_in">this</span>._slerp;</span><br><span class="line">                    mixFunctionAdditive = <span class="built_in">this</span>._slerpAdditive;</span><br><span class="line">                    setIdentity = <span class="built_in">this</span>._setAdditiveIdentityQuaternion;</span><br><span class="line">                    <span class="built_in">this</span>.buffer = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(valueSize * <span class="number">6</span>);</span><br><span class="line">                    <span class="built_in">this</span>._workIndex = <span class="number">5</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;bool&#x27;</span>:</span><br><span class="line">                    mixFunction = <span class="built_in">this</span>._select; <span class="comment">// Use the regular mix function and for additive on these types,</span></span><br><span class="line">                    <span class="comment">// additive is not relevant for non-numeric types</span></span><br><span class="line"></span><br><span class="line">                    mixFunctionAdditive = <span class="built_in">this</span>._select;</span><br><span class="line">                    setIdentity = <span class="built_in">this</span>._setAdditiveIdentityOther;</span><br><span class="line">                    <span class="built_in">this</span>.buffer = <span class="keyword">new</span> <span class="built_in">Array</span>(valueSize * <span class="number">5</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    mixFunction = <span class="built_in">this</span>._lerp;</span><br><span class="line">                    mixFunctionAdditive = <span class="built_in">this</span>._lerpAdditive;</span><br><span class="line">                    setIdentity = <span class="built_in">this</span>._setAdditiveIdentityNumeric;</span><br><span class="line">                    <span class="built_in">this</span>.buffer = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(valueSize * <span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._mixBufferRegion = mixFunction;</span><br><span class="line">            <span class="built_in">this</span>._mixBufferRegionAdditive = mixFunctionAdditive;</span><br><span class="line">            <span class="built_in">this</span>._setIdentity = setIdentity;</span><br><span class="line">            <span class="built_in">this</span>._origIndex = <span class="number">3</span>;</span><br><span class="line">            <span class="built_in">this</span>._addIndex = <span class="number">4</span>;</span><br><span class="line">            <span class="built_in">this</span>.cumulativeWeight = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.cumulativeWeightAdditive = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.useCount = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.referenceCount = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="comment">// accumulate data in the &#x27;incoming&#x27; region into &#x27;accu&lt;i&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">accumulate</span>(<span class="params">accuIndex, weight</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// note: happily accumulating nothing when weight = 0, the caller knows</span></span><br><span class="line">            <span class="comment">// the weight and shouldn&#x27;t have made the call in the first place</span></span><br><span class="line">            <span class="keyword">const</span> buffer = <span class="built_in">this</span>.buffer,</span><br><span class="line">                stride = <span class="built_in">this</span>.valueSize,</span><br><span class="line">                offset = accuIndex * stride + stride;</span><br><span class="line">            <span class="keyword">let</span> currentWeight = <span class="built_in">this</span>.cumulativeWeight;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currentWeight === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// accuN := incoming * weight</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i !== stride; ++i) &#123;</span><br><span class="line">                    buffer[offset + i] = buffer[i];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                currentWeight = weight;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// accuN := accuN + incoming * weight</span></span><br><span class="line">                currentWeight += weight;</span><br><span class="line">                <span class="keyword">const</span> mix = weight / currentWeight;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>._mixBufferRegion(buffer, offset, <span class="number">0</span>, mix, stride);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.cumulativeWeight = currentWeight;</span><br><span class="line">        &#125; <span class="comment">// accumulate data in the &#x27;incoming&#x27; region into &#x27;add&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">accumulateAdditive</span>(<span class="params">weight</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> buffer = <span class="built_in">this</span>.buffer,</span><br><span class="line">                stride = <span class="built_in">this</span>.valueSize,</span><br><span class="line">                offset = stride * <span class="built_in">this</span>._addIndex;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.cumulativeWeightAdditive === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// add = identity</span></span><br><span class="line">                <span class="built_in">this</span>._setIdentity();</span><br><span class="line">            &#125; <span class="comment">// add := add + incoming * weight</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._mixBufferRegionAdditive(buffer, offset, <span class="number">0</span>, weight, stride);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.cumulativeWeightAdditive += weight;</span><br><span class="line">        &#125; <span class="comment">// apply the state of &#x27;accu&lt;i&gt;&#x27; to the binding when accus differ</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">apply</span>(<span class="params">accuIndex</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> stride = <span class="built_in">this</span>.valueSize,</span><br><span class="line">                buffer = <span class="built_in">this</span>.buffer,</span><br><span class="line">                offset = accuIndex * stride + stride,</span><br><span class="line">                weight = <span class="built_in">this</span>.cumulativeWeight,</span><br><span class="line">                weightAdditive = <span class="built_in">this</span>.cumulativeWeightAdditive,</span><br><span class="line">                binding = <span class="built_in">this</span>.binding;</span><br><span class="line">            <span class="built_in">this</span>.cumulativeWeight = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.cumulativeWeightAdditive = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (weight &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// accuN := accuN + original * ( 1 - cumulativeWeight )</span></span><br><span class="line">                <span class="keyword">const</span> originalValueOffset = stride * <span class="built_in">this</span>._origIndex;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>._mixBufferRegion(buffer, offset, originalValueOffset, <span class="number">1</span> - weight, stride);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (weightAdditive &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// accuN := accuN + additive accuN</span></span><br><span class="line">                <span class="built_in">this</span>._mixBufferRegionAdditive(buffer, offset, <span class="built_in">this</span>._addIndex * stride, <span class="number">1</span>, stride);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = stride, e = stride + stride; i !== e; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (buffer[i] !== buffer[i + stride]) &#123;</span><br><span class="line">                    <span class="comment">// value has changed -&gt; update scene graph</span></span><br><span class="line">                    binding.setValue(buffer, offset);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// remember the state of the bound property and copy it to both accus</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">saveOriginalState</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> binding = <span class="built_in">this</span>.binding;</span><br><span class="line">            <span class="keyword">const</span> buffer = <span class="built_in">this</span>.buffer,</span><br><span class="line">                stride = <span class="built_in">this</span>.valueSize,</span><br><span class="line">                originalValueOffset = stride * <span class="built_in">this</span>._origIndex;</span><br><span class="line">            binding.getValue(buffer, originalValueOffset); <span class="comment">// accu[0..1] := orig -- initially detect changes against the original</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = stride, e = originalValueOffset; i !== e; ++i) &#123;</span><br><span class="line">                buffer[i] = buffer[originalValueOffset + i % stride];</span><br><span class="line">            &#125; <span class="comment">// Add to identity for additive</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._setIdentity();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.cumulativeWeight = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.cumulativeWeightAdditive = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="comment">// apply the state previously taken via &#x27;saveOriginalState&#x27; to the binding</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">restoreOriginalState</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> originalValueOffset = <span class="built_in">this</span>.valueSize * <span class="number">3</span>;</span><br><span class="line">            <span class="built_in">this</span>.binding.setValue(<span class="built_in">this</span>.buffer, originalValueOffset);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_setAdditiveIdentityNumeric</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> startIndex = <span class="built_in">this</span>._addIndex * <span class="built_in">this</span>.valueSize;</span><br><span class="line">            <span class="keyword">const</span> endIndex = startIndex + <span class="built_in">this</span>.valueSize;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = startIndex; i &lt; endIndex; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.buffer[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_setAdditiveIdentityQuaternion</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._setAdditiveIdentityNumeric();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.buffer[<span class="built_in">this</span>._addIndex * <span class="built_in">this</span>.valueSize + <span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_setAdditiveIdentityOther</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> startIndex = <span class="built_in">this</span>._origIndex * <span class="built_in">this</span>.valueSize;</span><br><span class="line">            <span class="keyword">const</span> targetIndex = <span class="built_in">this</span>._addIndex * <span class="built_in">this</span>.valueSize;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.valueSize; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.buffer[targetIndex + i] = <span class="built_in">this</span>.buffer[startIndex + i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// mix functions</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_select</span>(<span class="params">buffer, dstOffset, srcOffset, t, stride</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (t &gt;= <span class="number">0.5</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i !== stride; ++i) &#123;</span><br><span class="line">                    buffer[dstOffset + i] = buffer[srcOffset + i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_slerp</span>(<span class="params">buffer, dstOffset, srcOffset, t</span>)</span> &#123;</span><br><span class="line">            Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_slerpAdditive</span>(<span class="params">buffer, dstOffset, srcOffset, t, stride</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> workOffset = <span class="built_in">this</span>._workIndex * stride; <span class="comment">// Store result in intermediate buffer offset</span></span><br><span class="line"></span><br><span class="line">            Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset); <span class="comment">// Slerp to the intermediate result</span></span><br><span class="line"></span><br><span class="line">            Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_lerp</span>(<span class="params">buffer, dstOffset, srcOffset, t, stride</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> s = <span class="number">1</span> - t;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i !== stride; ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> j = dstOffset + i;</span><br><span class="line">                buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_lerpAdditive</span>(<span class="params">buffer, dstOffset, srcOffset, t, stride</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i !== stride; ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> j = dstOffset + i;</span><br><span class="line">                buffer[j] = buffer[j] + buffer[srcOffset + i] * t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Characters [].:/ are reserved for track binding syntax.</span></span><br><span class="line">    <span class="keyword">const</span> _RESERVED_CHARS_RE = <span class="string">&#x27;\\[\\]\\.:\\/&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _reservedRe = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;[&#x27;</span> + _RESERVED_CHARS_RE + <span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;g&#x27;</span>); <span class="comment">// Attempts to allow node names from any language. ES5&#x27;s `\w` regexp matches</span></span><br><span class="line">    <span class="comment">// only latin characters, and the unicode \p&#123;L&#125; is not yet supported. So</span></span><br><span class="line">    <span class="comment">// instead, we exclude reserved characters and match everything else.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _wordChar = <span class="string">&#x27;[^&#x27;</span> + _RESERVED_CHARS_RE + <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _wordCharOrDot = <span class="string">&#x27;[^&#x27;</span> + _RESERVED_CHARS_RE.replace(<span class="string">&#x27;\\.&#x27;</span>, <span class="string">&#x27;&#x27;</span>) + <span class="string">&#x27;]&#x27;</span>; <span class="comment">// Parent directories, delimited by &#x27;/&#x27; or &#x27;:&#x27;. Currently unused, but must</span></span><br><span class="line">    <span class="comment">// be matched to parse the rest of the track name.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _directoryRe = <span class="regexp">/((?:WC+[\/:])*)/</span>.source.replace(<span class="string">&#x27;WC&#x27;</span>, _wordChar); <span class="comment">// Target node. May contain word characters (a-zA-Z0-9_) and &#x27;.&#x27; or &#x27;-&#x27;.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _nodeRe = <span class="regexp">/(WCOD+)?/</span>.source.replace(<span class="string">&#x27;WCOD&#x27;</span>, _wordCharOrDot); <span class="comment">// Object on target node, and accessor. May not contain reserved</span></span><br><span class="line">    <span class="comment">// characters. Accessor may contain any character except closing bracket.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _objectRe = <span class="regexp">/(?:\.(WC+)(?:\[(.+)\])?)?/</span>.source.replace(<span class="string">&#x27;WC&#x27;</span>, _wordChar); <span class="comment">// Property and accessor. May not contain reserved characters. Accessor may</span></span><br><span class="line">    <span class="comment">// contain any non-bracket characters.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _propertyRe = <span class="regexp">/\.(WC+)(?:\[(.+)\])?/</span>.source.replace(<span class="string">&#x27;WC&#x27;</span>, _wordChar);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _trackRe = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;&#x27;</span> + <span class="string">&#x27;^&#x27;</span> + _directoryRe + _nodeRe + _objectRe + _propertyRe + <span class="string">&#x27;$&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _supportedObjectNames = [<span class="string">&#x27;material&#x27;</span>, <span class="string">&#x27;materials&#x27;</span>, <span class="string">&#x27;bones&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Composite</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">targetGroup, path, optionalParsedPath</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);</span><br><span class="line">            <span class="built_in">this</span>._targetGroup = targetGroup;</span><br><span class="line">            <span class="built_in">this</span>._bindings = targetGroup.subscribe_(path, parsedPath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getValue</span>(<span class="params">array, offset</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.bind(); <span class="comment">// bind all binding</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> firstValidIndex = <span class="built_in">this</span>._targetGroup.nCachedObjects_,</span><br><span class="line">                binding = <span class="built_in">this</span>._bindings[firstValidIndex]; <span class="comment">// and only call .getValue on the first</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (binding !== <span class="literal">undefined</span>) binding.getValue(array, offset);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setValue</span>(<span class="params">array, offset</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> bindings = <span class="built_in">this</span>._bindings;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">this</span>._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) &#123;</span><br><span class="line">                bindings[i].setValue(array, offset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">bind</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> bindings = <span class="built_in">this</span>._bindings;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">this</span>._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) &#123;</span><br><span class="line">                bindings[i].bind();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">unbind</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> bindings = <span class="built_in">this</span>._bindings;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">this</span>._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) &#123;</span><br><span class="line">                bindings[i].unbind();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">// Note: This class uses a State pattern on a per-method basis:</span></span><br><span class="line">    <span class="comment">// &#x27;bind&#x27; sets &#x27;this.getValue&#x27; / &#x27;setValue&#x27; and shadows the</span></span><br><span class="line">    <span class="comment">// prototype version of these methods with one that represents</span></span><br><span class="line">    <span class="comment">// the bound state. When the property is not found, the methods</span></span><br><span class="line">    <span class="comment">// become no-ops.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PropertyBinding</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">rootNode, path, parsedPath</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.path = path;</span><br><span class="line">            <span class="built_in">this</span>.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);</span><br><span class="line">            <span class="built_in">this</span>.node = PropertyBinding.findNode(rootNode, <span class="built_in">this</span>.parsedPath.nodeName) || rootNode;</span><br><span class="line">            <span class="built_in">this</span>.rootNode = rootNode; <span class="comment">// initial state of these methods that calls &#x27;bind&#x27;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.getValue = <span class="built_in">this</span>._getValue_unbound;</span><br><span class="line">            <span class="built_in">this</span>.setValue = <span class="built_in">this</span>._setValue_unbound;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">create</span>(<span class="params">root, path, parsedPath</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(root &amp;&amp; root.isAnimationObjectGroup)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PropertyBinding(root, path, parsedPath);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PropertyBinding.Composite(root, path, parsedPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Replaces spaces with underscores and removes unsupported characters from</span></span><br><span class="line"><span class="comment">         * node names, to ensure compatibility with parseTrackName().</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>name Node name to be sanitized.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">sanitizeNodeName</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name.replace(<span class="regexp">/\s/g</span>, <span class="string">&#x27;_&#x27;</span>).replace(_reservedRe, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">parseTrackName</span>(<span class="params">trackName</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> matches = _trackRe.exec(trackName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (matches === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;PropertyBinding: Cannot parse trackName: &#x27;</span> + trackName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> results = &#123;</span><br><span class="line">                <span class="comment">// directoryName: matches[ 1 ], // (tschw) currently unused</span></span><br><span class="line">                <span class="attr">nodeName</span>: matches[<span class="number">2</span>],</span><br><span class="line">                <span class="attr">objectName</span>: matches[<span class="number">3</span>],</span><br><span class="line">                <span class="attr">objectIndex</span>: matches[<span class="number">4</span>],</span><br><span class="line">                <span class="attr">propertyName</span>: matches[<span class="number">5</span>],</span><br><span class="line">                <span class="comment">// required</span></span><br><span class="line">                <span class="attr">propertyIndex</span>: matches[<span class="number">6</span>]</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">const</span> lastDot = results.nodeName &amp;&amp; results.nodeName.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (lastDot !== <span class="literal">undefined</span> &amp;&amp; lastDot !== -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> objectName = results.nodeName.substring(lastDot + <span class="number">1</span>); <span class="comment">// Object names must be checked against an allowlist. Otherwise, there</span></span><br><span class="line">                <span class="comment">// is no way to parse &#x27;foo.bar.baz&#x27;: &#x27;baz&#x27; must be a property, but</span></span><br><span class="line">                <span class="comment">// &#x27;bar&#x27; could be the objectName, or part of a nodeName (which can</span></span><br><span class="line">                <span class="comment">// include &#x27;.&#x27; characters).</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (_supportedObjectNames.indexOf(objectName) !== -<span class="number">1</span>) &#123;</span><br><span class="line">                    results.nodeName = results.nodeName.substring(<span class="number">0</span>, lastDot);</span><br><span class="line">                    results.objectName = objectName;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (results.propertyName === <span class="literal">null</span> || results.propertyName.length === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;PropertyBinding: can not parse propertyName from trackName: &#x27;</span> + trackName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> results;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">findNode</span>(<span class="params">root, nodeName</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeName === <span class="literal">undefined</span> || nodeName === <span class="string">&#x27;&#x27;</span> || nodeName === <span class="string">&#x27;.&#x27;</span> || nodeName === -<span class="number">1</span> || nodeName === root.name || nodeName === root.uuid) &#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125; <span class="comment">// search into skeleton bones.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (root.skeleton) &#123;</span><br><span class="line">                <span class="keyword">const</span> bone = root.skeleton.getBoneByName(nodeName);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bone !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> bone;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// search into node subtree.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (root.children) &#123;</span><br><span class="line">                <span class="keyword">const</span> searchNodeSubtree = <span class="function"><span class="keyword">function</span> (<span class="params">children</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> childNode = children[i];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (childNode.name === nodeName || childNode.uuid === nodeName) &#123;</span><br><span class="line">                            <span class="keyword">return</span> childNode;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">const</span> result = searchNodeSubtree(childNode.children);</span><br><span class="line">                        <span class="keyword">if</span> (result) <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> subTreeNode = searchNodeSubtree(root.children);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (subTreeNode) &#123;</span><br><span class="line">                    <span class="keyword">return</span> subTreeNode;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="comment">// these are used to &quot;bind&quot; a nonexistent property</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_getValue_unavailable</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_setValue_unavailable</span>(<span class="params"></span>)</span> &#123;&#125; <span class="comment">// Getters</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_getValue_direct</span>(<span class="params">buffer, offset</span>)</span> &#123;</span><br><span class="line">            buffer[offset] = <span class="built_in">this</span>.targetObject[<span class="built_in">this</span>.propertyName];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_getValue_array</span>(<span class="params">buffer, offset</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> source = <span class="built_in">this</span>.resolvedProperty;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = source.length; i !== n; ++i) &#123;</span><br><span class="line">                buffer[offset++] = source[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_getValue_arrayElement</span>(<span class="params">buffer, offset</span>)</span> &#123;</span><br><span class="line">            buffer[offset] = <span class="built_in">this</span>.resolvedProperty[<span class="built_in">this</span>.propertyIndex];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_getValue_toArray</span>(<span class="params">buffer, offset</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.resolvedProperty.toArray(buffer, offset);</span><br><span class="line">        &#125; <span class="comment">// Direct</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_setValue_direct</span>(<span class="params">buffer, offset</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.targetObject[<span class="built_in">this</span>.propertyName] = buffer[offset];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_setValue_direct_setNeedsUpdate</span>(<span class="params">buffer, offset</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.targetObject[<span class="built_in">this</span>.propertyName] = buffer[offset];</span><br><span class="line">            <span class="built_in">this</span>.targetObject.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_setValue_direct_setMatrixWorldNeedsUpdate</span>(<span class="params">buffer, offset</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.targetObject[<span class="built_in">this</span>.propertyName] = buffer[offset];</span><br><span class="line">            <span class="built_in">this</span>.targetObject.matrixWorldNeedsUpdate = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="comment">// EntireArray</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_setValue_array</span>(<span class="params">buffer, offset</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> dest = <span class="built_in">this</span>.resolvedProperty;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = dest.length; i !== n; ++i) &#123;</span><br><span class="line">                dest[i] = buffer[offset++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_setValue_array_setNeedsUpdate</span>(<span class="params">buffer, offset</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> dest = <span class="built_in">this</span>.resolvedProperty;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = dest.length; i !== n; ++i) &#123;</span><br><span class="line">                dest[i] = buffer[offset++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.targetObject.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_setValue_array_setMatrixWorldNeedsUpdate</span>(<span class="params">buffer, offset</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> dest = <span class="built_in">this</span>.resolvedProperty;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = dest.length; i !== n; ++i) &#123;</span><br><span class="line">                dest[i] = buffer[offset++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.targetObject.matrixWorldNeedsUpdate = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="comment">// ArrayElement</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_setValue_arrayElement</span>(<span class="params">buffer, offset</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.resolvedProperty[<span class="built_in">this</span>.propertyIndex] = buffer[offset];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_setValue_arrayElement_setNeedsUpdate</span>(<span class="params">buffer, offset</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.resolvedProperty[<span class="built_in">this</span>.propertyIndex] = buffer[offset];</span><br><span class="line">            <span class="built_in">this</span>.targetObject.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_setValue_arrayElement_setMatrixWorldNeedsUpdate</span>(<span class="params">buffer, offset</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.resolvedProperty[<span class="built_in">this</span>.propertyIndex] = buffer[offset];</span><br><span class="line">            <span class="built_in">this</span>.targetObject.matrixWorldNeedsUpdate = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="comment">// HasToFromArray</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_setValue_fromArray</span>(<span class="params">buffer, offset</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.resolvedProperty.fromArray(buffer, offset);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_setValue_fromArray_setNeedsUpdate</span>(<span class="params">buffer, offset</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.resolvedProperty.fromArray(buffer, offset);</span><br><span class="line">            <span class="built_in">this</span>.targetObject.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_setValue_fromArray_setMatrixWorldNeedsUpdate</span>(<span class="params">buffer, offset</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.resolvedProperty.fromArray(buffer, offset);</span><br><span class="line">            <span class="built_in">this</span>.targetObject.matrixWorldNeedsUpdate = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_getValue_unbound</span>(<span class="params">targetArray, offset</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.bind();</span><br><span class="line">            <span class="built_in">this</span>.getValue(targetArray, offset);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_setValue_unbound</span>(<span class="params">sourceArray, offset</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.bind();</span><br><span class="line">            <span class="built_in">this</span>.setValue(sourceArray, offset);</span><br><span class="line">        &#125; <span class="comment">// create getter / setter pair for a property in the scene graph</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">bind</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> targetObject = <span class="built_in">this</span>.node;</span><br><span class="line">            <span class="keyword">const</span> parsedPath = <span class="built_in">this</span>.parsedPath;</span><br><span class="line">            <span class="keyword">const</span> objectName = parsedPath.objectName;</span><br><span class="line">            <span class="keyword">const</span> propertyName = parsedPath.propertyName;</span><br><span class="line">            <span class="keyword">let</span> propertyIndex = parsedPath.propertyIndex;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!targetObject) &#123;</span><br><span class="line">                targetObject = PropertyBinding.findNode(<span class="built_in">this</span>.rootNode, parsedPath.nodeName) || <span class="built_in">this</span>.rootNode;</span><br><span class="line">                <span class="built_in">this</span>.node = targetObject;</span><br><span class="line">            &#125; <span class="comment">// set fail state so we can just &#x27;return&#x27; on error</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.getValue = <span class="built_in">this</span>._getValue_unavailable;</span><br><span class="line">            <span class="built_in">this</span>.setValue = <span class="built_in">this</span>._setValue_unavailable; <span class="comment">// ensure there is a value node</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!targetObject) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.PropertyBinding: Trying to update node for track: &#x27;</span> + <span class="built_in">this</span>.path + <span class="string">&#x27; but it wasn\&#x27;t found.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (objectName) &#123;</span><br><span class="line">                <span class="keyword">let</span> objectIndex = parsedPath.objectIndex; <span class="comment">// special cases were we need to reach deeper into the hierarchy to get the face materials....</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (objectName) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;materials&#x27;</span>:</span><br><span class="line">                        <span class="keyword">if</span> (!targetObject.material) &#123;</span><br><span class="line">                            <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.PropertyBinding: Can not bind to material as node does not have a material.&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!targetObject.material.materials) &#123;</span><br><span class="line">                            <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        targetObject = targetObject.material.materials;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;bones&#x27;</span>:</span><br><span class="line">                        <span class="keyword">if</span> (!targetObject.skeleton) &#123;</span><br><span class="line">                            <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125; <span class="comment">// potential future optimization: skip this if propertyIndex is already an integer</span></span><br><span class="line">                        <span class="comment">// and convert the integer string to a true integer.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        targetObject = targetObject.skeleton.bones; <span class="comment">// support resolving morphTarget names into indices.</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; targetObject.length; i++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (targetObject[i].name === objectIndex) &#123;</span><br><span class="line">                                objectIndex = i;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">if</span> (targetObject[objectName] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                            <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.PropertyBinding: Can not bind to objectName of node undefined.&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        targetObject = targetObject[objectName];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (objectIndex !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (targetObject[objectIndex] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.&#x27;</span>, <span class="built_in">this</span>, targetObject);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    targetObject = targetObject[objectIndex];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// resolve property</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> nodeProperty = targetObject[propertyName];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nodeProperty === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> nodeName = parsedPath.nodeName;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.PropertyBinding: Trying to update property for track: &#x27;</span> + nodeName + <span class="string">&#x27;.&#x27;</span> + propertyName + <span class="string">&#x27; but it wasn\&#x27;t found.&#x27;</span>, targetObject);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="comment">// determine versioning scheme</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> versioning = <span class="built_in">this</span>.Versioning.None;</span><br><span class="line">            <span class="built_in">this</span>.targetObject = targetObject;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (targetObject.needsUpdate !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="comment">// material</span></span><br><span class="line">                versioning = <span class="built_in">this</span>.Versioning.NeedsUpdate;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetObject.matrixWorldNeedsUpdate !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="comment">// node transform</span></span><br><span class="line">                versioning = <span class="built_in">this</span>.Versioning.MatrixWorldNeedsUpdate;</span><br><span class="line">            &#125; <span class="comment">// determine how the property gets bound</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> bindingType = <span class="built_in">this</span>.BindingType.Direct;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (propertyIndex !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="comment">// access a sub element of the property array (only primitives are supported right now)</span></span><br><span class="line">                <span class="keyword">if</span> (propertyName === <span class="string">&#x27;morphTargetInfluences&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.</span></span><br><span class="line">                    <span class="comment">// support resolving morphTarget names into indices.</span></span><br><span class="line">                    <span class="keyword">if</span> (!targetObject.geometry) &#123;</span><br><span class="line">                        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (targetObject.geometry.isBufferGeometry) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!targetObject.geometry.morphAttributes) &#123;</span><br><span class="line">                            <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (targetObject.morphTargetDictionary[propertyIndex] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                bindingType = <span class="built_in">this</span>.BindingType.ArrayElement;</span><br><span class="line">                <span class="built_in">this</span>.resolvedProperty = nodeProperty;</span><br><span class="line">                <span class="built_in">this</span>.propertyIndex = propertyIndex;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeProperty.fromArray !== <span class="literal">undefined</span> &amp;&amp; nodeProperty.toArray !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="comment">// must use copy for Object3D.Euler/Quaternion</span></span><br><span class="line">                bindingType = <span class="built_in">this</span>.BindingType.HasFromToArray;</span><br><span class="line">                <span class="built_in">this</span>.resolvedProperty = nodeProperty;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(nodeProperty)) &#123;</span><br><span class="line">                bindingType = <span class="built_in">this</span>.BindingType.EntireArray;</span><br><span class="line">                <span class="built_in">this</span>.resolvedProperty = nodeProperty;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.propertyName = propertyName;</span><br><span class="line">            &#125; <span class="comment">// select getter / setter</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.getValue = <span class="built_in">this</span>.GetterByBindingType[bindingType];</span><br><span class="line">            <span class="built_in">this</span>.setValue = <span class="built_in">this</span>.SetterByBindingTypeAndVersioning[bindingType][versioning];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">unbind</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.node = <span class="literal">null</span>; <span class="comment">// back to the prototype version of getValue / setValue</span></span><br><span class="line">            <span class="comment">// note: avoiding to mutate the shape of &#x27;this&#x27; via &#x27;delete&#x27;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.getValue = <span class="built_in">this</span>._getValue_unbound;</span><br><span class="line">            <span class="built_in">this</span>.setValue = <span class="built_in">this</span>._setValue_unbound;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PropertyBinding.Composite = Composite;</span><br><span class="line">    PropertyBinding.prototype.BindingType = &#123;</span><br><span class="line">        <span class="attr">Direct</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">EntireArray</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">ArrayElement</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">HasFromToArray</span>: <span class="number">3</span></span><br><span class="line">    &#125;;</span><br><span class="line">    PropertyBinding.prototype.Versioning = &#123;</span><br><span class="line">        <span class="attr">None</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">NeedsUpdate</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">MatrixWorldNeedsUpdate</span>: <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line">    PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];</span><br><span class="line">    PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[<span class="comment">// Direct</span></span><br><span class="line">        PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [<span class="comment">// EntireArray</span></span><br><span class="line">        PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [<span class="comment">// ArrayElement</span></span><br><span class="line">        PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [<span class="comment">// HasToFromArray</span></span><br><span class="line">        PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A group of objects that receives a shared animation state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Usage:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *	- Add objects you would otherwise pass as &#x27;root&#x27; to the</span></span><br><span class="line"><span class="comment">     *		constructor or the .clipAction method of AnimationMixer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *	- Instead pass this object as &#x27;root&#x27;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *	- You can also add and remove objects later when the mixer</span></span><br><span class="line"><span class="comment">     *		is running.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *		Objects of this class appear as one object to the mixer,</span></span><br><span class="line"><span class="comment">     *		so cache control of the individual objects must be done</span></span><br><span class="line"><span class="comment">     *		on the group.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Limitation:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *	- The animated properties must be compatible among the</span></span><br><span class="line"><span class="comment">     *		all objects in the group.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *	- A single property can either be controlled through a</span></span><br><span class="line"><span class="comment">     *		target group or directly, but not both.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AnimationObjectGroup</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.uuid = generateUUID(); <span class="comment">// cached objects followed by the active ones</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._objects = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">            <span class="built_in">this</span>.nCachedObjects_ = <span class="number">0</span>; <span class="comment">// threshold</span></span><br><span class="line">            <span class="comment">// note: read by PropertyBinding.Composite</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> indices = &#123;&#125;;</span><br><span class="line">            <span class="built_in">this</span>._indicesByUUID = indices; <span class="comment">// for bookkeeping</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = <span class="built_in">arguments</span>.length; i !== n; ++i) &#123;</span><br><span class="line">                indices[<span class="built_in">arguments</span>[i].uuid] = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._paths = []; <span class="comment">// inside: string</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._parsedPaths = []; <span class="comment">// inside: &#123; we don&#x27;t care, here &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._bindings = []; <span class="comment">// inside: Array&lt; PropertyBinding &gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._bindingsIndicesByPath = &#123;&#125;; <span class="comment">// inside: indices in these arrays</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> scope = <span class="built_in">this</span>;</span><br><span class="line">            <span class="built_in">this</span>.stats = &#123;</span><br><span class="line">                <span class="attr">objects</span>: &#123;</span><br><span class="line">                    <span class="keyword">get</span> <span class="title">total</span>() &#123;</span><br><span class="line">                        <span class="keyword">return</span> scope._objects.length;</span><br><span class="line">                    &#125;,</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">get</span> <span class="title">inUse</span>() &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">this</span>.total - scope.nCachedObjects_;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;,</span><br><span class="line"></span><br><span class="line">                <span class="keyword">get</span> <span class="title">bindingsPerObject</span>() &#123;</span><br><span class="line">                    <span class="keyword">return</span> scope._bindings.length;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> objects = <span class="built_in">this</span>._objects,</span><br><span class="line">                indicesByUUID = <span class="built_in">this</span>._indicesByUUID,</span><br><span class="line">                paths = <span class="built_in">this</span>._paths,</span><br><span class="line">                parsedPaths = <span class="built_in">this</span>._parsedPaths,</span><br><span class="line">                bindings = <span class="built_in">this</span>._bindings,</span><br><span class="line">                nBindings = bindings.length;</span><br><span class="line">            <span class="keyword">let</span> knownObject = <span class="literal">undefined</span>,</span><br><span class="line">                nObjects = objects.length,</span><br><span class="line">                nCachedObjects = <span class="built_in">this</span>.nCachedObjects_;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = <span class="built_in">arguments</span>.length; i !== n; ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> object = <span class="built_in">arguments</span>[i],</span><br><span class="line">                    uuid = object.uuid;</span><br><span class="line">                <span class="keyword">let</span> index = indicesByUUID[uuid];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (index === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="comment">// unknown object -&gt; add it to the ACTIVE region</span></span><br><span class="line">                    index = nObjects++;</span><br><span class="line">                    indicesByUUID[uuid] = index;</span><br><span class="line">                    objects.push(object); <span class="comment">// accounting is done, now do the same for all bindings</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, m = nBindings; j !== m; ++j) &#123;</span><br><span class="line">                        bindings[j].push(<span class="keyword">new</span> PropertyBinding(object, paths[j], parsedPaths[j]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; nCachedObjects) &#123;</span><br><span class="line">                    knownObject = objects[index]; <span class="comment">// move existing object to the ACTIVE region</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> firstActiveIndex = --nCachedObjects,</span><br><span class="line">                        lastCachedObject = objects[firstActiveIndex];</span><br><span class="line">                    indicesByUUID[lastCachedObject.uuid] = index;</span><br><span class="line">                    objects[index] = lastCachedObject;</span><br><span class="line">                    indicesByUUID[uuid] = firstActiveIndex;</span><br><span class="line">                    objects[firstActiveIndex] = object; <span class="comment">// accounting is done, now do the same for all bindings</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, m = nBindings; j !== m; ++j) &#123;</span><br><span class="line">                        <span class="keyword">const</span> bindingsForPath = bindings[j],</span><br><span class="line">                            lastCached = bindingsForPath[firstActiveIndex];</span><br><span class="line">                        <span class="keyword">let</span> binding = bindingsForPath[index];</span><br><span class="line">                        bindingsForPath[index] = lastCached;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (binding === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                            <span class="comment">// since we do not bother to create new bindings</span></span><br><span class="line">                            <span class="comment">// for objects that are cached, the binding may</span></span><br><span class="line">                            <span class="comment">// or may not exist</span></span><br><span class="line">                            binding = <span class="keyword">new</span> PropertyBinding(object, paths[j], parsedPaths[j]);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        bindingsForPath[firstActiveIndex] = binding;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objects[index] !== knownObject) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.AnimationObjectGroup: Different objects with the same UUID &#x27;</span> + <span class="string">&#x27;detected. Clean the caches or recreate your infrastructure when reloading scenes.&#x27;</span>);</span><br><span class="line">                &#125; <span class="comment">// else the object is already where we want it to be</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="comment">// for arguments</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.nCachedObjects_ = nCachedObjects;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">remove</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> objects = <span class="built_in">this</span>._objects,</span><br><span class="line">                indicesByUUID = <span class="built_in">this</span>._indicesByUUID,</span><br><span class="line">                bindings = <span class="built_in">this</span>._bindings,</span><br><span class="line">                nBindings = bindings.length;</span><br><span class="line">            <span class="keyword">let</span> nCachedObjects = <span class="built_in">this</span>.nCachedObjects_;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = <span class="built_in">arguments</span>.length; i !== n; ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> object = <span class="built_in">arguments</span>[i],</span><br><span class="line">                    uuid = object.uuid,</span><br><span class="line">                    index = indicesByUUID[uuid];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (index !== <span class="literal">undefined</span> &amp;&amp; index &gt;= nCachedObjects) &#123;</span><br><span class="line">                    <span class="comment">// move existing object into the CACHED region</span></span><br><span class="line">                    <span class="keyword">const</span> lastCachedIndex = nCachedObjects++,</span><br><span class="line">                        firstActiveObject = objects[lastCachedIndex];</span><br><span class="line">                    indicesByUUID[firstActiveObject.uuid] = index;</span><br><span class="line">                    objects[index] = firstActiveObject;</span><br><span class="line">                    indicesByUUID[uuid] = lastCachedIndex;</span><br><span class="line">                    objects[lastCachedIndex] = object; <span class="comment">// accounting is done, now do the same for all bindings</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, m = nBindings; j !== m; ++j) &#123;</span><br><span class="line">                        <span class="keyword">const</span> bindingsForPath = bindings[j],</span><br><span class="line">                            firstActive = bindingsForPath[lastCachedIndex],</span><br><span class="line">                            binding = bindingsForPath[index];</span><br><span class="line">                        bindingsForPath[index] = firstActive;</span><br><span class="line">                        bindingsForPath[lastCachedIndex] = binding;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// for arguments</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.nCachedObjects_ = nCachedObjects;</span><br><span class="line">        &#125; <span class="comment">// remove &amp; forget</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">uncache</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> objects = <span class="built_in">this</span>._objects,</span><br><span class="line">                indicesByUUID = <span class="built_in">this</span>._indicesByUUID,</span><br><span class="line">                bindings = <span class="built_in">this</span>._bindings,</span><br><span class="line">                nBindings = bindings.length;</span><br><span class="line">            <span class="keyword">let</span> nCachedObjects = <span class="built_in">this</span>.nCachedObjects_,</span><br><span class="line">                nObjects = objects.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = <span class="built_in">arguments</span>.length; i !== n; ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> object = <span class="built_in">arguments</span>[i],</span><br><span class="line">                    uuid = object.uuid,</span><br><span class="line">                    index = indicesByUUID[uuid];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (index !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="keyword">delete</span> indicesByUUID[uuid];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (index &lt; nCachedObjects) &#123;</span><br><span class="line">                        <span class="comment">// object is cached, shrink the CACHED region</span></span><br><span class="line">                        <span class="keyword">const</span> firstActiveIndex = --nCachedObjects,</span><br><span class="line">                            lastCachedObject = objects[firstActiveIndex],</span><br><span class="line">                            lastIndex = --nObjects,</span><br><span class="line">                            lastObject = objects[lastIndex]; <span class="comment">// last cached object takes this object&#x27;s place</span></span><br><span class="line"></span><br><span class="line">                        indicesByUUID[lastCachedObject.uuid] = index;</span><br><span class="line">                        objects[index] = lastCachedObject; <span class="comment">// last object goes to the activated slot and pop</span></span><br><span class="line"></span><br><span class="line">                        indicesByUUID[lastObject.uuid] = firstActiveIndex;</span><br><span class="line">                        objects[firstActiveIndex] = lastObject;</span><br><span class="line">                        objects.pop(); <span class="comment">// accounting is done, now do the same for all bindings</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, m = nBindings; j !== m; ++j) &#123;</span><br><span class="line">                            <span class="keyword">const</span> bindingsForPath = bindings[j],</span><br><span class="line">                                lastCached = bindingsForPath[firstActiveIndex],</span><br><span class="line">                                last = bindingsForPath[lastIndex];</span><br><span class="line">                            bindingsForPath[index] = lastCached;</span><br><span class="line">                            bindingsForPath[firstActiveIndex] = last;</span><br><span class="line">                            bindingsForPath.pop();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// object is active, just swap with the last and pop</span></span><br><span class="line">                        <span class="keyword">const</span> lastIndex = --nObjects,</span><br><span class="line">                            lastObject = objects[lastIndex];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (lastIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            indicesByUUID[lastObject.uuid] = index;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        objects[index] = lastObject;</span><br><span class="line">                        objects.pop(); <span class="comment">// accounting is done, now do the same for all bindings</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, m = nBindings; j !== m; ++j) &#123;</span><br><span class="line">                            <span class="keyword">const</span> bindingsForPath = bindings[j];</span><br><span class="line">                            bindingsForPath[index] = bindingsForPath[lastIndex];</span><br><span class="line">                            bindingsForPath.pop();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="comment">// cached or active</span></span><br><span class="line"></span><br><span class="line">                &#125; <span class="comment">// if object is known</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="comment">// for arguments</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.nCachedObjects_ = nCachedObjects;</span><br><span class="line">        &#125; <span class="comment">// Internal interface used by befriended PropertyBinding.Composite:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">subscribe_</span>(<span class="params">path, parsedPath</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// returns an array of bindings for the given path that is changed</span></span><br><span class="line">            <span class="comment">// according to the contained objects in the group</span></span><br><span class="line">            <span class="keyword">const</span> indicesByPath = <span class="built_in">this</span>._bindingsIndicesByPath;</span><br><span class="line">            <span class="keyword">let</span> index = indicesByPath[path];</span><br><span class="line">            <span class="keyword">const</span> bindings = <span class="built_in">this</span>._bindings;</span><br><span class="line">            <span class="keyword">if</span> (index !== <span class="literal">undefined</span>) <span class="keyword">return</span> bindings[index];</span><br><span class="line">            <span class="keyword">const</span> paths = <span class="built_in">this</span>._paths,</span><br><span class="line">                parsedPaths = <span class="built_in">this</span>._parsedPaths,</span><br><span class="line">                objects = <span class="built_in">this</span>._objects,</span><br><span class="line">                nObjects = objects.length,</span><br><span class="line">                nCachedObjects = <span class="built_in">this</span>.nCachedObjects_,</span><br><span class="line">                bindingsForPath = <span class="keyword">new</span> <span class="built_in">Array</span>(nObjects);</span><br><span class="line">            index = bindings.length;</span><br><span class="line">            indicesByPath[path] = index;</span><br><span class="line">            paths.push(path);</span><br><span class="line">            parsedPaths.push(parsedPath);</span><br><span class="line">            bindings.push(bindingsForPath);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = nCachedObjects, n = objects.length; i !== n; ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> object = objects[i];</span><br><span class="line">                bindingsForPath[i] = <span class="keyword">new</span> PropertyBinding(object, path, parsedPath);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> bindingsForPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">unsubscribe_</span>(<span class="params">path</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// tells the group to forget about a property path and no longer</span></span><br><span class="line">            <span class="comment">// update the array previously obtained with &#x27;subscribe_&#x27;</span></span><br><span class="line">            <span class="keyword">const</span> indicesByPath = <span class="built_in">this</span>._bindingsIndicesByPath,</span><br><span class="line">                index = indicesByPath[path];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> paths = <span class="built_in">this</span>._paths,</span><br><span class="line">                    parsedPaths = <span class="built_in">this</span>._parsedPaths,</span><br><span class="line">                    bindings = <span class="built_in">this</span>._bindings,</span><br><span class="line">                    lastBindingsIndex = bindings.length - <span class="number">1</span>,</span><br><span class="line">                    lastBindings = bindings[lastBindingsIndex],</span><br><span class="line">                    lastBindingsPath = path[lastBindingsIndex];</span><br><span class="line">                indicesByPath[lastBindingsPath] = index;</span><br><span class="line">                bindings[index] = lastBindings;</span><br><span class="line">                bindings.pop();</span><br><span class="line">                parsedPaths[index] = parsedPaths[lastBindingsIndex];</span><br><span class="line">                parsedPaths.pop();</span><br><span class="line">                paths[index] = paths[lastBindingsIndex];</span><br><span class="line">                paths.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AnimationObjectGroup.prototype.isAnimationObjectGroup = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AnimationAction</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">mixer, clip, localRoot = <span class="literal">null</span>, blendMode = clip.blendMode</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._mixer = mixer;</span><br><span class="line">            <span class="built_in">this</span>._clip = clip;</span><br><span class="line">            <span class="built_in">this</span>._localRoot = localRoot;</span><br><span class="line">            <span class="built_in">this</span>.blendMode = blendMode;</span><br><span class="line">            <span class="keyword">const</span> tracks = clip.tracks,</span><br><span class="line">                nTracks = tracks.length,</span><br><span class="line">                interpolants = <span class="keyword">new</span> <span class="built_in">Array</span>(nTracks);</span><br><span class="line">            <span class="keyword">const</span> interpolantSettings = &#123;</span><br><span class="line">                <span class="attr">endingStart</span>: ZeroCurvatureEnding,</span><br><span class="line">                <span class="attr">endingEnd</span>: ZeroCurvatureEnding</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i !== nTracks; ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> interpolant = tracks[i].createInterpolant(<span class="literal">null</span>);</span><br><span class="line">                interpolants[i] = interpolant;</span><br><span class="line">                interpolant.settings = interpolantSettings;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._interpolantSettings = interpolantSettings;</span><br><span class="line">            <span class="built_in">this</span>._interpolants = interpolants; <span class="comment">// bound by the mixer</span></span><br><span class="line">            <span class="comment">// inside: PropertyMixer (managed by the mixer)</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._propertyBindings = <span class="keyword">new</span> <span class="built_in">Array</span>(nTracks);</span><br><span class="line">            <span class="built_in">this</span>._cacheIndex = <span class="literal">null</span>; <span class="comment">// for the memory manager</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._byClipCacheIndex = <span class="literal">null</span>; <span class="comment">// for the memory manager</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._timeScaleInterpolant = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>._weightInterpolant = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.loop = LoopRepeat;</span><br><span class="line">            <span class="built_in">this</span>._loopCount = -<span class="number">1</span>; <span class="comment">// global mixer time when the action is to be started</span></span><br><span class="line">            <span class="comment">// it&#x27;s set back to &#x27;null&#x27; upon start of the action</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._startTime = <span class="literal">null</span>; <span class="comment">// scaled local time of the action</span></span><br><span class="line">            <span class="comment">// gets clamped or wrapped to 0..clip.duration according to loop</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.time = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.timeScale = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>._effectiveTimeScale = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.weight = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>._effectiveWeight = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.repetitions = <span class="literal">Infinity</span>; <span class="comment">// no. of repetitions when looping</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.paused = <span class="literal">false</span>; <span class="comment">// true -&gt; zero effective time scale</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.enabled = <span class="literal">true</span>; <span class="comment">// false -&gt; zero effective weight</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.clampWhenFinished = <span class="literal">false</span>; <span class="comment">// keep feeding the last frame?</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.zeroSlopeAtStart = <span class="literal">true</span>; <span class="comment">// for smooth interpolation w/o separate</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.zeroSlopeAtEnd = <span class="literal">true</span>; <span class="comment">// clips for start, loop and end</span></span><br><span class="line">        &#125; <span class="comment">// State &amp; Scheduling</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">play</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._mixer._activateAction(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">stop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._mixer._deactivateAction(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.reset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">reset</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.paused = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.enabled = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.time = <span class="number">0</span>; <span class="comment">// restart clip</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._loopCount = -<span class="number">1</span>; <span class="comment">// forget previous loops</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._startTime = <span class="literal">null</span>; <span class="comment">// forget scheduling</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.stopFading().stopWarping();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">isRunning</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.enabled &amp;&amp; !<span class="built_in">this</span>.paused &amp;&amp; <span class="built_in">this</span>.timeScale !== <span class="number">0</span> &amp;&amp; <span class="built_in">this</span>._startTime === <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>._mixer._isActiveAction(<span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="comment">// return true when play has been called</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">isScheduled</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._mixer._isActiveAction(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">startAt</span>(<span class="params">time</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._startTime = time;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setLoop</span>(<span class="params">mode, repetitions</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.loop = mode;</span><br><span class="line">            <span class="built_in">this</span>.repetitions = repetitions;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125; <span class="comment">// Weight</span></span><br><span class="line">        <span class="comment">// set the weight stopping any scheduled fading</span></span><br><span class="line">        <span class="comment">// although .enabled = false yields an effective weight of zero, this</span></span><br><span class="line">        <span class="comment">// method does *not* change .enabled, because it would be confusing</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setEffectiveWeight</span>(<span class="params">weight</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.weight = weight; <span class="comment">// note: same logic as when updated at runtime</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._effectiveWeight = <span class="built_in">this</span>.enabled ? weight : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.stopFading();</span><br><span class="line">        &#125; <span class="comment">// return the weight considering fading and .enabled</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getEffectiveWeight</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._effectiveWeight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fadeIn</span>(<span class="params">duration</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._scheduleFading(duration, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">fadeOut</span>(<span class="params">duration</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._scheduleFading(duration, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">crossFadeFrom</span>(<span class="params">fadeOutAction, duration, warp</span>)</span> &#123;</span><br><span class="line">            fadeOutAction.fadeOut(duration);</span><br><span class="line">            <span class="built_in">this</span>.fadeIn(duration);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (warp) &#123;</span><br><span class="line">                <span class="keyword">const</span> fadeInDuration = <span class="built_in">this</span>._clip.duration,</span><br><span class="line">                    fadeOutDuration = fadeOutAction._clip.duration,</span><br><span class="line">                    startEndRatio = fadeOutDuration / fadeInDuration,</span><br><span class="line">                    endStartRatio = fadeInDuration / fadeOutDuration;</span><br><span class="line">                fadeOutAction.warp(<span class="number">1.0</span>, startEndRatio, duration);</span><br><span class="line">                <span class="built_in">this</span>.warp(endStartRatio, <span class="number">1.0</span>, duration);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">crossFadeTo</span>(<span class="params">fadeInAction, duration, warp</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fadeInAction.crossFadeFrom(<span class="built_in">this</span>, duration, warp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">stopFading</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> weightInterpolant = <span class="built_in">this</span>._weightInterpolant;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (weightInterpolant !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>._weightInterpolant = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>._mixer._takeBackControlInterpolant(weightInterpolant);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125; <span class="comment">// Time Scale Control</span></span><br><span class="line">        <span class="comment">// set the time scale stopping any scheduled warping</span></span><br><span class="line">        <span class="comment">// although .paused = true yields an effective time scale of zero, this</span></span><br><span class="line">        <span class="comment">// method does *not* change .paused, because it would be confusing</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setEffectiveTimeScale</span>(<span class="params">timeScale</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.timeScale = timeScale;</span><br><span class="line">            <span class="built_in">this</span>._effectiveTimeScale = <span class="built_in">this</span>.paused ? <span class="number">0</span> : timeScale;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.stopWarping();</span><br><span class="line">        &#125; <span class="comment">// return the time scale considering warping and .paused</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getEffectiveTimeScale</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._effectiveTimeScale;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setDuration</span>(<span class="params">duration</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.timeScale = <span class="built_in">this</span>._clip.duration / duration;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.stopWarping();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">syncWith</span>(<span class="params">action</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.time = action.time;</span><br><span class="line">            <span class="built_in">this</span>.timeScale = action.timeScale;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.stopWarping();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">halt</span>(<span class="params">duration</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.warp(<span class="built_in">this</span>._effectiveTimeScale, <span class="number">0</span>, duration);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">warp</span>(<span class="params">startTimeScale, endTimeScale, duration</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> mixer = <span class="built_in">this</span>._mixer,</span><br><span class="line">                now = mixer.time,</span><br><span class="line">                timeScale = <span class="built_in">this</span>.timeScale;</span><br><span class="line">            <span class="keyword">let</span> interpolant = <span class="built_in">this</span>._timeScaleInterpolant;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (interpolant === <span class="literal">null</span>) &#123;</span><br><span class="line">                interpolant = mixer._lendControlInterpolant();</span><br><span class="line">                <span class="built_in">this</span>._timeScaleInterpolant = interpolant;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> times = interpolant.parameterPositions,</span><br><span class="line">                values = interpolant.sampleValues;</span><br><span class="line">            times[<span class="number">0</span>] = now;</span><br><span class="line">            times[<span class="number">1</span>] = now + duration;</span><br><span class="line">            values[<span class="number">0</span>] = startTimeScale / timeScale;</span><br><span class="line">            values[<span class="number">1</span>] = endTimeScale / timeScale;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">stopWarping</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> timeScaleInterpolant = <span class="built_in">this</span>._timeScaleInterpolant;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timeScaleInterpolant !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>._timeScaleInterpolant = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>._mixer._takeBackControlInterpolant(timeScaleInterpolant);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125; <span class="comment">// Object Accessors</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getMixer</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._mixer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getClip</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._clip;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getRoot</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._localRoot || <span class="built_in">this</span>._mixer._root;</span><br><span class="line">        &#125; <span class="comment">// Interna</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_update</span>(<span class="params">time, deltaTime, timeDirection, accuIndex</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// called by the mixer</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>.enabled) &#123;</span><br><span class="line">                <span class="comment">// call ._updateWeight() to update ._effectiveWeight</span></span><br><span class="line">                <span class="built_in">this</span>._updateWeight(time);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> startTime = <span class="built_in">this</span>._startTime;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (startTime !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// check for scheduled start of action</span></span><br><span class="line">                <span class="keyword">const</span> timeRunning = (time - startTime) * timeDirection;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (timeRunning &lt; <span class="number">0</span> || timeDirection === <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// yet to come / don&#x27;t decide when delta = 0</span></span><br><span class="line">                &#125; <span class="comment">// start</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>._startTime = <span class="literal">null</span>; <span class="comment">// unschedule</span></span><br><span class="line"></span><br><span class="line">                deltaTime = timeDirection * timeRunning;</span><br><span class="line">            &#125; <span class="comment">// apply time scale and advance time</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            deltaTime *= <span class="built_in">this</span>._updateTimeScale(time);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> clipTime = <span class="built_in">this</span>._updateTime(deltaTime); <span class="comment">// note: _updateTime may disable the action resulting in</span></span><br><span class="line">            <span class="comment">// an effective weight of 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> weight = <span class="built_in">this</span>._updateWeight(time);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> interpolants = <span class="built_in">this</span>._interpolants;</span><br><span class="line">                <span class="keyword">const</span> propertyMixers = <span class="built_in">this</span>._propertyBindings;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (<span class="built_in">this</span>.blendMode) &#123;</span><br><span class="line">                    <span class="keyword">case</span> AdditiveAnimationBlendMode:</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, m = interpolants.length; j !== m; ++j) &#123;</span><br><span class="line">                            interpolants[j].evaluate(clipTime);</span><br><span class="line">                            propertyMixers[j].accumulateAdditive(weight);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> NormalAnimationBlendMode:</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, m = interpolants.length; j !== m; ++j) &#123;</span><br><span class="line">                            interpolants[j].evaluate(clipTime);</span><br><span class="line">                            propertyMixers[j].accumulate(accuIndex, weight);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_updateWeight</span>(<span class="params">time</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> weight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.enabled) &#123;</span><br><span class="line">                weight = <span class="built_in">this</span>.weight;</span><br><span class="line">                <span class="keyword">const</span> interpolant = <span class="built_in">this</span>._weightInterpolant;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (interpolant !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> interpolantValue = interpolant.evaluate(time)[<span class="number">0</span>];</span><br><span class="line">                    weight *= interpolantValue;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (time &gt; interpolant.parameterPositions[<span class="number">1</span>]) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.stopFading();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (interpolantValue === <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// faded out, disable</span></span><br><span class="line">                            <span class="built_in">this</span>.enabled = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._effectiveWeight = weight;</span><br><span class="line">            <span class="keyword">return</span> weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_updateTimeScale</span>(<span class="params">time</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> timeScale = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>.paused) &#123;</span><br><span class="line">                timeScale = <span class="built_in">this</span>.timeScale;</span><br><span class="line">                <span class="keyword">const</span> interpolant = <span class="built_in">this</span>._timeScaleInterpolant;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (interpolant !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> interpolantValue = interpolant.evaluate(time)[<span class="number">0</span>];</span><br><span class="line">                    timeScale *= interpolantValue;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (time &gt; interpolant.parameterPositions[<span class="number">1</span>]) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.stopWarping();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (timeScale === <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// motion has halted, pause</span></span><br><span class="line">                            <span class="built_in">this</span>.paused = <span class="literal">true</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// warp done - apply final time scale</span></span><br><span class="line">                            <span class="built_in">this</span>.timeScale = timeScale;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._effectiveTimeScale = timeScale;</span><br><span class="line">            <span class="keyword">return</span> timeScale;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_updateTime</span>(<span class="params">deltaTime</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> duration = <span class="built_in">this</span>._clip.duration;</span><br><span class="line">            <span class="keyword">const</span> loop = <span class="built_in">this</span>.loop;</span><br><span class="line">            <span class="keyword">let</span> time = <span class="built_in">this</span>.time + deltaTime;</span><br><span class="line">            <span class="keyword">let</span> loopCount = <span class="built_in">this</span>._loopCount;</span><br><span class="line">            <span class="keyword">const</span> pingPong = loop === LoopPingPong;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (deltaTime === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (loopCount === -<span class="number">1</span>) <span class="keyword">return</span> time;</span><br><span class="line">                <span class="keyword">return</span> pingPong &amp;&amp; (loopCount &amp; <span class="number">1</span>) === <span class="number">1</span> ? duration - time : time;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (loop === LoopOnce) &#123;</span><br><span class="line">                <span class="keyword">if</span> (loopCount === -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// just started</span></span><br><span class="line">                    <span class="built_in">this</span>._loopCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">this</span>._setEndings(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="attr">handle_stop</span>: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (time &gt;= duration) &#123;</span><br><span class="line">                        time = duration;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (time &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        time = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.time = time;</span><br><span class="line">                        <span class="keyword">break</span> handle_stop;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">this</span>.clampWhenFinished) <span class="built_in">this</span>.paused = <span class="literal">true</span>;<span class="keyword">else</span> <span class="built_in">this</span>.enabled = <span class="literal">false</span>;</span><br><span class="line">                    <span class="built_in">this</span>.time = time;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">this</span>._mixer.dispatchEvent(&#123;</span><br><span class="line">                        <span class="attr">type</span>: <span class="string">&#x27;finished&#x27;</span>,</span><br><span class="line">                        <span class="attr">action</span>: <span class="built_in">this</span>,</span><br><span class="line">                        <span class="attr">direction</span>: deltaTime &lt; <span class="number">0</span> ? -<span class="number">1</span> : <span class="number">1</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// repetitive Repeat or PingPong</span></span><br><span class="line">                <span class="keyword">if</span> (loopCount === -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// just started</span></span><br><span class="line">                    <span class="keyword">if</span> (deltaTime &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        loopCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">this</span>._setEndings(<span class="literal">true</span>, <span class="built_in">this</span>.repetitions === <span class="number">0</span>, pingPong);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// when looping in reverse direction, the initial</span></span><br><span class="line">                        <span class="comment">// transition through zero counts as a repetition,</span></span><br><span class="line">                        <span class="comment">// so leave loopCount at -1</span></span><br><span class="line">                        <span class="built_in">this</span>._setEndings(<span class="built_in">this</span>.repetitions === <span class="number">0</span>, <span class="literal">true</span>, pingPong);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (time &gt;= duration || time &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// wrap around</span></span><br><span class="line">                    <span class="keyword">const</span> loopDelta = <span class="built_in">Math</span>.floor(time / duration); <span class="comment">// signed</span></span><br><span class="line"></span><br><span class="line">                    time -= duration * loopDelta;</span><br><span class="line">                    loopCount += <span class="built_in">Math</span>.abs(loopDelta);</span><br><span class="line">                    <span class="keyword">const</span> pending = <span class="built_in">this</span>.repetitions - loopCount;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (pending &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// have to stop (switch state, clamp time, fire event)</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.clampWhenFinished) <span class="built_in">this</span>.paused = <span class="literal">true</span>;<span class="keyword">else</span> <span class="built_in">this</span>.enabled = <span class="literal">false</span>;</span><br><span class="line">                        time = deltaTime &gt; <span class="number">0</span> ? duration : <span class="number">0</span>;</span><br><span class="line">                        <span class="built_in">this</span>.time = time;</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">this</span>._mixer.dispatchEvent(&#123;</span><br><span class="line">                            <span class="attr">type</span>: <span class="string">&#x27;finished&#x27;</span>,</span><br><span class="line">                            <span class="attr">action</span>: <span class="built_in">this</span>,</span><br><span class="line">                            <span class="attr">direction</span>: deltaTime &gt; <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// keep running</span></span><br><span class="line">                        <span class="keyword">if</span> (pending === <span class="number">1</span>) &#123;</span><br><span class="line">                            <span class="comment">// entering the last round</span></span><br><span class="line">                            <span class="keyword">const</span> atStart = deltaTime &lt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="built_in">this</span>._setEndings(atStart, !atStart, pingPong);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="built_in">this</span>._setEndings(<span class="literal">false</span>, <span class="literal">false</span>, pingPong);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">this</span>._loopCount = loopCount;</span><br><span class="line">                        <span class="built_in">this</span>.time = time;</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">this</span>._mixer.dispatchEvent(&#123;</span><br><span class="line">                            <span class="attr">type</span>: <span class="string">&#x27;loop&#x27;</span>,</span><br><span class="line">                            <span class="attr">action</span>: <span class="built_in">this</span>,</span><br><span class="line">                            <span class="attr">loopDelta</span>: loopDelta</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.time = time;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pingPong &amp;&amp; (loopCount &amp; <span class="number">1</span>) === <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// invert time for the &quot;pong round&quot;</span></span><br><span class="line">                    <span class="keyword">return</span> duration - time;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> time;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_setEndings</span>(<span class="params">atStart, atEnd, pingPong</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> settings = <span class="built_in">this</span>._interpolantSettings;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pingPong) &#123;</span><br><span class="line">                settings.endingStart = ZeroSlopeEnding;</span><br><span class="line">                settings.endingEnd = ZeroSlopeEnding;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// assuming for LoopOnce atStart == atEnd == true</span></span><br><span class="line">                <span class="keyword">if</span> (atStart) &#123;</span><br><span class="line">                    settings.endingStart = <span class="built_in">this</span>.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    settings.endingStart = WrapAroundEnding;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (atEnd) &#123;</span><br><span class="line">                    settings.endingEnd = <span class="built_in">this</span>.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    settings.endingEnd = WrapAroundEnding;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_scheduleFading</span>(<span class="params">duration, weightNow, weightThen</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> mixer = <span class="built_in">this</span>._mixer,</span><br><span class="line">                now = mixer.time;</span><br><span class="line">            <span class="keyword">let</span> interpolant = <span class="built_in">this</span>._weightInterpolant;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (interpolant === <span class="literal">null</span>) &#123;</span><br><span class="line">                interpolant = mixer._lendControlInterpolant();</span><br><span class="line">                <span class="built_in">this</span>._weightInterpolant = interpolant;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> times = interpolant.parameterPositions,</span><br><span class="line">                values = interpolant.sampleValues;</span><br><span class="line">            times[<span class="number">0</span>] = now;</span><br><span class="line">            values[<span class="number">0</span>] = weightNow;</span><br><span class="line">            times[<span class="number">1</span>] = now + duration;</span><br><span class="line">            values[<span class="number">1</span>] = weightThen;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AnimationMixer</span> <span class="keyword">extends</span> <span class="title">EventDispatcher</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">root</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>._root = root;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._initMemoryManager();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._accuIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.time = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.timeScale = <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_bindAction</span>(<span class="params">action, prototypeAction</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> root = action._localRoot || <span class="built_in">this</span>._root,</span><br><span class="line">                tracks = action._clip.tracks,</span><br><span class="line">                nTracks = tracks.length,</span><br><span class="line">                bindings = action._propertyBindings,</span><br><span class="line">                interpolants = action._interpolants,</span><br><span class="line">                rootUuid = root.uuid,</span><br><span class="line">                bindingsByRoot = <span class="built_in">this</span>._bindingsByRootAndName;</span><br><span class="line">            <span class="keyword">let</span> bindingsByName = bindingsByRoot[rootUuid];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bindingsByName === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                bindingsByName = &#123;&#125;;</span><br><span class="line">                bindingsByRoot[rootUuid] = bindingsByName;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i !== nTracks; ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> track = tracks[i],</span><br><span class="line">                    trackName = track.name;</span><br><span class="line">                <span class="keyword">let</span> binding = bindingsByName[trackName];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (binding !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    ++binding.referenceCount;</span><br><span class="line">                    bindings[i] = binding;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    binding = bindings[i];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (binding !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        <span class="comment">// existing binding, make sure the cache knows</span></span><br><span class="line">                        <span class="keyword">if</span> (binding._cacheIndex === <span class="literal">null</span>) &#123;</span><br><span class="line">                            ++binding.referenceCount;</span><br><span class="line"></span><br><span class="line">                            <span class="built_in">this</span>._addInactiveBinding(binding, rootUuid, trackName);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> path = prototypeAction &amp;&amp; prototypeAction._propertyBindings[i].binding.parsedPath;</span><br><span class="line">                    binding = <span class="keyword">new</span> PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());</span><br><span class="line">                    ++binding.referenceCount;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">this</span>._addInactiveBinding(binding, rootUuid, trackName);</span><br><span class="line"></span><br><span class="line">                    bindings[i] = binding;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                interpolants[i].resultBuffer = binding.buffer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_activateAction</span>(<span class="params">action</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>._isActiveAction(action)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (action._cacheIndex === <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// this action has been forgotten by the cache, but the user</span></span><br><span class="line">                    <span class="comment">// appears to be still using it -&gt; rebind</span></span><br><span class="line">                    <span class="keyword">const</span> rootUuid = (action._localRoot || <span class="built_in">this</span>._root).uuid,</span><br><span class="line">                        clipUuid = action._clip.uuid,</span><br><span class="line">                        actionsForClip = <span class="built_in">this</span>._actionsByClip[clipUuid];</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">this</span>._bindAction(action, actionsForClip &amp;&amp; actionsForClip.knownActions[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">this</span>._addInactiveAction(action, clipUuid, rootUuid);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> bindings = action._propertyBindings; <span class="comment">// increment reference counts / sort out state</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = bindings.length; i !== n; ++i) &#123;</span><br><span class="line">                    <span class="keyword">const</span> binding = bindings[i];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (binding.useCount++ === <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>._lendBinding(binding);</span><br><span class="line"></span><br><span class="line">                        binding.saveOriginalState();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>._lendAction(action);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_deactivateAction</span>(<span class="params">action</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>._isActiveAction(action)) &#123;</span><br><span class="line">                <span class="keyword">const</span> bindings = action._propertyBindings; <span class="comment">// decrement reference counts / sort out state</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = bindings.length; i !== n; ++i) &#123;</span><br><span class="line">                    <span class="keyword">const</span> binding = bindings[i];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (--binding.useCount === <span class="number">0</span>) &#123;</span><br><span class="line">                        binding.restoreOriginalState();</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">this</span>._takeBackBinding(binding);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>._takeBackAction(action);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// Memory manager</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_initMemoryManager</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._actions = []; <span class="comment">// &#x27;nActiveActions&#x27; followed by inactive ones</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._nActiveActions = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>._actionsByClip = &#123;&#125;; <span class="comment">// inside:</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">// 	knownActions: Array&lt; AnimationAction &gt; - used as prototypes</span></span><br><span class="line">            <span class="comment">// 	actionByRoot: AnimationAction - lookup</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._bindings = []; <span class="comment">// &#x27;nActiveBindings&#x27; followed by inactive ones</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._nActiveBindings = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>._bindingsByRootAndName = &#123;&#125;; <span class="comment">// inside: Map&lt; name, PropertyMixer &gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._controlInterpolants = []; <span class="comment">// same game as above</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._nActiveControlInterpolants = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> scope = <span class="built_in">this</span>;</span><br><span class="line">            <span class="built_in">this</span>.stats = &#123;</span><br><span class="line">                <span class="attr">actions</span>: &#123;</span><br><span class="line">                    <span class="keyword">get</span> <span class="title">total</span>() &#123;</span><br><span class="line">                        <span class="keyword">return</span> scope._actions.length;</span><br><span class="line">                    &#125;,</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">get</span> <span class="title">inUse</span>() &#123;</span><br><span class="line">                        <span class="keyword">return</span> scope._nActiveActions;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">bindings</span>: &#123;</span><br><span class="line">                    <span class="keyword">get</span> <span class="title">total</span>() &#123;</span><br><span class="line">                        <span class="keyword">return</span> scope._bindings.length;</span><br><span class="line">                    &#125;,</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">get</span> <span class="title">inUse</span>() &#123;</span><br><span class="line">                        <span class="keyword">return</span> scope._nActiveBindings;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">controlInterpolants</span>: &#123;</span><br><span class="line">                    <span class="keyword">get</span> <span class="title">total</span>() &#123;</span><br><span class="line">                        <span class="keyword">return</span> scope._controlInterpolants.length;</span><br><span class="line">                    &#125;,</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">get</span> <span class="title">inUse</span>() &#123;</span><br><span class="line">                        <span class="keyword">return</span> scope._nActiveControlInterpolants;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; <span class="comment">// Memory management for AnimationAction objects</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_isActiveAction</span>(<span class="params">action</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> index = action._cacheIndex;</span><br><span class="line">            <span class="keyword">return</span> index !== <span class="literal">null</span> &amp;&amp; index &lt; <span class="built_in">this</span>._nActiveActions;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_addInactiveAction</span>(<span class="params">action, clipUuid, rootUuid</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> actions = <span class="built_in">this</span>._actions,</span><br><span class="line">                actionsByClip = <span class="built_in">this</span>._actionsByClip;</span><br><span class="line">            <span class="keyword">let</span> actionsForClip = actionsByClip[clipUuid];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (actionsForClip === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                actionsForClip = &#123;</span><br><span class="line">                    <span class="attr">knownActions</span>: [action],</span><br><span class="line">                    <span class="attr">actionByRoot</span>: &#123;&#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                action._byClipCacheIndex = <span class="number">0</span>;</span><br><span class="line">                actionsByClip[clipUuid] = actionsForClip;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> knownActions = actionsForClip.knownActions;</span><br><span class="line">                action._byClipCacheIndex = knownActions.length;</span><br><span class="line">                knownActions.push(action);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            action._cacheIndex = actions.length;</span><br><span class="line">            actions.push(action);</span><br><span class="line">            actionsForClip.actionByRoot[rootUuid] = action;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_removeInactiveAction</span>(<span class="params">action</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> actions = <span class="built_in">this</span>._actions,</span><br><span class="line">                lastInactiveAction = actions[actions.length - <span class="number">1</span>],</span><br><span class="line">                cacheIndex = action._cacheIndex;</span><br><span class="line">            lastInactiveAction._cacheIndex = cacheIndex;</span><br><span class="line">            actions[cacheIndex] = lastInactiveAction;</span><br><span class="line">            actions.pop();</span><br><span class="line">            action._cacheIndex = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">const</span> clipUuid = action._clip.uuid,</span><br><span class="line">                actionsByClip = <span class="built_in">this</span>._actionsByClip,</span><br><span class="line">                actionsForClip = actionsByClip[clipUuid],</span><br><span class="line">                knownActionsForClip = actionsForClip.knownActions,</span><br><span class="line">                lastKnownAction = knownActionsForClip[knownActionsForClip.length - <span class="number">1</span>],</span><br><span class="line">                byClipCacheIndex = action._byClipCacheIndex;</span><br><span class="line">            lastKnownAction._byClipCacheIndex = byClipCacheIndex;</span><br><span class="line">            knownActionsForClip[byClipCacheIndex] = lastKnownAction;</span><br><span class="line">            knownActionsForClip.pop();</span><br><span class="line">            action._byClipCacheIndex = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">const</span> actionByRoot = actionsForClip.actionByRoot,</span><br><span class="line">                rootUuid = (action._localRoot || <span class="built_in">this</span>._root).uuid;</span><br><span class="line">            <span class="keyword">delete</span> actionByRoot[rootUuid];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (knownActionsForClip.length === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> actionsByClip[clipUuid];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._removeInactiveBindingsForAction(action);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_removeInactiveBindingsForAction</span>(<span class="params">action</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> bindings = action._propertyBindings;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = bindings.length; i !== n; ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> binding = bindings[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (--binding.referenceCount === <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>._removeInactiveBinding(binding);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_lendAction</span>(<span class="params">action</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// [ active actions |	inactive actions	]</span></span><br><span class="line">            <span class="comment">// [	active actions &gt;| inactive actions ]</span></span><br><span class="line">            <span class="comment">//								 s				a</span></span><br><span class="line">            <span class="comment">//									&lt;-swap-&gt;</span></span><br><span class="line">            <span class="comment">//								 a				s</span></span><br><span class="line">            <span class="keyword">const</span> actions = <span class="built_in">this</span>._actions,</span><br><span class="line">                prevIndex = action._cacheIndex,</span><br><span class="line">                lastActiveIndex = <span class="built_in">this</span>._nActiveActions++,</span><br><span class="line">                firstInactiveAction = actions[lastActiveIndex];</span><br><span class="line">            action._cacheIndex = lastActiveIndex;</span><br><span class="line">            actions[lastActiveIndex] = action;</span><br><span class="line">            firstInactiveAction._cacheIndex = prevIndex;</span><br><span class="line">            actions[prevIndex] = firstInactiveAction;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_takeBackAction</span>(<span class="params">action</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// [	active actions	| inactive actions ]</span></span><br><span class="line">            <span class="comment">// [ active actions |&lt; inactive actions	]</span></span><br><span class="line">            <span class="comment">//				a				s</span></span><br><span class="line">            <span class="comment">//				 &lt;-swap-&gt;</span></span><br><span class="line">            <span class="comment">//				s				a</span></span><br><span class="line">            <span class="keyword">const</span> actions = <span class="built_in">this</span>._actions,</span><br><span class="line">                prevIndex = action._cacheIndex,</span><br><span class="line">                firstInactiveIndex = --<span class="built_in">this</span>._nActiveActions,</span><br><span class="line">                lastActiveAction = actions[firstInactiveIndex];</span><br><span class="line">            action._cacheIndex = firstInactiveIndex;</span><br><span class="line">            actions[firstInactiveIndex] = action;</span><br><span class="line">            lastActiveAction._cacheIndex = prevIndex;</span><br><span class="line">            actions[prevIndex] = lastActiveAction;</span><br><span class="line">        &#125; <span class="comment">// Memory management for PropertyMixer objects</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_addInactiveBinding</span>(<span class="params">binding, rootUuid, trackName</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> bindingsByRoot = <span class="built_in">this</span>._bindingsByRootAndName,</span><br><span class="line">                bindings = <span class="built_in">this</span>._bindings;</span><br><span class="line">            <span class="keyword">let</span> bindingByName = bindingsByRoot[rootUuid];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bindingByName === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                bindingByName = &#123;&#125;;</span><br><span class="line">                bindingsByRoot[rootUuid] = bindingByName;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bindingByName[trackName] = binding;</span><br><span class="line">            binding._cacheIndex = bindings.length;</span><br><span class="line">            bindings.push(binding);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_removeInactiveBinding</span>(<span class="params">binding</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> bindings = <span class="built_in">this</span>._bindings,</span><br><span class="line">                propBinding = binding.binding,</span><br><span class="line">                rootUuid = propBinding.rootNode.uuid,</span><br><span class="line">                trackName = propBinding.path,</span><br><span class="line">                bindingsByRoot = <span class="built_in">this</span>._bindingsByRootAndName,</span><br><span class="line">                bindingByName = bindingsByRoot[rootUuid],</span><br><span class="line">                lastInactiveBinding = bindings[bindings.length - <span class="number">1</span>],</span><br><span class="line">                cacheIndex = binding._cacheIndex;</span><br><span class="line">            lastInactiveBinding._cacheIndex = cacheIndex;</span><br><span class="line">            bindings[cacheIndex] = lastInactiveBinding;</span><br><span class="line">            bindings.pop();</span><br><span class="line">            <span class="keyword">delete</span> bindingByName[trackName];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(bindingByName).length === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> bindingsByRoot[rootUuid];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_lendBinding</span>(<span class="params">binding</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> bindings = <span class="built_in">this</span>._bindings,</span><br><span class="line">                prevIndex = binding._cacheIndex,</span><br><span class="line">                lastActiveIndex = <span class="built_in">this</span>._nActiveBindings++,</span><br><span class="line">                firstInactiveBinding = bindings[lastActiveIndex];</span><br><span class="line">            binding._cacheIndex = lastActiveIndex;</span><br><span class="line">            bindings[lastActiveIndex] = binding;</span><br><span class="line">            firstInactiveBinding._cacheIndex = prevIndex;</span><br><span class="line">            bindings[prevIndex] = firstInactiveBinding;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_takeBackBinding</span>(<span class="params">binding</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> bindings = <span class="built_in">this</span>._bindings,</span><br><span class="line">                prevIndex = binding._cacheIndex,</span><br><span class="line">                firstInactiveIndex = --<span class="built_in">this</span>._nActiveBindings,</span><br><span class="line">                lastActiveBinding = bindings[firstInactiveIndex];</span><br><span class="line">            binding._cacheIndex = firstInactiveIndex;</span><br><span class="line">            bindings[firstInactiveIndex] = binding;</span><br><span class="line">            lastActiveBinding._cacheIndex = prevIndex;</span><br><span class="line">            bindings[prevIndex] = lastActiveBinding;</span><br><span class="line">        &#125; <span class="comment">// Memory management of Interpolants for weight and time scale</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_lendControlInterpolant</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> interpolants = <span class="built_in">this</span>._controlInterpolants,</span><br><span class="line">                lastActiveIndex = <span class="built_in">this</span>._nActiveControlInterpolants++;</span><br><span class="line">            <span class="keyword">let</span> interpolant = interpolants[lastActiveIndex];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (interpolant === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                interpolant = <span class="keyword">new</span> LinearInterpolant(<span class="keyword">new</span> <span class="built_in">Float32Array</span>(<span class="number">2</span>), <span class="keyword">new</span> <span class="built_in">Float32Array</span>(<span class="number">2</span>), <span class="number">1</span>, <span class="built_in">this</span>._controlInterpolantsResultBuffer);</span><br><span class="line">                interpolant.__cacheIndex = lastActiveIndex;</span><br><span class="line">                interpolants[lastActiveIndex] = interpolant;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> interpolant;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_takeBackControlInterpolant</span>(<span class="params">interpolant</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> interpolants = <span class="built_in">this</span>._controlInterpolants,</span><br><span class="line">                prevIndex = interpolant.__cacheIndex,</span><br><span class="line">                firstInactiveIndex = --<span class="built_in">this</span>._nActiveControlInterpolants,</span><br><span class="line">                lastActiveInterpolant = interpolants[firstInactiveIndex];</span><br><span class="line">            interpolant.__cacheIndex = firstInactiveIndex;</span><br><span class="line">            interpolants[firstInactiveIndex] = interpolant;</span><br><span class="line">            lastActiveInterpolant.__cacheIndex = prevIndex;</span><br><span class="line">            interpolants[prevIndex] = lastActiveInterpolant;</span><br><span class="line">        &#125; <span class="comment">// return an action for a clip optionally using a custom root target</span></span><br><span class="line">        <span class="comment">// object (this method allocates a lot of dynamic memory in case a</span></span><br><span class="line">        <span class="comment">// previously unknown clip/root combination is specified)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clipAction</span>(<span class="params">clip, optionalRoot, blendMode</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> root = optionalRoot || <span class="built_in">this</span>._root,</span><br><span class="line">                rootUuid = root.uuid;</span><br><span class="line">            <span class="keyword">let</span> clipObject = <span class="keyword">typeof</span> clip === <span class="string">&#x27;string&#x27;</span> ? AnimationClip.findByName(root, clip) : clip;</span><br><span class="line">            <span class="keyword">const</span> clipUuid = clipObject !== <span class="literal">null</span> ? clipObject.uuid : clip;</span><br><span class="line">            <span class="keyword">const</span> actionsForClip = <span class="built_in">this</span>._actionsByClip[clipUuid];</span><br><span class="line">            <span class="keyword">let</span> prototypeAction = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (blendMode === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (clipObject !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    blendMode = clipObject.blendMode;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    blendMode = NormalAnimationBlendMode;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (actionsForClip !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> existingAction = actionsForClip.actionByRoot[rootUuid];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (existingAction !== <span class="literal">undefined</span> &amp;&amp; existingAction.blendMode === blendMode) &#123;</span><br><span class="line">                    <span class="keyword">return</span> existingAction;</span><br><span class="line">                &#125; <span class="comment">// we know the clip, so we don&#x27;t have to parse all</span></span><br><span class="line">                <span class="comment">// the bindings again but can just copy</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                prototypeAction = actionsForClip.knownActions[<span class="number">0</span>]; <span class="comment">// also, take the clip from the prototype action</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (clipObject === <span class="literal">null</span>) clipObject = prototypeAction._clip;</span><br><span class="line">            &#125; <span class="comment">// clip must be known when specified via string</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (clipObject === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// allocate all resources required to run it</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> newAction = <span class="keyword">new</span> AnimationAction(<span class="built_in">this</span>, clipObject, optionalRoot, blendMode);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._bindAction(newAction, prototypeAction); <span class="comment">// and make the action known to the memory manager</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>._addInactiveAction(newAction, clipUuid, rootUuid);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> newAction;</span><br><span class="line">        &#125; <span class="comment">// get an existing action</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">existingAction</span>(<span class="params">clip, optionalRoot</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> root = optionalRoot || <span class="built_in">this</span>._root,</span><br><span class="line">                rootUuid = root.uuid,</span><br><span class="line">                clipObject = <span class="keyword">typeof</span> clip === <span class="string">&#x27;string&#x27;</span> ? AnimationClip.findByName(root, clip) : clip,</span><br><span class="line">                clipUuid = clipObject ? clipObject.uuid : clip,</span><br><span class="line">                actionsForClip = <span class="built_in">this</span>._actionsByClip[clipUuid];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (actionsForClip !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> actionsForClip.actionByRoot[rootUuid] || <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="comment">// deactivates all previously scheduled actions</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">stopAllAction</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> actions = <span class="built_in">this</span>._actions,</span><br><span class="line">                nActions = <span class="built_in">this</span>._nActiveActions;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = nActions - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                actions[i].stop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125; <span class="comment">// advance the time and update apply the animation</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">update</span>(<span class="params">deltaTime</span>)</span> &#123;</span><br><span class="line">            deltaTime *= <span class="built_in">this</span>.timeScale;</span><br><span class="line">            <span class="keyword">const</span> actions = <span class="built_in">this</span>._actions,</span><br><span class="line">                nActions = <span class="built_in">this</span>._nActiveActions,</span><br><span class="line">                time = <span class="built_in">this</span>.time += deltaTime,</span><br><span class="line">                timeDirection = <span class="built_in">Math</span>.sign(deltaTime),</span><br><span class="line">                accuIndex = <span class="built_in">this</span>._accuIndex ^= <span class="number">1</span>; <span class="comment">// run active actions</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i !== nActions; ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> action = actions[i];</span><br><span class="line"></span><br><span class="line">                action._update(time, deltaTime, timeDirection, accuIndex);</span><br><span class="line">            &#125; <span class="comment">// update scene graph</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> bindings = <span class="built_in">this</span>._bindings,</span><br><span class="line">                nBindings = <span class="built_in">this</span>._nActiveBindings;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i !== nBindings; ++i) &#123;</span><br><span class="line">                bindings[i].apply(accuIndex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125; <span class="comment">// Allows you to seek to a specific time in an animation.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setTime</span>(<span class="params">timeInSeconds</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.time = <span class="number">0</span>; <span class="comment">// Zero out time attribute for AnimationMixer object;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>._actions.length; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>._actions[i].time = <span class="number">0</span>; <span class="comment">// Zero out time attribute for all associated AnimationAction objects.</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.update(timeInSeconds); <span class="comment">// Update used to set exact time. Returns &quot;this&quot; AnimationMixer object.</span></span><br><span class="line">        &#125; <span class="comment">// return this mixer&#x27;s root target object</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getRoot</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._root;</span><br><span class="line">        &#125; <span class="comment">// free all resources specific to a particular clip</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">uncacheClip</span>(<span class="params">clip</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> actions = <span class="built_in">this</span>._actions,</span><br><span class="line">                clipUuid = clip.uuid,</span><br><span class="line">                actionsByClip = <span class="built_in">this</span>._actionsByClip,</span><br><span class="line">                actionsForClip = actionsByClip[clipUuid];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (actionsForClip !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="comment">// note: just calling _removeInactiveAction would mess up the</span></span><br><span class="line">                <span class="comment">// iteration state and also require updating the state we can</span></span><br><span class="line">                <span class="comment">// just throw away</span></span><br><span class="line">                <span class="keyword">const</span> actionsToRemove = actionsForClip.knownActions;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = actionsToRemove.length; i !== n; ++i) &#123;</span><br><span class="line">                    <span class="keyword">const</span> action = actionsToRemove[i];</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">this</span>._deactivateAction(action);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> cacheIndex = action._cacheIndex,</span><br><span class="line">                        lastInactiveAction = actions[actions.length - <span class="number">1</span>];</span><br><span class="line">                    action._cacheIndex = <span class="literal">null</span>;</span><br><span class="line">                    action._byClipCacheIndex = <span class="literal">null</span>;</span><br><span class="line">                    lastInactiveAction._cacheIndex = cacheIndex;</span><br><span class="line">                    actions[cacheIndex] = lastInactiveAction;</span><br><span class="line">                    actions.pop();</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">this</span>._removeInactiveBindingsForAction(action);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">delete</span> actionsByClip[clipUuid];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// free all resources specific to a particular root target object</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">uncacheRoot</span>(<span class="params">root</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> rootUuid = root.uuid,</span><br><span class="line">                actionsByClip = <span class="built_in">this</span>._actionsByClip;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> clipUuid <span class="keyword">in</span> actionsByClip) &#123;</span><br><span class="line">                <span class="keyword">const</span> actionByRoot = actionsByClip[clipUuid].actionByRoot,</span><br><span class="line">                    action = actionByRoot[rootUuid];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (action !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>._deactivateAction(action);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">this</span>._removeInactiveAction(action);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> bindingsByRoot = <span class="built_in">this</span>._bindingsByRootAndName,</span><br><span class="line">                bindingByName = bindingsByRoot[rootUuid];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bindingByName !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> trackName <span class="keyword">in</span> bindingByName) &#123;</span><br><span class="line">                    <span class="keyword">const</span> binding = bindingByName[trackName];</span><br><span class="line">                    binding.restoreOriginalState();</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">this</span>._removeInactiveBinding(binding);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// remove a targeted clip from the cache</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">uncacheAction</span>(<span class="params">clip, optionalRoot</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> action = <span class="built_in">this</span>.existingAction(clip, optionalRoot);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (action !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>._deactivateAction(action);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>._removeInactiveAction(action);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AnimationMixer.prototype._controlInterpolantsResultBuffer = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Uniform</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Uniform: Type parameter is no longer needed.&#x27;</span>);</span><br><span class="line">                value = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Uniform(<span class="built_in">this</span>.value.clone === <span class="literal">undefined</span> ? <span class="built_in">this</span>.value : <span class="built_in">this</span>.value.clone());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InstancedInterleavedBuffer</span> <span class="keyword">extends</span> <span class="title">InterleavedBuffer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array, stride, meshPerAttribute = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(array, stride);</span><br><span class="line">            <span class="built_in">this</span>.meshPerAttribute = meshPerAttribute;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source);</span><br><span class="line">            <span class="built_in">this</span>.meshPerAttribute = source.meshPerAttribute;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> ib = <span class="built_in">super</span>.clone(data);</span><br><span class="line">            ib.meshPerAttribute = <span class="built_in">this</span>.meshPerAttribute;</span><br><span class="line">            <span class="keyword">return</span> ib;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toJSON</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> json = <span class="built_in">super</span>.toJSON(data);</span><br><span class="line">            json.isInstancedInterleavedBuffer = <span class="literal">true</span>;</span><br><span class="line">            json.meshPerAttribute = <span class="built_in">this</span>.meshPerAttribute;</span><br><span class="line">            <span class="keyword">return</span> json;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GLBufferAttribute</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">buffer, type, itemSize, elementSize, count</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.buffer = buffer;</span><br><span class="line">            <span class="built_in">this</span>.type = type;</span><br><span class="line">            <span class="built_in">this</span>.itemSize = itemSize;</span><br><span class="line">            <span class="built_in">this</span>.elementSize = elementSize;</span><br><span class="line">            <span class="built_in">this</span>.count = count;</span><br><span class="line">            <span class="built_in">this</span>.version = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> <span class="title">needsUpdate</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value === <span class="literal">true</span>) <span class="built_in">this</span>.version++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setBuffer</span>(<span class="params">buffer</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.buffer = buffer;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setType</span>(<span class="params">type, elementSize</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.type = type;</span><br><span class="line">            <span class="built_in">this</span>.elementSize = elementSize;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setItemSize</span>(<span class="params">itemSize</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.itemSize = itemSize;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setCount</span>(<span class="params">count</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.count = count;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GLBufferAttribute.prototype.isGLBufferAttribute = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Raycaster</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">origin, direction, near = <span class="number">0</span>, far = <span class="literal">Infinity</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.ray = <span class="keyword">new</span> Ray(origin, direction); <span class="comment">// direction is assumed to be normalized (for accurate distance calculations)</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.near = near;</span><br><span class="line">            <span class="built_in">this</span>.far = far;</span><br><span class="line">            <span class="built_in">this</span>.camera = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.layers = <span class="keyword">new</span> Layers();</span><br><span class="line">            <span class="built_in">this</span>.params = &#123;</span><br><span class="line">                <span class="attr">Mesh</span>: &#123;&#125;,</span><br><span class="line">                <span class="attr">Line</span>: &#123;</span><br><span class="line">                    <span class="attr">threshold</span>: <span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">LOD</span>: &#123;&#125;,</span><br><span class="line">                <span class="attr">Points</span>: &#123;</span><br><span class="line">                    <span class="attr">threshold</span>: <span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">Sprite</span>: &#123;&#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">origin, direction</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// direction is assumed to be normalized (for accurate distance calculations)</span></span><br><span class="line">            <span class="built_in">this</span>.ray.set(origin, direction);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromCamera</span>(<span class="params">coords, camera</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (camera.isPerspectiveCamera) &#123;</span><br><span class="line">                <span class="built_in">this</span>.ray.origin.setFromMatrixPosition(camera.matrixWorld);</span><br><span class="line">                <span class="built_in">this</span>.ray.direction.set(coords.x, coords.y, <span class="number">0.5</span>).unproject(camera).sub(<span class="built_in">this</span>.ray.origin).normalize();</span><br><span class="line">                <span class="built_in">this</span>.camera = camera;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (camera.isOrthographicCamera) &#123;</span><br><span class="line">                <span class="built_in">this</span>.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); <span class="comment">// set origin in plane of camera</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.ray.direction.set(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>).transformDirection(camera.matrixWorld);</span><br><span class="line">                <span class="built_in">this</span>.camera = camera;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Raycaster: Unsupported camera type: &#x27;</span> + camera.type);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectObject</span>(<span class="params">object, recursive = <span class="literal">true</span>, intersects = []</span>)</span> &#123;</span><br><span class="line">            intersectObject(object, <span class="built_in">this</span>, intersects, recursive);</span><br><span class="line">            intersects.sort(ascSort);</span><br><span class="line">            <span class="keyword">return</span> intersects;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectObjects</span>(<span class="params">objects, recursive = <span class="literal">true</span>, intersects = []</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = objects.length; i &lt; l; i++) &#123;</span><br><span class="line">                intersectObject(objects[i], <span class="built_in">this</span>, intersects, recursive);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            intersects.sort(ascSort);</span><br><span class="line">            <span class="keyword">return</span> intersects;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ascSort</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.distance - b.distance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">intersectObject</span>(<span class="params">object, raycaster, intersects, recursive</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (object.layers.test(raycaster.layers)) &#123;</span><br><span class="line">            object.raycast(raycaster, intersects);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (recursive === <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> children = object.children;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = children.length; i &lt; l; i++) &#123;</span><br><span class="line">                intersectObject(children[i], raycaster, intersects, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.</span></span><br><span class="line"><span class="comment">     * The azimuthal angle (theta) is measured from the positive z-axis.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Spherical</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">radius = <span class="number">1</span>, phi = <span class="number">0</span>, theta = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.radius = radius;</span><br><span class="line">            <span class="built_in">this</span>.phi = phi; <span class="comment">// polar angle</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.theta = theta; <span class="comment">// azimuthal angle</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">radius, phi, theta</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.radius = radius;</span><br><span class="line">            <span class="built_in">this</span>.phi = phi;</span><br><span class="line">            <span class="built_in">this</span>.theta = theta;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">other</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.radius = other.radius;</span><br><span class="line">            <span class="built_in">this</span>.phi = other.phi;</span><br><span class="line">            <span class="built_in">this</span>.theta = other.theta;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125; <span class="comment">// restrict phi to be between EPS and PI-EPS</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">makeSafe</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> EPS = <span class="number">0.000001</span>;</span><br><span class="line">            <span class="built_in">this</span>.phi = <span class="built_in">Math</span>.max(EPS, <span class="built_in">Math</span>.min(<span class="built_in">Math</span>.PI - EPS, <span class="built_in">this</span>.phi));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromVector3</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.setFromCartesianCoords(v.x, v.y, v.z);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromCartesianCoords</span>(<span class="params">x, y, z</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.radius = <span class="built_in">Math</span>.sqrt(x * x + y * y + z * z);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.radius === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.theta = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">this</span>.phi = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.theta = <span class="built_in">Math</span>.atan2(x, z);</span><br><span class="line">                <span class="built_in">this</span>.phi = <span class="built_in">Math</span>.acos(clamp(y / <span class="built_in">this</span>.radius, -<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor().copy(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cylindrical</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">radius = <span class="number">1</span>, theta = <span class="number">0</span>, y = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.radius = radius; <span class="comment">// distance from the origin to a point in the x-z plane</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.theta = theta; <span class="comment">// counterclockwise angle in the x-z plane measured in radians from the positive z-axis</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.y = y; <span class="comment">// height above the x-z plane</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">radius, theta, y</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.radius = radius;</span><br><span class="line">            <span class="built_in">this</span>.theta = theta;</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">other</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.radius = other.radius;</span><br><span class="line">            <span class="built_in">this</span>.theta = other.theta;</span><br><span class="line">            <span class="built_in">this</span>.y = other.y;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromVector3</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.setFromCartesianCoords(v.x, v.y, v.z);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromCartesianCoords</span>(<span class="params">x, y, z</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.radius = <span class="built_in">Math</span>.sqrt(x * x + z * z);</span><br><span class="line">            <span class="built_in">this</span>.theta = <span class="built_in">Math</span>.atan2(x, z);</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor().copy(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vector$<span class="number">4</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector2();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Box2</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">min = <span class="keyword">new</span> Vector2(+<span class="literal">Infinity</span>, +<span class="literal">Infinity</span>), max = <span class="keyword">new</span> Vector2(-<span class="literal">Infinity</span>, -<span class="literal">Infinity</span>)</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.min = min;</span><br><span class="line">            <span class="built_in">this</span>.max = max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">min, max</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.min.copy(min);</span><br><span class="line">            <span class="built_in">this</span>.max.copy(max);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromPoints</span>(<span class="params">points</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.makeEmpty();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = points.length; i &lt; il; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.expandByPoint(points[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromCenterAndSize</span>(<span class="params">center, size</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> halfSize = _vector$<span class="number">4.</span>copy(size).multiplyScalar(<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.min.copy(center).sub(halfSize);</span><br><span class="line">            <span class="built_in">this</span>.max.copy(center).add(halfSize);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor().copy(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">box</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.min.copy(box.min);</span><br><span class="line">            <span class="built_in">this</span>.max.copy(box.max);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">makeEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.min.x = <span class="built_in">this</span>.min.y = +<span class="literal">Infinity</span>;</span><br><span class="line">            <span class="built_in">this</span>.max.x = <span class="built_in">this</span>.max.y = -<span class="literal">Infinity</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// this is a more robust check for empty than ( volume &lt;= 0 ) because volume can get positive with two negative axes</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.max.x &lt; <span class="built_in">this</span>.min.x || <span class="built_in">this</span>.max.y &lt; <span class="built_in">this</span>.min.y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getCenter</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.isEmpty() ? target.set(<span class="number">0</span>, <span class="number">0</span>) : target.addVectors(<span class="built_in">this</span>.min, <span class="built_in">this</span>.max).multiplyScalar(<span class="number">0.5</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getSize</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.isEmpty() ? target.set(<span class="number">0</span>, <span class="number">0</span>) : target.subVectors(<span class="built_in">this</span>.max, <span class="built_in">this</span>.min);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">expandByPoint</span>(<span class="params">point</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.min.min(point);</span><br><span class="line">            <span class="built_in">this</span>.max.max(point);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">expandByVector</span>(<span class="params">vector</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.min.sub(vector);</span><br><span class="line">            <span class="built_in">this</span>.max.add(vector);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">expandByScalar</span>(<span class="params">scalar</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.min.addScalar(-scalar);</span><br><span class="line">            <span class="built_in">this</span>.max.addScalar(scalar);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">containsPoint</span>(<span class="params">point</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> point.x &lt; <span class="built_in">this</span>.min.x || point.x &gt; <span class="built_in">this</span>.max.x || point.y &lt; <span class="built_in">this</span>.min.y || point.y &gt; <span class="built_in">this</span>.max.y ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">containsBox</span>(<span class="params">box</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.min.x &lt;= box.min.x &amp;&amp; box.max.x &lt;= <span class="built_in">this</span>.max.x &amp;&amp; <span class="built_in">this</span>.min.y &lt;= box.min.y &amp;&amp; box.max.y &lt;= <span class="built_in">this</span>.max.y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getParameter</span>(<span class="params">point, target</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// This can potentially have a divide by zero if the box</span></span><br><span class="line">            <span class="comment">// has a size dimension of 0.</span></span><br><span class="line">            <span class="keyword">return</span> target.set((point.x - <span class="built_in">this</span>.min.x) / (<span class="built_in">this</span>.max.x - <span class="built_in">this</span>.min.x), (point.y - <span class="built_in">this</span>.min.y) / (<span class="built_in">this</span>.max.y - <span class="built_in">this</span>.min.y));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersectsBox</span>(<span class="params">box</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// using 4 splitting planes to rule out intersections</span></span><br><span class="line">            <span class="keyword">return</span> box.max.x &lt; <span class="built_in">this</span>.min.x || box.min.x &gt; <span class="built_in">this</span>.max.x || box.max.y &lt; <span class="built_in">this</span>.min.y || box.min.y &gt; <span class="built_in">this</span>.max.y ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clampPoint</span>(<span class="params">point, target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> target.copy(point).clamp(<span class="built_in">this</span>.min, <span class="built_in">this</span>.max);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">distanceToPoint</span>(<span class="params">point</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> clampedPoint = _vector$<span class="number">4.</span>copy(point).clamp(<span class="built_in">this</span>.min, <span class="built_in">this</span>.max);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> clampedPoint.sub(point).length();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">intersect</span>(<span class="params">box</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.min.max(box.min);</span><br><span class="line">            <span class="built_in">this</span>.max.min(box.max);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">union</span>(<span class="params">box</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.min.min(box.min);</span><br><span class="line">            <span class="built_in">this</span>.max.max(box.max);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">translate</span>(<span class="params">offset</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.min.add(offset);</span><br><span class="line">            <span class="built_in">this</span>.max.add(offset);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">equals</span>(<span class="params">box</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> box.min.equals(<span class="built_in">this</span>.min) &amp;&amp; box.max.equals(<span class="built_in">this</span>.max);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Box2.prototype.isBox2 = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _startP = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _startEnd = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Line3</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">start = <span class="keyword">new</span> Vector3(), end = <span class="keyword">new</span> Vector3()</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.start = start;</span><br><span class="line">            <span class="built_in">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">start, end</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.start.copy(start);</span><br><span class="line">            <span class="built_in">this</span>.end.copy(end);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">line</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.start.copy(line.start);</span><br><span class="line">            <span class="built_in">this</span>.end.copy(line.end);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getCenter</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> target.addVectors(<span class="built_in">this</span>.start, <span class="built_in">this</span>.end).multiplyScalar(<span class="number">0.5</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">delta</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> target.subVectors(<span class="built_in">this</span>.end, <span class="built_in">this</span>.start);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">distanceSq</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.start.distanceToSquared(<span class="built_in">this</span>.end);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">distance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.start.distanceTo(<span class="built_in">this</span>.end);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">at</span>(<span class="params">t, target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.delta(target).multiplyScalar(t).add(<span class="built_in">this</span>.start);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">closestPointToPointParameter</span>(<span class="params">point, clampToLine</span>)</span> &#123;</span><br><span class="line">            _startP.subVectors(point, <span class="built_in">this</span>.start);</span><br><span class="line"></span><br><span class="line">            _startEnd.subVectors(<span class="built_in">this</span>.end, <span class="built_in">this</span>.start);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> startEnd2 = _startEnd.dot(_startEnd);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> startEnd_startP = _startEnd.dot(_startP);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> t = startEnd_startP / startEnd2;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (clampToLine) &#123;</span><br><span class="line">                t = clamp(t, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">closestPointToPoint</span>(<span class="params">point, clampToLine, target</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> t = <span class="built_in">this</span>.closestPointToPointParameter(point, clampToLine);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.delta(target).multiplyScalar(t).add(<span class="built_in">this</span>.start);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">applyMatrix4</span>(<span class="params">matrix</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.start.applyMatrix4(matrix);</span><br><span class="line">            <span class="built_in">this</span>.end.applyMatrix4(matrix);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">equals</span>(<span class="params">line</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> line.start.equals(<span class="built_in">this</span>.start) &amp;&amp; line.end.equals(<span class="built_in">this</span>.end);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor().copy(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vector$<span class="number">3</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SpotLightHelper</span> <span class="keyword">extends</span> <span class="title">Object3D</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">light, color</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.light = light;</span><br><span class="line">            <span class="built_in">this</span>.light.updateMatrixWorld();</span><br><span class="line">            <span class="built_in">this</span>.matrix = light.matrixWorld;</span><br><span class="line">            <span class="built_in">this</span>.matrixAutoUpdate = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.color = color;</span><br><span class="line">            <span class="keyword">const</span> geometry = <span class="keyword">new</span> BufferGeometry();</span><br><span class="line">            <span class="keyword">const</span> positions = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">1</span>, l = <span class="number">32</span>; i &lt; l; i++, j++) &#123;</span><br><span class="line">                <span class="keyword">const</span> p1 = i / l * <span class="built_in">Math</span>.PI * <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">const</span> p2 = j / l * <span class="built_in">Math</span>.PI * <span class="number">2</span>;</span><br><span class="line">                positions.push(<span class="built_in">Math</span>.cos(p1), <span class="built_in">Math</span>.sin(p1), <span class="number">1</span>, <span class="built_in">Math</span>.cos(p2), <span class="built_in">Math</span>.sin(p2), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            geometry.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(positions, <span class="number">3</span>));</span><br><span class="line">            <span class="keyword">const</span> material = <span class="keyword">new</span> LineBasicMaterial(&#123;</span><br><span class="line">                <span class="attr">fog</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">toneMapped</span>: <span class="literal">false</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">this</span>.cone = <span class="keyword">new</span> LineSegments(geometry, material);</span><br><span class="line">            <span class="built_in">this</span>.add(<span class="built_in">this</span>.cone);</span><br><span class="line">            <span class="built_in">this</span>.update();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dispose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.cone.geometry.dispose();</span><br><span class="line">            <span class="built_in">this</span>.cone.material.dispose();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.light.updateMatrixWorld();</span><br><span class="line">            <span class="keyword">const</span> coneLength = <span class="built_in">this</span>.light.distance ? <span class="built_in">this</span>.light.distance : <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">const</span> coneWidth = coneLength * <span class="built_in">Math</span>.tan(<span class="built_in">this</span>.light.angle);</span><br><span class="line">            <span class="built_in">this</span>.cone.scale.set(coneWidth, coneWidth, coneLength);</span><br><span class="line"></span><br><span class="line">            _vector$<span class="number">3.</span>setFromMatrixPosition(<span class="built_in">this</span>.light.target.matrixWorld);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.cone.lookAt(_vector$<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.color !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.cone.material.color.set(<span class="built_in">this</span>.color);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.cone.material.color.copy(<span class="built_in">this</span>.light.color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vector$<span class="number">2</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _boneMatrix = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Matrix4();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _matrixWorldInv = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Matrix4();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SkeletonHelper</span> <span class="keyword">extends</span> <span class="title">LineSegments</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">object</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> bones = getBoneList(object);</span><br><span class="line">            <span class="keyword">const</span> geometry = <span class="keyword">new</span> BufferGeometry();</span><br><span class="line">            <span class="keyword">const</span> vertices = [];</span><br><span class="line">            <span class="keyword">const</span> colors = [];</span><br><span class="line">            <span class="keyword">const</span> color1 = <span class="keyword">new</span> Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">const</span> color2 = <span class="keyword">new</span> Color(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bones.length; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> bone = bones[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bone.parent &amp;&amp; bone.parent.isBone) &#123;</span><br><span class="line">                    vertices.push(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    vertices.push(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    colors.push(color1.r, color1.g, color1.b);</span><br><span class="line">                    colors.push(color2.r, color2.g, color2.b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            geometry.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(vertices, <span class="number">3</span>));</span><br><span class="line">            geometry.setAttribute(<span class="string">&#x27;color&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(colors, <span class="number">3</span>));</span><br><span class="line">            <span class="keyword">const</span> material = <span class="keyword">new</span> LineBasicMaterial(&#123;</span><br><span class="line">                <span class="attr">vertexColors</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">depthTest</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">depthWrite</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">toneMapped</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">transparent</span>: <span class="literal">true</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">super</span>(geometry, material);</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;SkeletonHelper&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.isSkeletonHelper = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.root = object;</span><br><span class="line">            <span class="built_in">this</span>.bones = bones;</span><br><span class="line">            <span class="built_in">this</span>.matrix = object.matrixWorld;</span><br><span class="line">            <span class="built_in">this</span>.matrixAutoUpdate = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">updateMatrixWorld</span>(<span class="params">force</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> bones = <span class="built_in">this</span>.bones;</span><br><span class="line">            <span class="keyword">const</span> geometry = <span class="built_in">this</span>.geometry;</span><br><span class="line">            <span class="keyword">const</span> position = geometry.getAttribute(<span class="string">&#x27;position&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            _matrixWorldInv.copy(<span class="built_in">this</span>.root.matrixWorld).invert();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; bones.length; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> bone = bones[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bone.parent &amp;&amp; bone.parent.isBone) &#123;</span><br><span class="line">                    _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);</span><br><span class="line"></span><br><span class="line">                    _vector$<span class="number">2.</span>setFromMatrixPosition(_boneMatrix);</span><br><span class="line"></span><br><span class="line">                    position.setXYZ(j, _vector$<span class="number">2.</span>x, _vector$<span class="number">2.</span>y, _vector$<span class="number">2.</span>z);</span><br><span class="line"></span><br><span class="line">                    _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);</span><br><span class="line"></span><br><span class="line">                    _vector$<span class="number">2.</span>setFromMatrixPosition(_boneMatrix);</span><br><span class="line"></span><br><span class="line">                    position.setXYZ(j + <span class="number">1</span>, _vector$<span class="number">2.</span>x, _vector$<span class="number">2.</span>y, _vector$<span class="number">2.</span>z);</span><br><span class="line">                    j += <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            geometry.getAttribute(<span class="string">&#x27;position&#x27;</span>).needsUpdate = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">super</span>.updateMatrixWorld(force);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getBoneList</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> boneList = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (object.isBone === <span class="literal">true</span>) &#123;</span><br><span class="line">            boneList.push(object);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; object.children.length; i++) &#123;</span><br><span class="line">            boneList.push.apply(boneList, getBoneList(object.children[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> boneList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PointLightHelper</span> <span class="keyword">extends</span> <span class="title">Mesh</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">light, sphereSize, color</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> geometry = <span class="keyword">new</span> SphereGeometry(sphereSize, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">const</span> material = <span class="keyword">new</span> MeshBasicMaterial(&#123;</span><br><span class="line">                <span class="attr">wireframe</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">fog</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">toneMapped</span>: <span class="literal">false</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">super</span>(geometry, material);</span><br><span class="line">            <span class="built_in">this</span>.light = light;</span><br><span class="line">            <span class="built_in">this</span>.light.updateMatrixWorld();</span><br><span class="line">            <span class="built_in">this</span>.color = color;</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;PointLightHelper&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.matrix = <span class="built_in">this</span>.light.matrixWorld;</span><br><span class="line">            <span class="built_in">this</span>.matrixAutoUpdate = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.update();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">			// <span class="doctag">TODO:</span> delete this comment?</span></span><br><span class="line"><span class="comment">			const distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );</span></span><br><span class="line"><span class="comment">			const distanceMaterial = new THREE.MeshBasicMaterial( &#123; color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true &#125; );</span></span><br><span class="line"><span class="comment">			this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );</span></span><br><span class="line"><span class="comment">			this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );</span></span><br><span class="line"><span class="comment">			const d = light.distance;</span></span><br><span class="line"><span class="comment">			if ( d === 0.0 ) &#123;</span></span><br><span class="line"><span class="comment">				this.lightDistance.visible = false;</span></span><br><span class="line"><span class="comment">			&#125; else &#123;</span></span><br><span class="line"><span class="comment">				this.lightDistance.scale.set( d, d, d );</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">			this.add( this.lightDistance );</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dispose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.geometry.dispose();</span><br><span class="line">            <span class="built_in">this</span>.material.dispose();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.color !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.material.color.set(<span class="built_in">this</span>.color);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.material.color.copy(<span class="built_in">this</span>.light.color);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">			const d = this.light.distance;</span></span><br><span class="line"><span class="comment">				if ( d === 0.0 ) &#123;</span></span><br><span class="line"><span class="comment">					this.lightDistance.visible = false;</span></span><br><span class="line"><span class="comment">				&#125; else &#123;</span></span><br><span class="line"><span class="comment">					this.lightDistance.visible = true;</span></span><br><span class="line"><span class="comment">				this.lightDistance.scale.set( d, d, d );</span></span><br><span class="line"><span class="comment">				&#125;</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vector$<span class="number">1</span> = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _color1 = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Color();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _color2 = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Color();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HemisphereLightHelper</span> <span class="keyword">extends</span> <span class="title">Object3D</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">light, size, color</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.light = light;</span><br><span class="line">            <span class="built_in">this</span>.light.updateMatrixWorld();</span><br><span class="line">            <span class="built_in">this</span>.matrix = light.matrixWorld;</span><br><span class="line">            <span class="built_in">this</span>.matrixAutoUpdate = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.color = color;</span><br><span class="line">            <span class="keyword">const</span> geometry = <span class="keyword">new</span> OctahedronGeometry(size);</span><br><span class="line">            geometry.rotateY(<span class="built_in">Math</span>.PI * <span class="number">0.5</span>);</span><br><span class="line">            <span class="built_in">this</span>.material = <span class="keyword">new</span> MeshBasicMaterial(&#123;</span><br><span class="line">                <span class="attr">wireframe</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">fog</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">toneMapped</span>: <span class="literal">false</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.color === <span class="literal">undefined</span>) <span class="built_in">this</span>.material.vertexColors = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">const</span> position = geometry.getAttribute(<span class="string">&#x27;position&#x27;</span>);</span><br><span class="line">            <span class="keyword">const</span> colors = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(position.count * <span class="number">3</span>);</span><br><span class="line">            geometry.setAttribute(<span class="string">&#x27;color&#x27;</span>, <span class="keyword">new</span> BufferAttribute(colors, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.add(<span class="keyword">new</span> Mesh(geometry, <span class="built_in">this</span>.material));</span><br><span class="line">            <span class="built_in">this</span>.update();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dispose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.children[<span class="number">0</span>].geometry.dispose();</span><br><span class="line">            <span class="built_in">this</span>.children[<span class="number">0</span>].material.dispose();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> mesh = <span class="built_in">this</span>.children[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.color !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.material.color.set(<span class="built_in">this</span>.color);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> colors = mesh.geometry.getAttribute(<span class="string">&#x27;color&#x27;</span>);</span><br><span class="line"></span><br><span class="line">                _color1.copy(<span class="built_in">this</span>.light.color);</span><br><span class="line"></span><br><span class="line">                _color2.copy(<span class="built_in">this</span>.light.groundColor);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = colors.count; i &lt; l; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> color = i &lt; l / <span class="number">2</span> ? _color1 : _color2;</span><br><span class="line">                    colors.setXYZ(i, color.r, color.g, color.b);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                colors.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mesh.lookAt(_vector$<span class="number">1.</span>setFromMatrixPosition(<span class="built_in">this</span>.light.matrixWorld).negate());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GridHelper</span> <span class="keyword">extends</span> <span class="title">LineSegments</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">size = <span class="number">10</span>, divisions = <span class="number">10</span>, color1 = <span class="number">0x444444</span>, color2 = <span class="number">0x888888</span></span>)</span> &#123;</span><br><span class="line">            color1 = <span class="keyword">new</span> Color(color1);</span><br><span class="line">            color2 = <span class="keyword">new</span> Color(color2);</span><br><span class="line">            <span class="keyword">const</span> center = divisions / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">const</span> step = size / divisions;</span><br><span class="line">            <span class="keyword">const</span> halfSize = size / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">const</span> vertices = [],</span><br><span class="line">                colors = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = -halfSize; i &lt;= divisions; i++, k += step) &#123;</span><br><span class="line">                vertices.push(-halfSize, <span class="number">0</span>, k, halfSize, <span class="number">0</span>, k);</span><br><span class="line">                vertices.push(k, <span class="number">0</span>, -halfSize, k, <span class="number">0</span>, halfSize);</span><br><span class="line">                <span class="keyword">const</span> color = i === center ? color1 : color2;</span><br><span class="line">                color.toArray(colors, j);</span><br><span class="line">                j += <span class="number">3</span>;</span><br><span class="line">                color.toArray(colors, j);</span><br><span class="line">                j += <span class="number">3</span>;</span><br><span class="line">                color.toArray(colors, j);</span><br><span class="line">                j += <span class="number">3</span>;</span><br><span class="line">                color.toArray(colors, j);</span><br><span class="line">                j += <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> geometry = <span class="keyword">new</span> BufferGeometry();</span><br><span class="line">            geometry.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(vertices, <span class="number">3</span>));</span><br><span class="line">            geometry.setAttribute(<span class="string">&#x27;color&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(colors, <span class="number">3</span>));</span><br><span class="line">            <span class="keyword">const</span> material = <span class="keyword">new</span> LineBasicMaterial(&#123;</span><br><span class="line">                <span class="attr">vertexColors</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">toneMapped</span>: <span class="literal">false</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">super</span>(geometry, material);</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;GridHelper&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PolarGridHelper</span> <span class="keyword">extends</span> <span class="title">LineSegments</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">radius = <span class="number">10</span>, radials = <span class="number">16</span>, circles = <span class="number">8</span>, divisions = <span class="number">64</span>, color1 = <span class="number">0x444444</span>, color2 = <span class="number">0x888888</span></span>)</span> &#123;</span><br><span class="line">            color1 = <span class="keyword">new</span> Color(color1);</span><br><span class="line">            color2 = <span class="keyword">new</span> Color(color2);</span><br><span class="line">            <span class="keyword">const</span> vertices = [];</span><br><span class="line">            <span class="keyword">const</span> colors = []; <span class="comment">// create the radials</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= radials; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> v = i / radials * (<span class="built_in">Math</span>.PI * <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">const</span> x = <span class="built_in">Math</span>.sin(v) * radius;</span><br><span class="line">                <span class="keyword">const</span> z = <span class="built_in">Math</span>.cos(v) * radius;</span><br><span class="line">                vertices.push(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                vertices.push(x, <span class="number">0</span>, z);</span><br><span class="line">                <span class="keyword">const</span> color = i &amp; <span class="number">1</span> ? color1 : color2;</span><br><span class="line">                colors.push(color.r, color.g, color.b);</span><br><span class="line">                colors.push(color.r, color.g, color.b);</span><br><span class="line">            &#125; <span class="comment">// create the circles</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= circles; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> color = i &amp; <span class="number">1</span> ? color1 : color2;</span><br><span class="line">                <span class="keyword">const</span> r = radius - radius / circles * i;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; divisions; j++) &#123;</span><br><span class="line">                    <span class="comment">// first vertex</span></span><br><span class="line">                    <span class="keyword">let</span> v = j / divisions * (<span class="built_in">Math</span>.PI * <span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">let</span> x = <span class="built_in">Math</span>.sin(v) * r;</span><br><span class="line">                    <span class="keyword">let</span> z = <span class="built_in">Math</span>.cos(v) * r;</span><br><span class="line">                    vertices.push(x, <span class="number">0</span>, z);</span><br><span class="line">                    colors.push(color.r, color.g, color.b); <span class="comment">// second vertex</span></span><br><span class="line"></span><br><span class="line">                    v = (j + <span class="number">1</span>) / divisions * (<span class="built_in">Math</span>.PI * <span class="number">2</span>);</span><br><span class="line">                    x = <span class="built_in">Math</span>.sin(v) * r;</span><br><span class="line">                    z = <span class="built_in">Math</span>.cos(v) * r;</span><br><span class="line">                    vertices.push(x, <span class="number">0</span>, z);</span><br><span class="line">                    colors.push(color.r, color.g, color.b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> geometry = <span class="keyword">new</span> BufferGeometry();</span><br><span class="line">            geometry.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(vertices, <span class="number">3</span>));</span><br><span class="line">            geometry.setAttribute(<span class="string">&#x27;color&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(colors, <span class="number">3</span>));</span><br><span class="line">            <span class="keyword">const</span> material = <span class="keyword">new</span> LineBasicMaterial(&#123;</span><br><span class="line">                <span class="attr">vertexColors</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">toneMapped</span>: <span class="literal">false</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">super</span>(geometry, material);</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;PolarGridHelper&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _v1 = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _v2 = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _v3 = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DirectionalLightHelper</span> <span class="keyword">extends</span> <span class="title">Object3D</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">light, size, color</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.light = light;</span><br><span class="line">            <span class="built_in">this</span>.light.updateMatrixWorld();</span><br><span class="line">            <span class="built_in">this</span>.matrix = light.matrixWorld;</span><br><span class="line">            <span class="built_in">this</span>.matrixAutoUpdate = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.color = color;</span><br><span class="line">            <span class="keyword">if</span> (size === <span class="literal">undefined</span>) size = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">let</span> geometry = <span class="keyword">new</span> BufferGeometry();</span><br><span class="line">            geometry.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute([-size, size, <span class="number">0</span>, size, size, <span class="number">0</span>, size, -size, <span class="number">0</span>, -size, -size, <span class="number">0</span>, -size, size, <span class="number">0</span>], <span class="number">3</span>));</span><br><span class="line">            <span class="keyword">const</span> material = <span class="keyword">new</span> LineBasicMaterial(&#123;</span><br><span class="line">                <span class="attr">fog</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">toneMapped</span>: <span class="literal">false</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">this</span>.lightPlane = <span class="keyword">new</span> Line(geometry, material);</span><br><span class="line">            <span class="built_in">this</span>.add(<span class="built_in">this</span>.lightPlane);</span><br><span class="line">            geometry = <span class="keyword">new</span> BufferGeometry();</span><br><span class="line">            geometry.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">this</span>.targetLine = <span class="keyword">new</span> Line(geometry, material);</span><br><span class="line">            <span class="built_in">this</span>.add(<span class="built_in">this</span>.targetLine);</span><br><span class="line">            <span class="built_in">this</span>.update();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dispose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.lightPlane.geometry.dispose();</span><br><span class="line">            <span class="built_in">this</span>.lightPlane.material.dispose();</span><br><span class="line">            <span class="built_in">this</span>.targetLine.geometry.dispose();</span><br><span class="line">            <span class="built_in">this</span>.targetLine.material.dispose();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            _v1.setFromMatrixPosition(<span class="built_in">this</span>.light.matrixWorld);</span><br><span class="line"></span><br><span class="line">            _v2.setFromMatrixPosition(<span class="built_in">this</span>.light.target.matrixWorld);</span><br><span class="line"></span><br><span class="line">            _v3.subVectors(_v2, _v1);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.lightPlane.lookAt(_v2);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.color !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.lightPlane.material.color.set(<span class="built_in">this</span>.color);</span><br><span class="line">                <span class="built_in">this</span>.targetLine.material.color.set(<span class="built_in">this</span>.color);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.lightPlane.material.color.copy(<span class="built_in">this</span>.light.color);</span><br><span class="line">                <span class="built_in">this</span>.targetLine.material.color.copy(<span class="built_in">this</span>.light.color);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.targetLine.lookAt(_v2);</span><br><span class="line">            <span class="built_in">this</span>.targetLine.scale.z = _v3.length();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _vector = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _camera = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Camera();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *	- shows frustum, line of sight and up of the camera</span></span><br><span class="line"><span class="comment">     *	- suitable for fast updates</span></span><br><span class="line"><span class="comment">     * 	- based on frustum visualization in lightgl.js shadowmap example</span></span><br><span class="line"><span class="comment">     *		https://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CameraHelper</span> <span class="keyword">extends</span> <span class="title">LineSegments</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">camera</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> geometry = <span class="keyword">new</span> BufferGeometry();</span><br><span class="line">            <span class="keyword">const</span> material = <span class="keyword">new</span> LineBasicMaterial(&#123;</span><br><span class="line">                <span class="attr">color</span>: <span class="number">0xffffff</span>,</span><br><span class="line">                <span class="attr">vertexColors</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">toneMapped</span>: <span class="literal">false</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">const</span> vertices = [];</span><br><span class="line">            <span class="keyword">const</span> colors = [];</span><br><span class="line">            <span class="keyword">const</span> pointMap = &#123;&#125;; <span class="comment">// colors</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> colorFrustum = <span class="keyword">new</span> Color(<span class="number">0xffaa00</span>);</span><br><span class="line">            <span class="keyword">const</span> colorCone = <span class="keyword">new</span> Color(<span class="number">0xff0000</span>);</span><br><span class="line">            <span class="keyword">const</span> colorUp = <span class="keyword">new</span> Color(<span class="number">0x00aaff</span>);</span><br><span class="line">            <span class="keyword">const</span> colorTarget = <span class="keyword">new</span> Color(<span class="number">0xffffff</span>);</span><br><span class="line">            <span class="keyword">const</span> colorCross = <span class="keyword">new</span> Color(<span class="number">0x333333</span>); <span class="comment">// near</span></span><br><span class="line"></span><br><span class="line">            addLine(<span class="string">&#x27;n1&#x27;</span>, <span class="string">&#x27;n2&#x27;</span>, colorFrustum);</span><br><span class="line">            addLine(<span class="string">&#x27;n2&#x27;</span>, <span class="string">&#x27;n4&#x27;</span>, colorFrustum);</span><br><span class="line">            addLine(<span class="string">&#x27;n4&#x27;</span>, <span class="string">&#x27;n3&#x27;</span>, colorFrustum);</span><br><span class="line">            addLine(<span class="string">&#x27;n3&#x27;</span>, <span class="string">&#x27;n1&#x27;</span>, colorFrustum); <span class="comment">// far</span></span><br><span class="line"></span><br><span class="line">            addLine(<span class="string">&#x27;f1&#x27;</span>, <span class="string">&#x27;f2&#x27;</span>, colorFrustum);</span><br><span class="line">            addLine(<span class="string">&#x27;f2&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>, colorFrustum);</span><br><span class="line">            addLine(<span class="string">&#x27;f4&#x27;</span>, <span class="string">&#x27;f3&#x27;</span>, colorFrustum);</span><br><span class="line">            addLine(<span class="string">&#x27;f3&#x27;</span>, <span class="string">&#x27;f1&#x27;</span>, colorFrustum); <span class="comment">// sides</span></span><br><span class="line"></span><br><span class="line">            addLine(<span class="string">&#x27;n1&#x27;</span>, <span class="string">&#x27;f1&#x27;</span>, colorFrustum);</span><br><span class="line">            addLine(<span class="string">&#x27;n2&#x27;</span>, <span class="string">&#x27;f2&#x27;</span>, colorFrustum);</span><br><span class="line">            addLine(<span class="string">&#x27;n3&#x27;</span>, <span class="string">&#x27;f3&#x27;</span>, colorFrustum);</span><br><span class="line">            addLine(<span class="string">&#x27;n4&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>, colorFrustum); <span class="comment">// cone</span></span><br><span class="line"></span><br><span class="line">            addLine(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;n1&#x27;</span>, colorCone);</span><br><span class="line">            addLine(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;n2&#x27;</span>, colorCone);</span><br><span class="line">            addLine(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;n3&#x27;</span>, colorCone);</span><br><span class="line">            addLine(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;n4&#x27;</span>, colorCone); <span class="comment">// up</span></span><br><span class="line"></span><br><span class="line">            addLine(<span class="string">&#x27;u1&#x27;</span>, <span class="string">&#x27;u2&#x27;</span>, colorUp);</span><br><span class="line">            addLine(<span class="string">&#x27;u2&#x27;</span>, <span class="string">&#x27;u3&#x27;</span>, colorUp);</span><br><span class="line">            addLine(<span class="string">&#x27;u3&#x27;</span>, <span class="string">&#x27;u1&#x27;</span>, colorUp); <span class="comment">// target</span></span><br><span class="line"></span><br><span class="line">            addLine(<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, colorTarget);</span><br><span class="line">            addLine(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, colorCross); <span class="comment">// cross</span></span><br><span class="line"></span><br><span class="line">            addLine(<span class="string">&#x27;cn1&#x27;</span>, <span class="string">&#x27;cn2&#x27;</span>, colorCross);</span><br><span class="line">            addLine(<span class="string">&#x27;cn3&#x27;</span>, <span class="string">&#x27;cn4&#x27;</span>, colorCross);</span><br><span class="line">            addLine(<span class="string">&#x27;cf1&#x27;</span>, <span class="string">&#x27;cf2&#x27;</span>, colorCross);</span><br><span class="line">            addLine(<span class="string">&#x27;cf3&#x27;</span>, <span class="string">&#x27;cf4&#x27;</span>, colorCross);</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">addLine</span>(<span class="params">a, b, color</span>) </span>&#123;</span><br><span class="line">                addPoint(a, color);</span><br><span class="line">                addPoint(b, color);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">addPoint</span>(<span class="params">id, color</span>) </span>&#123;</span><br><span class="line">                vertices.push(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                colors.push(color.r, color.g, color.b);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pointMap[id] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    pointMap[id] = [];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                pointMap[id].push(vertices.length / <span class="number">3</span> - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            geometry.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(vertices, <span class="number">3</span>));</span><br><span class="line">            geometry.setAttribute(<span class="string">&#x27;color&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(colors, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">super</span>(geometry, material);</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;CameraHelper&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.camera = camera;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.camera.updateProjectionMatrix) <span class="built_in">this</span>.camera.updateProjectionMatrix();</span><br><span class="line">            <span class="built_in">this</span>.matrix = camera.matrixWorld;</span><br><span class="line">            <span class="built_in">this</span>.matrixAutoUpdate = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.pointMap = pointMap;</span><br><span class="line">            <span class="built_in">this</span>.update();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> geometry = <span class="built_in">this</span>.geometry;</span><br><span class="line">            <span class="keyword">const</span> pointMap = <span class="built_in">this</span>.pointMap;</span><br><span class="line">            <span class="keyword">const</span> w = <span class="number">1</span>,</span><br><span class="line">                h = <span class="number">1</span>; <span class="comment">// we need just camera projection matrix inverse</span></span><br><span class="line">            <span class="comment">// world matrix must be identity</span></span><br><span class="line"></span><br><span class="line">            _camera.projectionMatrixInverse.copy(<span class="built_in">this</span>.camera.projectionMatrixInverse); <span class="comment">// center / target</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            setPoint(<span class="string">&#x27;c&#x27;</span>, pointMap, geometry, _camera, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">            setPoint(<span class="string">&#x27;t&#x27;</span>, pointMap, geometry, _camera, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// near</span></span><br><span class="line"></span><br><span class="line">            setPoint(<span class="string">&#x27;n1&#x27;</span>, pointMap, geometry, _camera, -w, -h, -<span class="number">1</span>);</span><br><span class="line">            setPoint(<span class="string">&#x27;n2&#x27;</span>, pointMap, geometry, _camera, w, -h, -<span class="number">1</span>);</span><br><span class="line">            setPoint(<span class="string">&#x27;n3&#x27;</span>, pointMap, geometry, _camera, -w, h, -<span class="number">1</span>);</span><br><span class="line">            setPoint(<span class="string">&#x27;n4&#x27;</span>, pointMap, geometry, _camera, w, h, -<span class="number">1</span>); <span class="comment">// far</span></span><br><span class="line"></span><br><span class="line">            setPoint(<span class="string">&#x27;f1&#x27;</span>, pointMap, geometry, _camera, -w, -h, <span class="number">1</span>);</span><br><span class="line">            setPoint(<span class="string">&#x27;f2&#x27;</span>, pointMap, geometry, _camera, w, -h, <span class="number">1</span>);</span><br><span class="line">            setPoint(<span class="string">&#x27;f3&#x27;</span>, pointMap, geometry, _camera, -w, h, <span class="number">1</span>);</span><br><span class="line">            setPoint(<span class="string">&#x27;f4&#x27;</span>, pointMap, geometry, _camera, w, h, <span class="number">1</span>); <span class="comment">// up</span></span><br><span class="line"></span><br><span class="line">            setPoint(<span class="string">&#x27;u1&#x27;</span>, pointMap, geometry, _camera, w * <span class="number">0.7</span>, h * <span class="number">1.1</span>, -<span class="number">1</span>);</span><br><span class="line">            setPoint(<span class="string">&#x27;u2&#x27;</span>, pointMap, geometry, _camera, -w * <span class="number">0.7</span>, h * <span class="number">1.1</span>, -<span class="number">1</span>);</span><br><span class="line">            setPoint(<span class="string">&#x27;u3&#x27;</span>, pointMap, geometry, _camera, <span class="number">0</span>, h * <span class="number">2</span>, -<span class="number">1</span>); <span class="comment">// cross</span></span><br><span class="line"></span><br><span class="line">            setPoint(<span class="string">&#x27;cf1&#x27;</span>, pointMap, geometry, _camera, -w, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            setPoint(<span class="string">&#x27;cf2&#x27;</span>, pointMap, geometry, _camera, w, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            setPoint(<span class="string">&#x27;cf3&#x27;</span>, pointMap, geometry, _camera, <span class="number">0</span>, -h, <span class="number">1</span>);</span><br><span class="line">            setPoint(<span class="string">&#x27;cf4&#x27;</span>, pointMap, geometry, _camera, <span class="number">0</span>, h, <span class="number">1</span>);</span><br><span class="line">            setPoint(<span class="string">&#x27;cn1&#x27;</span>, pointMap, geometry, _camera, -w, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">            setPoint(<span class="string">&#x27;cn2&#x27;</span>, pointMap, geometry, _camera, w, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">            setPoint(<span class="string">&#x27;cn3&#x27;</span>, pointMap, geometry, _camera, <span class="number">0</span>, -h, -<span class="number">1</span>);</span><br><span class="line">            setPoint(<span class="string">&#x27;cn4&#x27;</span>, pointMap, geometry, _camera, <span class="number">0</span>, h, -<span class="number">1</span>);</span><br><span class="line">            geometry.getAttribute(<span class="string">&#x27;position&#x27;</span>).needsUpdate = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dispose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.geometry.dispose();</span><br><span class="line">            <span class="built_in">this</span>.material.dispose();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setPoint</span>(<span class="params">point, pointMap, geometry, camera, x, y, z</span>) </span>&#123;</span><br><span class="line">        _vector.set(x, y, z).unproject(camera);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> points = pointMap[point];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (points !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> position = geometry.getAttribute(<span class="string">&#x27;position&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = points.length; i &lt; l; i++) &#123;</span><br><span class="line">                position.setXYZ(points[i], _vector.x, _vector.y, _vector.z);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _box = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Box3();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BoxHelper</span> <span class="keyword">extends</span> <span class="title">LineSegments</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">object, color = <span class="number">0xffff00</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> indices = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>]);</span><br><span class="line">            <span class="keyword">const</span> positions = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(<span class="number">8</span> * <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">const</span> geometry = <span class="keyword">new</span> BufferGeometry();</span><br><span class="line">            geometry.setIndex(<span class="keyword">new</span> BufferAttribute(indices, <span class="number">1</span>));</span><br><span class="line">            geometry.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> BufferAttribute(positions, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">super</span>(geometry, <span class="keyword">new</span> LineBasicMaterial(&#123;</span><br><span class="line">                <span class="attr">color</span>: color,</span><br><span class="line">                <span class="attr">toneMapped</span>: <span class="literal">false</span></span><br><span class="line">            &#125;));</span><br><span class="line">            <span class="built_in">this</span>.object = object;</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;BoxHelper&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.matrixAutoUpdate = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.update();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">update</span>(<span class="params">object</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (object !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.BoxHelper: .update() has no longer arguments.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.object !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                _box.setFromObject(<span class="built_in">this</span>.object);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_box.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">const</span> min = _box.min;</span><br><span class="line">            <span class="keyword">const</span> max = _box.max;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">				5____4</span></span><br><span class="line"><span class="comment">			1/___0/|</span></span><br><span class="line"><span class="comment">			| 6__|_7</span></span><br><span class="line"><span class="comment">			2/___3/</span></span><br><span class="line"><span class="comment">				0: max.x, max.y, max.z</span></span><br><span class="line"><span class="comment">			1: min.x, max.y, max.z</span></span><br><span class="line"><span class="comment">			2: min.x, min.y, max.z</span></span><br><span class="line"><span class="comment">			3: max.x, min.y, max.z</span></span><br><span class="line"><span class="comment">			4: max.x, max.y, min.z</span></span><br><span class="line"><span class="comment">			5: min.x, max.y, min.z</span></span><br><span class="line"><span class="comment">			6: min.x, min.y, min.z</span></span><br><span class="line"><span class="comment">			7: max.x, min.y, min.z</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> position = <span class="built_in">this</span>.geometry.attributes.position;</span><br><span class="line">            <span class="keyword">const</span> array = position.array;</span><br><span class="line">            array[<span class="number">0</span>] = max.x;</span><br><span class="line">            array[<span class="number">1</span>] = max.y;</span><br><span class="line">            array[<span class="number">2</span>] = max.z;</span><br><span class="line">            array[<span class="number">3</span>] = min.x;</span><br><span class="line">            array[<span class="number">4</span>] = max.y;</span><br><span class="line">            array[<span class="number">5</span>] = max.z;</span><br><span class="line">            array[<span class="number">6</span>] = min.x;</span><br><span class="line">            array[<span class="number">7</span>] = min.y;</span><br><span class="line">            array[<span class="number">8</span>] = max.z;</span><br><span class="line">            array[<span class="number">9</span>] = max.x;</span><br><span class="line">            array[<span class="number">10</span>] = min.y;</span><br><span class="line">            array[<span class="number">11</span>] = max.z;</span><br><span class="line">            array[<span class="number">12</span>] = max.x;</span><br><span class="line">            array[<span class="number">13</span>] = max.y;</span><br><span class="line">            array[<span class="number">14</span>] = min.z;</span><br><span class="line">            array[<span class="number">15</span>] = min.x;</span><br><span class="line">            array[<span class="number">16</span>] = max.y;</span><br><span class="line">            array[<span class="number">17</span>] = min.z;</span><br><span class="line">            array[<span class="number">18</span>] = min.x;</span><br><span class="line">            array[<span class="number">19</span>] = min.y;</span><br><span class="line">            array[<span class="number">20</span>] = min.z;</span><br><span class="line">            array[<span class="number">21</span>] = max.x;</span><br><span class="line">            array[<span class="number">22</span>] = min.y;</span><br><span class="line">            array[<span class="number">23</span>] = min.z;</span><br><span class="line">            position.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.geometry.computeBoundingSphere();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setFromObject</span>(<span class="params">object</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.object = object;</span><br><span class="line">            <span class="built_in">this</span>.update();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            LineSegments.prototype.copy.call(<span class="built_in">this</span>, source);</span><br><span class="line">            <span class="built_in">this</span>.object = source.object;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Box3Helper</span> <span class="keyword">extends</span> <span class="title">LineSegments</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">box, color = <span class="number">0xffff00</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> indices = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>]);</span><br><span class="line">            <span class="keyword">const</span> positions = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">const</span> geometry = <span class="keyword">new</span> BufferGeometry();</span><br><span class="line">            geometry.setIndex(<span class="keyword">new</span> BufferAttribute(indices, <span class="number">1</span>));</span><br><span class="line">            geometry.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(positions, <span class="number">3</span>));</span><br><span class="line">            <span class="built_in">super</span>(geometry, <span class="keyword">new</span> LineBasicMaterial(&#123;</span><br><span class="line">                <span class="attr">color</span>: color,</span><br><span class="line">                <span class="attr">toneMapped</span>: <span class="literal">false</span></span><br><span class="line">            &#125;));</span><br><span class="line">            <span class="built_in">this</span>.box = box;</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;Box3Helper&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.geometry.computeBoundingSphere();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">updateMatrixWorld</span>(<span class="params">force</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> box = <span class="built_in">this</span>.box;</span><br><span class="line">            <span class="keyword">if</span> (box.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">            box.getCenter(<span class="built_in">this</span>.position);</span><br><span class="line">            box.getSize(<span class="built_in">this</span>.scale);</span><br><span class="line">            <span class="built_in">this</span>.scale.multiplyScalar(<span class="number">0.5</span>);</span><br><span class="line">            <span class="built_in">super</span>.updateMatrixWorld(force);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PlaneHelper</span> <span class="keyword">extends</span> <span class="title">Line</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">plane, size = <span class="number">1</span>, hex = <span class="number">0xffff00</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> color = hex;</span><br><span class="line">            <span class="keyword">const</span> positions = [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">            <span class="keyword">const</span> geometry = <span class="keyword">new</span> BufferGeometry();</span><br><span class="line">            geometry.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(positions, <span class="number">3</span>));</span><br><span class="line">            geometry.computeBoundingSphere();</span><br><span class="line">            <span class="built_in">super</span>(geometry, <span class="keyword">new</span> LineBasicMaterial(&#123;</span><br><span class="line">                <span class="attr">color</span>: color,</span><br><span class="line">                <span class="attr">toneMapped</span>: <span class="literal">false</span></span><br><span class="line">            &#125;));</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;PlaneHelper&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.plane = plane;</span><br><span class="line">            <span class="built_in">this</span>.size = size;</span><br><span class="line">            <span class="keyword">const</span> positions2 = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">const</span> geometry2 = <span class="keyword">new</span> BufferGeometry();</span><br><span class="line">            geometry2.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(positions2, <span class="number">3</span>));</span><br><span class="line">            geometry2.computeBoundingSphere();</span><br><span class="line">            <span class="built_in">this</span>.add(<span class="keyword">new</span> Mesh(geometry2, <span class="keyword">new</span> MeshBasicMaterial(&#123;</span><br><span class="line">                <span class="attr">color</span>: color,</span><br><span class="line">                <span class="attr">opacity</span>: <span class="number">0.2</span>,</span><br><span class="line">                <span class="attr">transparent</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">depthWrite</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">toneMapped</span>: <span class="literal">false</span></span><br><span class="line">            &#125;)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">updateMatrixWorld</span>(<span class="params">force</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> scale = -<span class="built_in">this</span>.plane.constant;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(scale) &lt; <span class="number">1e-8</span>) scale = <span class="number">1e-8</span>; <span class="comment">// sign does not matter</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.scale.set(<span class="number">0.5</span> * <span class="built_in">this</span>.size, <span class="number">0.5</span> * <span class="built_in">this</span>.size, scale);</span><br><span class="line">            <span class="built_in">this</span>.children[<span class="number">0</span>].material.side = scale &lt; <span class="number">0</span> ? BackSide : FrontSide; <span class="comment">// renderer flips side when determinant &lt; 0; flipping not wanted here</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.lookAt(<span class="built_in">this</span>.plane.normal);</span><br><span class="line">            <span class="built_in">super</span>.updateMatrixWorld(force);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _axis = <span class="comment">/*@__PURE__*/</span><span class="keyword">new</span> Vector3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> _lineGeometry, _coneGeometry;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ArrowHelper</span> <span class="keyword">extends</span> <span class="title">Object3D</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dir is assumed to be normalized</span></span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">dir = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), origin = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), length = <span class="number">1</span>, color = <span class="number">0xffff00</span>, headLength = length * <span class="number">0.2</span>, headWidth = headLength * <span class="number">0.2</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;ArrowHelper&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_lineGeometry === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                _lineGeometry = <span class="keyword">new</span> BufferGeometry();</span><br><span class="line"></span><br><span class="line">                _lineGeometry.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">                _coneGeometry = <span class="keyword">new</span> CylinderGeometry(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                _coneGeometry.translate(<span class="number">0</span>, -<span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.position.copy(origin);</span><br><span class="line">            <span class="built_in">this</span>.line = <span class="keyword">new</span> Line(_lineGeometry, <span class="keyword">new</span> LineBasicMaterial(&#123;</span><br><span class="line">                <span class="attr">color</span>: color,</span><br><span class="line">                <span class="attr">toneMapped</span>: <span class="literal">false</span></span><br><span class="line">            &#125;));</span><br><span class="line">            <span class="built_in">this</span>.line.matrixAutoUpdate = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.add(<span class="built_in">this</span>.line);</span><br><span class="line">            <span class="built_in">this</span>.cone = <span class="keyword">new</span> Mesh(_coneGeometry, <span class="keyword">new</span> MeshBasicMaterial(&#123;</span><br><span class="line">                <span class="attr">color</span>: color,</span><br><span class="line">                <span class="attr">toneMapped</span>: <span class="literal">false</span></span><br><span class="line">            &#125;));</span><br><span class="line">            <span class="built_in">this</span>.cone.matrixAutoUpdate = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.add(<span class="built_in">this</span>.cone);</span><br><span class="line">            <span class="built_in">this</span>.setDirection(dir);</span><br><span class="line">            <span class="built_in">this</span>.setLength(length, headLength, headWidth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setDirection</span>(<span class="params">dir</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// dir is assumed to be normalized</span></span><br><span class="line">            <span class="keyword">if</span> (dir.y &gt; <span class="number">0.99999</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.quaternion.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dir.y &lt; -<span class="number">0.99999</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.quaternion.set(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _axis.set(dir.z, <span class="number">0</span>, -dir.x).normalize();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> radians = <span class="built_in">Math</span>.acos(dir.y);</span><br><span class="line">                <span class="built_in">this</span>.quaternion.setFromAxisAngle(_axis, radians);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setLength</span>(<span class="params">length, headLength = length * <span class="number">0.2</span>, headWidth = headLength * <span class="number">0.2</span></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.line.scale.set(<span class="number">1</span>, <span class="built_in">Math</span>.max(<span class="number">0.0001</span>, length - headLength), <span class="number">1</span>); <span class="comment">// see #17458</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.line.updateMatrix();</span><br><span class="line">            <span class="built_in">this</span>.cone.scale.set(headWidth, headLength, headWidth);</span><br><span class="line">            <span class="built_in">this</span>.cone.position.y = length;</span><br><span class="line">            <span class="built_in">this</span>.cone.updateMatrix();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setColor</span>(<span class="params">color</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.line.material.color.set(color);</span><br><span class="line">            <span class="built_in">this</span>.cone.material.color.set(color);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">copy</span>(<span class="params">source</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.copy(source, <span class="literal">false</span>);</span><br><span class="line">            <span class="built_in">this</span>.line.copy(source.line);</span><br><span class="line">            <span class="built_in">this</span>.cone.copy(source.cone);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AxesHelper</span> <span class="keyword">extends</span> <span class="title">LineSegments</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">size = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> vertices = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, size, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, size, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, size];</span><br><span class="line">            <span class="keyword">const</span> colors = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0.6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0.6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0.6</span>, <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">const</span> geometry = <span class="keyword">new</span> BufferGeometry();</span><br><span class="line">            geometry.setAttribute(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(vertices, <span class="number">3</span>));</span><br><span class="line">            geometry.setAttribute(<span class="string">&#x27;color&#x27;</span>, <span class="keyword">new</span> Float32BufferAttribute(colors, <span class="number">3</span>));</span><br><span class="line">            <span class="keyword">const</span> material = <span class="keyword">new</span> LineBasicMaterial(&#123;</span><br><span class="line">                <span class="attr">vertexColors</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">toneMapped</span>: <span class="literal">false</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">super</span>(geometry, material);</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;AxesHelper&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">setColors</span>(<span class="params">xAxisColor, yAxisColor, zAxisColor</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> color = <span class="keyword">new</span> Color();</span><br><span class="line">            <span class="keyword">const</span> array = <span class="built_in">this</span>.geometry.attributes.color.array;</span><br><span class="line">            color.set(xAxisColor);</span><br><span class="line">            color.toArray(array, <span class="number">0</span>);</span><br><span class="line">            color.toArray(array, <span class="number">3</span>);</span><br><span class="line">            color.set(yAxisColor);</span><br><span class="line">            color.toArray(array, <span class="number">6</span>);</span><br><span class="line">            color.toArray(array, <span class="number">9</span>);</span><br><span class="line">            color.set(zAxisColor);</span><br><span class="line">            color.toArray(array, <span class="number">12</span>);</span><br><span class="line">            color.toArray(array, <span class="number">15</span>);</span><br><span class="line">            <span class="built_in">this</span>.geometry.attributes.color.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">dispose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.geometry.dispose();</span><br><span class="line">            <span class="built_in">this</span>.material.dispose();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ShapePath</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.type = <span class="string">&#x27;ShapePath&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.color = <span class="keyword">new</span> Color();</span><br><span class="line">            <span class="built_in">this</span>.subPaths = [];</span><br><span class="line">            <span class="built_in">this</span>.currentPath = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">moveTo</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.currentPath = <span class="keyword">new</span> Path();</span><br><span class="line">            <span class="built_in">this</span>.subPaths.push(<span class="built_in">this</span>.currentPath);</span><br><span class="line">            <span class="built_in">this</span>.currentPath.moveTo(x, y);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">lineTo</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.currentPath.lineTo(x, y);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">quadraticCurveTo</span>(<span class="params">aCPx, aCPy, aX, aY</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">bezierCurveTo</span>(<span class="params">aCP1x, aCP1y, aCP2x, aCP2y, aX, aY</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">splineThru</span>(<span class="params">pts</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.currentPath.splineThru(pts);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">toShapes</span>(<span class="params">isCCW, noHoles</span>)</span> &#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">toShapesNoHoles</span>(<span class="params">inSubpaths</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> shapes = [];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = inSubpaths.length; i &lt; l; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> tmpPath = inSubpaths[i];</span><br><span class="line">                    <span class="keyword">const</span> tmpShape = <span class="keyword">new</span> Shape();</span><br><span class="line">                    tmpShape.curves = tmpPath.curves;</span><br><span class="line">                    shapes.push(tmpShape);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> shapes;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">isPointInsidePolygon</span>(<span class="params">inPt, inPolygon</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> polyLen = inPolygon.length; <span class="comment">// inPt on polygon contour =&gt; immediate success		or</span></span><br><span class="line">                <span class="comment">// toggling of inside/outside at every single! intersection point of an edge</span></span><br><span class="line">                <span class="comment">//	with the horizontal line through inPt, left of inPt</span></span><br><span class="line">                <span class="comment">//	not counting lowerY endpoints of edges and whole edges on that line</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> inside = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> p = polyLen - <span class="number">1</span>, q = <span class="number">0</span>; q &lt; polyLen; p = q++) &#123;</span><br><span class="line">                    <span class="keyword">let</span> edgeLowPt = inPolygon[p];</span><br><span class="line">                    <span class="keyword">let</span> edgeHighPt = inPolygon[q];</span><br><span class="line">                    <span class="keyword">let</span> edgeDx = edgeHighPt.x - edgeLowPt.x;</span><br><span class="line">                    <span class="keyword">let</span> edgeDy = edgeHighPt.y - edgeLowPt.y;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(edgeDy) &gt; <span class="built_in">Number</span>.EPSILON) &#123;</span><br><span class="line">                        <span class="comment">// not parallel</span></span><br><span class="line">                        <span class="keyword">if</span> (edgeDy &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                            edgeLowPt = inPolygon[q];</span><br><span class="line">                            edgeDx = -edgeDx;</span><br><span class="line">                            edgeHighPt = inPolygon[p];</span><br><span class="line">                            edgeDy = -edgeDy;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (inPt.y &lt; edgeLowPt.y || inPt.y &gt; edgeHighPt.y) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (inPt.y === edgeLowPt.y) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (inPt.x === edgeLowPt.x) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// inPt is on contour ?</span></span><br><span class="line">                            <span class="comment">// continue;				// no intersection or edgeLowPt =&gt; doesn&#x27;t count !!!</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">const</span> perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);</span><br><span class="line">                            <span class="keyword">if</span> (perpEdge === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// inPt is on contour ?</span></span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (perpEdge &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                            inside = !inside; <span class="comment">// true intersection left of inPt</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// parallel or collinear</span></span><br><span class="line">                        <span class="keyword">if</span> (inPt.y !== edgeLowPt.y) <span class="keyword">continue</span>; <span class="comment">// parallel</span></span><br><span class="line">                        <span class="comment">// edge lies on the same horizontal line as inPt</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (edgeHighPt.x &lt;= inPt.x &amp;&amp; inPt.x &lt;= edgeLowPt.x || edgeLowPt.x &lt;= inPt.x &amp;&amp; inPt.x &lt;= edgeHighPt.x) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// inPt: Point on contour !</span></span><br><span class="line">                        <span class="comment">// continue;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> inside;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> isClockWise = ShapeUtils.isClockWise;</span><br><span class="line">            <span class="keyword">const</span> subPaths = <span class="built_in">this</span>.subPaths;</span><br><span class="line">            <span class="keyword">if</span> (subPaths.length === <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">            <span class="keyword">if</span> (noHoles === <span class="literal">true</span>) <span class="keyword">return</span> toShapesNoHoles(subPaths);</span><br><span class="line">            <span class="keyword">let</span> solid, tmpPath, tmpShape;</span><br><span class="line">            <span class="keyword">const</span> shapes = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (subPaths.length === <span class="number">1</span>) &#123;</span><br><span class="line">                tmpPath = subPaths[<span class="number">0</span>];</span><br><span class="line">                tmpShape = <span class="keyword">new</span> Shape();</span><br><span class="line">                tmpShape.curves = tmpPath.curves;</span><br><span class="line">                shapes.push(tmpShape);</span><br><span class="line">                <span class="keyword">return</span> shapes;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> holesFirst = !isClockWise(subPaths[<span class="number">0</span>].getPoints());</span><br><span class="line">            holesFirst = isCCW ? !holesFirst : holesFirst; <span class="comment">// console.log(&quot;Holes first&quot;, holesFirst);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> betterShapeHoles = [];</span><br><span class="line">            <span class="keyword">const</span> newShapes = [];</span><br><span class="line">            <span class="keyword">let</span> newShapeHoles = [];</span><br><span class="line">            <span class="keyword">let</span> mainIdx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> tmpPoints;</span><br><span class="line">            newShapes[mainIdx] = <span class="literal">undefined</span>;</span><br><span class="line">            newShapeHoles[mainIdx] = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subPaths.length; i &lt; l; i++) &#123;</span><br><span class="line">                tmpPath = subPaths[i];</span><br><span class="line">                tmpPoints = tmpPath.getPoints();</span><br><span class="line">                solid = isClockWise(tmpPoints);</span><br><span class="line">                solid = isCCW ? !solid : solid;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (solid) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!holesFirst &amp;&amp; newShapes[mainIdx]) mainIdx++;</span><br><span class="line">                    newShapes[mainIdx] = &#123;</span><br><span class="line">                        <span class="attr">s</span>: <span class="keyword">new</span> Shape(),</span><br><span class="line">                        <span class="attr">p</span>: tmpPoints</span><br><span class="line">                    &#125;;</span><br><span class="line">                    newShapes[mainIdx].s.curves = tmpPath.curves;</span><br><span class="line">                    <span class="keyword">if</span> (holesFirst) mainIdx++;</span><br><span class="line">                    newShapeHoles[mainIdx] = []; <span class="comment">//console.log(&#x27;cw&#x27;, i);</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    newShapeHoles[mainIdx].push(&#123;</span><br><span class="line">                        <span class="attr">h</span>: tmpPath,</span><br><span class="line">                        <span class="attr">p</span>: tmpPoints[<span class="number">0</span>]</span><br><span class="line">                    &#125;); <span class="comment">//console.log(&#x27;ccw&#x27;, i);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// only Holes? -&gt; probably all Shapes with wrong orientation</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!newShapes[<span class="number">0</span>]) <span class="keyword">return</span> toShapesNoHoles(subPaths);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newShapes.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> ambiguous = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">let</span> toChange = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> sIdx = <span class="number">0</span>, sLen = newShapes.length; sIdx &lt; sLen; sIdx++) &#123;</span><br><span class="line">                    betterShapeHoles[sIdx] = [];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> sIdx = <span class="number">0</span>, sLen = newShapes.length; sIdx &lt; sLen; sIdx++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> sho = newShapeHoles[sIdx];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> hIdx = <span class="number">0</span>; hIdx &lt; sho.length; hIdx++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> ho = sho[hIdx];</span><br><span class="line">                        <span class="keyword">let</span> hole_unassigned = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> s2Idx = <span class="number">0</span>; s2Idx &lt; newShapes.length; s2Idx++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (sIdx !== s2Idx) toChange++;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (hole_unassigned) &#123;</span><br><span class="line">                                    hole_unassigned = <span class="literal">false</span>;</span><br><span class="line">                                    betterShapeHoles[s2Idx].push(ho);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    ambiguous = <span class="literal">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (hole_unassigned) &#123;</span><br><span class="line">                            betterShapeHoles[sIdx].push(ho);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (toChange &gt; <span class="number">0</span> &amp;&amp; ambiguous === <span class="literal">false</span>) &#123;</span><br><span class="line">                    newShapeHoles = betterShapeHoles;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> tmpHoles;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = newShapes.length; i &lt; il; i++) &#123;</span><br><span class="line">                tmpShape = newShapes[i].s;</span><br><span class="line">                shapes.push(tmpShape);</span><br><span class="line">                tmpHoles = newShapeHoles[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, jl = tmpHoles.length; j &lt; jl; j++) &#123;</span><br><span class="line">                    tmpShape.holes.push(tmpHoles[j].h);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">//console.log(&quot;shape&quot;, shapes);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> shapes;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DataUtils</span> </span>&#123;</span><br><span class="line">        <span class="comment">// float32 to float16</span></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">toHalfFloat</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(val) &gt; <span class="number">65504</span>) <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.DataUtils.toHalfFloat(): Value out of range.&#x27;</span>);</span><br><span class="line">            val = clamp(val, -<span class="number">65504</span>, <span class="number">65504</span>);</span><br><span class="line">            _floatView[<span class="number">0</span>] = val;</span><br><span class="line">            <span class="keyword">const</span> f = _uint32View[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">const</span> e = f &gt;&gt; <span class="number">23</span> &amp; <span class="number">0x1ff</span>;</span><br><span class="line">            <span class="keyword">return</span> _baseTable[e] + ((f &amp; <span class="number">0x007fffff</span>) &gt;&gt; _shiftTable[e]);</span><br><span class="line">        &#125; <span class="comment">// float16 to float32</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="title">fromHalfFloat</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> m = val &gt;&gt; <span class="number">10</span>;</span><br><span class="line">            _uint32View[<span class="number">0</span>] = _mantissaTable[_offsetTable[m] + (val &amp; <span class="number">0x3ff</span>)] + _exponentTable[m];</span><br><span class="line">            <span class="keyword">return</span> _floatView[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">// float32 to float16 helpers</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _floatView = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(_buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _uint32View = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(_buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _baseTable = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(<span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _shiftTable = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(<span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> e = i - <span class="number">127</span>; <span class="comment">// very small number (0, -0)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e &lt; -<span class="number">27</span>) &#123;</span><br><span class="line">            _baseTable[i] = <span class="number">0x0000</span>;</span><br><span class="line">            _baseTable[i | <span class="number">0x100</span>] = <span class="number">0x8000</span>;</span><br><span class="line">            _shiftTable[i] = <span class="number">24</span>;</span><br><span class="line">            _shiftTable[i | <span class="number">0x100</span>] = <span class="number">24</span>; <span class="comment">// small number (denorm)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e &lt; -<span class="number">14</span>) &#123;</span><br><span class="line">            _baseTable[i] = <span class="number">0x0400</span> &gt;&gt; -e - <span class="number">14</span>;</span><br><span class="line">            _baseTable[i | <span class="number">0x100</span>] = <span class="number">0x0400</span> &gt;&gt; -e - <span class="number">14</span> | <span class="number">0x8000</span>;</span><br><span class="line">            _shiftTable[i] = -e - <span class="number">1</span>;</span><br><span class="line">            _shiftTable[i | <span class="number">0x100</span>] = -e - <span class="number">1</span>; <span class="comment">// normal number</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e &lt;= <span class="number">15</span>) &#123;</span><br><span class="line">            _baseTable[i] = e + <span class="number">15</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line">            _baseTable[i | <span class="number">0x100</span>] = e + <span class="number">15</span> &lt;&lt; <span class="number">10</span> | <span class="number">0x8000</span>;</span><br><span class="line">            _shiftTable[i] = <span class="number">13</span>;</span><br><span class="line">            _shiftTable[i | <span class="number">0x100</span>] = <span class="number">13</span>; <span class="comment">// large number (Infinity, -Infinity)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e &lt; <span class="number">128</span>) &#123;</span><br><span class="line">            _baseTable[i] = <span class="number">0x7c00</span>;</span><br><span class="line">            _baseTable[i | <span class="number">0x100</span>] = <span class="number">0xfc00</span>;</span><br><span class="line">            _shiftTable[i] = <span class="number">24</span>;</span><br><span class="line">            _shiftTable[i | <span class="number">0x100</span>] = <span class="number">24</span>; <span class="comment">// stay (NaN, Infinity, -Infinity)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _baseTable[i] = <span class="number">0x7c00</span>;</span><br><span class="line">            _baseTable[i | <span class="number">0x100</span>] = <span class="number">0xfc00</span>;</span><br><span class="line">            _shiftTable[i] = <span class="number">13</span>;</span><br><span class="line">            _shiftTable[i | <span class="number">0x100</span>] = <span class="number">13</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// float16 to float32 helpers</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _mantissaTable = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(<span class="number">2048</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _exponentTable = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _offsetTable = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">1024</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">let</span> m = i &lt;&lt; <span class="number">13</span>; <span class="comment">// zero pad mantissa bits</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> e = <span class="number">0</span>; <span class="comment">// zero exponent</span></span><br><span class="line">        <span class="comment">// normalized</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((m &amp; <span class="number">0x00800000</span>) === <span class="number">0</span>) &#123;</span><br><span class="line">            m &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            e -= <span class="number">0x00800000</span>; <span class="comment">// decrement exponent</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m &amp;= ~<span class="number">0x00800000</span>; <span class="comment">// clear leading 1 bit</span></span><br><span class="line"></span><br><span class="line">        e += <span class="number">0x38800000</span>; <span class="comment">// adjust bias</span></span><br><span class="line"></span><br><span class="line">        _mantissaTable[i] = m | e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1024</span>; i &lt; <span class="number">2048</span>; ++i) &#123;</span><br><span class="line">        _mantissaTable[i] = <span class="number">0x38000000</span> + (i - <span class="number">1024</span> &lt;&lt; <span class="number">13</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">31</span>; ++i) &#123;</span><br><span class="line">        _exponentTable[i] = i &lt;&lt; <span class="number">23</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _exponentTable[<span class="number">31</span>] = <span class="number">0x47800000</span>;</span><br><span class="line">    _exponentTable[<span class="number">32</span>] = <span class="number">0x80000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">33</span>; i &lt; <span class="number">63</span>; ++i) &#123;</span><br><span class="line">        _exponentTable[i] = <span class="number">0x80000000</span> + (i - <span class="number">32</span> &lt;&lt; <span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _exponentTable[<span class="number">63</span>] = <span class="number">0xc7800000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">64</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i !== <span class="number">32</span>) &#123;</span><br><span class="line">            _offsetTable[i] = <span class="number">1024</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> LineStrip = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> LinePieces = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> NoColors = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> FaceColors = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> VertexColors = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">MeshFaceMaterial</span>(<span class="params">materials</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.MeshFaceMaterial has been removed. Use an Array instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> materials;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">MultiMaterial</span>(<span class="params">materials = []</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.MultiMaterial has been removed. Use an Array instead.&#x27;</span>);</span><br><span class="line">        materials.isMultiMaterial = <span class="literal">true</span>;</span><br><span class="line">        materials.materials = materials;</span><br><span class="line"></span><br><span class="line">        materials.clone = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> materials.slice();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> materials;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PointCloud</span> <span class="keyword">extends</span> <span class="title">Points</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">geometry, material</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.PointCloud has been renamed to THREE.Points.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(geometry, material);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Particle</span> <span class="keyword">extends</span> <span class="title">Sprite</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">material</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Particle has been renamed to THREE.Sprite.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(material);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ParticleSystem</span> <span class="keyword">extends</span> <span class="title">Points</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">geometry, material</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.ParticleSystem has been renamed to THREE.Points.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(geometry, material);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PointCloudMaterial</span> <span class="keyword">extends</span> <span class="title">PointsMaterial</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameters</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(parameters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ParticleBasicMaterial</span> <span class="keyword">extends</span> <span class="title">PointsMaterial</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameters</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(parameters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ParticleSystemMaterial</span> <span class="keyword">extends</span> <span class="title">PointsMaterial</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">parameters</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(parameters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> <span class="keyword">extends</span> <span class="title">Vector3</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">x, y, z</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Vertex has been removed. Use THREE.Vector3 instead.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(x, y, z);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DynamicBufferAttribute</span> <span class="keyword">extends</span> <span class="title">BufferAttribute</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array, itemSize</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(array, itemSize);</span><br><span class="line">            <span class="built_in">this</span>.setUsage(DynamicDrawUsage);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Int8Attribute</span> <span class="keyword">extends</span> <span class="title">Int8BufferAttribute</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array, itemSize</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(array, itemSize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Uint8Attribute</span> <span class="keyword">extends</span> <span class="title">Uint8BufferAttribute</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array, itemSize</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(array, itemSize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Uint8ClampedAttribute</span> <span class="keyword">extends</span> <span class="title">Uint8ClampedBufferAttribute</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array, itemSize</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(array, itemSize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Int16Attribute</span> <span class="keyword">extends</span> <span class="title">Int16BufferAttribute</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array, itemSize</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(array, itemSize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Uint16Attribute</span> <span class="keyword">extends</span> <span class="title">Uint16BufferAttribute</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array, itemSize</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(array, itemSize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Int32Attribute</span> <span class="keyword">extends</span> <span class="title">Int32BufferAttribute</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array, itemSize</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(array, itemSize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Uint32Attribute</span> <span class="keyword">extends</span> <span class="title">Uint32BufferAttribute</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array, itemSize</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(array, itemSize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Float32Attribute</span> <span class="keyword">extends</span> <span class="title">Float32BufferAttribute</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array, itemSize</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(array, itemSize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Float64Attribute</span> <span class="keyword">extends</span> <span class="title">Float64BufferAttribute</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">array, itemSize</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(array, itemSize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    Curve.create = <span class="function"><span class="keyword">function</span> (<span class="params">construct, getPoint</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;THREE.Curve.create() has been deprecated&#x27;</span>);</span><br><span class="line">        construct.prototype = <span class="built_in">Object</span>.create(Curve.prototype);</span><br><span class="line">        construct.prototype.constructor = construct;</span><br><span class="line">        construct.prototype.getPoint = getPoint;</span><br><span class="line">        <span class="keyword">return</span> construct;</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Path.prototype.fromPoints = <span class="function"><span class="keyword">function</span> (<span class="params">points</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Path: .fromPoints() has been renamed to .setFromPoints().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.setFromPoints(points);</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AxisHelper</span> <span class="keyword">extends</span> <span class="title">AxesHelper</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">size</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.AxisHelper has been renamed to THREE.AxesHelper.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BoundingBoxHelper</span> <span class="keyword">extends</span> <span class="title">BoxHelper</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">object, color</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(object, color);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EdgesHelper</span> <span class="keyword">extends</span> <span class="title">LineSegments</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">object, hex</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(<span class="keyword">new</span> EdgesGeometry(object.geometry), <span class="keyword">new</span> LineBasicMaterial(&#123;</span><br><span class="line">                <span class="attr">color</span>: hex !== <span class="literal">undefined</span> ? hex : <span class="number">0xffffff</span></span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GridHelper.prototype.setColors = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    SkeletonHelper.prototype.update = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.SkeletonHelper: update() no longer needs to be called.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WireframeHelper</span> <span class="keyword">extends</span> <span class="title">LineSegments</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">object, hex</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(<span class="keyword">new</span> WireframeGeometry(object.geometry), <span class="keyword">new</span> LineBasicMaterial(&#123;</span><br><span class="line">                <span class="attr">color</span>: hex !== <span class="literal">undefined</span> ? hex : <span class="number">0xffffff</span></span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    Loader.prototype.extractUrlBase = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> LoaderUtils.extractUrlBase(url);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Loader.Handlers = &#123;</span><br><span class="line">        <span class="attr">add</span>: <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">            /* <span class="title">regex</span>, <span class="title">loader</span> */</span></span><br><span class="line"><span class="function">            (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.&#x27;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">            /* <span class="title">file</span> */</span></span><br><span class="line"><span class="function">            (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">XHRLoader</span> <span class="keyword">extends</span> <span class="title">FileLoader</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">manager</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.XHRLoader has been renamed to THREE.FileLoader.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(manager);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BinaryTextureLoader</span> <span class="keyword">extends</span> <span class="title">DataTextureLoader</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">manager</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(manager);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    Box2.prototype.center = <span class="function"><span class="keyword">function</span> (<span class="params">optionalTarget</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Box2: .center() has been renamed to .getCenter().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getCenter(optionalTarget);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Box2.prototype.empty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Box2: .empty() has been renamed to .isEmpty().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.isEmpty();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Box2.prototype.isIntersectionBox = <span class="function"><span class="keyword">function</span> (<span class="params">box</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.intersectsBox(box);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Box2.prototype.size = <span class="function"><span class="keyword">function</span> (<span class="params">optionalTarget</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Box2: .size() has been renamed to .getSize().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getSize(optionalTarget);</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Box3.prototype.center = <span class="function"><span class="keyword">function</span> (<span class="params">optionalTarget</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Box3: .center() has been renamed to .getCenter().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getCenter(optionalTarget);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Box3.prototype.empty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Box3: .empty() has been renamed to .isEmpty().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.isEmpty();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Box3.prototype.isIntersectionBox = <span class="function"><span class="keyword">function</span> (<span class="params">box</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.intersectsBox(box);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Box3.prototype.isIntersectionSphere = <span class="function"><span class="keyword">function</span> (<span class="params">sphere</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.intersectsSphere(sphere);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Box3.prototype.size = <span class="function"><span class="keyword">function</span> (<span class="params">optionalTarget</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Box3: .size() has been renamed to .getSize().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getSize(optionalTarget);</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Euler.prototype.toVector3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead&#x27;</span>);</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Sphere.prototype.empty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Sphere: .empty() has been renamed to .isEmpty().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.isEmpty();</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Frustum.prototype.setFromMatrix = <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.setFromProjectionMatrix(m);</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Line3.prototype.center = <span class="function"><span class="keyword">function</span> (<span class="params">optionalTarget</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Line3: .center() has been renamed to .getCenter().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getCenter(optionalTarget);</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Matrix3.prototype.flattenToArrayOffset = <span class="function"><span class="keyword">function</span> (<span class="params">array, offset</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.toArray(array, offset);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matrix3.prototype.multiplyVector3 = <span class="function"><span class="keyword">function</span> (<span class="params">vector</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> vector.applyMatrix3(<span class="built_in">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matrix3.prototype.multiplyVector3Array = <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">        /* <span class="title">a</span> */</span></span><br><span class="line"><span class="function">        (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Matrix3: .multiplyVector3Array() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matrix3.prototype.applyToBufferAttribute = <span class="function"><span class="keyword">function</span> (<span class="params">attribute</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> attribute.applyMatrix3(<span class="built_in">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matrix3.prototype.applyToVector3Array = <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">        /* <span class="title">array</span>, <span class="title">offset</span>, <span class="title">length</span> */</span></span><br><span class="line"><span class="function">        (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Matrix3: .applyToVector3Array() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matrix3.prototype.getInverse = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.copy(matrix).invert();</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Matrix4.prototype.extractPosition = <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.copyPosition(m);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matrix4.prototype.flattenToArrayOffset = <span class="function"><span class="keyword">function</span> (<span class="params">array, offset</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.toArray(array, offset);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matrix4.prototype.getPosition = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector3().setFromMatrixColumn(<span class="built_in">this</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matrix4.prototype.setRotationFromQuaternion = <span class="function"><span class="keyword">function</span> (<span class="params">q</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.makeRotationFromQuaternion(q);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matrix4.prototype.multiplyToArray = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Matrix4: .multiplyToArray() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matrix4.prototype.multiplyVector3 = <span class="function"><span class="keyword">function</span> (<span class="params">vector</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> vector.applyMatrix4(<span class="built_in">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matrix4.prototype.multiplyVector4 = <span class="function"><span class="keyword">function</span> (<span class="params">vector</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> vector.applyMatrix4(<span class="built_in">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matrix4.prototype.multiplyVector3Array = <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">        /* <span class="title">a</span> */</span></span><br><span class="line"><span class="function">        (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Matrix4: .multiplyVector3Array() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matrix4.prototype.rotateAxis = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.&#x27;</span>);</span><br><span class="line">        v.transformDirection(<span class="built_in">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matrix4.prototype.crossVector = <span class="function"><span class="keyword">function</span> (<span class="params">vector</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> vector.applyMatrix4(<span class="built_in">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matrix4.prototype.translate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Matrix4: .translate() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matrix4.prototype.rotateX = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Matrix4: .rotateX() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matrix4.prototype.rotateY = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Matrix4: .rotateY() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matrix4.prototype.rotateZ = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Matrix4: .rotateZ() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matrix4.prototype.rotateByAxis = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Matrix4: .rotateByAxis() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matrix4.prototype.applyToBufferAttribute = <span class="function"><span class="keyword">function</span> (<span class="params">attribute</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> attribute.applyMatrix4(<span class="built_in">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matrix4.prototype.applyToVector3Array = <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">        /* <span class="title">array</span>, <span class="title">offset</span>, <span class="title">length</span> */</span></span><br><span class="line"><span class="function">        (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Matrix4: .applyToVector3Array() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matrix4.prototype.makeFrustum = <span class="function"><span class="keyword">function</span> (<span class="params">left, right, bottom, top, near, far</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.makePerspective(left, right, top, bottom, near, far);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Matrix4.prototype.getInverse = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.copy(matrix).invert();</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Plane.prototype.isIntersectionLine = <span class="function"><span class="keyword">function</span> (<span class="params">line</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.intersectsLine(line);</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Quaternion.prototype.multiplyVector3 = <span class="function"><span class="keyword">function</span> (<span class="params">vector</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> vector.applyQuaternion(<span class="built_in">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Quaternion.prototype.inverse = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Quaternion: .inverse() has been renamed to invert().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.invert();</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Ray.prototype.isIntersectionBox = <span class="function"><span class="keyword">function</span> (<span class="params">box</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.intersectsBox(box);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Ray.prototype.isIntersectionPlane = <span class="function"><span class="keyword">function</span> (<span class="params">plane</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.intersectsPlane(plane);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Ray.prototype.isIntersectionSphere = <span class="function"><span class="keyword">function</span> (<span class="params">sphere</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.intersectsSphere(sphere);</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Triangle.prototype.area = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Triangle: .area() has been renamed to .getArea().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getArea();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Triangle.prototype.barycoordFromPoint = <span class="function"><span class="keyword">function</span> (<span class="params">point, target</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getBarycoord(point, target);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Triangle.prototype.midpoint = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Triangle: .midpoint() has been renamed to .getMidpoint().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getMidpoint(target);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Triangle.prototypenormal = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Triangle: .normal() has been renamed to .getNormal().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getNormal(target);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Triangle.prototype.plane = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Triangle: .plane() has been renamed to .getPlane().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getPlane(target);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Triangle.barycoordFromPoint = <span class="function"><span class="keyword">function</span> (<span class="params">point, a, b, c, target</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> Triangle.getBarycoord(point, a, b, c, target);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Triangle.normal = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c, target</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Triangle: .normal() has been renamed to .getNormal().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> Triangle.getNormal(a, b, c, target);</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Shape.prototype.extractAllPoints = <span class="function"><span class="keyword">function</span> (<span class="params">divisions</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.extractPoints(divisions);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Shape.prototype.extrude = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExtrudeGeometry(<span class="built_in">this</span>, options);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Shape.prototype.makeGeometry = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShapeGeometry(<span class="built_in">this</span>, options);</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Vector2.prototype.fromAttribute = <span class="function"><span class="keyword">function</span> (<span class="params">attribute, index, offset</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.fromBufferAttribute(attribute, index, offset);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Vector2.prototype.distanceToManhattan = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.manhattanDistanceTo(v);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Vector2.prototype.lengthManhattan = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.manhattanLength();</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Vector3.prototype.setEulerFromRotationMatrix = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Vector3.prototype.setEulerFromQuaternion = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Vector3.prototype.getPositionFromMatrix = <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.setFromMatrixPosition(m);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Vector3.prototype.getScaleFromMatrix = <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.setFromMatrixScale(m);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Vector3.prototype.getColumnFromMatrix = <span class="function"><span class="keyword">function</span> (<span class="params">index, matrix</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.setFromMatrixColumn(matrix, index);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Vector3.prototype.applyProjection = <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.applyMatrix4(m);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Vector3.prototype.fromAttribute = <span class="function"><span class="keyword">function</span> (<span class="params">attribute, index, offset</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.fromBufferAttribute(attribute, index, offset);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Vector3.prototype.distanceToManhattan = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.manhattanDistanceTo(v);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Vector3.prototype.lengthManhattan = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.manhattanLength();</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Vector4.prototype.fromAttribute = <span class="function"><span class="keyword">function</span> (<span class="params">attribute, index, offset</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.fromBufferAttribute(attribute, index, offset);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Vector4.prototype.lengthManhattan = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.manhattanLength();</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Object3D.prototype.getChildByName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getObjectByName(name);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Object3D.prototype.renderDepth = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Object3D.prototype.translate = <span class="function"><span class="keyword">function</span> (<span class="params">distance, axis</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.translateOnAxis(axis, distance);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Object3D.prototype.getWorldRotation = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Object3D.prototype.applyMatrix = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.applyMatrix4(matrix);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(Object3D.prototype, &#123;</span><br><span class="line">        <span class="attr">eulerOrder</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Object3D: .eulerOrder is now .rotation.order.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.rotation.order;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Object3D: .eulerOrder is now .rotation.order.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.rotation.order = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">useQuaternion</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.&#x27;</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Mesh.prototype.setDrawMode = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(Mesh.prototype, &#123;</span><br><span class="line">        <span class="attr">drawMode</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> TrianglesDrawMode;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    SkinnedMesh.prototype.initBones = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.SkinnedMesh: initBones() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    PerspectiveCamera.prototype.setLens = <span class="function"><span class="keyword">function</span> (<span class="params">focalLength, filmGauge</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.PerspectiveCamera.setLens is deprecated. &#x27;</span> + <span class="string">&#x27;Use .setFocalLength and .filmGauge for a photographic setup.&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (filmGauge !== <span class="literal">undefined</span>) <span class="built_in">this</span>.filmGauge = filmGauge;</span><br><span class="line">        <span class="built_in">this</span>.setFocalLength(focalLength);</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(Light.prototype, &#123;</span><br><span class="line">        <span class="attr">onlyShadow</span>: &#123;</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Light: .onlyShadow has been removed.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">shadowCameraFov</span>: &#123;</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Light: .shadowCameraFov is now .shadow.camera.fov.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.shadow.camera.fov = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">shadowCameraLeft</span>: &#123;</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Light: .shadowCameraLeft is now .shadow.camera.left.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.shadow.camera.left = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">shadowCameraRight</span>: &#123;</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Light: .shadowCameraRight is now .shadow.camera.right.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.shadow.camera.right = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">shadowCameraTop</span>: &#123;</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Light: .shadowCameraTop is now .shadow.camera.top.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.shadow.camera.top = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">shadowCameraBottom</span>: &#123;</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.shadow.camera.bottom = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">shadowCameraNear</span>: &#123;</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Light: .shadowCameraNear is now .shadow.camera.near.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.shadow.camera.near = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">shadowCameraFar</span>: &#123;</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Light: .shadowCameraFar is now .shadow.camera.far.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.shadow.camera.far = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">shadowCameraVisible</span>: &#123;</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">shadowBias</span>: &#123;</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Light: .shadowBias is now .shadow.bias.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.shadow.bias = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">shadowDarkness</span>: &#123;</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Light: .shadowDarkness has been removed.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">shadowMapWidth</span>: &#123;</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.shadow.mapSize.width = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">shadowMapHeight</span>: &#123;</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.shadow.mapSize.height = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(BufferAttribute.prototype, &#123;</span><br><span class="line">        <span class="attr">length</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.BufferAttribute: .length has been deprecated. Use .count instead.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.array.length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">dynamic</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.usage === DynamicDrawUsage;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">                /* <span class="title">value</span> */</span></span><br><span class="line"><span class="function">                (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.setUsage(DynamicDrawUsage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    BufferAttribute.prototype.setDynamic = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setUsage(value === <span class="literal">true</span> ? DynamicDrawUsage : StaticDrawUsage);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    BufferAttribute.prototype.copyIndicesArray = <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">        /* <span class="title">indices</span> */</span></span><br><span class="line"><span class="function">        (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.BufferAttribute: .copyIndicesArray() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;, BufferAttribute.prototype.setArray = <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">        /* <span class="title">array</span> */</span></span><br><span class="line"><span class="function">        (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers&#x27;</span>);</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    BufferGeometry.prototype.addIndex = <span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setIndex(index);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    BufferGeometry.prototype.addAttribute = <span class="function"><span class="keyword">function</span> (<span class="params">name, attribute</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(attribute &amp;&amp; attribute.isBufferAttribute) &amp;&amp; !(attribute &amp;&amp; attribute.isInterleavedBufferAttribute)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.setAttribute(name, <span class="keyword">new</span> BufferAttribute(<span class="built_in">arguments</span>[<span class="number">1</span>], <span class="built_in">arguments</span>[<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name === <span class="string">&#x27;index&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.&#x27;</span>);</span><br><span class="line">            <span class="built_in">this</span>.setIndex(attribute);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.setAttribute(name, attribute);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    BufferGeometry.prototype.addDrawCall = <span class="function"><span class="keyword">function</span> (<span class="params">start, count, indexOffset</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (indexOffset !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.BufferGeometry: .addDrawCall() is now .addGroup().&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.addGroup(start, count);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    BufferGeometry.prototype.clearDrawCalls = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.clearGroups();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    BufferGeometry.prototype.computeOffsets = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.BufferGeometry: .computeOffsets() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    BufferGeometry.prototype.removeAttribute = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.deleteAttribute(name);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    BufferGeometry.prototype.applyMatrix = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.applyMatrix4(matrix);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(BufferGeometry.prototype, &#123;</span><br><span class="line">        <span class="attr">drawcalls</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.BufferGeometry: .drawcalls has been renamed to .groups.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.groups;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">offsets</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.BufferGeometry: .offsets has been renamed to .groups.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.groups;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    InterleavedBuffer.prototype.setDynamic = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setUsage(value === <span class="literal">true</span> ? DynamicDrawUsage : StaticDrawUsage);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    InterleavedBuffer.prototype.setArray = <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">        /* <span class="title">array</span> */</span></span><br><span class="line"><span class="function">        (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers&#x27;</span>);</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ExtrudeGeometry.prototype.getArrays = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.ExtrudeGeometry: .getArrays() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ExtrudeGeometry.prototype.addShapeList = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.ExtrudeGeometry: .addShapeList() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ExtrudeGeometry.prototype.addShape = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.ExtrudeGeometry: .addShape() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Scene.prototype.dispose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Scene: .dispose() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Uniform.prototype.onUpdate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(Material.prototype, &#123;</span><br><span class="line">        <span class="attr">wrapAround</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Material: .wrapAround has been removed.&#x27;</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Material: .wrapAround has been removed.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">overdraw</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Material: .overdraw has been removed.&#x27;</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Material: .overdraw has been removed.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">wrapRGB</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Material: .wrapRGB has been removed.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Color();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">shading</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.&#x27;</span> + <span class="built_in">this</span>.type + <span class="string">&#x27;: .shading has been removed. Use the boolean .flatShading instead.&#x27;</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.&#x27;</span> + <span class="built_in">this</span>.type + <span class="string">&#x27;: .shading has been removed. Use the boolean .flatShading instead.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.flatShading = value === FlatShading;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">stencilMask</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.&#x27;</span> + <span class="built_in">this</span>.type + <span class="string">&#x27;: .stencilMask has been removed. Use .stencilFuncMask instead.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.stencilFuncMask;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.&#x27;</span> + <span class="built_in">this</span>.type + <span class="string">&#x27;: .stencilMask has been removed. Use .stencilFuncMask instead.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.stencilFuncMask = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">vertexTangents</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.&#x27;</span> + <span class="built_in">this</span>.type + <span class="string">&#x27;: .vertexTangents has been removed.&#x27;</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.&#x27;</span> + <span class="built_in">this</span>.type + <span class="string">&#x27;: .vertexTangents has been removed.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(ShaderMaterial.prototype, &#123;</span><br><span class="line">        <span class="attr">derivatives</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.extensions.derivatives;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.extensions.derivatives = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.clearTarget = <span class="function"><span class="keyword">function</span> (<span class="params">renderTarget, color, depth, stencil</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setRenderTarget(renderTarget);</span><br><span class="line">        <span class="built_in">this</span>.clear(color, depth, stencil);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.animate = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .animate() is now .setAnimationLoop().&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setAnimationLoop(callback);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.getCurrentRenderTarget = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getRenderTarget();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.getMaxAnisotropy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.capabilities.getMaxAnisotropy();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.getPrecision = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.capabilities.precision;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.resetGLState = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .resetGLState() is now .state.reset().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.state.reset();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.supportsFloatTextures = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \&#x27;OES_texture_float\&#x27; ).&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.extensions.get(<span class="string">&#x27;OES_texture_float&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.supportsHalfFloatTextures = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \&#x27;OES_texture_half_float\&#x27; ).&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.extensions.get(<span class="string">&#x27;OES_texture_half_float&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.supportsStandardDerivatives = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \&#x27;OES_standard_derivatives\&#x27; ).&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.extensions.get(<span class="string">&#x27;OES_standard_derivatives&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.supportsCompressedTextureS3TC = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \&#x27;WEBGL_compressed_texture_s3tc\&#x27; ).&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.extensions.get(<span class="string">&#x27;WEBGL_compressed_texture_s3tc&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.supportsCompressedTexturePVRTC = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \&#x27;WEBGL_compressed_texture_pvrtc\&#x27; ).&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.extensions.get(<span class="string">&#x27;WEBGL_compressed_texture_pvrtc&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.supportsBlendMinMax = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \&#x27;EXT_blend_minmax\&#x27; ).&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.extensions.get(<span class="string">&#x27;EXT_blend_minmax&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.supportsVertexTextures = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.capabilities.vertexTextures;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.supportsInstancedArrays = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \&#x27;ANGLE_instanced_arrays\&#x27; ).&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.extensions.get(<span class="string">&#x27;ANGLE_instanced_arrays&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.enableScissorTest = <span class="function"><span class="keyword">function</span> (<span class="params">boolean</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setScissorTest(boolean);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.initMaterial = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .initMaterial() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.addPrePlugin = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .addPrePlugin() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.addPostPlugin = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .addPostPlugin() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.updateShadowMap = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .updateShadowMap() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.setFaceCulling = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .setFaceCulling() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.allocTextureUnit = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .allocTextureUnit() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.setTexture = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .setTexture() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.setTexture2D = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .setTexture2D() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.setTextureCube = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .setTextureCube() has been removed.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WebGLRenderer.prototype.getActiveMipMapLevel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getActiveMipmapLevel();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(WebGLRenderer.prototype, &#123;</span><br><span class="line">        <span class="attr">shadowMapEnabled</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.shadowMap.enabled;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.shadowMap.enabled = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">shadowMapType</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.shadowMap.type;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.shadowMap.type = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">shadowMapCullFace</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">                /* <span class="title">value</span> */</span></span><br><span class="line"><span class="function">                (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">context</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.getContext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">vr</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .vr has been renamed to .xr&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.xr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">gammaInput</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">gammaOutput</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.outputEncoding = value === <span class="literal">true</span> ? sRGBEncoding : LinearEncoding;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">toneMappingWhitePoint</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">gammaFactor</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .gammaFactor has been removed.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .gammaFactor has been removed.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(WebGLShadowMap.prototype, &#123;</span><br><span class="line">        <span class="attr">cullFace</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">                /* <span class="title">cullFace</span> */</span></span><br><span class="line"><span class="function">                (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">renderReverseSided</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">renderSingleSided</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WebGLRenderTargetCube</span> <span class="keyword">extends</span> <span class="title">WebGLCubeRenderTarget</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">width, height, options</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(width, options);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(WebGLRenderTarget.prototype, &#123;</span><br><span class="line">        <span class="attr">wrapS</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.texture.wrapS;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.texture.wrapS = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">wrapT</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.texture.wrapT;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.texture.wrapT = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">magFilter</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.texture.magFilter;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.texture.magFilter = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">minFilter</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.texture.minFilter;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.texture.minFilter = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">anisotropy</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.texture.anisotropy;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.texture.anisotropy = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">offset</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderTarget: .offset is now .texture.offset.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.texture.offset;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderTarget: .offset is now .texture.offset.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.texture.offset = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">repeat</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderTarget: .repeat is now .texture.repeat.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.texture.repeat;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderTarget: .repeat is now .texture.repeat.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.texture.repeat = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">format</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderTarget: .format is now .texture.format.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.texture.format;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderTarget: .format is now .texture.format.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.texture.format = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">type</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderTarget: .type is now .texture.type.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.texture.type;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderTarget: .type is now .texture.type.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.texture.type = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">generateMipmaps</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.texture.generateMipmaps;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.texture.generateMipmaps = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    Audio.prototype.load = <span class="function"><span class="keyword">function</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> scope = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">const</span> audioLoader = <span class="keyword">new</span> AudioLoader();</span><br><span class="line">        audioLoader.load(file, <span class="function"><span class="keyword">function</span> (<span class="params">buffer</span>) </span>&#123;</span><br><span class="line">            scope.setBuffer(buffer);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    AudioAnalyser.prototype.getData = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.AudioAnalyser: .getData() is now .getFrequencyData().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getFrequencyData();</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CubeCamera.prototype.updateCubeMap = <span class="function"><span class="keyword">function</span> (<span class="params">renderer, scene</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.CubeCamera: .updateCubeMap() is now .update().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.update(renderer, scene);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    CubeCamera.prototype.clear = <span class="function"><span class="keyword">function</span> (<span class="params">renderer, color, depth, stencil</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.CubeCamera: .clear() is now .renderTarget.clear().&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.renderTarget.clear(renderer, color, depth, stencil);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ImageUtils.crossOrigin = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    ImageUtils.loadTexture = <span class="function"><span class="keyword">function</span> (<span class="params">url, mapping, onLoad, onError</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> loader = <span class="keyword">new</span> TextureLoader();</span><br><span class="line">        loader.setCrossOrigin(<span class="built_in">this</span>.crossOrigin);</span><br><span class="line">        <span class="keyword">const</span> texture = loader.load(url, onLoad, <span class="literal">undefined</span>, onError);</span><br><span class="line">        <span class="keyword">if</span> (mapping) texture.mapping = mapping;</span><br><span class="line">        <span class="keyword">return</span> texture;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ImageUtils.loadTextureCube = <span class="function"><span class="keyword">function</span> (<span class="params">urls, mapping, onLoad, onError</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> loader = <span class="keyword">new</span> CubeTextureLoader();</span><br><span class="line">        loader.setCrossOrigin(<span class="built_in">this</span>.crossOrigin);</span><br><span class="line">        <span class="keyword">const</span> texture = loader.load(urls, onLoad, <span class="literal">undefined</span>, onError);</span><br><span class="line">        <span class="keyword">if</span> (mapping) texture.mapping = mapping;</span><br><span class="line">        <span class="keyword">return</span> texture;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ImageUtils.loadCompressedTexture = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ImageUtils.loadCompressedTextureCube = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.&#x27;</span>);</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">CanvasRenderer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.CanvasRenderer has been removed&#x27;</span>);</span><br><span class="line">    &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">JSONLoader</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.JSONLoader has been removed.&#x27;</span>);</span><br><span class="line">    &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> SceneUtils = &#123;</span><br><span class="line">        <span class="attr">createMultiMaterialObject</span>: <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">            /* <span class="title">geometry</span>, <span class="title">materials</span> */</span></span><br><span class="line"><span class="function">            (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js&#x27;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">detach</span>: <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">            /* <span class="title">child</span>, <span class="title">parent</span>, <span class="title">scene</span> */</span></span><br><span class="line"><span class="function">            (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js&#x27;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">attach</span>: <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">            /* <span class="title">child</span>, <span class="title">scene</span>, <span class="title">parent</span> */</span></span><br><span class="line"><span class="function">            (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">LensFlare</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js&#x27;</span>);</span><br><span class="line">    &#125; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ParametricGeometry</span> <span class="keyword">extends</span> <span class="title">BufferGeometry</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TextGeometry</span> <span class="keyword">extends</span> <span class="title">BufferGeometry</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">FontLoader</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Font</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ImmediateRenderObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.ImmediateRenderObject has been removed.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WebGLMultisampleRenderTarget</span> <span class="keyword">extends</span> <span class="title">WebGLRenderTarget</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">width, height, options</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">&#x27;THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the &quot;samples&quot; property to greater 0 to enable multisampling.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(width, height, options);</span><br><span class="line">            <span class="built_in">this</span>.samples = <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DataTexture2DArray</span> <span class="keyword">extends</span> <span class="title">DataArrayTexture</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">data, width, height, depth</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.DataTexture2DArray has been renamed to DataArrayTexture.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(data, width, height, depth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DataTexture3D</span> <span class="keyword">extends</span> <span class="title">Data3DTexture</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">data, width, height, depth</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;THREE.DataTexture3D has been renamed to Data3DTexture.&#x27;</span>);</span><br><span class="line">            <span class="built_in">super</span>(data, width, height, depth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> __THREE_DEVTOOLS__ !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">        __THREE_DEVTOOLS__.dispatchEvent(<span class="keyword">new</span> CustomEvent(<span class="string">&#x27;register&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">detail</span>: &#123;</span><br><span class="line">                <span class="attr">revision</span>: REVISION</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">window</span>.__THREE__) &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">&#x27;WARNING: Multiple instances of Three.js being imported.&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">window</span>.__THREE__ = REVISION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exports</span>.ACESFilmicToneMapping = ACESFilmicToneMapping;</span><br><span class="line">    <span class="built_in">exports</span>.AddEquation = AddEquation;</span><br><span class="line">    <span class="built_in">exports</span>.AddOperation = AddOperation;</span><br><span class="line">    <span class="built_in">exports</span>.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;</span><br><span class="line">    <span class="built_in">exports</span>.AdditiveBlending = AdditiveBlending;</span><br><span class="line">    <span class="built_in">exports</span>.AlphaFormat = AlphaFormat;</span><br><span class="line">    <span class="built_in">exports</span>.AlwaysDepth = AlwaysDepth;</span><br><span class="line">    <span class="built_in">exports</span>.AlwaysStencilFunc = AlwaysStencilFunc;</span><br><span class="line">    <span class="built_in">exports</span>.AmbientLight = AmbientLight;</span><br><span class="line">    <span class="built_in">exports</span>.AmbientLightProbe = AmbientLightProbe;</span><br><span class="line">    <span class="built_in">exports</span>.AnimationClip = AnimationClip;</span><br><span class="line">    <span class="built_in">exports</span>.AnimationLoader = AnimationLoader;</span><br><span class="line">    <span class="built_in">exports</span>.AnimationMixer = AnimationMixer;</span><br><span class="line">    <span class="built_in">exports</span>.AnimationObjectGroup = AnimationObjectGroup;</span><br><span class="line">    <span class="built_in">exports</span>.AnimationUtils = AnimationUtils;</span><br><span class="line">    <span class="built_in">exports</span>.ArcCurve = ArcCurve;</span><br><span class="line">    <span class="built_in">exports</span>.ArrayCamera = ArrayCamera;</span><br><span class="line">    <span class="built_in">exports</span>.ArrowHelper = ArrowHelper;</span><br><span class="line">    <span class="built_in">exports</span>.Audio = Audio;</span><br><span class="line">    <span class="built_in">exports</span>.AudioAnalyser = AudioAnalyser;</span><br><span class="line">    <span class="built_in">exports</span>.AudioContext = AudioContext;</span><br><span class="line">    <span class="built_in">exports</span>.AudioListener = AudioListener;</span><br><span class="line">    <span class="built_in">exports</span>.AudioLoader = AudioLoader;</span><br><span class="line">    <span class="built_in">exports</span>.AxesHelper = AxesHelper;</span><br><span class="line">    <span class="built_in">exports</span>.AxisHelper = AxisHelper;</span><br><span class="line">    <span class="built_in">exports</span>.BackSide = BackSide;</span><br><span class="line">    <span class="built_in">exports</span>.BasicDepthPacking = BasicDepthPacking;</span><br><span class="line">    <span class="built_in">exports</span>.BasicShadowMap = BasicShadowMap;</span><br><span class="line">    <span class="built_in">exports</span>.BinaryTextureLoader = BinaryTextureLoader;</span><br><span class="line">    <span class="built_in">exports</span>.Bone = Bone;</span><br><span class="line">    <span class="built_in">exports</span>.BooleanKeyframeTrack = BooleanKeyframeTrack;</span><br><span class="line">    <span class="built_in">exports</span>.BoundingBoxHelper = BoundingBoxHelper;</span><br><span class="line">    <span class="built_in">exports</span>.Box2 = Box2;</span><br><span class="line">    <span class="built_in">exports</span>.Box3 = Box3;</span><br><span class="line">    <span class="built_in">exports</span>.Box3Helper = Box3Helper;</span><br><span class="line">    <span class="built_in">exports</span>.BoxBufferGeometry = BoxGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.BoxGeometry = BoxGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.BoxHelper = BoxHelper;</span><br><span class="line">    <span class="built_in">exports</span>.BufferAttribute = BufferAttribute;</span><br><span class="line">    <span class="built_in">exports</span>.BufferGeometry = BufferGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.BufferGeometryLoader = BufferGeometryLoader;</span><br><span class="line">    <span class="built_in">exports</span>.ByteType = ByteType;</span><br><span class="line">    <span class="built_in">exports</span>.Cache = Cache;</span><br><span class="line">    <span class="built_in">exports</span>.Camera = Camera;</span><br><span class="line">    <span class="built_in">exports</span>.CameraHelper = CameraHelper;</span><br><span class="line">    <span class="built_in">exports</span>.CanvasRenderer = CanvasRenderer;</span><br><span class="line">    <span class="built_in">exports</span>.CanvasTexture = CanvasTexture;</span><br><span class="line">    <span class="built_in">exports</span>.CapsuleBufferGeometry = CapsuleGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.CapsuleGeometry = CapsuleGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.CatmullRomCurve3 = CatmullRomCurve3;</span><br><span class="line">    <span class="built_in">exports</span>.CineonToneMapping = CineonToneMapping;</span><br><span class="line">    <span class="built_in">exports</span>.CircleBufferGeometry = CircleGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.CircleGeometry = CircleGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.ClampToEdgeWrapping = ClampToEdgeWrapping;</span><br><span class="line">    <span class="built_in">exports</span>.Clock = Clock;</span><br><span class="line">    <span class="built_in">exports</span>.Color = Color;</span><br><span class="line">    <span class="built_in">exports</span>.ColorKeyframeTrack = ColorKeyframeTrack;</span><br><span class="line">    <span class="built_in">exports</span>.ColorManagement = ColorManagement;</span><br><span class="line">    <span class="built_in">exports</span>.CompressedTexture = CompressedTexture;</span><br><span class="line">    <span class="built_in">exports</span>.CompressedTextureLoader = CompressedTextureLoader;</span><br><span class="line">    <span class="built_in">exports</span>.ConeBufferGeometry = ConeGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.ConeGeometry = ConeGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.CubeCamera = CubeCamera;</span><br><span class="line">    <span class="built_in">exports</span>.CubeReflectionMapping = CubeReflectionMapping;</span><br><span class="line">    <span class="built_in">exports</span>.CubeRefractionMapping = CubeRefractionMapping;</span><br><span class="line">    <span class="built_in">exports</span>.CubeTexture = CubeTexture;</span><br><span class="line">    <span class="built_in">exports</span>.CubeTextureLoader = CubeTextureLoader;</span><br><span class="line">    <span class="built_in">exports</span>.CubeUVReflectionMapping = CubeUVReflectionMapping;</span><br><span class="line">    <span class="built_in">exports</span>.CubicBezierCurve = CubicBezierCurve;</span><br><span class="line">    <span class="built_in">exports</span>.CubicBezierCurve3 = CubicBezierCurve3;</span><br><span class="line">    <span class="built_in">exports</span>.CubicInterpolant = CubicInterpolant;</span><br><span class="line">    <span class="built_in">exports</span>.CullFaceBack = CullFaceBack;</span><br><span class="line">    <span class="built_in">exports</span>.CullFaceFront = CullFaceFront;</span><br><span class="line">    <span class="built_in">exports</span>.CullFaceFrontBack = CullFaceFrontBack;</span><br><span class="line">    <span class="built_in">exports</span>.CullFaceNone = CullFaceNone;</span><br><span class="line">    <span class="built_in">exports</span>.Curve = Curve;</span><br><span class="line">    <span class="built_in">exports</span>.CurvePath = CurvePath;</span><br><span class="line">    <span class="built_in">exports</span>.CustomBlending = CustomBlending;</span><br><span class="line">    <span class="built_in">exports</span>.CustomToneMapping = CustomToneMapping;</span><br><span class="line">    <span class="built_in">exports</span>.CylinderBufferGeometry = CylinderGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.CylinderGeometry = CylinderGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.Cylindrical = Cylindrical;</span><br><span class="line">    <span class="built_in">exports</span>.Data3DTexture = Data3DTexture;</span><br><span class="line">    <span class="built_in">exports</span>.DataArrayTexture = DataArrayTexture;</span><br><span class="line">    <span class="built_in">exports</span>.DataTexture = DataTexture;</span><br><span class="line">    <span class="built_in">exports</span>.DataTexture2DArray = DataTexture2DArray;</span><br><span class="line">    <span class="built_in">exports</span>.DataTexture3D = DataTexture3D;</span><br><span class="line">    <span class="built_in">exports</span>.DataTextureLoader = DataTextureLoader;</span><br><span class="line">    <span class="built_in">exports</span>.DataUtils = DataUtils;</span><br><span class="line">    <span class="built_in">exports</span>.DecrementStencilOp = DecrementStencilOp;</span><br><span class="line">    <span class="built_in">exports</span>.DecrementWrapStencilOp = DecrementWrapStencilOp;</span><br><span class="line">    <span class="built_in">exports</span>.DefaultLoadingManager = DefaultLoadingManager;</span><br><span class="line">    <span class="built_in">exports</span>.DepthFormat = DepthFormat;</span><br><span class="line">    <span class="built_in">exports</span>.DepthStencilFormat = DepthStencilFormat;</span><br><span class="line">    <span class="built_in">exports</span>.DepthTexture = DepthTexture;</span><br><span class="line">    <span class="built_in">exports</span>.DirectionalLight = DirectionalLight;</span><br><span class="line">    <span class="built_in">exports</span>.DirectionalLightHelper = DirectionalLightHelper;</span><br><span class="line">    <span class="built_in">exports</span>.DiscreteInterpolant = DiscreteInterpolant;</span><br><span class="line">    <span class="built_in">exports</span>.DodecahedronBufferGeometry = DodecahedronGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.DodecahedronGeometry = DodecahedronGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.DoubleSide = DoubleSide;</span><br><span class="line">    <span class="built_in">exports</span>.DstAlphaFactor = DstAlphaFactor;</span><br><span class="line">    <span class="built_in">exports</span>.DstColorFactor = DstColorFactor;</span><br><span class="line">    <span class="built_in">exports</span>.DynamicBufferAttribute = DynamicBufferAttribute;</span><br><span class="line">    <span class="built_in">exports</span>.DynamicCopyUsage = DynamicCopyUsage;</span><br><span class="line">    <span class="built_in">exports</span>.DynamicDrawUsage = DynamicDrawUsage;</span><br><span class="line">    <span class="built_in">exports</span>.DynamicReadUsage = DynamicReadUsage;</span><br><span class="line">    <span class="built_in">exports</span>.EdgesGeometry = EdgesGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.EdgesHelper = EdgesHelper;</span><br><span class="line">    <span class="built_in">exports</span>.EllipseCurve = EllipseCurve;</span><br><span class="line">    <span class="built_in">exports</span>.EqualDepth = EqualDepth;</span><br><span class="line">    <span class="built_in">exports</span>.EqualStencilFunc = EqualStencilFunc;</span><br><span class="line">    <span class="built_in">exports</span>.EquirectangularReflectionMapping = EquirectangularReflectionMapping;</span><br><span class="line">    <span class="built_in">exports</span>.EquirectangularRefractionMapping = EquirectangularRefractionMapping;</span><br><span class="line">    <span class="built_in">exports</span>.Euler = Euler;</span><br><span class="line">    <span class="built_in">exports</span>.EventDispatcher = EventDispatcher;</span><br><span class="line">    <span class="built_in">exports</span>.ExtrudeBufferGeometry = ExtrudeGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.ExtrudeGeometry = ExtrudeGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.FaceColors = FaceColors;</span><br><span class="line">    <span class="built_in">exports</span>.FileLoader = FileLoader;</span><br><span class="line">    <span class="built_in">exports</span>.FlatShading = FlatShading;</span><br><span class="line">    <span class="built_in">exports</span>.Float16BufferAttribute = Float16BufferAttribute;</span><br><span class="line">    <span class="built_in">exports</span>.Float32Attribute = Float32Attribute;</span><br><span class="line">    <span class="built_in">exports</span>.Float32BufferAttribute = Float32BufferAttribute;</span><br><span class="line">    <span class="built_in">exports</span>.Float64Attribute = Float64Attribute;</span><br><span class="line">    <span class="built_in">exports</span>.Float64BufferAttribute = Float64BufferAttribute;</span><br><span class="line">    <span class="built_in">exports</span>.FloatType = FloatType;</span><br><span class="line">    <span class="built_in">exports</span>.Fog = Fog;</span><br><span class="line">    <span class="built_in">exports</span>.FogExp2 = FogExp2;</span><br><span class="line">    <span class="built_in">exports</span>.Font = Font;</span><br><span class="line">    <span class="built_in">exports</span>.FontLoader = FontLoader;</span><br><span class="line">    <span class="built_in">exports</span>.FramebufferTexture = FramebufferTexture;</span><br><span class="line">    <span class="built_in">exports</span>.FrontSide = FrontSide;</span><br><span class="line">    <span class="built_in">exports</span>.Frustum = Frustum;</span><br><span class="line">    <span class="built_in">exports</span>.GLBufferAttribute = GLBufferAttribute;</span><br><span class="line">    <span class="built_in">exports</span>.GLSL1 = GLSL1;</span><br><span class="line">    <span class="built_in">exports</span>.GLSL3 = GLSL3;</span><br><span class="line">    <span class="built_in">exports</span>.GreaterDepth = GreaterDepth;</span><br><span class="line">    <span class="built_in">exports</span>.GreaterEqualDepth = GreaterEqualDepth;</span><br><span class="line">    <span class="built_in">exports</span>.GreaterEqualStencilFunc = GreaterEqualStencilFunc;</span><br><span class="line">    <span class="built_in">exports</span>.GreaterStencilFunc = GreaterStencilFunc;</span><br><span class="line">    <span class="built_in">exports</span>.GridHelper = GridHelper;</span><br><span class="line">    <span class="built_in">exports</span>.Group = Group;</span><br><span class="line">    <span class="built_in">exports</span>.HalfFloatType = HalfFloatType;</span><br><span class="line">    <span class="built_in">exports</span>.HemisphereLight = HemisphereLight;</span><br><span class="line">    <span class="built_in">exports</span>.HemisphereLightHelper = HemisphereLightHelper;</span><br><span class="line">    <span class="built_in">exports</span>.HemisphereLightProbe = HemisphereLightProbe;</span><br><span class="line">    <span class="built_in">exports</span>.IcosahedronBufferGeometry = IcosahedronGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.IcosahedronGeometry = IcosahedronGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.ImageBitmapLoader = ImageBitmapLoader;</span><br><span class="line">    <span class="built_in">exports</span>.ImageLoader = ImageLoader;</span><br><span class="line">    <span class="built_in">exports</span>.ImageUtils = ImageUtils;</span><br><span class="line">    <span class="built_in">exports</span>.ImmediateRenderObject = ImmediateRenderObject;</span><br><span class="line">    <span class="built_in">exports</span>.IncrementStencilOp = IncrementStencilOp;</span><br><span class="line">    <span class="built_in">exports</span>.IncrementWrapStencilOp = IncrementWrapStencilOp;</span><br><span class="line">    <span class="built_in">exports</span>.InstancedBufferAttribute = InstancedBufferAttribute;</span><br><span class="line">    <span class="built_in">exports</span>.InstancedBufferGeometry = InstancedBufferGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.InstancedInterleavedBuffer = InstancedInterleavedBuffer;</span><br><span class="line">    <span class="built_in">exports</span>.InstancedMesh = InstancedMesh;</span><br><span class="line">    <span class="built_in">exports</span>.Int16Attribute = Int16Attribute;</span><br><span class="line">    <span class="built_in">exports</span>.Int16BufferAttribute = Int16BufferAttribute;</span><br><span class="line">    <span class="built_in">exports</span>.Int32Attribute = Int32Attribute;</span><br><span class="line">    <span class="built_in">exports</span>.Int32BufferAttribute = Int32BufferAttribute;</span><br><span class="line">    <span class="built_in">exports</span>.Int8Attribute = Int8Attribute;</span><br><span class="line">    <span class="built_in">exports</span>.Int8BufferAttribute = Int8BufferAttribute;</span><br><span class="line">    <span class="built_in">exports</span>.IntType = IntType;</span><br><span class="line">    <span class="built_in">exports</span>.InterleavedBuffer = InterleavedBuffer;</span><br><span class="line">    <span class="built_in">exports</span>.InterleavedBufferAttribute = InterleavedBufferAttribute;</span><br><span class="line">    <span class="built_in">exports</span>.Interpolant = Interpolant;</span><br><span class="line">    <span class="built_in">exports</span>.InterpolateDiscrete = InterpolateDiscrete;</span><br><span class="line">    <span class="built_in">exports</span>.InterpolateLinear = InterpolateLinear;</span><br><span class="line">    <span class="built_in">exports</span>.InterpolateSmooth = InterpolateSmooth;</span><br><span class="line">    <span class="built_in">exports</span>.InvertStencilOp = InvertStencilOp;</span><br><span class="line">    <span class="built_in">exports</span>.JSONLoader = JSONLoader;</span><br><span class="line">    <span class="built_in">exports</span>.KeepStencilOp = KeepStencilOp;</span><br><span class="line">    <span class="built_in">exports</span>.KeyframeTrack = KeyframeTrack;</span><br><span class="line">    <span class="built_in">exports</span>.LOD = LOD;</span><br><span class="line">    <span class="built_in">exports</span>.LatheBufferGeometry = LatheGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.LatheGeometry = LatheGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.Layers = Layers;</span><br><span class="line">    <span class="built_in">exports</span>.LensFlare = LensFlare;</span><br><span class="line">    <span class="built_in">exports</span>.LessDepth = LessDepth;</span><br><span class="line">    <span class="built_in">exports</span>.LessEqualDepth = LessEqualDepth;</span><br><span class="line">    <span class="built_in">exports</span>.LessEqualStencilFunc = LessEqualStencilFunc;</span><br><span class="line">    <span class="built_in">exports</span>.LessStencilFunc = LessStencilFunc;</span><br><span class="line">    <span class="built_in">exports</span>.Light = Light;</span><br><span class="line">    <span class="built_in">exports</span>.LightProbe = LightProbe;</span><br><span class="line">    <span class="built_in">exports</span>.Line = Line;</span><br><span class="line">    <span class="built_in">exports</span>.Line3 = Line3;</span><br><span class="line">    <span class="built_in">exports</span>.LineBasicMaterial = LineBasicMaterial;</span><br><span class="line">    <span class="built_in">exports</span>.LineCurve = LineCurve;</span><br><span class="line">    <span class="built_in">exports</span>.LineCurve3 = LineCurve3;</span><br><span class="line">    <span class="built_in">exports</span>.LineDashedMaterial = LineDashedMaterial;</span><br><span class="line">    <span class="built_in">exports</span>.LineLoop = LineLoop;</span><br><span class="line">    <span class="built_in">exports</span>.LinePieces = LinePieces;</span><br><span class="line">    <span class="built_in">exports</span>.LineSegments = LineSegments;</span><br><span class="line">    <span class="built_in">exports</span>.LineStrip = LineStrip;</span><br><span class="line">    <span class="built_in">exports</span>.LinearEncoding = LinearEncoding;</span><br><span class="line">    <span class="built_in">exports</span>.LinearFilter = LinearFilter;</span><br><span class="line">    <span class="built_in">exports</span>.LinearInterpolant = LinearInterpolant;</span><br><span class="line">    <span class="built_in">exports</span>.LinearMipMapLinearFilter = LinearMipMapLinearFilter;</span><br><span class="line">    <span class="built_in">exports</span>.LinearMipMapNearestFilter = LinearMipMapNearestFilter;</span><br><span class="line">    <span class="built_in">exports</span>.LinearMipmapLinearFilter = LinearMipmapLinearFilter;</span><br><span class="line">    <span class="built_in">exports</span>.LinearMipmapNearestFilter = LinearMipmapNearestFilter;</span><br><span class="line">    <span class="built_in">exports</span>.LinearSRGBColorSpace = LinearSRGBColorSpace;</span><br><span class="line">    <span class="built_in">exports</span>.LinearToneMapping = LinearToneMapping;</span><br><span class="line">    <span class="built_in">exports</span>.Loader = Loader;</span><br><span class="line">    <span class="built_in">exports</span>.LoaderUtils = LoaderUtils;</span><br><span class="line">    <span class="built_in">exports</span>.LoadingManager = LoadingManager;</span><br><span class="line">    <span class="built_in">exports</span>.LoopOnce = LoopOnce;</span><br><span class="line">    <span class="built_in">exports</span>.LoopPingPong = LoopPingPong;</span><br><span class="line">    <span class="built_in">exports</span>.LoopRepeat = LoopRepeat;</span><br><span class="line">    <span class="built_in">exports</span>.LuminanceAlphaFormat = LuminanceAlphaFormat;</span><br><span class="line">    <span class="built_in">exports</span>.LuminanceFormat = LuminanceFormat;</span><br><span class="line">    <span class="built_in">exports</span>.MOUSE = MOUSE;</span><br><span class="line">    <span class="built_in">exports</span>.Material = Material;</span><br><span class="line">    <span class="built_in">exports</span>.MaterialLoader = MaterialLoader;</span><br><span class="line">    <span class="built_in">exports</span>.Math = MathUtils;</span><br><span class="line">    <span class="built_in">exports</span>.MathUtils = MathUtils;</span><br><span class="line">    <span class="built_in">exports</span>.Matrix3 = Matrix3;</span><br><span class="line">    <span class="built_in">exports</span>.Matrix4 = Matrix4;</span><br><span class="line">    <span class="built_in">exports</span>.MaxEquation = MaxEquation;</span><br><span class="line">    <span class="built_in">exports</span>.Mesh = Mesh;</span><br><span class="line">    <span class="built_in">exports</span>.MeshBasicMaterial = MeshBasicMaterial;</span><br><span class="line">    <span class="built_in">exports</span>.MeshDepthMaterial = MeshDepthMaterial;</span><br><span class="line">    <span class="built_in">exports</span>.MeshDistanceMaterial = MeshDistanceMaterial;</span><br><span class="line">    <span class="built_in">exports</span>.MeshFaceMaterial = MeshFaceMaterial;</span><br><span class="line">    <span class="built_in">exports</span>.MeshLambertMaterial = MeshLambertMaterial;</span><br><span class="line">    <span class="built_in">exports</span>.MeshMatcapMaterial = MeshMatcapMaterial;</span><br><span class="line">    <span class="built_in">exports</span>.MeshNormalMaterial = MeshNormalMaterial;</span><br><span class="line">    <span class="built_in">exports</span>.MeshPhongMaterial = MeshPhongMaterial;</span><br><span class="line">    <span class="built_in">exports</span>.MeshPhysicalMaterial = MeshPhysicalMaterial;</span><br><span class="line">    <span class="built_in">exports</span>.MeshStandardMaterial = MeshStandardMaterial;</span><br><span class="line">    <span class="built_in">exports</span>.MeshToonMaterial = MeshToonMaterial;</span><br><span class="line">    <span class="built_in">exports</span>.MinEquation = MinEquation;</span><br><span class="line">    <span class="built_in">exports</span>.MirroredRepeatWrapping = MirroredRepeatWrapping;</span><br><span class="line">    <span class="built_in">exports</span>.MixOperation = MixOperation;</span><br><span class="line">    <span class="built_in">exports</span>.MultiMaterial = MultiMaterial;</span><br><span class="line">    <span class="built_in">exports</span>.MultiplyBlending = MultiplyBlending;</span><br><span class="line">    <span class="built_in">exports</span>.MultiplyOperation = MultiplyOperation;</span><br><span class="line">    <span class="built_in">exports</span>.NearestFilter = NearestFilter;</span><br><span class="line">    <span class="built_in">exports</span>.NearestMipMapLinearFilter = NearestMipMapLinearFilter;</span><br><span class="line">    <span class="built_in">exports</span>.NearestMipMapNearestFilter = NearestMipMapNearestFilter;</span><br><span class="line">    <span class="built_in">exports</span>.NearestMipmapLinearFilter = NearestMipmapLinearFilter;</span><br><span class="line">    <span class="built_in">exports</span>.NearestMipmapNearestFilter = NearestMipmapNearestFilter;</span><br><span class="line">    <span class="built_in">exports</span>.NeverDepth = NeverDepth;</span><br><span class="line">    <span class="built_in">exports</span>.NeverStencilFunc = NeverStencilFunc;</span><br><span class="line">    <span class="built_in">exports</span>.NoBlending = NoBlending;</span><br><span class="line">    <span class="built_in">exports</span>.NoColorSpace = NoColorSpace;</span><br><span class="line">    <span class="built_in">exports</span>.NoColors = NoColors;</span><br><span class="line">    <span class="built_in">exports</span>.NoToneMapping = NoToneMapping;</span><br><span class="line">    <span class="built_in">exports</span>.NormalAnimationBlendMode = NormalAnimationBlendMode;</span><br><span class="line">    <span class="built_in">exports</span>.NormalBlending = NormalBlending;</span><br><span class="line">    <span class="built_in">exports</span>.NotEqualDepth = NotEqualDepth;</span><br><span class="line">    <span class="built_in">exports</span>.NotEqualStencilFunc = NotEqualStencilFunc;</span><br><span class="line">    <span class="built_in">exports</span>.NumberKeyframeTrack = NumberKeyframeTrack;</span><br><span class="line">    <span class="built_in">exports</span>.Object3D = Object3D;</span><br><span class="line">    <span class="built_in">exports</span>.ObjectLoader = ObjectLoader;</span><br><span class="line">    <span class="built_in">exports</span>.ObjectSpaceNormalMap = ObjectSpaceNormalMap;</span><br><span class="line">    <span class="built_in">exports</span>.OctahedronBufferGeometry = OctahedronGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.OctahedronGeometry = OctahedronGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.OneFactor = OneFactor;</span><br><span class="line">    <span class="built_in">exports</span>.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;</span><br><span class="line">    <span class="built_in">exports</span>.OneMinusDstColorFactor = OneMinusDstColorFactor;</span><br><span class="line">    <span class="built_in">exports</span>.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;</span><br><span class="line">    <span class="built_in">exports</span>.OneMinusSrcColorFactor = OneMinusSrcColorFactor;</span><br><span class="line">    <span class="built_in">exports</span>.OrthographicCamera = OrthographicCamera;</span><br><span class="line">    <span class="built_in">exports</span>.PCFShadowMap = PCFShadowMap;</span><br><span class="line">    <span class="built_in">exports</span>.PCFSoftShadowMap = PCFSoftShadowMap;</span><br><span class="line">    <span class="built_in">exports</span>.PMREMGenerator = PMREMGenerator;</span><br><span class="line">    <span class="built_in">exports</span>.ParametricGeometry = ParametricGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.Particle = Particle;</span><br><span class="line">    <span class="built_in">exports</span>.ParticleBasicMaterial = ParticleBasicMaterial;</span><br><span class="line">    <span class="built_in">exports</span>.ParticleSystem = ParticleSystem;</span><br><span class="line">    <span class="built_in">exports</span>.ParticleSystemMaterial = ParticleSystemMaterial;</span><br><span class="line">    <span class="built_in">exports</span>.Path = Path;</span><br><span class="line">    <span class="built_in">exports</span>.PerspectiveCamera = PerspectiveCamera;</span><br><span class="line">    <span class="built_in">exports</span>.Plane = Plane;</span><br><span class="line">    <span class="built_in">exports</span>.PlaneBufferGeometry = PlaneGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.PlaneGeometry = PlaneGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.PlaneHelper = PlaneHelper;</span><br><span class="line">    <span class="built_in">exports</span>.PointCloud = PointCloud;</span><br><span class="line">    <span class="built_in">exports</span>.PointCloudMaterial = PointCloudMaterial;</span><br><span class="line">    <span class="built_in">exports</span>.PointLight = PointLight;</span><br><span class="line">    <span class="built_in">exports</span>.PointLightHelper = PointLightHelper;</span><br><span class="line">    <span class="built_in">exports</span>.Points = Points;</span><br><span class="line">    <span class="built_in">exports</span>.PointsMaterial = PointsMaterial;</span><br><span class="line">    <span class="built_in">exports</span>.PolarGridHelper = PolarGridHelper;</span><br><span class="line">    <span class="built_in">exports</span>.PolyhedronBufferGeometry = PolyhedronGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.PolyhedronGeometry = PolyhedronGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.PositionalAudio = PositionalAudio;</span><br><span class="line">    <span class="built_in">exports</span>.PropertyBinding = PropertyBinding;</span><br><span class="line">    <span class="built_in">exports</span>.PropertyMixer = PropertyMixer;</span><br><span class="line">    <span class="built_in">exports</span>.QuadraticBezierCurve = QuadraticBezierCurve;</span><br><span class="line">    <span class="built_in">exports</span>.QuadraticBezierCurve3 = QuadraticBezierCurve3;</span><br><span class="line">    <span class="built_in">exports</span>.Quaternion = Quaternion;</span><br><span class="line">    <span class="built_in">exports</span>.QuaternionKeyframeTrack = QuaternionKeyframeTrack;</span><br><span class="line">    <span class="built_in">exports</span>.QuaternionLinearInterpolant = QuaternionLinearInterpolant;</span><br><span class="line">    <span class="built_in">exports</span>.REVISION = REVISION;</span><br><span class="line">    <span class="built_in">exports</span>.RGBADepthPacking = RGBADepthPacking;</span><br><span class="line">    <span class="built_in">exports</span>.RGBAFormat = RGBAFormat;</span><br><span class="line">    <span class="built_in">exports</span>.RGBAIntegerFormat = RGBAIntegerFormat;</span><br><span class="line">    <span class="built_in">exports</span>.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGBA_BPTC_Format = RGBA_BPTC_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGBFormat = RGBFormat;</span><br><span class="line">    <span class="built_in">exports</span>.RGB_ETC1_Format = RGB_ETC1_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGB_ETC2_Format = RGB_ETC2_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;</span><br><span class="line">    <span class="built_in">exports</span>.RGFormat = RGFormat;</span><br><span class="line">    <span class="built_in">exports</span>.RGIntegerFormat = RGIntegerFormat;</span><br><span class="line">    <span class="built_in">exports</span>.RawShaderMaterial = RawShaderMaterial;</span><br><span class="line">    <span class="built_in">exports</span>.Ray = Ray;</span><br><span class="line">    <span class="built_in">exports</span>.Raycaster = Raycaster;</span><br><span class="line">    <span class="built_in">exports</span>.RectAreaLight = RectAreaLight;</span><br><span class="line">    <span class="built_in">exports</span>.RedFormat = RedFormat;</span><br><span class="line">    <span class="built_in">exports</span>.RedIntegerFormat = RedIntegerFormat;</span><br><span class="line">    <span class="built_in">exports</span>.ReinhardToneMapping = ReinhardToneMapping;</span><br><span class="line">    <span class="built_in">exports</span>.RepeatWrapping = RepeatWrapping;</span><br><span class="line">    <span class="built_in">exports</span>.ReplaceStencilOp = ReplaceStencilOp;</span><br><span class="line">    <span class="built_in">exports</span>.ReverseSubtractEquation = ReverseSubtractEquation;</span><br><span class="line">    <span class="built_in">exports</span>.RingBufferGeometry = RingGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.RingGeometry = RingGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.SRGBColorSpace = SRGBColorSpace;</span><br><span class="line">    <span class="built_in">exports</span>.Scene = Scene;</span><br><span class="line">    <span class="built_in">exports</span>.SceneUtils = SceneUtils;</span><br><span class="line">    <span class="built_in">exports</span>.ShaderChunk = ShaderChunk;</span><br><span class="line">    <span class="built_in">exports</span>.ShaderLib = ShaderLib;</span><br><span class="line">    <span class="built_in">exports</span>.ShaderMaterial = ShaderMaterial;</span><br><span class="line">    <span class="built_in">exports</span>.ShadowMaterial = ShadowMaterial;</span><br><span class="line">    <span class="built_in">exports</span>.Shape = Shape;</span><br><span class="line">    <span class="built_in">exports</span>.ShapeBufferGeometry = ShapeGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.ShapeGeometry = ShapeGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.ShapePath = ShapePath;</span><br><span class="line">    <span class="built_in">exports</span>.ShapeUtils = ShapeUtils;</span><br><span class="line">    <span class="built_in">exports</span>.ShortType = ShortType;</span><br><span class="line">    <span class="built_in">exports</span>.Skeleton = Skeleton;</span><br><span class="line">    <span class="built_in">exports</span>.SkeletonHelper = SkeletonHelper;</span><br><span class="line">    <span class="built_in">exports</span>.SkinnedMesh = SkinnedMesh;</span><br><span class="line">    <span class="built_in">exports</span>.SmoothShading = SmoothShading;</span><br><span class="line">    <span class="built_in">exports</span>.Source = Source;</span><br><span class="line">    <span class="built_in">exports</span>.Sphere = Sphere;</span><br><span class="line">    <span class="built_in">exports</span>.SphereBufferGeometry = SphereGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.SphereGeometry = SphereGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.Spherical = Spherical;</span><br><span class="line">    <span class="built_in">exports</span>.SphericalHarmonics3 = SphericalHarmonics3;</span><br><span class="line">    <span class="built_in">exports</span>.SplineCurve = SplineCurve;</span><br><span class="line">    <span class="built_in">exports</span>.SpotLight = SpotLight;</span><br><span class="line">    <span class="built_in">exports</span>.SpotLightHelper = SpotLightHelper;</span><br><span class="line">    <span class="built_in">exports</span>.Sprite = Sprite;</span><br><span class="line">    <span class="built_in">exports</span>.SpriteMaterial = SpriteMaterial;</span><br><span class="line">    <span class="built_in">exports</span>.SrcAlphaFactor = SrcAlphaFactor;</span><br><span class="line">    <span class="built_in">exports</span>.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;</span><br><span class="line">    <span class="built_in">exports</span>.SrcColorFactor = SrcColorFactor;</span><br><span class="line">    <span class="built_in">exports</span>.StaticCopyUsage = StaticCopyUsage;</span><br><span class="line">    <span class="built_in">exports</span>.StaticDrawUsage = StaticDrawUsage;</span><br><span class="line">    <span class="built_in">exports</span>.StaticReadUsage = StaticReadUsage;</span><br><span class="line">    <span class="built_in">exports</span>.StereoCamera = StereoCamera;</span><br><span class="line">    <span class="built_in">exports</span>.StreamCopyUsage = StreamCopyUsage;</span><br><span class="line">    <span class="built_in">exports</span>.StreamDrawUsage = StreamDrawUsage;</span><br><span class="line">    <span class="built_in">exports</span>.StreamReadUsage = StreamReadUsage;</span><br><span class="line">    <span class="built_in">exports</span>.StringKeyframeTrack = StringKeyframeTrack;</span><br><span class="line">    <span class="built_in">exports</span>.SubtractEquation = SubtractEquation;</span><br><span class="line">    <span class="built_in">exports</span>.SubtractiveBlending = SubtractiveBlending;</span><br><span class="line">    <span class="built_in">exports</span>.TOUCH = TOUCH;</span><br><span class="line">    <span class="built_in">exports</span>.TangentSpaceNormalMap = TangentSpaceNormalMap;</span><br><span class="line">    <span class="built_in">exports</span>.TetrahedronBufferGeometry = TetrahedronGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.TetrahedronGeometry = TetrahedronGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.TextGeometry = TextGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.Texture = Texture;</span><br><span class="line">    <span class="built_in">exports</span>.TextureLoader = TextureLoader;</span><br><span class="line">    <span class="built_in">exports</span>.TorusBufferGeometry = TorusGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.TorusGeometry = TorusGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.TorusKnotBufferGeometry = TorusKnotGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.TorusKnotGeometry = TorusKnotGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.Triangle = Triangle;</span><br><span class="line">    <span class="built_in">exports</span>.TriangleFanDrawMode = TriangleFanDrawMode;</span><br><span class="line">    <span class="built_in">exports</span>.TriangleStripDrawMode = TriangleStripDrawMode;</span><br><span class="line">    <span class="built_in">exports</span>.TrianglesDrawMode = TrianglesDrawMode;</span><br><span class="line">    <span class="built_in">exports</span>.TubeBufferGeometry = TubeGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.TubeGeometry = TubeGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.UVMapping = UVMapping;</span><br><span class="line">    <span class="built_in">exports</span>.Uint16Attribute = Uint16Attribute;</span><br><span class="line">    <span class="built_in">exports</span>.Uint16BufferAttribute = Uint16BufferAttribute;</span><br><span class="line">    <span class="built_in">exports</span>.Uint32Attribute = Uint32Attribute;</span><br><span class="line">    <span class="built_in">exports</span>.Uint32BufferAttribute = Uint32BufferAttribute;</span><br><span class="line">    <span class="built_in">exports</span>.Uint8Attribute = Uint8Attribute;</span><br><span class="line">    <span class="built_in">exports</span>.Uint8BufferAttribute = Uint8BufferAttribute;</span><br><span class="line">    <span class="built_in">exports</span>.Uint8ClampedAttribute = Uint8ClampedAttribute;</span><br><span class="line">    <span class="built_in">exports</span>.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;</span><br><span class="line">    <span class="built_in">exports</span>.Uniform = Uniform;</span><br><span class="line">    <span class="built_in">exports</span>.UniformsLib = UniformsLib;</span><br><span class="line">    <span class="built_in">exports</span>.UniformsUtils = UniformsUtils;</span><br><span class="line">    <span class="built_in">exports</span>.UnsignedByteType = UnsignedByteType;</span><br><span class="line">    <span class="built_in">exports</span>.UnsignedInt248Type = UnsignedInt248Type;</span><br><span class="line">    <span class="built_in">exports</span>.UnsignedIntType = UnsignedIntType;</span><br><span class="line">    <span class="built_in">exports</span>.UnsignedShort4444Type = UnsignedShort4444Type;</span><br><span class="line">    <span class="built_in">exports</span>.UnsignedShort5551Type = UnsignedShort5551Type;</span><br><span class="line">    <span class="built_in">exports</span>.UnsignedShortType = UnsignedShortType;</span><br><span class="line">    <span class="built_in">exports</span>.VSMShadowMap = VSMShadowMap;</span><br><span class="line">    <span class="built_in">exports</span>.Vector2 = Vector2;</span><br><span class="line">    <span class="built_in">exports</span>.Vector3 = Vector3;</span><br><span class="line">    <span class="built_in">exports</span>.Vector4 = Vector4;</span><br><span class="line">    <span class="built_in">exports</span>.VectorKeyframeTrack = VectorKeyframeTrack;</span><br><span class="line">    <span class="built_in">exports</span>.Vertex = Vertex;</span><br><span class="line">    <span class="built_in">exports</span>.VertexColors = VertexColors;</span><br><span class="line">    <span class="built_in">exports</span>.VideoTexture = VideoTexture;</span><br><span class="line">    <span class="built_in">exports</span>.WebGL1Renderer = WebGL1Renderer;</span><br><span class="line">    <span class="built_in">exports</span>.WebGL3DRenderTarget = WebGL3DRenderTarget;</span><br><span class="line">    <span class="built_in">exports</span>.WebGLArrayRenderTarget = WebGLArrayRenderTarget;</span><br><span class="line">    <span class="built_in">exports</span>.WebGLCubeRenderTarget = WebGLCubeRenderTarget;</span><br><span class="line">    <span class="built_in">exports</span>.WebGLMultipleRenderTargets = WebGLMultipleRenderTargets;</span><br><span class="line">    <span class="built_in">exports</span>.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;</span><br><span class="line">    <span class="built_in">exports</span>.WebGLRenderTarget = WebGLRenderTarget;</span><br><span class="line">    <span class="built_in">exports</span>.WebGLRenderTargetCube = WebGLRenderTargetCube;</span><br><span class="line">    <span class="built_in">exports</span>.WebGLRenderer = WebGLRenderer;</span><br><span class="line">    <span class="built_in">exports</span>.WebGLUtils = WebGLUtils;</span><br><span class="line">    <span class="built_in">exports</span>.WireframeGeometry = WireframeGeometry;</span><br><span class="line">    <span class="built_in">exports</span>.WireframeHelper = WireframeHelper;</span><br><span class="line">    <span class="built_in">exports</span>.WrapAroundEnding = WrapAroundEnding;</span><br><span class="line">    <span class="built_in">exports</span>.XHRLoader = XHRLoader;</span><br><span class="line">    <span class="built_in">exports</span>.ZeroCurvatureEnding = ZeroCurvatureEnding;</span><br><span class="line">    <span class="built_in">exports</span>.ZeroFactor = ZeroFactor;</span><br><span class="line">    <span class="built_in">exports</span>.ZeroSlopeEnding = ZeroSlopeEnding;</span><br><span class="line">    <span class="built_in">exports</span>.ZeroStencilOp = ZeroStencilOp;</span><br><span class="line">    <span class="built_in">exports</span>._SRGBAFormat = _SRGBAFormat;</span><br><span class="line">    <span class="built_in">exports</span>.sRGBEncoding = sRGBEncoding;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&#x27;__esModule&#x27;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>在 HTML文件中我们要创建容器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=Edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Demo-01<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;libs/Three.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">body</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;webGl-output&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Script --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="WEBGL-三维画面效果的创建-放置在Script标签下-："><a href="#WEBGL-三维画面效果的创建-放置在Script标签下-：" class="headerlink" title="WEBGL 三维画面效果的创建(放置在Script标签下)："></a>WEBGL 三维画面效果的创建(放置在Script标签下)：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 创建场景</span></span><br><span class="line">    <span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene();</span><br><span class="line">    <span class="comment">// 设置摄像机 (45度,长宽比&lt;当前屏幕宽/屏幕高&gt;,最近可视距离,最远可视距离)</span></span><br><span class="line">    <span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">45</span>,<span class="built_in">window</span>.innerWidth/<span class="built_in">window</span>.innerHeight,<span class="number">0.1</span>,<span class="number">2000</span>);</span><br><span class="line">    <span class="comment">// 创建渲染器</span></span><br><span class="line">    <span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span><br><span class="line">    <span class="comment">// 渲染器初始化颜色</span></span><br><span class="line">    renderer.setClearColor(<span class="keyword">new</span> THREE.Color(<span class="number">0xEEEEEE</span>));</span><br><span class="line">    <span class="comment">// 渲染输出 Canvas 画面大小</span></span><br><span class="line">    renderer.setSize(<span class="built_in">window</span>.innerWidth,<span class="built_in">window</span>.innerHeight);</span><br><span class="line">    <span class="comment">// 创建显示卡迪坐标轴</span></span><br><span class="line">    <span class="keyword">var</span> axes = <span class="keyword">new</span> THREE.AxisHelper(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 添加坐标系到场景</span></span><br><span class="line">    scene.add(axes);</span><br><span class="line">    <span class="comment">// 场景创建平面(地面几何体)</span></span><br><span class="line">    <span class="keyword">var</span> planeGeometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">60</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 设置平面(地面)材质</span></span><br><span class="line">    <span class="keyword">var</span> PlaneMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;<span class="attr">color</span>:<span class="number">0xCCCCCC</span>&#125;);</span><br><span class="line">    <span class="comment">// 创建地面 通过 THREE.Mesh 进行结合操作</span></span><br><span class="line">    <span class="keyword">var</span> plane = <span class="keyword">new</span> THREE.Mesh(planeGeometry,PlaneMaterial);</span><br><span class="line">    <span class="comment">// 物体位移坐标</span></span><br><span class="line">    plane.rotation.x = -<span class="number">0.5</span>*<span class="built_in">Math</span>.PI;</span><br><span class="line">    plane.position.x = <span class="number">15</span>;</span><br><span class="line">    plane.position.y = <span class="number">0</span>;</span><br><span class="line">    plane.position.z = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将地面添加到场景</span></span><br><span class="line">    scene.add(plane);</span><br><span class="line">    <span class="comment">// 定位摄影机视角指向场景中心点</span></span><br><span class="line">    camera.position.x = -<span class="number">30</span>;</span><br><span class="line">    camera.position.y = <span class="number">40</span>;</span><br><span class="line">    camera.position.z = <span class="number">30</span>;</span><br><span class="line">    camera.lookAt(scene.position)</span><br><span class="line">    <span class="comment">// 渲染器输出添加至 HTML</span></span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;webGl-output&#x27;</span>).appendChild(renderer.domElement);</span><br><span class="line">    <span class="comment">// 最终渲染</span></span><br><span class="line">    renderer.render(scene,camera);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onload = init    <span class="comment">// 全部加载完成后运行</span></span><br></pre></td></tr></table></figure>
<h2 id="完整实例代码："><a href="#完整实例代码：" class="headerlink" title="完整实例代码："></a>完整实例代码：</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=Edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Demo-01<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;libs/Three.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">body</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;webGl-output&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Script --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 创建场景</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene();</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 设置摄像机 (45度,长宽比&lt;当前屏幕宽/屏幕高&gt;,最近可视距离,最远可视距离)</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">45</span>,<span class="built_in">window</span>.innerWidth/<span class="built_in">window</span>.innerHeight,<span class="number">0.1</span>,<span class="number">2000</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 创建渲染器</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 渲染器初始化颜色</span></span></span><br><span class="line"><span class="javascript">        renderer.setClearColor(<span class="keyword">new</span> THREE.Color(<span class="number">0xEEEEEE</span>));</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 渲染输出 Canvas 画面大小</span></span></span><br><span class="line"><span class="javascript">        renderer.setSize(<span class="built_in">window</span>.innerWidth,<span class="built_in">window</span>.innerHeight);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 创建显示卡迪坐标轴</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> axes = <span class="keyword">new</span> THREE.AxisHelper(<span class="number">20</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 添加坐标系到场景</span></span></span><br><span class="line"><span class="javascript">        scene.add(axes);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 场景创建平面(地面几何体)</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> planeGeometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">60</span>,<span class="number">20</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 设置平面(地面)材质</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> PlaneMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;<span class="attr">color</span>:<span class="number">0xCCCCCC</span>&#125;);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 创建地面 通过 THREE.Mesh 进行结合操作</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> plane = <span class="keyword">new</span> THREE.Mesh(planeGeometry,PlaneMaterial);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 物体位移坐标</span></span></span><br><span class="line"><span class="javascript">        plane.rotation.x = -<span class="number">0.5</span>*<span class="built_in">Math</span>.PI;</span></span><br><span class="line"><span class="javascript">        plane.position.x = <span class="number">15</span>;</span></span><br><span class="line"><span class="javascript">        plane.position.y = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        plane.position.z = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 将地面添加到场景</span></span></span><br><span class="line"><span class="javascript">        scene.add(plane);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 定位摄影机视角指向场景中心点</span></span></span><br><span class="line"><span class="javascript">        camera.position.x = -<span class="number">30</span>;</span></span><br><span class="line"><span class="javascript">        camera.position.y = <span class="number">40</span>;</span></span><br><span class="line"><span class="javascript">        camera.position.z = <span class="number">30</span>;</span></span><br><span class="line"><span class="javascript">        camera.lookAt(scene.position)</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 渲染器输出添加至 HTML</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">&#x27;webGl-output&#x27;</span>).appendChild(renderer.domElement);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 最终渲染</span></span></span><br><span class="line"><span class="javascript">        renderer.render(scene,camera);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = init    <span class="comment">// 全部加载完成后运行</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/ArvinRoad">Arvin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章連結: </span><span class="post-copyright-info"><a href="https://arvinroad.github.io/2022/04/19/ThreeJsWebGL_2022_4.19.01/">https://arvinroad.github.io/2022/04/19/ThreeJsWebGL_2022_4.19.01/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版權聲明: </span><span class="post-copyright-info">此文章版權歸Arvin所有，如有轉載，請註明來自原作者</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%99%E5%AD%A6%E6%96%87%E6%A1%A3/">教学文档</a><a class="post-meta__tags" href="/tags/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/">博客网站</a></div><div class="post_share"><div class="social-share" data-image="https://pic3.zhimg.com/v2-7af105b5915de8a7fdcf6332b681aba5_r.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/03/21/C_2022_3.21.01/"><img class="next-cover" src="https://tse1-mm.cn.bing.net/th/id/R-C.f24dba1c0741d3e26719d27dcbfa9ddb?rik=ixXaTtSKatsoXg&amp;riu=http%3a%2f%2fwww.huatengzy.com%2fuploadfile%2f2020%2f1124%2f20201124084901674.jpg&amp;ehk=8cudqdmImcXfxpnTIdHfG5Fw3USMKmi72wqJwGyq34M%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="onerror=null;src='/./img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C语言文件操作</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相關推薦</span></div><div class="relatedPosts-list"><div><a href="/2021/08/29/Spring_Blog/" title="基于Spring-Boot的博客开发系统"><img class="cover" src="https://pic2.zhimg.com/v2-8315cb308b890c7087edfc088043f572_1200x500.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-29</div><div class="title">基于Spring-Boot的博客开发系统</div></div></a></div><div><a href="/2022/03/06/Assembly_2022_3.6.01/" title="初识汇编"><img class="cover" src="https://tse1-mm.cn.bing.net/th/id/R-C.713f092ccdb317f1f0c087f3539f7cab?rik=bOE%2bVTWSO1ntvA&riu=http%3a%2f%2fi1.hdslb.com%2fbfs%2farchive%2fde6d0f9a0cc0e1ccae53a428089163f10b795a9d.jpg&ehk=7dDrxNiIDQOVlzPnHk42gtOex6jz9ANqVywfOJIg2lk%3d&risl=&pid=ImgRaw&r=0" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-06</div><div class="title">初识汇编</div></div></a></div><div><a href="/2022/02/22/C_2022.2.22.02/" title="C语言概述"><img class="cover" src="https://tse1-mm.cn.bing.net/th/id/R-C.f24dba1c0741d3e26719d27dcbfa9ddb?rik=ixXaTtSKatsoXg&riu=http%3a%2f%2fwww.huatengzy.com%2fuploadfile%2f2020%2f1124%2f20201124084901674.jpg&ehk=8cudqdmImcXfxpnTIdHfG5Fw3USMKmi72wqJwGyq34M%3d&risl=&pid=ImgRaw&r=0" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-22</div><div class="title">C语言概述</div></div></a></div><div><a href="/2022/02/22/C_2022.2.22.03/" title="C语言特性"><img class="cover" src="https://tse1-mm.cn.bing.net/th/id/R-C.f24dba1c0741d3e26719d27dcbfa9ddb?rik=ixXaTtSKatsoXg&riu=http%3a%2f%2fwww.huatengzy.com%2fuploadfile%2f2020%2f1124%2f20201124084901674.jpg&ehk=8cudqdmImcXfxpnTIdHfG5Fw3USMKmi72wqJwGyq34M%3d&risl=&pid=ImgRaw&r=0" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-22</div><div class="title">C语言特性</div></div></a></div><div><a href="/2022/03/07/C_2022_3.07.01/" title="C语言逻辑流程"><img class="cover" src="https://tse1-mm.cn.bing.net/th/id/R-C.f24dba1c0741d3e26719d27dcbfa9ddb?rik=ixXaTtSKatsoXg&riu=http%3a%2f%2fwww.huatengzy.com%2fuploadfile%2f2020%2f1124%2f20201124084901674.jpg&ehk=8cudqdmImcXfxpnTIdHfG5Fw3USMKmi72wqJwGyq34M%3d&risl=&pid=ImgRaw&r=0" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-07</div><div class="title">C语言逻辑流程</div></div></a></div><div><a href="/2022/03/09/C_2022_3.09.01/" title="C语言指针(上)"><img class="cover" src="https://tse1-mm.cn.bing.net/th/id/R-C.f24dba1c0741d3e26719d27dcbfa9ddb?rik=ixXaTtSKatsoXg&riu=http%3a%2f%2fwww.huatengzy.com%2fuploadfile%2f2020%2f1124%2f20201124084901674.jpg&ehk=8cudqdmImcXfxpnTIdHfG5Fw3USMKmi72wqJwGyq34M%3d&risl=&pid=ImgRaw&r=0" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-09</div><div class="title">C语言指针(上)</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 評論</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/./img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Arvin</div><div class="author-info__description">创造幻想中的故事世界！</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">標籤</div><div class="length-num">21</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分類</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Think-Create-Technology-Studio"><i class="fab fa-github"></i><span>关注我们</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ArvinRoad" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2644266656syx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">创想科技，创造好的游戏（建议采用夜间模式）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目錄</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Three-Js%E5%BC%80%E5%8F%91WebGL%E5%88%9B%E5%BB%BA%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4"><span class="toc-number">1.</span> <span class="toc-text">Three.Js开发WebGL创建三维空间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#WEBGL-%E4%B8%89%E7%BB%B4%E7%94%BB%E9%9D%A2%E6%95%88%E6%9E%9C%E7%9A%84%E5%88%9B%E5%BB%BA-%E6%94%BE%E7%BD%AE%E5%9C%A8Script%E6%A0%87%E7%AD%BE%E4%B8%8B-%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">WEBGL 三维画面效果的创建(放置在Script标签下)：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">完整实例代码：</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/19/ThreeJsWebGL_2022_4.19.01/" title="Three.Js开发WebGL创建三维空间"><img src="https://pic3.zhimg.com/v2-7af105b5915de8a7fdcf6332b681aba5_r.jpg" onerror="this.onerror=null;this.src='/./img/404.jpg'" alt="Three.Js开发WebGL创建三维空间"/></a><div class="content"><a class="title" href="/2022/04/19/ThreeJsWebGL_2022_4.19.01/" title="Three.Js开发WebGL创建三维空间">Three.Js开发WebGL创建三维空间</a><time datetime="2022-04-19T06:46:00.000Z" title="發表於 2022-04-19 14:46:00">2022-04-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/21/C_2022_3.21.01/" title="C语言文件操作"><img src="https://tse1-mm.cn.bing.net/th/id/R-C.f24dba1c0741d3e26719d27dcbfa9ddb?rik=ixXaTtSKatsoXg&amp;riu=http%3a%2f%2fwww.huatengzy.com%2fuploadfile%2f2020%2f1124%2f20201124084901674.jpg&amp;ehk=8cudqdmImcXfxpnTIdHfG5Fw3USMKmi72wqJwGyq34M%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/./img/404.jpg'" alt="C语言文件操作"/></a><div class="content"><a class="title" href="/2022/03/21/C_2022_3.21.01/" title="C语言文件操作">C语言文件操作</a><time datetime="2022-03-21T05:20:00.000Z" title="發表於 2022-03-21 13:20:00">2022-03-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/13/C_2022_3.13.01/" title="C语言指针(下)"><img src="https://s1.ax1x.com/2022/03/13/bbLsWF.png" onerror="this.onerror=null;this.src='/./img/404.jpg'" alt="C语言指针(下)"/></a><div class="content"><a class="title" href="/2022/03/13/C_2022_3.13.01/" title="C语言指针(下)">C语言指针(下)</a><time datetime="2022-03-13T06:22:00.000Z" title="發表於 2022-03-13 14:22:00">2022-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/09/C_2022_3.09.01/" title="C语言指针(上)"><img src="https://tse1-mm.cn.bing.net/th/id/R-C.f24dba1c0741d3e26719d27dcbfa9ddb?rik=ixXaTtSKatsoXg&amp;riu=http%3a%2f%2fwww.huatengzy.com%2fuploadfile%2f2020%2f1124%2f20201124084901674.jpg&amp;ehk=8cudqdmImcXfxpnTIdHfG5Fw3USMKmi72wqJwGyq34M%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/./img/404.jpg'" alt="C语言指针(上)"/></a><div class="content"><a class="title" href="/2022/03/09/C_2022_3.09.01/" title="C语言指针(上)">C语言指针(上)</a><time datetime="2022-03-09T07:20:00.000Z" title="發表於 2022-03-09 15:20:00">2022-03-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/08/WebServer_2022_3.08.01/" title="WebServer构建"><img src="https://img.php.cn/upload/article/000/000/020/5e91393a49cb1970.jpg" onerror="this.onerror=null;this.src='/./img/404.jpg'" alt="WebServer构建"/></a><div class="content"><a class="title" href="/2022/03/08/WebServer_2022_3.08.01/" title="WebServer构建">WebServer构建</a><time datetime="2022-03-07T19:55:00.000Z" title="發表於 2022-03-08 03:55:00">2022-03-08</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://pic3.zhimg.com/v2-7af105b5915de8a7fdcf6332b681aba5_r.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Arvin</div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61011602000392"> <img class="icp-icon" src="/img/icp.png"> <span>備案號：陕公网安备 61011602000392号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="閱讀模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="簡繁轉換">繁</button><button id="darkmode" type="button" title="淺色和深色模式轉換"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="單欄和雙欄切換"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="設定"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目錄"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直達評論"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到頂部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜尋</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜尋文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'twikoo-2gpelq3q7fc2f05c',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'twikoo-2gpelq3q7fc2f05c',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js"></script><script src="https://myhkw.cn/api/player/1631371731108" id="myhk" key="1631371731108" m="1"></script><script src="/js/mourning.js"></script><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script src="//code.tidio.co/7w9ege46jxui0verthfqsrenlqozsnv4.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>